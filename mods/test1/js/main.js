(function() {
    (function() {
        var t = this
          , U = U || {};
        return U.game = null,
        U.WEBGL_RENDERER = 0,
        U.CANVAS_RENDERER = 1,
        U.VERSION = "v2.2.9",
        U._UID = 0,
        "undefined" != typeof Float32Array ? (U.Float32Array = Float32Array,
        U.Uint16Array = Uint16Array,
        U.Uint32Array = Uint32Array,
        U.ArrayBuffer = ArrayBuffer) : (U.Float32Array = Array,
        U.Uint16Array = Array),
        U.PI_2 = 2 * Math.PI,
        U.RAD_TO_DEG = 180 / Math.PI,
        U.DEG_TO_RAD = Math.PI / 180,
        U.RETINA_PREFIX = "@2x",
        U.DisplayObject = function() {
            this.position = new U.Point(0,0),
            this.scale = new U.Point(1,1),
            this.pivot = new U.Point(0,0),
            this.rotation = 0,
            this.alpha = 1,
            this.visible = !0,
            this.hitArea = null,
            this.renderable = !1,
            this.parent = null,
            this.worldAlpha = 1,
            this.worldTransform = new U.Matrix,
            this.worldPosition = new U.Point(0,0),
            this.worldScale = new U.Point(1,1),
            this.worldRotation = 0,
            this.filterArea = null,
            this._sr = 0,
            this._cr = 1,
            this._bounds = new U.Rectangle(0,0,0,0),
            this._currentBounds = null,
            this._mask = null,
            this._cacheAsBitmap = !1,
            this._cacheIsDirty = !1
        }
        ,
        U.DisplayObject.prototype.constructor = U.DisplayObject,
        U.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--; )
                        this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null,
                this.parent = null,
                this.worldTransform = null,
                this.filterArea = null,
                this.renderable = !1,
                this._bounds = null,
                this._currentBounds = null,
                this._mask = null,
                this._destroyCachedSprite()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game)
                    return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i, r, s, n, a, o, h = e.worldTransform, l = this.worldTransform;
                return this.rotation % U.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation,
                this._sr = Math.sin(this.rotation),
                this._cr = Math.cos(this.rotation)),
                i = this._cr * this.scale.x,
                r = this._sr * this.scale.x,
                s = -this._sr * this.scale.y,
                n = this._cr * this.scale.y,
                a = this.position.x,
                o = this.position.y,
                (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * i + this.pivot.y * s,
                o -= this.pivot.x * r + this.pivot.y * n),
                l.a = i * h.a + r * h.c,
                l.b = i * h.b + r * h.d,
                l.c = s * h.a + n * h.c,
                l.d = s * h.b + n * h.d) : (i = this.scale.x,
                n = this.scale.y,
                a = this.position.x - this.pivot.x * i,
                o = this.position.y - this.pivot.y * n,
                l.a = i * h.a,
                l.b = i * h.b,
                l.c = n * h.c,
                l.d = n * h.d),
                l.tx = a * h.a + o * h.c + h.tx,
                l.ty = a * h.b + o * h.d + h.ty,
                this.worldAlpha = this.alpha * e.worldAlpha,
                this.worldPosition.set(l.tx, l.ty),
                this.worldScale.set(this.scale.x * Math.sqrt(l.a * l.a + l.c * l.c), this.scale.y * Math.sqrt(l.b * l.b + l.d * l.d)),
                this.worldRotation = Math.atan2(-l.c, l.d),
                this._currentBounds = null,
                this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h),
                this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, i) {
                var r = this.getLocalBounds()
                  , s = new U.RenderTexture(0 | r.width,0 | r.height,i,e,t);
                return U.DisplayObject._tempMatrix.tx = -r.x,
                U.DisplayObject._tempMatrix.ty = -r.y,
                s.render(this, U.DisplayObject._tempMatrix),
                s
            },
            updateCache: function() {
                return this._generateCachedSprite(),
                this
            },
            toGlobal: function(t) {
                return this.updateTransform(),
                this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)),
                this.updateTransform(),
                this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha,
                t.gl ? U.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : U.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)),
                t.height = Math.max(1, Math.ceil(t.height)),
                this.updateTransform(),
                this._cachedSprite)
                    this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var e = new U.RenderTexture(t.width,t.height);
                    this._cachedSprite = new U.Sprite(e),
                    this._cachedSprite.worldTransform = this.worldTransform
                }
                var i = this._filters;
                this._filters = null,
                this._cachedSprite.filters = i,
                U.DisplayObject._tempMatrix.tx = -t.x,
                U.DisplayObject._tempMatrix.ty = -t.y,
                this._cachedSprite.texture.render(this, U.DisplayObject._tempMatrix, !0),
                this._cachedSprite.anchor.x = -t.x / t.width,
                this._cachedSprite.anchor.y = -t.y / t.height,
                this._filters = i,
                this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0),
                this._cachedSprite = null)
            }
        },
        U.DisplayObject.prototype.displayObjectUpdateTransform = U.DisplayObject.prototype.updateTransform,
        Object.defineProperties(U.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t)
                            return this.visible;
                        do {
                            if (!t.visible)
                                return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1),
                    (this._mask = t) && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)
                            for (var r = t[i].passes, s = 0; s < r.length; s++)
                                e.push(r[s]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t,
                    this.blendMode && this.blendMode === U.blendModes.MULTIPLY && (this.blendMode = U.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(),
                    this._cacheAsBitmap = t)
                }
            }
        }),
        U.DisplayObjectContainer = function() {
            U.DisplayObject.call(this),
            this.children = [],
            this.ignoreChildInput = !1
        }
        ,
        U.DisplayObjectContainer.prototype = Object.create(U.DisplayObject.prototype),
        U.DisplayObjectContainer.prototype.constructor = U.DisplayObjectContainer,
        U.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }
        ,
        U.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (0 <= e && e <= this.children.length)
                return t.parent && t.parent.removeChild(t),
                (t.parent = this).children.splice(e, 0, t),
                t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }
        ,
        U.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t)
                  , r = this.getChildIndex(e);
                if (i < 0 || r < 0)
                    throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e,
                this.children[r] = t
            }
        }
        ,
        U.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e)
                throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }
        ,
        U.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length)
                throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1),
            this.children.splice(e, 0, t)
        }
        ,
        U.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length)
                throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }
        ,
        U.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e)
                return this.removeChildAt(e)
        }
        ,
        U.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0,
            this.children.splice(t, 1)),
            e
        }
        ,
        U.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0),
            void 0 === e && (e = this.children.length);
            var i = e - t;
            if (0 < i && i <= e) {
                for (var r = this.children.splice(begin, i), s = 0; s < r.length; s++) {
                    r[s].parent = void 0
                }
                return r
            }
            if (0 == i && 0 === this.children.length)
                return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }
        ,
        U.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(),
            !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++)
                    this.children[t].updateTransform()
        }
        ,
        U.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = U.DisplayObjectContainer.prototype.updateTransform,
        U.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e, i = t && t instanceof U.DisplayObject, r = !0;
            if (i ? r = t instanceof U.DisplayObjectContainer && t.contains(this) : t = this,
            i) {
                var s = t.worldTransform;
                for (t.worldTransform = U.identityMatrix,
                e = 0; e < t.children.length; e++)
                    t.children[e].updateTransform()
            }
            var n, a, o, h = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0, d = !1;
            for (e = 0; e < this.children.length; e++) {
                this.children[e].visible && (d = !0,
                h = h < (n = this.children[e].getBounds()).x ? h : n.x,
                l = l < n.y ? l : n.y,
                u = (a = n.width + n.x) < u ? u : a,
                c = (o = n.height + n.y) < c ? c : o)
            }
            var f = this._bounds;
            if (!d) {
                var p = (f = new U.Rectangle).x
                  , x = f.width + f.x
                  , g = f.y
                  , v = f.height + f.y
                  , T = this.worldTransform
                  , m = T.a
                  , y = T.b
                  , b = T.c
                  , S = T.d
                  , _ = T.tx
                  , A = T.ty
                  , E = m * x + b * v + _
                  , R = S * v + y * x + A
                  , B = m * p + b * v + _
                  , w = S * v + y * p + A
                  , M = m * p + b * g + _
                  , C = S * g + y * p + A
                  , L = m * x + b * g + _
                  , F = S * g + y * x + A;
                h = L < (h = M < (h = B < (h = u = E) ? B : h) ? M : h) ? L : h,
                l = F < (l = C < (l = w < (l = c = R) ? w : l) ? C : l) ? F : l,
                u = (u = (u = u < B ? B : u) < M ? M : u) < L ? L : u,
                c = (c = (c = c < w ? w : c) < C ? C : c) < F ? F : c
            }
            if (f.x = h,
            f.y = l,
            f.width = u - h,
            f.height = c - l,
            i)
                for (t.worldTransform = s,
                e = 0; e < t.children.length; e++)
                    t.children[e].updateTransform();
            if (!r) {
                var P = t.getBounds();
                f.x -= P.x,
                f.y -= P.y
            }
            return f
        }
        ,
        U.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }
        ,
        U.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }
        ,
        U.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            var e;
            if (this.visible && !(this.alpha <= 0))
                if (this._cacheAsBitmap)
                    this._renderCachedSprite(t);
                else if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(),
                    t.filterManager.pushFilter(this._filterBlock)),
                    this._mask && (t.spriteBatch.stop(),
                    t.maskManager.pushMask(this.mask, t),
                    t.spriteBatch.start()),
                    e = 0; e < this.children.length; e++)
                        this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(),
                    this._mask && t.maskManager.popMask(this._mask, t),
                    this._filters && t.filterManager.popFilter(),
                    t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++)
                        this.children[e]._renderWebGL(t)
        }
        ,
        U.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha)
                if (this._cacheAsBitmap)
                    this._renderCachedSprite(t);
                else {
                    this._mask && t.maskManager.pushMask(this._mask, t);
                    for (var e = 0; e < this.children.length; e++)
                        this.children[e]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
        }
        ,
        Object.defineProperty(U.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1,
                this._width = t
            }
        }),
        Object.defineProperty(U.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1,
                this._height = t
            }
        }),
        U.Sprite = function(t) {
            U.DisplayObjectContainer.call(this),
            this.anchor = new U.Point,
            this.texture = t || U.Texture.emptyTexture,
            this._width = 0,
            this._height = 0,
            this.tint = 16777215,
            this.cachedTint = -1,
            this.tintedTexture = null,
            this.blendMode = U.blendModes.NORMAL,
            this.shader = null,
            this.exists = !0,
            this.texture.baseTexture.hasLoaded && this.onTextureUpdate(),
            this.renderable = !0
        }
        ,
        U.Sprite.prototype = Object.create(U.DisplayObjectContainer.prototype),
        U.Sprite.prototype.constructor = U.Sprite,
        Object.defineProperty(U.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width,
                this._width = t
            }
        }),
        Object.defineProperty(U.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height,
                this._height = t
            }
        }),
        U.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(),
            this.texture.baseTexture.skipRender = !1,
            this.texture = t,
            this.texture.valid = !0,
            this.cachedTint = -1
        }
        ,
        U.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width),
            this._height && (this.scale.y = this._height / this.texture.frame.height)
        }
        ,
        U.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width
              , i = this.texture.frame.height
              , r = e * (1 - this.anchor.x)
              , s = e * -this.anchor.x
              , n = i * (1 - this.anchor.y)
              , a = i * -this.anchor.y
              , o = t || this.worldTransform
              , h = o.a
              , l = o.b
              , u = o.c
              , c = o.d
              , d = o.tx
              , f = o.ty
              , p = -1 / 0
              , x = -1 / 0
              , g = 1 / 0
              , v = 1 / 0;
            if (0 === l && 0 === u) {
                if (h < 0) {
                    h *= -1;
                    var T = r;
                    r = -s,
                    s = -T
                }
                if (c < 0) {
                    c *= -1;
                    T = n;
                    n = -a,
                    a = -T
                }
                g = h * s + d,
                p = h * r + d,
                v = c * a + f,
                x = c * n + f
            } else {
                var m = h * s + u * a + d
                  , y = c * a + l * s + f
                  , b = h * r + u * a + d
                  , S = c * a + l * r + f
                  , _ = h * r + u * n + d
                  , A = c * n + l * r + f
                  , E = h * s + u * n + d
                  , R = c * n + l * s + f;
                g = E < (g = _ < (g = b < (g = m < g ? m : g) ? b : g) ? _ : g) ? E : g,
                v = R < (v = A < (v = S < (v = y < v ? y : v) ? S : v) ? A : v) ? R : v,
                p = (p = (p = (p = p < m ? m : p) < b ? b : p) < _ ? _ : p) < E ? E : p,
                x = (x = (x = (x = x < y ? y : x) < S ? S : x) < A ? A : x) < R ? R : x
            }
            var B = this._bounds;
            return B.x = g,
            B.width = p - g,
            B.y = v,
            B.height = x - v,
            this._currentBounds = B
        }
        ,
        U.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = U.identityMatrix;
            for (var e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t,
            e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            return i
        }
        ,
        U.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e),
                this._mask || this._filters) {
                    var r = t.spriteBatch;
                    this._filters && (r.flush(),
                    t.filterManager.pushFilter(this._filterBlock)),
                    this._mask && (r.stop(),
                    t.maskManager.pushMask(this.mask, t),
                    r.start()),
                    r.render(this);
                    for (var s = 0; s < this.children.length; s++)
                        this.children[s]._renderWebGL(t);
                    r.stop(),
                    this._mask && t.maskManager.popMask(this._mask, t),
                    this._filters && t.filterManager.popFilter(),
                    r.start()
                } else {
                    t.spriteBatch.render(this);
                    for (s = 0; s < this.children.length; s++)
                        this.children[s]._renderWebGL(t, i)
                }
            }
        }
        ,
        U.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var i = this.worldTransform;
                if (e && (i = e),
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                t.context.globalCompositeOperation = U.blendModesCanvas[t.currentBlendMode]),
                this._mask && t.maskManager.pushMask(this._mask, t),
                this.texture.valid) {
                    var r = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha,
                    t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode,
                    t.context[t.smoothProperty] = t.scaleMode === U.scaleModes.LINEAR);
                    var s = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width
                      , n = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height
                      , a = i.tx * t.resolution + t.shakeX
                      , o = i.ty * t.resolution + t.shakeY;
                    t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | a, 0 | o),
                    s |= 0,
                    n |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, a, o);
                    var h = this.texture.crop.width
                      , l = this.texture.crop.height;
                    if (s /= r,
                    n /= r,
                    16777215 !== this.tint)
                        !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = U.CanvasTinter.getTintedTexture(this, this.tint),
                        this.cachedTint = this.tint,
                        this.texture.requiresReTint = !1),
                        t.context.drawImage(this.tintedTexture, 0, 0, h, l, s, n, h / r, l / r);
                    else {
                        var u = this.texture.crop.x
                          , c = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, u, c, h, l, s, n, h / r, l / r)
                    }
                }
                for (var d = 0; d < this.children.length; d++)
                    this.children[d]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }
        ,
        U.SpriteBatch = function(t) {
            U.DisplayObjectContainer.call(this),
            this.textureThing = t,
            this.ready = !1
        }
        ,
        U.SpriteBatch.prototype = Object.create(U.DisplayObjectContainer.prototype),
        U.SpriteBatch.prototype.constructor = U.SpriteBatch,
        U.SpriteBatch.prototype.initWebGL = function(t) {
            this.fastSpriteBatch = new U.WebGLFastSpriteBatch(t),
            this.ready = !0
        }
        ,
        U.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }
        ,
        U.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl),
            this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl),
            t.spriteBatch.stop(),
            t.shaderManager.setShader(t.shaderManager.fastShader),
            this.fastSpriteBatch.begin(this, t),
            this.fastSpriteBatch.render(this),
            t.spriteBatch.start())
        }
        ,
        U.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha,
                this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, r = !0, s = 0; s < this.children.length; s++) {
                    var n = this.children[s];
                    if (n.visible) {
                        var a = n.texture
                          , o = a.frame;
                        if (e.globalAlpha = this.worldAlpha * n.alpha,
                        n.rotation % (2 * Math.PI) == 0)
                            r && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty),
                            r = !1),
                            e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, n.anchor.x * (-o.width * n.scale.x) + n.position.x + .5 + t.shakeX | 0, n.anchor.y * (-o.height * n.scale.y) + n.position.y + .5 + t.shakeY | 0, o.width * n.scale.x, o.height * n.scale.y);
                        else {
                            r = r || !0,
                            n.displayObjectUpdateTransform();
                            var h = n.worldTransform
                              , l = h.tx * t.resolution + t.shakeX
                              , u = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | u) : e.setTransform(h.a, h.b, h.c, h.d, l, u),
                            e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, n.anchor.x * -o.width + .5 | 0, n.anchor.y * -o.height + .5 | 0, o.width, o.height)
                        }
                    }
                }
            }
        }
        ,
        U.hex2rgb = function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        }
        ,
        U.rgb2hex = function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        }
        ,
        U.canUseNewCanvasBlendModes = function() {
            if (void 0 === document)
                return !1;
            var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/"
              , e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=="
              , i = new Image;
            i.src = t + "AP804Oa6" + e;
            var r = new Image;
            r.src = t + "/wCKxvRF" + e;
            var s = U.CanvasPool.create(this, 6, 1).getContext("2d");
            if (s.globalCompositeOperation = "multiply",
            s.drawImage(i, 0, 0),
            s.drawImage(r, 2, 0),
            !s.getImageData(2, 0, 1, 1))
                return !1;
            var n = s.getImageData(2, 0, 1, 1).data;
            return U.CanvasPool.remove(this),
            255 === n[0] && 0 === n[1] && 0 === n[2]
        }
        ,
        U.getNextPowerOfTwo = function(t) {
            if (0 < t && 0 == (t & t - 1))
                return t;
            for (var e = 1; e < t; )
                e <<= 1;
            return e
        }
        ,
        U.isPowerOfTwo = function(t, e) {
            return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
        }
        ,
        U.CanvasPool = {
            create: function(t, e, i) {
                var r, s = U.CanvasPool.getFirst();
                if (-1 === s) {
                    var n = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    };
                    U.CanvasPool.pool.push(n),
                    r = n.canvas
                } else
                    U.CanvasPool.pool[s].parent = t,
                    r = U.CanvasPool.pool[s].canvas;
                return void 0 !== e && (r.width = e,
                r.height = i),
                r
            },
            getFirst: function() {
                for (var t = U.CanvasPool.pool, e = 0; e < t.length; e++)
                    if (!t[e].parent)
                        return e;
                return -1
            },
            remove: function(t) {
                for (var e = U.CanvasPool.pool, i = 0; i < e.length; i++)
                    e[i].parent === t && (e[i].parent = null,
                    e[i].canvas.width = 1,
                    e[i].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var e = U.CanvasPool.pool, i = 0; i < e.length; i++)
                    e[i].canvas === t && (e[i].parent = null,
                    e[i].canvas.width = 1,
                    e[i].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = U.CanvasPool.pool, e = 0, i = 0; i < t.length; i++)
                    t[i].parent && e++;
                return e
            },
            getFree: function() {
                for (var t = U.CanvasPool.pool, e = 0, i = 0; i < t.length; i++)
                    t[i].parent || e++;
                return e
            }
        },
        U.CanvasPool.pool = [],
        U.initDefaultShaders = function() {}
        ,
        U.CompileVertexShader = function(t, e) {
            return U._CompileShader(t, e, t.VERTEX_SHADER)
        }
        ,
        U.CompileFragmentShader = function(t, e) {
            return U._CompileShader(t, e, t.FRAGMENT_SHADER)
        }
        ,
        U._CompileShader = function(t, e, i) {
            var r = e;
            Array.isArray(e) && (r = e.join("\n"));
            var s = t.createShader(i);
            return t.shaderSource(s, r),
            t.compileShader(s),
            t.getShaderParameter(s, t.COMPILE_STATUS) ? s : (window.console.log(t.getShaderInfoLog(s)),
            null)
        }
        ,
        U.compileProgram = function(t, e, i) {
            var r = U.CompileFragmentShader(t, i)
              , s = U.CompileVertexShader(t, e)
              , n = t.createProgram();
            return t.attachShader(n, s),
            t.attachShader(n, r),
            t.linkProgram(n),
            t.getProgramParameter(n, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(n)),
            window.console.log("Could not initialise shaders")),
            n
        }
        ,
        U.PixiShader = function(t) {
            this._UID = U._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"],
            this.textureCount = 0,
            this.firstRun = !0,
            this.dirty = !0,
            this.attributes = [],
            this.init()
        }
        ,
        U.PixiShader.prototype.constructor = U.PixiShader,
        U.PixiShader.prototype.init = function() {
            var t = this.gl
              , e = U.compileProgram(t, this.vertexSrc || U.PixiShader.defaultVertexSrc, this.fragmentSrc);
            for (var i in t.useProgram(e),
            this.uSampler = t.getUniformLocation(e, "uSampler"),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.dimensions = t.getUniformLocation(e, "dimensions"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            -1 === this.colorAttribute && (this.colorAttribute = 2),
            this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute],
            this.uniforms)
                this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
            this.initUniforms(),
            this.program = e
        }
        ,
        U.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) {
                var r = (t = this.uniforms[i]).type;
                "sampler2D" === r ? (t._init = !1,
                null !== t.value && this.initSampler2D(t)) : "mat2" === r || "mat3" === r || "mat4" === r ? (t.glMatrix = !0,
                t.glValueLength = 1,
                "mat2" === r ? t.glFunc = e.uniformMatrix2fv : "mat3" === r ? t.glFunc = e.uniformMatrix3fv : "mat4" === r && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + r],
                t.glValueLength = "2f" === r || "2i" === r ? 2 : "3f" === r || "3i" === r ? 3 : "4f" === r || "4i" === r ? 4 : 1)
            }
        }
        ,
        U.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e["TEXTURE" + this.textureCount]),
                e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]),
                t.textureData) {
                    var i = t.textureData
                      , r = i.magFilter ? i.magFilter : e.LINEAR
                      , s = i.minFilter ? i.minFilter : e.LINEAR
                      , n = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE
                      , a = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE
                      , o = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (n = e.REPEAT,
                    a = e.REPEAT),
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY),
                    i.width) {
                        var h = i.width ? i.width : 512
                          , l = i.height ? i.height : 2
                          , u = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, o, h, l, u, o, e.UNSIGNED_BYTE, null)
                    } else
                        e.texImage2D(e.TEXTURE_2D, 0, o, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, r),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)
                }
                e.uniform1i(t.uniformLocation, this.textureCount),
                t._init = !0,
                this.textureCount++
            }
        }
        ,
        U.PixiShader.prototype.syncUniforms = function() {
            var t;
            this.textureCount = 1;
            var e = this.gl;
            for (var i in this.uniforms)
                1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]),
                t.value.baseTexture._dirty[e.id] ? U.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]),
                e.uniform1i(t.uniformLocation, this.textureCount),
                this.textureCount++) : this.initSampler2D(t))
        }
        ,
        U.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        U.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"],
        U.PixiFastShader = function(t) {
            this._UID = U._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"],
            this.textureCount = 0,
            this.init()
        }
        ,
        U.PixiFastShader.prototype.constructor = U.PixiFastShader,
        U.PixiFastShader.prototype.init = function() {
            var t = this.gl
              , e = U.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.uSampler = t.getUniformLocation(e, "uSampler"),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.dimensions = t.getUniformLocation(e, "dimensions"),
            this.uMatrix = t.getUniformLocation(e, "uMatrix"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"),
            this.aScale = t.getAttribLocation(e, "aScale"),
            this.aRotation = t.getAttribLocation(e, "aRotation"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            -1 === this.colorAttribute && (this.colorAttribute = 2),
            this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute],
            this.program = e
        }
        ,
        U.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        U.StripShader = function(t) {
            this._UID = U._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"],
            this.init()
        }
        ,
        U.StripShader.prototype.constructor = U.StripShader,
        U.StripShader.prototype.init = function() {
            var t = this.gl
              , e = U.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.uSampler = t.getUniformLocation(e, "uSampler"),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.attributes = [this.aVertexPosition, this.aTextureCoord],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        U.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attribute = null
        }
        ,
        U.PrimitiveShader = function(t) {
            this._UID = U._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"],
            this.init()
        }
        ,
        U.PrimitiveShader.prototype.constructor = U.PrimitiveShader,
        U.PrimitiveShader.prototype.init = function() {
            var t = this.gl
              , e = U.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.tintColor = t.getUniformLocation(e, "tint"),
            this.flipY = t.getUniformLocation(e, "flipY"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.attributes = [this.aVertexPosition, this.colorAttribute],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        U.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        U.ComplexPrimitiveShader = function(t) {
            this._UID = U._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"],
            this.init()
        }
        ,
        U.ComplexPrimitiveShader.prototype.constructor = U.ComplexPrimitiveShader,
        U.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl
              , e = U.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.tintColor = t.getUniformLocation(e, "tint"),
            this.color = t.getUniformLocation(e, "color"),
            this.flipY = t.getUniformLocation(e, "flipY"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.attributes = [this.aVertexPosition, this.colorAttribute],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        U.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attribute = null
        }
        ,
        U.glContexts = [],
        U.instances = [],
        U.WebGLRenderer = function(t) {
            this.game = t,
            U.defaultRenderer || (U.defaultRenderer = this),
            this.type = U.WEBGL_RENDERER,
            this.resolution = t.resolution,
            this.transparent = t.transparent,
            this.autoResize = !1,
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.clearBeforeRender = t.clearBeforeRender,
            this.width = t.width,
            this.height = t.height,
            this.view = t.canvas,
            this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            },
            this.projection = new U.Point,
            this.offset = new U.Point,
            this.shaderManager = new U.WebGLShaderManager,
            this.spriteBatch = new U.WebGLSpriteBatch,
            this.maskManager = new U.WebGLMaskManager,
            this.filterManager = new U.WebGLFilterManager,
            this.stencilManager = new U.WebGLStencilManager,
            this.blendModeManager = new U.WebGLBlendModeManager,
            this.renderSession = {},
            this.renderSession.game = this.game,
            this.renderSession.gl = this.gl,
            this.renderSession.drawCount = 0,
            this.renderSession.shaderManager = this.shaderManager,
            this.renderSession.maskManager = this.maskManager,
            this.renderSession.filterManager = this.filterManager,
            this.renderSession.blendModeManager = this.blendModeManager,
            this.renderSession.spriteBatch = this.spriteBatch,
            this.renderSession.stencilManager = this.stencilManager,
            (this.renderSession.renderer = this).renderSession.resolution = this.resolution,
            this.initContext(),
            this.mapBlendModes()
        }
        ,
        U.WebGLRenderer.prototype.constructor = U.WebGLRenderer,
        U.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (!(this.gl = t))
                throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = t.id = U.WebGLRenderer.glContextId++,
            U.glContexts[this.glContextId] = t,
            U.instances[this.glContextId] = this,
            t.disable(t.DEPTH_TEST),
            t.disable(t.CULL_FACE),
            t.enable(t.BLEND),
            this.shaderManager.setContext(t),
            this.spriteBatch.setContext(t),
            this.maskManager.setContext(t),
            this.filterManager.setContext(t),
            this.blendModeManager.setContext(t),
            this.stencilManager.setContext(t),
            this.renderSession.gl = this.gl,
            this.resize(this.width, this.height)
        }
        ,
        U.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height),
                e.bindFramebuffer(e.FRAMEBUFFER, null),
                this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a),
                e.clear(e.COLOR_BUFFER_BIT)),
                this.offset.x = this.game.camera._shake.x,
                this.offset.y = this.game.camera._shake.y,
                this.renderDisplayObject(t, this.projection)
            }
        }
        ,
        U.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, r) {
            this.renderSession.blendModeManager.setBlendMode(U.blendModes.NORMAL),
            this.renderSession.drawCount = 0,
            this.renderSession.flipY = i ? -1 : 1,
            this.renderSession.projection = e,
            this.renderSession.offset = this.offset,
            this.spriteBatch.begin(this.renderSession),
            this.filterManager.begin(this.renderSession, i),
            t._renderWebGL(this.renderSession, r),
            this.spriteBatch.end()
        }
        ,
        U.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution,
            this.height = e * this.resolution,
            this.view.width = this.width,
            this.view.height = this.height,
            this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
            this.view.style.height = this.height / this.resolution + "px"),
            this.gl.viewport(0, 0, this.width, this.height),
            this.projection.x = this.width / 2 / this.resolution,
            this.projection.y = -this.height / 2 / this.resolution
        }
        ,
        U.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded)
                return !1;
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()),
            e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === U.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t.mipmap && U.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === U.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST),
            e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === U.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
            !(t._dirty[e.id] = !1)
        }
        ,
        U.WebGLRenderer.prototype.destroy = function() {
            U.glContexts[this.glContextId] = null,
            this.projection = null,
            this.offset = null,
            this.shaderManager.destroy(),
            this.spriteBatch.destroy(),
            this.maskManager.destroy(),
            this.filterManager.destroy(),
            this.shaderManager = null,
            this.spriteBatch = null,
            this.maskManager = null,
            this.filterManager = null,
            this.gl = null,
            this.renderSession = null,
            U.CanvasPool.remove(this),
            U.instances[this.glContextId] = null,
            U.WebGLRenderer.glContextId--
        }
        ,
        U.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!U.blendModesWebGL) {
                var e = []
                  , i = U.blendModes;
                e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA],
                e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA],
                e[i.SCREEN] = [t.SRC_ALPHA, t.ONE],
                e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                U.blendModesWebGL = e
            }
        }
        ,
        U.WebGLRenderer.glContextId = 0,
        U.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }
        ,
        U.WebGLBlendModeManager.prototype.constructor = U.WebGLBlendModeManager,
        U.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        U.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t)
                return !1;
            this.currentBlendMode = t;
            var e = U.blendModesWebGL[this.currentBlendMode];
            return e && this.gl.blendFunc(e[0], e[1]),
            !0
        }
        ,
        U.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }
        ,
        U.WebGLMaskManager = function() {}
        ,
        U.WebGLMaskManager.prototype.constructor = U.WebGLMaskManager,
        U.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        U.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var i = e.gl;
            t.dirty && U.WebGLGraphics.updateGraphics(t, i),
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
        }
        ,
        U.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }
        ,
        U.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }
        ,
        U.WebGLStencilManager = function() {
            this.stencilStack = [],
            this.reverse = !0,
            this.count = 0
        }
        ,
        U.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        U.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var r = this.gl;
            this.bindGraphics(t, e, i),
            0 === this.stencilStack.length && (r.enable(r.STENCIL_TEST),
            r.clear(r.STENCIL_BUFFER_BIT),
            this.reverse = !0,
            this.count = 0),
            this.stencilStack.push(e);
            var s = this.count;
            r.colorMask(!1, !1, !1, !1),
            r.stencilFunc(r.ALWAYS, 0, 255),
            r.stencilOp(r.KEEP, r.KEEP, r.INVERT),
            1 === e.mode ? (r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0),
            this.reverse ? (r.stencilFunc(r.EQUAL, 255 - s, 255),
            r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, s, 255),
            r.stencilOp(r.KEEP, r.KEEP, r.INCR)),
            r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
            this.reverse ? r.stencilFunc(r.EQUAL, 255 - (s + 1), 255) : r.stencilFunc(r.EQUAL, s + 1, 255),
            this.reverse = !this.reverse) : (this.reverse ? (r.stencilFunc(r.EQUAL, s, 255),
            r.stencilOp(r.KEEP, r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, 255 - s, 255),
            r.stencilOp(r.KEEP, r.KEEP, r.DECR)),
            r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0),
            this.reverse ? r.stencilFunc(r.EQUAL, s + 1, 255) : r.stencilFunc(r.EQUAL, 255 - (s + 1), 255)),
            r.colorMask(!0, !0, !0, !0),
            r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
            this.count++
        }
        ,
        U.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var r, s = this.gl, n = i.projection, a = i.offset;
            1 === e.mode ? (r = i.shaderManager.complexPrimitiveShader,
            i.shaderManager.setShader(r),
            s.uniform1f(r.flipY, i.flipY),
            s.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)),
            s.uniform2f(r.projectionVector, n.x, -n.y),
            s.uniform2f(r.offsetVector, -a.x, -a.y),
            s.uniform3fv(r.tintColor, U.hex2rgb(t.tint)),
            s.uniform3fv(r.color, e.color),
            s.uniform1f(r.alpha, t.worldAlpha * e.alpha),
            s.bindBuffer(s.ARRAY_BUFFER, e.buffer),
            s.vertexAttribPointer(r.aVertexPosition, 2, s.FLOAT, !1, 8, 0)) : (r = i.shaderManager.primitiveShader,
            i.shaderManager.setShader(r),
            s.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)),
            s.uniform1f(r.flipY, i.flipY),
            s.uniform2f(r.projectionVector, n.x, -n.y),
            s.uniform2f(r.offsetVector, -a.x, -a.y),
            s.uniform3fv(r.tintColor, U.hex2rgb(t.tint)),
            s.uniform1f(r.alpha, t.worldAlpha),
            s.bindBuffer(s.ARRAY_BUFFER, e.buffer),
            s.vertexAttribPointer(r.aVertexPosition, 2, s.FLOAT, !1, 24, 0),
            s.vertexAttribPointer(r.colorAttribute, 4, s.FLOAT, !1, 24, 8)),
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
        }
        ,
        U.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var r = this.gl;
            if (this.stencilStack.pop(),
            this.count--,
            0 === this.stencilStack.length)
                r.disable(r.STENCIL_TEST);
            else {
                var s = this.count;
                this.bindGraphics(t, e, i),
                r.colorMask(!1, !1, !1, !1),
                1 === e.mode ? (this.reverse = !this.reverse,
                this.reverse ? (r.stencilFunc(r.EQUAL, 255 - (s + 1), 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, s + 1, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.DECR)),
                r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
                r.stencilFunc(r.ALWAYS, 0, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INVERT),
                r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0)) : (this.reverse ? (r.stencilFunc(r.EQUAL, s + 1, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, 255 - (s + 1), 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INCR)),
                r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0)),
                this.reverse ? r.stencilFunc(r.EQUAL, s, 255) : r.stencilFunc(r.EQUAL, 255 - s, 255),
                r.colorMask(!0, !0, !0, !0),
                r.stencilOp(r.KEEP, r.KEEP, r.KEEP)
            }
        }
        ,
        U.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null,
            this.gl = null
        }
        ,
        U.WebGLShaderManager = function() {
            this.maxAttibs = 10,
            this.attribState = [],
            this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++)
                this.attribState[t] = !1;
            this.stack = []
        }
        ,
        U.WebGLShaderManager.prototype.constructor = U.WebGLShaderManager,
        U.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t,
            this.primitiveShader = new U.PrimitiveShader(t),
            this.complexPrimitiveShader = new U.ComplexPrimitiveShader(t),
            this.defaultShader = new U.PixiShader(t),
            this.fastShader = new U.PixiFastShader(t),
            this.stripShader = new U.StripShader(t),
            this.setShader(this.defaultShader)
        }
        ,
        U.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++)
                this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var r = this.gl;
            for (e = 0; e < this.attribState.length; e++)
                this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e],
                this.tempAttribState[e] ? r.enableVertexAttribArray(e) : r.disableVertexAttribArray(e))
        }
        ,
        U.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID,
            this.currentShader = t,
            this.gl.useProgram(t.program),
            this.setAttribs(t.attributes),
            !0)
        }
        ,
        U.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null,
            this.tempAttribState = null,
            this.primitiveShader.destroy(),
            this.complexPrimitiveShader.destroy(),
            this.defaultShader.destroy(),
            this.fastShader.destroy(),
            this.stripShader.destroy(),
            this.gl = null
        }
        ,
        U.WebGLSpriteBatch = function() {
            this.vertSize = 5,
            this.size = 2e3;
            var t = 4 * this.size * 4 * this.vertSize
              , e = 6 * this.size;
            this.vertices = new U.ArrayBuffer(t),
            this.positions = new U.Float32Array(this.vertices),
            this.colors = new U.Uint32Array(this.vertices),
            this.indices = new U.Uint16Array(e);
            for (var i = this.lastIndexCount = 0, r = 0; i < e; i += 6,
            r += 4)
                this.indices[i + 0] = r + 0,
                this.indices[i + 1] = r + 1,
                this.indices[i + 2] = r + 2,
                this.indices[i + 3] = r + 0,
                this.indices[i + 4] = r + 2,
                this.indices[i + 5] = r + 3;
            this.drawing = !1,
            this.currentBatchSize = 0,
            this.currentBaseTexture = null,
            this.dirty = !0,
            this.textures = [],
            this.blendModes = [],
            this.shaders = [],
            this.sprites = [],
            this.defaultShader = new U.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }
        ,
        U.WebGLSpriteBatch.prototype.setContext = function(t) {
            this.gl = t,
            this.vertexBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW),
            this.currentBlendMode = 99999;
            var e = new U.PixiShader(t);
            e.fragmentSrc = this.defaultShader.fragmentSrc,
            e.uniforms = {},
            e.init(),
            this.defaultShader.shaders[t.id] = e
        }
        ,
        U.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t,
            this.shader = this.renderSession.shaderManager.defaultShader,
            this.start()
        }
        ,
        U.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }
        ,
        U.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture
              , r = t.worldTransform;
            e && (r = e),
            this.currentBatchSize >= this.size && (this.flush(),
            this.currentBaseTexture = i.baseTexture);
            var s = i._uvs;
            if (s) {
                var n, a, o, h, l = t.anchor.x, u = t.anchor.y;
                if (i.trim) {
                    var c = i.trim;
                    n = (a = c.x - l * c.width) + i.crop.width,
                    o = (h = c.y - u * c.height) + i.crop.height
                } else
                    n = i.frame.width * (1 - l),
                    a = i.frame.width * -l,
                    o = i.frame.height * (1 - u),
                    h = i.frame.height * -u;
                var d = 4 * this.currentBatchSize * this.vertSize
                  , f = i.baseTexture.resolution
                  , p = r.a / f
                  , x = r.b / f
                  , g = r.c / f
                  , v = r.d / f
                  , T = r.tx
                  , m = r.ty
                  , y = this.colors
                  , b = this.positions;
                this.renderSession.roundPixels ? (b[d] = p * a + g * h + T | 0,
                b[1 + d] = v * h + x * a + m | 0,
                b[5 + d] = p * n + g * h + T | 0,
                b[6 + d] = v * h + x * n + m | 0,
                b[10 + d] = p * n + g * o + T | 0,
                b[11 + d] = v * o + x * n + m | 0,
                b[15 + d] = p * a + g * o + T | 0,
                b[16 + d] = v * o + x * a + m | 0) : (b[d] = p * a + g * h + T,
                b[1 + d] = v * h + x * a + m,
                b[5 + d] = p * n + g * h + T,
                b[6 + d] = v * h + x * n + m,
                b[10 + d] = p * n + g * o + T,
                b[11 + d] = v * o + x * n + m,
                b[15 + d] = p * a + g * o + T,
                b[16 + d] = v * o + x * a + m),
                b[2 + d] = s.x0,
                b[3 + d] = s.y0,
                b[7 + d] = s.x1,
                b[8 + d] = s.y1,
                b[12 + d] = s.x2,
                b[13 + d] = s.y2,
                b[17 + d] = s.x3,
                b[18 + d] = s.y3;
                var S = t.tint;
                y[4 + d] = y[9 + d] = y[14 + d] = y[19 + d] = (S >> 16) + (65280 & S) + ((255 & S) << 16) + (255 * t.worldAlpha << 24),
                this.sprites[this.currentBatchSize++] = t
            }
        }
        ,
        U.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(),
            this.currentBaseTexture = e.baseTexture),
            t._uvs || (t._uvs = new U.TextureUvs);
            var i = t._uvs
              , r = e.baseTexture.width
              , s = e.baseTexture.height;
            t.tilePosition.x %= r * t.tileScaleOffset.x,
            t.tilePosition.y %= s * t.tileScaleOffset.y;
            var n = t.tilePosition.x / (r * t.tileScaleOffset.x)
              , a = t.tilePosition.y / (s * t.tileScaleOffset.y)
              , o = t.width / r / (t.tileScale.x * t.tileScaleOffset.x)
              , h = t.height / s / (t.tileScale.y * t.tileScaleOffset.y);
            i.x0 = 0 - n,
            i.y0 = 0 - a,
            i.x1 = 1 * o - n,
            i.y1 = 0 - a,
            i.x2 = 1 * o - n,
            i.y2 = 1 * h - a,
            i.x3 = 0 - n,
            i.y3 = 1 * h - a;
            var l = t.tint
              , u = (l >> 16) + (65280 & l) + ((255 & l) << 16) + (255 * t.worldAlpha << 24)
              , c = this.positions
              , d = this.colors
              , f = t.width
              , p = t.height
              , x = t.anchor.x
              , g = t.anchor.y
              , v = f * (1 - x)
              , T = f * -x
              , m = p * (1 - g)
              , y = p * -g
              , b = 4 * this.currentBatchSize * this.vertSize
              , S = e.baseTexture.resolution
              , _ = t.worldTransform
              , A = _.a / S
              , E = _.b / S
              , R = _.c / S
              , B = _.d / S
              , w = _.tx
              , M = _.ty;
            c[b++] = A * T + R * y + w,
            c[b++] = B * y + E * T + M,
            c[b++] = i.x0,
            c[b++] = i.y0,
            d[b++] = u,
            c[b++] = A * v + R * y + w,
            c[b++] = B * y + E * v + M,
            c[b++] = i.x1,
            c[b++] = i.y1,
            d[b++] = u,
            c[b++] = A * v + R * m + w,
            c[b++] = B * m + E * v + M,
            c[b++] = i.x2,
            c[b++] = i.y2,
            d[b++] = u,
            c[b++] = A * T + R * m + w,
            c[b++] = B * m + E * T + M,
            c[b++] = i.x3,
            c[b++] = i.y3,
            d[b++] = u,
            this.sprites[this.currentBatchSize++] = t
        }
        ,
        U.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, e, i, r, s = this.gl;
                if (this.dirty) {
                    this.dirty = !1,
                    s.activeTexture(s.TEXTURE0),
                    s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer),
                    s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                    t = this.defaultShader.shaders[s.id];
                    var n = 4 * this.vertSize;
                    s.vertexAttribPointer(t.aVertexPosition, 2, s.FLOAT, !1, n, 0),
                    s.vertexAttribPointer(t.aTextureCoord, 2, s.FLOAT, !1, n, 8),
                    s.vertexAttribPointer(t.colorAttribute, 4, s.UNSIGNED_BYTE, !0, n, 16)
                }
                if (this.currentBatchSize > .5 * this.size)
                    s.bufferSubData(s.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var a = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    s.bufferSubData(s.ARRAY_BUFFER, 0, a)
                }
                for (var o, h = 0, l = 0, u = null, c = this.renderSession.blendModeManager.currentBlendMode, d = null, f = !1, p = !1, x = 0, g = this.currentBatchSize; x < g; x++) {
                    e = (o = this.sprites[x]).tilingTexture ? o.tilingTexture.baseTexture : o.texture.baseTexture,
                    f = c !== (i = o.blendMode),
                    p = d !== (r = o.shader || this.defaultShader);
                    var v = e.skipRender;
                    if (v && 0 < o.children.length && (v = !1),
                    (u !== e && !v || f || p) && (this.renderBatch(u, h, l),
                    l = x,
                    h = 0,
                    u = e,
                    f && (c = i,
                    this.renderSession.blendModeManager.setBlendMode(c)),
                    p)) {
                        (t = (d = r).shaders[s.id]) || ((t = new U.PixiShader(s)).fragmentSrc = d.fragmentSrc,
                        t.uniforms = d.uniforms,
                        t.init(),
                        d.shaders[s.id] = t),
                        this.renderSession.shaderManager.setShader(t),
                        t.dirty && t.syncUniforms();
                        var T = this.renderSession.projection;
                        s.uniform2f(t.projectionVector, T.x, T.y);
                        var m = this.renderSession.offset;
                        s.uniform2f(t.offsetVector, m.x, m.y)
                    }
                    h++
                }
                this.renderBatch(u, h, l),
                this.currentBatchSize = 0
            }
        }
        ,
        U.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var r = this.gl;
                if (t._dirty[r.id]) {
                    if (!this.renderSession.renderer.updateTexture(t))
                        return
                } else
                    r.bindTexture(r.TEXTURE_2D, t._glTextures[r.id]);
                r.drawElements(r.TRIANGLES, 6 * e, r.UNSIGNED_SHORT, 6 * i * 2),
                this.renderSession.drawCount++
            }
        }
        ,
        U.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(),
            this.dirty = !0
        }
        ,
        U.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }
        ,
        U.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null,
            this.indices = null,
            this.gl.deleteBuffer(this.vertexBuffer),
            this.gl.deleteBuffer(this.indexBuffer),
            this.currentBaseTexture = null,
            this.gl = null
        }
        ,
        U.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 10,
            this.maxSize = 6e3,
            this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize
              , i = 6 * this.maxSize;
            this.vertices = new U.Float32Array(e),
            this.indices = new U.Uint16Array(i),
            this.vertexBuffer = null,
            this.indexBuffer = null;
            for (var r = this.lastIndexCount = 0, s = 0; r < i; r += 6,
            s += 4)
                this.indices[r + 0] = s + 0,
                this.indices[r + 1] = s + 1,
                this.indices[r + 2] = s + 2,
                this.indices[r + 3] = s + 0,
                this.indices[r + 4] = s + 2,
                this.indices[r + 5] = s + 3;
            this.drawing = !1,
            this.currentBatchSize = 0,
            this.currentBaseTexture = null,
            this.currentBlendMode = 0,
            this.renderSession = null,
            this.shader = null,
            this.matrix = null,
            this.setContext(t)
        }
        ,
        U.WebGLFastSpriteBatch.prototype.constructor = U.WebGLFastSpriteBatch,
        U.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t,
            this.vertexBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }
        ,
        U.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e,
            this.shader = this.renderSession.shaderManager.fastShader,
            this.matrix = t.worldTransform.toArray(!0),
            this.start()
        }
        ,
        U.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }
        ,
        U.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children
              , i = e[0];
            if (i.texture._uvs) {
                this.currentBaseTexture = i.texture.baseTexture,
                i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(),
                this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                for (var r = 0, s = e.length; r < s; r++)
                    this.renderSprite(e[r]);
                this.flush()
            }
        }
        ,
        U.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(),
            this.currentBaseTexture = t.texture.baseTexture,
            t.texture._uvs))) {
                var e, i, r, s, n, a, o = this.vertices;
                if (e = t.texture._uvs,
                t.texture.frame.width,
                t.texture.frame.height,
                t.texture.trim) {
                    var h = t.texture.trim;
                    i = (r = h.x - t.anchor.x * h.width) + t.texture.crop.width,
                    s = (n = h.y - t.anchor.y * h.height) + t.texture.crop.height
                } else
                    i = t.texture.frame.width * (1 - t.anchor.x),
                    r = t.texture.frame.width * -t.anchor.x,
                    s = t.texture.frame.height * (1 - t.anchor.y),
                    n = t.texture.frame.height * -t.anchor.y;
                a = 4 * this.currentBatchSize * this.vertSize,
                o[a++] = r,
                o[a++] = n,
                o[a++] = t.position.x,
                o[a++] = t.position.y,
                o[a++] = t.scale.x,
                o[a++] = t.scale.y,
                o[a++] = t.rotation,
                o[a++] = e.x0,
                o[a++] = e.y1,
                o[a++] = t.alpha,
                o[a++] = i,
                o[a++] = n,
                o[a++] = t.position.x,
                o[a++] = t.position.y,
                o[a++] = t.scale.x,
                o[a++] = t.scale.y,
                o[a++] = t.rotation,
                o[a++] = e.x1,
                o[a++] = e.y1,
                o[a++] = t.alpha,
                o[a++] = i,
                o[a++] = s,
                o[a++] = t.position.x,
                o[a++] = t.position.y,
                o[a++] = t.scale.x,
                o[a++] = t.scale.y,
                o[a++] = t.rotation,
                o[a++] = e.x2,
                o[a++] = e.y2,
                o[a++] = t.alpha,
                o[a++] = r,
                o[a++] = s,
                o[a++] = t.position.x,
                o[a++] = t.position.y,
                o[a++] = t.scale.x,
                o[a++] = t.scale.y,
                o[a++] = t.rotation,
                o[a++] = e.x3,
                o[a++] = e.y3,
                o[a++] = t.alpha,
                this.currentBatchSize++,
                this.currentBatchSize >= this.size && this.flush()
            }
        }
        ,
        U.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t),
                t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]),
                this.currentBatchSize > .5 * this.size)
                    t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                }
                t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0),
                this.currentBatchSize = 0,
                this.renderSession.drawCount++
            }
        }
        ,
        U.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }
        ,
        U.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y),
            t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0),
            t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8),
            t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16),
            t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24),
            t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28),
            t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
        }
        ,
        U.WebGLFilterManager = function() {
            this.filterStack = [],
            this.offsetX = 0,
            this.offsetY = 0
        }
        ,
        U.WebGLFilterManager.prototype.constructor = U.WebGLFilterManager,
        U.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t,
            this.texturePool = [],
            this.initShaderBuffers()
        }
        ,
        U.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t,
            this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x,
            this.height = 2 * -i.y,
            this.buffer = e
        }
        ,
        U.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl
              , i = this.renderSession.projection
              , r = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(),
            t._previous_stencil_mgr = this.renderSession.stencilManager,
            this.renderSession.stencilManager = new U.WebGLStencilManager,
            this.renderSession.stencilManager.setContext(e),
            e.disable(e.STENCIL_TEST),
            this.filterStack.push(t);
            var s = t.filterPasses[0];
            this.offsetX += t._filterArea.x,
            this.offsetY += t._filterArea.y;
            var n = this.texturePool.pop();
            n ? n.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : n = new U.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution),
            e.bindTexture(e.TEXTURE_2D, n.texture);
            var a = t._filterArea
              , o = s.padding;
            a.x -= o,
            a.y -= o,
            a.width += 2 * o,
            a.height += 2 * o,
            a.x < 0 && (a.x = 0),
            a.width > this.width && (a.width = this.width),
            a.y < 0 && (a.y = 0),
            a.height > this.height && (a.height = this.height),
            e.bindFramebuffer(e.FRAMEBUFFER, n.frameBuffer),
            e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution),
            i.x = a.width / 2,
            i.y = -a.height / 2,
            r.x = -a.x,
            r.y = -a.y,
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.clear(e.COLOR_BUFFER_BIT),
            t._glFilterTexture = n
        }
        ,
        U.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl
              , e = this.filterStack.pop()
              , i = e._filterArea
              , r = e._glFilterTexture
              , s = this.renderSession.projection
              , n = this.renderSession.offset;
            if (1 < e.filterPasses.length) {
                t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution),
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                this.vertexArray[0] = 0,
                this.vertexArray[1] = i.height,
                this.vertexArray[2] = i.width,
                this.vertexArray[3] = i.height,
                this.vertexArray[4] = 0,
                this.vertexArray[5] = 0,
                this.vertexArray[6] = i.width,
                this.vertexArray[7] = 0,
                t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
                t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
                this.uvArray[2] = i.width / this.width,
                this.uvArray[5] = i.height / this.height,
                this.uvArray[6] = i.width / this.width,
                this.uvArray[7] = i.height / this.height,
                t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var a = r
                  , o = this.texturePool.pop();
                (o = o || new U.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution)).resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
                t.bindFramebuffer(t.FRAMEBUFFER, o.frameBuffer),
                t.clear(t.COLOR_BUFFER_BIT),
                t.disable(t.BLEND);
                for (var h = 0; h < e.filterPasses.length - 1; h++) {
                    var l = e.filterPasses[h];
                    t.bindFramebuffer(t.FRAMEBUFFER, o.frameBuffer),
                    t.activeTexture(t.TEXTURE0),
                    t.bindTexture(t.TEXTURE_2D, a.texture),
                    this.applyFilterPass(l, i, i.width, i.height);
                    var u = a;
                    a = o,
                    o = u
                }
                t.enable(t.BLEND),
                r = a,
                this.texturePool.push(o)
            }
            var c = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= i.x,
            this.offsetY -= i.y;
            var d = this.width
              , f = this.height
              , p = 0
              , x = 0
              , g = this.buffer;
            if (0 === this.filterStack.length)
                t.colorMask(!0, !0, !0, !0);
            else {
                var v = this.filterStack[this.filterStack.length - 1];
                d = (i = v._filterArea).width,
                f = i.height,
                p = i.x,
                x = i.y,
                g = v._glFilterTexture.frameBuffer
            }
            s.x = d / 2,
            s.y = -f / 2,
            n.x = p,
            n.y = x;
            var T = (i = e._filterArea).x - p
              , m = i.y - x;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            this.vertexArray[0] = T,
            this.vertexArray[1] = m + i.height,
            this.vertexArray[2] = T + i.width,
            this.vertexArray[3] = m + i.height,
            this.vertexArray[4] = T,
            this.vertexArray[5] = m,
            this.vertexArray[6] = T + i.width,
            this.vertexArray[7] = m,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
            t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
            this.uvArray[2] = i.width / this.width,
            this.uvArray[5] = i.height / this.height,
            this.uvArray[6] = i.width / this.width,
            this.uvArray[7] = i.height / this.height,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray),
            t.viewport(0, 0, d * this.renderSession.resolution, f * this.renderSession.resolution),
            t.bindFramebuffer(t.FRAMEBUFFER, g),
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, r.texture),
            this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(),
            this.renderSession.stencilManager = e._previous_stencil_mgr,
            e._previous_stencil_mgr = null,
            0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST),
            this.applyFilterPass(c, i, d, f),
            this.texturePool.push(r),
            e._glFilterTexture = null
        }
        ,
        U.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, r) {
            var s = this.gl
              , n = t.shaders[s.id];
            n || ((n = new U.PixiShader(s)).fragmentSrc = t.fragmentSrc,
            n.uniforms = t.uniforms,
            n.init(),
            t.shaders[s.id] = n),
            this.renderSession.shaderManager.setShader(n),
            s.uniform2f(n.projectionVector, i / 2, -r / 2),
            s.uniform2f(n.offsetVector, 0, 0),
            t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width,
            t.uniforms.dimensions.value[1] = this.height,
            t.uniforms.dimensions.value[2] = this.vertexArray[0],
            t.uniforms.dimensions.value[3] = this.vertexArray[5]),
            n.syncUniforms(),
            s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer),
            s.vertexAttribPointer(n.aVertexPosition, 2, s.FLOAT, !1, 0, 0),
            s.bindBuffer(s.ARRAY_BUFFER, this.uvBuffer),
            s.vertexAttribPointer(n.aTextureCoord, 2, s.FLOAT, !1, 0, 0),
            s.bindBuffer(s.ARRAY_BUFFER, this.colorBuffer),
            s.vertexAttribPointer(n.colorAttribute, 2, s.FLOAT, !1, 0, 0),
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0),
            this.renderSession.drawCount++
        }
        ,
        U.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(),
            this.uvBuffer = t.createBuffer(),
            this.colorBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            this.vertexArray = new U.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW),
            this.uvArray = new U.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
            t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW),
            this.colorArray = new U.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]),
            t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }
        ,
        U.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null,
            this.offsetX = 0;
            for (var e = this.offsetY = 0; e < this.texturePool.length; e++)
                this.texturePool[e].destroy();
            this.texturePool = null,
            t.deleteBuffer(this.vertexBuffer),
            t.deleteBuffer(this.uvBuffer),
            t.deleteBuffer(this.colorBuffer),
            t.deleteBuffer(this.indexBuffer)
        }
        ,
        U.FilterTexture = function(t, e, i, r) {
            this.gl = t,
            this.frameBuffer = t.createFramebuffer(),
            this.texture = t.createTexture(),
            r = r || U.scaleModes.DEFAULT,
            t.bindTexture(t.TEXTURE_2D, this.texture),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, r === U.scaleModes.LINEAR ? t.LINEAR : t.NEAREST),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, r === U.scaleModes.LINEAR ? t.LINEAR : t.NEAREST),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer),
            t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0),
            this.renderBuffer = t.createRenderbuffer(),
            t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer),
            this.resize(e, i)
        }
        ,
        U.FilterTexture.prototype.constructor = U.FilterTexture,
        U.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0),
            t.clear(t.COLOR_BUFFER_BIT)
        }
        ,
        U.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t,
                this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture),
                i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null),
                i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer),
                i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }
        ,
        U.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer),
            t.deleteTexture(this.texture),
            this.frameBuffer = null,
            this.texture = null
        }
        ,
        U.CanvasBuffer = function(t, e) {
            this.width = t,
            this.height = e,
            this.canvas = U.CanvasPool.create(this, this.width, this.height),
            this.context = this.canvas.getContext("2d"),
            this.canvas.width = t,
            this.canvas.height = e
        }
        ,
        U.CanvasBuffer.prototype.constructor = U.CanvasBuffer,
        U.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.clearRect(0, 0, this.width, this.height)
        }
        ,
        U.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t,
            this.height = this.canvas.height = e
        }
        ,
        U.CanvasBuffer.prototype.destroy = function() {
            U.CanvasPool.remove(this)
        }
        ,
        U.CanvasMaskManager = function() {}
        ,
        U.CanvasMaskManager.prototype.constructor = U.CanvasMaskManager,
        U.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var i = e.context;
            i.save();
            var r = t.alpha
              , s = t.worldTransform
              , n = e.resolution;
            i.setTransform(s.a * n, s.b * n, s.c * n, s.d * n, s.tx * n, s.ty * n),
            U.CanvasGraphics.renderGraphicsMask(t, i),
            i.clip(),
            t.worldAlpha = r
        }
        ,
        U.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }
        ,
        U.CanvasTinter = function() {}
        ,
        U.CanvasTinter.getTintedTexture = function(t, e) {
            var i = t.tintedTexture || U.CanvasPool.create(this);
            return U.CanvasTinter.tintMethod(t.texture, e, i),
            i
        }
        ,
        U.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var r = i.getContext("2d")
              , s = t.crop;
            i.width === s.width && i.height === s.height || (i.width = s.width,
            i.height = s.height),
            r.clearRect(0, 0, s.width, s.height),
            r.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6),
            r.fillRect(0, 0, s.width, s.height),
            r.globalCompositeOperation = "multiply",
            r.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height),
            r.globalCompositeOperation = "destination-atop",
            r.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height)
        }
        ,
        U.CanvasTinter.tintWithPerPixel = function(t, e, i) {
            var r = i.getContext("2d")
              , s = t.crop;
            i.width = s.width,
            i.height = s.height,
            r.globalCompositeOperation = "copy",
            r.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height);
            for (var n = U.hex2rgb(e), a = n[0], o = n[1], h = n[2], l = r.getImageData(0, 0, s.width, s.height), u = l.data, c = 0; c < u.length; c += 4)
                if (u[c + 0] *= a,
                u[c + 1] *= o,
                u[c + 2] *= h,
                !U.CanvasTinter.canHandleAlpha) {
                    var d = u[c + 3];
                    u[c + 0] /= 255 / d,
                    u[c + 1] /= 255 / d,
                    u[c + 2] /= 255 / d
                }
            r.putImageData(l, 0, 0)
        }
        ,
        U.CanvasTinter.checkInverseAlpha = function() {
            var t = new U.CanvasBuffer(2,1);
            t.context.fillStyle = "rgba(10, 20, 30, 0.5)",
            t.context.fillRect(0, 0, 1, 1);
            var e = t.context.getImageData(0, 0, 1, 1);
            if (null === e)
                return !1;
            t.context.putImageData(e, 1, 0);
            var i = t.context.getImageData(1, 0, 1, 1);
            return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
        }
        ,
        U.CanvasTinter.canHandleAlpha = U.CanvasTinter.checkInverseAlpha(),
        U.CanvasTinter.canUseMultiply = U.canUseNewCanvasBlendModes(),
        U.CanvasTinter.tintMethod = U.CanvasTinter.canUseMultiply ? U.CanvasTinter.tintWithMultiply : U.CanvasTinter.tintWithPerPixel,
        U.CanvasRenderer = function(t) {
            this.game = t,
            U.defaultRenderer || (U.defaultRenderer = this),
            this.type = U.CANVAS_RENDERER,
            this.resolution = t.resolution,
            this.clearBeforeRender = t.clearBeforeRender,
            this.transparent = t.transparent,
            this.autoResize = !1,
            this.width = t.width * this.resolution,
            this.height = t.height * this.resolution,
            this.view = t.canvas,
            this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }),
            this.refresh = !0,
            this.count = 0,
            this.maskManager = new U.CanvasMaskManager,
            this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            },
            this.mapBlendModes(),
            this.resize(this.width, this.height)
        }
        ,
        U.CanvasRenderer.prototype.constructor = U.CanvasRenderer,
        U.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.globalAlpha = 1,
            this.renderSession.currentBlendMode = 0,
            this.renderSession.shakeX = this.game.camera._shake.x,
            this.renderSession.shakeY = this.game.camera._shake.y,
            this.context.globalCompositeOperation = "source-over",
            navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black",
            this.context.clear()),
            this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba,
            this.context.fillRect(0, 0, this.width, this.height))),
            this.renderDisplayObject(t)
        }
        ,
        U.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0),
            t && this.view.parent && this.view.parent.removeChild(this.view),
            this.view = null,
            this.context = null,
            this.maskManager = null,
            this.renderSession = null
        }
        ,
        U.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution,
            this.height = e * this.resolution,
            this.view.width = this.width,
            this.view.height = this.height,
            this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
            this.view.style.height = this.height / this.resolution + "px"),
            this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === U.scaleModes.LINEAR)
        }
        ,
        U.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context,
            this.renderSession.resolution = this.resolution,
            t._renderCanvas(this.renderSession, i)
        }
        ,
        U.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!U.blendModesCanvas) {
                var t = []
                  , e = U.blendModes
                  , i = U.canUseNewCanvasBlendModes();
                t[e.NORMAL] = "source-over",
                t[e.ADD] = "lighter",
                t[e.MULTIPLY] = i ? "multiply" : "source-over",
                t[e.SCREEN] = i ? "screen" : "source-over",
                t[e.OVERLAY] = i ? "overlay" : "source-over",
                t[e.DARKEN] = i ? "darken" : "source-over",
                t[e.LIGHTEN] = i ? "lighten" : "source-over",
                t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over",
                t[e.COLOR_BURN] = i ? "color-burn" : "source-over",
                t[e.HARD_LIGHT] = i ? "hard-light" : "source-over",
                t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over",
                t[e.DIFFERENCE] = i ? "difference" : "source-over",
                t[e.EXCLUSION] = i ? "exclusion" : "source-over",
                t[e.HUE] = i ? "hue" : "source-over",
                t[e.SATURATION] = i ? "saturation" : "source-over",
                t[e.COLOR] = i ? "color" : "source-over",
                t[e.LUMINOSITY] = i ? "luminosity" : "source-over",
                U.blendModesCanvas = t
            }
        }
        ,
        U.BaseTexture = function(t, e) {
            this.resolution = 1,
            this.width = 100,
            this.height = 100,
            this.scaleMode = e || U.scaleModes.DEFAULT,
            this.hasLoaded = !1,
            this.source = t,
            this.premultipliedAlpha = !0,
            this._glTextures = [],
            this.mipmap = !1,
            this._dirty = [!0, !0, !0, !0],
            t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0,
            this.width = this.source.naturalWidth || this.source.width,
            this.height = this.source.naturalHeight || this.source.height,
            this.dirty()),
            this.skipRender = !1,
            this._powerOf2 = !1)
        }
        ,
        U.BaseTexture.prototype.constructor = U.BaseTexture,
        U.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0,
            this.width = t,
            this.height = e,
            this.dirty()
        }
        ,
        U.BaseTexture.prototype.destroy = function() {
            this.source && U.CanvasPool.removeByCanvas(this.source),
            this.source = null,
            this.unloadFromGPU()
        }
        ,
        U.BaseTexture.prototype.updateSourceImage = function(t) {
            console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
        }
        ,
        U.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++)
                this._dirty[t] = !0
        }
        ,
        U.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; 0 <= t; t--) {
                var e = this._glTextures[t]
                  , i = U.glContexts[t];
                i && e && i.deleteTexture(e)
            }
            this._glTextures.length = 0,
            this.dirty()
        }
        ,
        U.BaseTexture.fromCanvas = function(t, e) {
            return 0 === t.width && (t.width = 1),
            0 === t.height && (t.height = 1),
            new U.BaseTexture(t,e)
        }
        ,
        U.TextureSilentFail = !1,
        U.Texture = function(t, e, i, r) {
            this.noFrame = !1,
            e || (this.noFrame = !0,
            e = new U.Rectangle(0,0,1,1)),
            t instanceof U.Texture && (t = t.baseTexture),
            this.baseTexture = t,
            this.frame = e,
            this.trim = r,
            this.valid = !1,
            this.isTiling = !1,
            this.requiresUpdate = !1,
            this.requiresReTint = !1,
            this._uvs = null,
            this.width = 0,
            this.height = 0,
            this.crop = i || new U.Rectangle(0,0,1,1),
            t.hasLoaded && (this.noFrame && (e = new U.Rectangle(0,0,t.width,t.height)),
            this.setFrame(e))
        }
        ,
        U.Texture.prototype.constructor = U.Texture,
        U.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new U.Rectangle(0,0,t.width,t.height)),
            this.setFrame(this.frame)
        }
        ,
        U.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(),
            this.valid = !1
        }
        ,
        U.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1,
            this.frame = t,
            this.width = t.width,
            this.height = t.height,
            this.crop.x = t.x,
            this.crop.y = t.y,
            this.crop.width = t.width,
            this.crop.height = t.height,
            this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height))
                this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded,
                this.trim && (this.width = this.trim.width,
                this.height = this.trim.height,
                this.frame.width = this.trim.width,
                this.frame.height = this.trim.height),
                this.valid && this._updateUvs();
            else {
                if (!U.TextureSilentFail)
                    throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                this.valid = !1
            }
        }
        ,
        U.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new U.TextureUvs);
            var t = this.crop
              , e = this.baseTexture.width
              , i = this.baseTexture.height;
            this._uvs.x0 = t.x / e,
            this._uvs.y0 = t.y / i,
            this._uvs.x1 = (t.x + t.width) / e,
            this._uvs.y1 = t.y / i,
            this._uvs.x2 = (t.x + t.width) / e,
            this._uvs.y2 = (t.y + t.height) / i,
            this._uvs.x3 = t.x / e,
            this._uvs.y3 = (t.y + t.height) / i
        }
        ,
        U.Texture.fromCanvas = function(t, e) {
            var i = U.BaseTexture.fromCanvas(t, e);
            return new U.Texture(i)
        }
        ,
        U.TextureUvs = function() {
            this.x0 = 0,
            this.y0 = 0,
            this.x1 = 0,
            this.y1 = 0,
            this.x2 = 0,
            this.y2 = 0,
            this.x3 = 0,
            this.y3 = 0
        }
        ,
        U.RenderTexture = function(t, e, i, r, s) {
            if (this.width = t || 100,
            this.height = e || 100,
            this.resolution = s || 1,
            this.frame = new U.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution),
            this.crop = new U.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution),
            this.baseTexture = new U.BaseTexture,
            this.baseTexture.width = this.width * this.resolution,
            this.baseTexture.height = this.height * this.resolution,
            this.baseTexture._glTextures = [],
            this.baseTexture.resolution = this.resolution,
            this.baseTexture.scaleMode = r || U.scaleModes.DEFAULT,
            this.baseTexture.hasLoaded = !0,
            U.Texture.call(this, this.baseTexture, new U.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution)),
            this.renderer = i || U.defaultRenderer,
            this.renderer.type === U.WEBGL_RENDERER) {
                var n = this.renderer.gl;
                this.baseTexture._dirty[n.id] = !1,
                this.textureBuffer = new U.FilterTexture(n,this.width,this.height,this.baseTexture.scaleMode),
                this.baseTexture._glTextures[n.id] = this.textureBuffer.texture,
                this.render = this.renderWebGL,
                this.projection = new U.Point(.5 * this.width,.5 * -this.height)
            } else
                this.render = this.renderCanvas,
                this.textureBuffer = new U.CanvasBuffer(this.width * this.resolution,this.height * this.resolution),
                this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0,
            this.tempMatrix = new Phaser.Matrix,
            this._updateUvs()
        }
        ,
        U.RenderTexture.prototype = Object.create(U.Texture.prototype),
        U.RenderTexture.prototype.constructor = U.RenderTexture,
        U.RenderTexture.prototype.resize = function(t, e, i) {
            t === this.width && e === this.height || (this.valid = 0 < t && 0 < e,
            this.width = t,
            this.height = e,
            this.frame.width = this.crop.width = t * this.resolution,
            this.frame.height = this.crop.height = e * this.resolution,
            i && (this.baseTexture.width = this.width * this.resolution,
            this.baseTexture.height = this.height * this.resolution),
            this.renderer.type === U.WEBGL_RENDERER && (this.projection.x = this.width / 2,
            this.projection.y = -this.height / 2),
            this.valid && this.textureBuffer.resize(this.width, this.height))
        }
        ,
        U.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === U.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            this.textureBuffer.clear())
        }
        ,
        U.RenderTexture.prototype.renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var r = t.worldTransform;
                r.identity(),
                r.translate(0, 2 * this.projection.y),
                e && r.append(e),
                r.scale(1, -1);
                for (var s = 0; s < t.children.length; s++)
                    t.children[s].updateTransform();
                var n = this.renderer.gl;
                n.viewport(0, 0, this.width * this.resolution, this.height * this.resolution),
                n.bindFramebuffer(n.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                i && this.textureBuffer.clear(),
                this.renderer.spriteBatch.dirty = !0,
                this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e),
                this.renderer.spriteBatch.dirty = !0
            }
        }
        ,
        U.RenderTexture.prototype.renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var r = t.worldTransform;
                r.identity(),
                e && r.append(e);
                for (var s = 0; s < t.children.length; s++)
                    t.children[s].updateTransform();
                i && this.textureBuffer.clear();
                var n = this.renderer.resolution;
                this.renderer.resolution = this.resolution,
                this.renderer.renderDisplayObject(t, this.textureBuffer.context, e),
                this.renderer.resolution = n
            }
        }
        ,
        U.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(),
            t
        }
        ,
        U.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }
        ,
        U.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type !== U.WEBGL_RENDERER)
                return this.textureBuffer.canvas;
            var t = this.renderer.gl
              , e = this.textureBuffer.width
              , i = this.textureBuffer.height
              , r = new Uint8Array(4 * e * i);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, r),
            t.bindFramebuffer(t.FRAMEBUFFER, null);
            var s = new U.CanvasBuffer(e,i)
              , n = s.context.getImageData(0, 0, e, i);
            return n.data.set(r),
            s.context.putImageData(n, 0, 0),
            s.canvas
        }
        ,
        U.AbstractFilter = function(t, e) {
            this.passes = [this],
            this.shaders = [],
            this.dirty = !0,
            this.padding = 0,
            this.uniforms = e || {},
            this.fragmentSrc = t || []
        }
        ,
        U.AbstractFilter.prototype.constructor = U.AbstractFilter,
        U.AbstractFilter.prototype.syncUniforms = function() {
            for (var t = 0, e = this.shaders.length; t < e; t++)
                this.shaders[t].dirty = !0
        }
        ,
        U.Strip = function(t) {
            U.DisplayObjectContainer.call(this),
            this.texture = t,
            this.uvs = new U.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]),
            this.vertices = new U.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
            this.colors = new U.Float32Array([1, 1, 1, 1]),
            this.indices = new U.Uint16Array([0, 1, 2, 3]),
            this.dirty = !0,
            this.blendMode = U.blendModes.NORMAL,
            this.canvasPadding = 0,
            this.drawMode = U.Strip.DrawModes.TRIANGLE_STRIP
        }
        ,
        U.Strip.prototype = Object.create(U.DisplayObjectContainer.prototype),
        U.Strip.prototype.constructor = U.Strip,
        U.Strip.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(),
            this._vertexBuffer || this._initWebGL(t),
            t.shaderManager.setShader(t.shaderManager.stripShader),
            this._renderStrip(t),
            t.spriteBatch.start())
        }
        ,
        U.Strip.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(),
            this._indexBuffer = e.createBuffer(),
            this._uvBuffer = e.createBuffer(),
            this._colorBuffer = e.createBuffer(),
            e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }
        ,
        U.Strip.prototype._renderStrip = function(t) {
            var e = t.gl
              , i = t.projection
              , r = t.offset
              , s = t.shaderManager.stripShader
              , n = this.drawMode === U.Strip.DrawModes.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode),
            e.uniformMatrix3fv(s.translationMatrix, !1, this.worldTransform.toArray(!0)),
            e.uniform2f(s.projectionVector, i.x, -i.y),
            e.uniform2f(s.offsetVector, -r.x, -r.y),
            e.uniform1f(s.alpha, this.worldAlpha),
            this.dirty ? (this.dirty = !1,
            e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW),
            e.vertexAttribPointer(s.aVertexPosition, 2, e.FLOAT, !1, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW),
            e.vertexAttribPointer(s.aTextureCoord, 2, e.FLOAT, !1, 0, 0),
            e.activeTexture(e.TEXTURE0),
            this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices),
            e.vertexAttribPointer(s.aVertexPosition, 2, e.FLOAT, !1, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.vertexAttribPointer(s.aTextureCoord, 2, e.FLOAT, !1, 0, 0),
            e.activeTexture(e.TEXTURE0),
            this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)),
            e.drawElements(n, this.indices.length, e.UNSIGNED_SHORT, 0)
        }
        ,
        U.Strip.prototype._renderCanvas = function(t) {
            var e = t.context
              , i = this.worldTransform
              , r = i.tx * t.resolution + t.shakeX
              , s = i.ty * t.resolution + t.shakeY;
            t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | r, 0 | s) : e.setTransform(i.a, i.b, i.c, i.d, r, s),
            this.drawMode === U.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
        }
        ,
        U.Strip.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices
              , i = this.uvs
              , r = e.length / 2;
            this.count++;
            for (var s = 0; s < r - 2; s++) {
                var n = 2 * s;
                this._renderCanvasDrawTriangle(t, e, i, n, 2 + n, 4 + n)
            }
        }
        ,
        U.Strip.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices
              , i = this.uvs
              , r = this.indices
              , s = r.length;
            this.count++;
            for (var n = 0; n < s; n += 3) {
                var a = 2 * r[n]
                  , o = 2 * r[n + 1]
                  , h = 2 * r[n + 2];
                this._renderCanvasDrawTriangle(t, e, i, a, o, h)
            }
        }
        ,
        U.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, r, s, n) {
            var a = this.texture.baseTexture.source
              , o = this.texture.width
              , h = this.texture.height
              , l = e[r]
              , u = e[s]
              , c = e[n]
              , d = e[r + 1]
              , f = e[s + 1]
              , p = e[n + 1]
              , x = i[r] * o
              , g = i[s] * o
              , v = i[n] * o
              , T = i[r + 1] * h
              , m = i[s + 1] * h
              , y = i[n + 1] * h;
            if (0 < this.canvasPadding) {
                var b = this.canvasPadding / this.worldTransform.a
                  , S = this.canvasPadding / this.worldTransform.d
                  , _ = (l + u + c) / 3
                  , A = (d + f + p) / 3
                  , E = l - _
                  , R = d - A
                  , B = Math.sqrt(E * E + R * R);
                l = _ + E / B * (B + b),
                d = A + R / B * (B + S),
                R = f - A,
                u = _ + (E = u - _) / (B = Math.sqrt(E * E + R * R)) * (B + b),
                f = A + R / B * (B + S),
                R = p - A,
                c = _ + (E = c - _) / (B = Math.sqrt(E * E + R * R)) * (B + b),
                p = A + R / B * (B + S)
            }
            t.save(),
            t.beginPath(),
            t.moveTo(l, d),
            t.lineTo(u, f),
            t.lineTo(c, p),
            t.closePath(),
            t.clip();
            var w = x * m + T * v + g * y - m * v - T * g - x * y
              , M = l * m + T * c + u * y - m * c - T * u - l * y
              , C = x * u + l * v + g * c - u * v - l * g - x * c
              , L = x * m * c + T * u * v + l * g * y - l * m * v - T * g * c - x * u * y
              , F = d * m + T * p + f * y - m * p - T * f - d * y
              , P = x * f + d * v + g * p - f * v - d * g - x * p
              , U = x * m * p + T * f * v + d * g * y - d * m * v - T * g * p - x * f * y;
            t.transform(M / w, F / w, C / w, P / w, L / w, U / w),
            t.drawImage(a, 0, 0),
            t.restore()
        }
        ,
        U.Strip.prototype.renderStripFlat = function(t) {
            var e = this.context
              , i = t.vertices
              , r = i.length / 2;
            this.count++,
            e.beginPath();
            for (var s = 1; s < r - 2; s++) {
                var n = 2 * s
                  , a = i[n]
                  , o = i[2 + n]
                  , h = i[4 + n]
                  , l = i[1 + n]
                  , u = i[3 + n]
                  , c = i[5 + n];
                e.moveTo(a, l),
                e.lineTo(o, u),
                e.lineTo(h, c)
            }
            e.fillStyle = "#FF0000",
            e.fill(),
            e.closePath()
        }
        ,
        U.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        }
        ,
        U.Strip.prototype.getBounds = function(t) {
            for (var e = t || this.worldTransform, i = e.a, r = e.b, s = e.c, n = e.d, a = e.tx, o = e.ty, h = -1 / 0, l = -1 / 0, u = 1 / 0, c = 1 / 0, d = this.vertices, f = 0, p = d.length; f < p; f += 2) {
                var x = d[f]
                  , g = d[f + 1]
                  , v = i * x + s * g + a
                  , T = n * g + r * x + o;
                u = v < u ? v : u,
                c = T < c ? T : c,
                h = h < v ? v : h,
                l = l < T ? T : l
            }
            if (u === -1 / 0 || l === 1 / 0)
                return U.EmptyRectangle;
            var m = this._bounds;
            return m.x = u,
            m.width = h - u,
            m.y = c,
            m.height = l - c,
            this._currentBounds = m
        }
        ,
        U.Strip.DrawModes = {
            TRIANGLE_STRIP: 0,
            TRIANGLES: 1
        },
        U.Rope = function(t, e) {
            U.Strip.call(this, t),
            this.points = e,
            this.vertices = new U.Float32Array(4 * e.length),
            this.uvs = new U.Float32Array(4 * e.length),
            this.colors = new U.Float32Array(2 * e.length),
            this.indices = new U.Uint16Array(2 * e.length),
            this.refresh()
        }
        ,
        U.Rope.prototype = Object.create(U.Strip.prototype),
        U.Rope.prototype.constructor = U.Rope,
        U.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs
                  , i = (t[0],
                this.indices)
                  , r = this.colors;
                this.count -= .2,
                e[0] = 0,
                e[1] = 0,
                e[2] = 0,
                e[3] = 1,
                r[0] = 1,
                r[1] = 1,
                i[0] = 0,
                i[1] = 1;
                for (var s, n, a, o = t.length, h = 1; h < o; h++)
                    s = t[h],
                    a = h / (o - 1),
                    e[n = 4 * h] = a,
                    e[n + 1] = 0,
                    e[n + 2] = a,
                    e[n + 3] = 1,
                    r[n = 2 * h] = 1,
                    r[n + 1] = 1,
                    i[n = 2 * h] = n,
                    i[n + 1] = n + 1,
                    s
            }
        }
        ,
        U.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e, i = t[0], r = {
                    x: 0,
                    y: 0
                };
                this.count -= .2;
                for (var s, n, a, o, h = this.vertices, l = t.length, u = 0; u < l; u++)
                    s = t[u],
                    n = 4 * u,
                    e = u < t.length - 1 ? t[u + 1] : s,
                    r.y = -(e.x - i.x),
                    r.x = e.y - i.y,
                    1 < 10 * (1 - u / (l - 1)) && 1,
                    a = Math.sqrt(r.x * r.x + r.y * r.y),
                    o = this.texture.height / 2,
                    r.x /= a,
                    r.y /= a,
                    r.x *= o,
                    r.y *= o,
                    h[n] = s.x + r.x,
                    h[1 + n] = s.y + r.y,
                    h[2 + n] = s.x - r.x,
                    h[3 + n] = s.y - r.y,
                    i = s;
                U.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }
        ,
        U.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }
        ,
        U.TilingSprite = function(t, e, i) {
            U.Sprite.call(this, t),
            this._width = e || 128,
            this._height = i || 128,
            this.tileScale = new U.Point(1,1),
            this.tileScaleOffset = new U.Point(1,1),
            this.tilePosition = new U.Point,
            this.renderable = !0,
            this.tint = 16777215,
            this.textureDebug = !1,
            this.blendMode = U.blendModes.NORMAL,
            this.canvasBuffer = null,
            this.tilingTexture = null,
            this.tilePattern = null,
            this.refreshTexture = !0,
            this.frameWidth = 0,
            this.frameHeight = 0
        }
        ,
        U.TilingSprite.prototype = Object.create(U.Sprite.prototype),
        U.TilingSprite.prototype.constructor = U.TilingSprite,
        U.TilingSprite.prototype.setTexture = function(t) {
            this.texture !== t && (this.texture = t,
            this.refreshTexture = !0,
            this.cachedTint = 16777215)
        }
        ,
        U.TilingSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(),
                t.maskManager.pushMask(this.mask, t),
                t.spriteBatch.start()),
                this._filters && (t.spriteBatch.flush(),
                t.filterManager.pushFilter(this._filterBlock)),
                this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t),
                    !this.tilingTexture)
                        return;
                    this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture),
                    this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++)
                    this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(),
                this._filters && t.filterManager.popFilter(),
                this._mask && t.maskManager.popMask(this._mask, t),
                t.spriteBatch.start()
            }
        }
        ,
        U.TilingSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t),
                e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform
                  , r = t.resolution
                  , s = i.tx * r + t.shakeX
                  , n = i.ty * r + t.shakeY;
                if (e.setTransform(i.a * r, i.b * r, i.c * r, i.d * r, s, n),
                this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t),
                    !this.tilingTexture)
                        return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var a = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                e.globalCompositeOperation = U.blendModesCanvas[t.currentBlendMode]);
                var o = this.tilePosition
                  , h = this.tileScale;
                o.x %= this.tilingTexture.baseTexture.width,
                o.y %= this.tilingTexture.baseTexture.height,
                e.scale(h.x, h.y),
                e.translate(o.x + this.anchor.x * -this._width, o.y + this.anchor.y * -this._height),
                e.fillStyle = this.tilePattern;
                s = -o.x,
                n = -o.y;
                var l = this._width / h.x
                  , u = this._height / h.y;
                t.roundPixels && (s |= 0,
                n |= 0,
                l |= 0,
                u |= 0),
                e.fillRect(s, n, l, u),
                e.scale(1 / h.x, 1 / h.y),
                e.translate(-o.x + this.anchor.x * this._width, -o.y + this.anchor.y * this._height),
                this._mask && t.maskManager.popMask(t);
                for (var c = 0; c < this.children.length; c++)
                    this.children[c]._renderCanvas(t);
                a !== this.blendMode && (t.currentBlendMode = a,
                e.globalCompositeOperation = U.blendModesCanvas[a])
            }
        }
        ,
        U.TilingSprite.prototype.onTextureUpdate = function() {}
        ,
        U.TilingSprite.prototype.generateTilingTexture = function(t, e) {
            if (this.texture.baseTexture.hasLoaded) {
                var i = this.texture
                  , r = i.frame
                  , s = this._frame.sourceSizeW || this._frame.width
                  , n = this._frame.sourceSizeH || this._frame.height
                  , a = 0
                  , o = 0;
                this._frame.trimmed && (a = this._frame.spriteSourceSizeX,
                o = this._frame.spriteSourceSizeY),
                t && (s = U.getNextPowerOfTwo(s),
                n = U.getNextPowerOfTwo(n)),
                this.canvasBuffer ? (this.canvasBuffer.resize(s, n),
                this.tilingTexture.baseTexture.width = s,
                this.tilingTexture.baseTexture.height = n) : (this.canvasBuffer = new U.CanvasBuffer(s,n),
                this.tilingTexture = U.Texture.fromCanvas(this.canvasBuffer.canvas),
                this.tilingTexture.isTiling = !0),
                this.tilingTexture.needsUpdate = !0,
                this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00",
                this.canvasBuffer.context.strokeRect(0, 0, s, n));
                var h = i.crop.width
                  , l = i.crop.height;
                h === s && l === n || (h = s,
                l = n),
                this.canvasBuffer.context.drawImage(i.baseTexture.source, i.crop.x, i.crop.y, i.crop.width, i.crop.height, a, o, h, l),
                this.tileScaleOffset.x = r.width / s,
                this.tileScaleOffset.y = r.height / n,
                this.refreshTexture = !1,
                this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }
        ,
        U.TilingSprite.prototype.getBounds = function() {
            var t = this._width
              , e = this._height
              , i = t * (1 - this.anchor.x)
              , r = t * -this.anchor.x
              , s = e * (1 - this.anchor.y)
              , n = e * -this.anchor.y
              , a = this.worldTransform
              , o = a.a
              , h = a.b
              , l = a.c
              , u = a.d
              , c = a.tx
              , d = a.ty
              , f = o * r + l * n + c
              , p = u * n + h * r + d
              , x = o * i + l * n + c
              , g = u * n + h * i + d
              , v = o * i + l * s + c
              , T = u * s + h * i + d
              , m = o * r + l * s + c
              , y = u * s + h * r + d
              , b = -1 / 0
              , S = -1 / 0
              , _ = 1 / 0
              , A = 1 / 0;
            _ = m < (_ = v < (_ = x < (_ = f < _ ? f : _) ? x : _) ? v : _) ? m : _,
            A = y < (A = T < (A = g < (A = p < A ? p : A) ? g : A) ? T : A) ? y : A,
            b = (b = (b = (b = b < f ? f : b) < x ? x : b) < v ? v : b) < m ? m : b,
            S = (S = (S = (S = S < p ? p : S) < g ? g : S) < T ? T : S) < y ? y : S;
            var E = this._bounds;
            return E.x = _,
            E.width = b - _,
            E.y = A,
            E.height = S - A,
            this._currentBounds = E
        }
        ,
        U.TilingSprite.prototype.destroy = function() {
            U.Sprite.prototype.destroy.call(this),
            this.canvasBuffer && (this.canvasBuffer.destroy(),
            this.canvasBuffer = null),
            this.tileScale = null,
            this.tileScaleOffset = null,
            this.tilePosition = null,
            this.tilingTexture && (this.tilingTexture.destroy(!0),
            this.tilingTexture = null)
        }
        ,
        Object.defineProperty(U.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }),
        Object.defineProperty(U.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }),
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = U),
        exports.PIXI = U) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = U) : t.PIXI = U,
        U
    }
    ).call(this);
    !function(t) {
        var e;
        "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self),
        e.p2 = t())
    }(function() {
        return function n(r, o, a) {
            function h(i, t) {
                if (!o[i]) {
                    if (!r[i]) {
                        var e = "function" == typeof require && require;
                        if (!t && e)
                            return e(i, !0);
                        if (l)
                            return l(i, !0);
                        throw new Error("Cannot find module '" + i + "'")
                    }
                    var s = o[i] = {
                        exports: {}
                    };
                    r[i][0].call(s.exports, function(t) {
                        var e = r[i][1][t];
                        return h(e || t)
                    }, s, s.exports, n, r, o, a)
                }
                return o[i].exports
            }
            for (var l = "function" == typeof require && require, t = 0; t < a.length; t++)
                h(a[t]);
            return h
        }({
            1: [function(t, e, i) {
                var u = t("./Scalar");
                function s() {}
                (e.exports = s).lineInt = function(t, e, i) {
                    i = i || 0;
                    var s, n, r, o, a, h, l, c = [0, 0];
                    return s = t[1][1] - t[0][1],
                    n = t[0][0] - t[1][0],
                    r = s * t[0][0] + n * t[0][1],
                    o = e[1][1] - e[0][1],
                    a = e[0][0] - e[1][0],
                    h = o * e[0][0] + a * e[0][1],
                    l = s * a - o * n,
                    u.eq(l, 0, i) || (c[0] = (a * r - n * h) / l,
                    c[1] = (s * h - o * r) / l),
                    c
                }
                ,
                s.segmentsIntersect = function(t, e, i, s) {
                    var n = e[0] - t[0]
                      , r = e[1] - t[1]
                      , o = s[0] - i[0]
                      , a = s[1] - i[1];
                    if (o * r - a * n == 0)
                        return !1;
                    var h = (n * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * n)
                      , l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - o * r);
                    return 0 <= h && h <= 1 && 0 <= l && l <= 1
                }
            }
            , {
                "./Scalar": 4
            }],
            2: [function(t, e, i) {
                function l() {}
                (e.exports = l).area = function(t, e, i) {
                    return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
                }
                ,
                l.left = function(t, e, i) {
                    return 0 < l.area(t, e, i)
                }
                ,
                l.leftOn = function(t, e, i) {
                    return 0 <= l.area(t, e, i)
                }
                ,
                l.right = function(t, e, i) {
                    return l.area(t, e, i) < 0
                }
                ,
                l.rightOn = function(t, e, i) {
                    return l.area(t, e, i) <= 0
                }
                ;
                var c = []
                  , u = [];
                l.collinear = function(t, e, i, s) {
                    if (s) {
                        var n = c
                          , r = u;
                        n[0] = e[0] - t[0],
                        n[1] = e[1] - t[1],
                        r[0] = i[0] - e[0],
                        r[1] = i[1] - e[1];
                        var o = n[0] * r[0] + n[1] * r[1]
                          , a = Math.sqrt(n[0] * n[0] + n[1] * n[1])
                          , h = Math.sqrt(r[0] * r[0] + r[1] * r[1]);
                        return Math.acos(o / (a * h)) < s
                    }
                    return 0 == l.area(t, e, i)
                }
                ,
                l.sqdist = function(t, e) {
                    var i = e[0] - t[0]
                      , s = e[1] - t[1];
                    return i * i + s * s
                }
            }
            , {}],
            3: [function(t, e, i) {
                var a = t("./Line")
                  , w = t("./Point")
                  , d = t("./Scalar");
                function T() {
                    this.vertices = []
                }
                (e.exports = T).prototype.at = function(t) {
                    var e = this.vertices
                      , i = e.length;
                    return e[t < 0 ? t % i + i : t % i]
                }
                ,
                T.prototype.first = function() {
                    return this.vertices[0]
                }
                ,
                T.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1]
                }
                ,
                T.prototype.clear = function() {
                    this.vertices.length = 0
                }
                ,
                T.prototype.append = function(t, e, i) {
                    if (void 0 === e)
                        throw new Error("From is not given!");
                    if (void 0 === i)
                        throw new Error("To is not given!");
                    if (i - 1 < e)
                        throw new Error("lol1");
                    if (i > t.vertices.length)
                        throw new Error("lol2");
                    if (e < 0)
                        throw new Error("lol3");
                    for (var s = e; s < i; s++)
                        this.vertices.push(t.vertices[s])
                }
                ,
                T.prototype.makeCCW = function() {
                    for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)
                        (e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                    w.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
                }
                ,
                T.prototype.reverse = function() {
                    for (var t = [], e = 0, i = this.vertices.length; e !== i; e++)
                        t.push(this.vertices.pop());
                    this.vertices = t
                }
                ,
                T.prototype.isReflex = function(t) {
                    return w.right(this.at(t - 1), this.at(t), this.at(t + 1))
                }
                ;
                var h = []
                  , l = [];
                function P(t, e, i, s, n) {
                    n = n || 0;
                    var r = e[1] - t[1]
                      , o = t[0] - e[0]
                      , a = r * t[0] + o * t[1]
                      , h = s[1] - i[1]
                      , l = i[0] - s[0]
                      , c = h * i[0] + l * i[1]
                      , u = r * l - h * o;
                    return d.eq(u, 0, n) ? [0, 0] : [(l * a - o * c) / u, (r * c - h * a) / u]
                }
                T.prototype.canSee = function(t, e) {
                    var i, s, n = h, r = l;
                    if (w.leftOn(this.at(t + 1), this.at(t), this.at(e)) && w.rightOn(this.at(t - 1), this.at(t), this.at(e)))
                        return !1;
                    s = w.sqdist(this.at(t), this.at(e));
                    for (var o = 0; o !== this.vertices.length; ++o)
                        if ((o + 1) % this.vertices.length !== t && o !== t && w.leftOn(this.at(t), this.at(e), this.at(o + 1)) && w.rightOn(this.at(t), this.at(e), this.at(o)) && (n[0] = this.at(t),
                        n[1] = this.at(e),
                        r[0] = this.at(o),
                        r[1] = this.at(o + 1),
                        i = a.lineInt(n, r),
                        w.sqdist(this.at(t), i) < s))
                            return !1;
                    return !0
                }
                ,
                T.prototype.copy = function(t, e, i) {
                    var s = i || new T;
                    if (s.clear(),
                    t < e)
                        for (var n = t; n <= e; n++)
                            s.vertices.push(this.vertices[n]);
                    else {
                        for (n = 0; n <= e; n++)
                            s.vertices.push(this.vertices[n]);
                        for (n = t; n < this.vertices.length; n++)
                            s.vertices.push(this.vertices[n])
                    }
                    return s
                }
                ,
                T.prototype.getCutEdges = function() {
                    for (var t = [], e = [], i = [], s = new T, n = Number.MAX_VALUE, r = 0; r < this.vertices.length; ++r)
                        if (this.isReflex(r))
                            for (var o = 0; o < this.vertices.length; ++o)
                                if (this.canSee(r, o)) {
                                    e = this.copy(r, o, s).getCutEdges(),
                                    i = this.copy(o, r, s).getCutEdges();
                                    for (var a = 0; a < i.length; a++)
                                        e.push(i[a]);
                                    e.length < n && (n = (t = e).length,
                                    t.push([this.at(r), this.at(o)]))
                                }
                    return t
                }
                ,
                T.prototype.decomp = function() {
                    var t = this.getCutEdges();
                    return 0 < t.length ? this.slice(t) : [this]
                }
                ,
                T.prototype.slice = function(t) {
                    if (0 == t.length)
                        return [this];
                    if (t instanceof Array && t.length && t[0]instanceof Array && 2 == t[0].length && t[0][0]instanceof Array) {
                        for (var e = [this], i = 0; i < t.length; i++)
                            for (var s = t[i], n = 0; n < e.length; n++) {
                                var r = e[n].slice(s);
                                if (r) {
                                    e.splice(n, 1),
                                    e.push(r[0], r[1]);
                                    break
                                }
                            }
                        return e
                    }
                    s = t,
                    i = this.vertices.indexOf(s[0]),
                    n = this.vertices.indexOf(s[1]);
                    return -1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)]
                }
                ,
                T.prototype.isSimple = function() {
                    for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                        for (var i = 0; i < e - 1; i++)
                            if (a.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1]))
                                return !1;
                    for (e = 1; e < t.length - 2; e++)
                        if (a.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1]))
                            return !1;
                    return !0
                }
                ,
                T.prototype.quickDecomp = function(t, e, i, s, n, r) {
                    n = n || 100,
                    r = r || 0,
                    s = s || 25,
                    t = void 0 !== t ? t : [],
                    e = e || [],
                    i = i || [];
                    var o = [0, 0]
                      , a = [0, 0]
                      , h = [0, 0]
                      , l = 0
                      , c = 0
                      , u = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , g = 0
                      , m = new T
                      , y = new T
                      , v = this
                      , x = this.vertices;
                    if (x.length < 3)
                        return t;
                    if (n < ++r)
                        return console.warn("quickDecomp: max level (" + n + ") reached."),
                        t;
                    for (var b = 0; b < this.vertices.length; ++b)
                        if (v.isReflex(b)) {
                            e.push(v.vertices[b]),
                            l = c = Number.MAX_VALUE;
                            for (var _ = 0; _ < this.vertices.length; ++_)
                                w.left(v.at(b - 1), v.at(b), v.at(_)) && w.rightOn(v.at(b - 1), v.at(b), v.at(_ - 1)) && (h = P(v.at(b - 1), v.at(b), v.at(_), v.at(_ - 1)),
                                w.right(v.at(b + 1), v.at(b), h) && (u = w.sqdist(v.vertices[b], h)) < c && (c = u,
                                a = h,
                                f = _)),
                                w.left(v.at(b + 1), v.at(b), v.at(_ + 1)) && w.rightOn(v.at(b + 1), v.at(b), v.at(_)) && (h = P(v.at(b + 1), v.at(b), v.at(_), v.at(_ + 1)),
                                w.left(v.at(b - 1), v.at(b), h) && (u = w.sqdist(v.vertices[b], h)) < l && (l = u,
                                o = h,
                                p = _));
                            if (f == (p + 1) % this.vertices.length)
                                h[0] = (a[0] + o[0]) / 2,
                                h[1] = (a[1] + o[1]) / 2,
                                i.push(h),
                                b < p ? (m.append(v, b, p + 1),
                                m.vertices.push(h),
                                y.vertices.push(h),
                                0 != f && y.append(v, f, v.vertices.length),
                                y.append(v, 0, b + 1)) : (0 != b && m.append(v, b, v.vertices.length),
                                m.append(v, 0, p + 1),
                                m.vertices.push(h),
                                y.vertices.push(h),
                                y.append(v, f, b + 1));
                            else {
                                if (p < f && (p += this.vertices.length),
                                d = Number.MAX_VALUE,
                                p < f)
                                    return t;
                                for (_ = f; _ <= p; ++_)
                                    w.leftOn(v.at(b - 1), v.at(b), v.at(_)) && w.rightOn(v.at(b + 1), v.at(b), v.at(_)) && (u = w.sqdist(v.at(b), v.at(_))) < d && (d = u,
                                    g = _ % this.vertices.length);
                                b < g ? (m.append(v, b, g + 1),
                                0 != g && y.append(v, g, x.length),
                                y.append(v, 0, b + 1)) : (0 != b && m.append(v, b, x.length),
                                m.append(v, 0, g + 1),
                                y.append(v, g, b + 1))
                            }
                            return m.vertices.length < y.vertices.length ? (m.quickDecomp(t, e, i, s, n, r),
                            y.quickDecomp(t, e, i, s, n, r)) : (y.quickDecomp(t, e, i, s, n, r),
                            m.quickDecomp(t, e, i, s, n, r)),
                            t
                        }
                    return t.push(this),
                    t
                }
                ,
                T.prototype.removeCollinearPoints = function(t) {
                    for (var e = 0, i = this.vertices.length - 1; 3 < this.vertices.length && 0 <= i; --i)
                        w.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1),
                        i--,
                        e++);
                    return e
                }
            }
            , {
                "./Line": 1,
                "./Point": 2,
                "./Scalar": 4
            }],
            4: [function(t, e, i) {
                function s() {}
                (e.exports = s).eq = function(t, e, i) {
                    return i = i || 0,
                    Math.abs(t - e) < i
                }
            }
            , {}],
            5: [function(t, e, i) {
                e.exports = {
                    Polygon: t("./Polygon"),
                    Point: t("./Point")
                }
            }
            , {
                "./Point": 2,
                "./Polygon": 3
            }],
            6: [function(t, e, i) {
                e.exports = {
                    name: "p2",
                    version: "0.7.1",
                    description: "A JavaScript 2D physics engine.",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                    main: "./src/p2.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/p2.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/p2.js/issues"
                    },
                    licenses: [{
                        type: "MIT"
                    }],
                    devDependencies: {
                        grunt: "^0.4.5",
                        "grunt-contrib-jshint": "^0.11.2",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "grunt-contrib-concat": "^0.4.0"
                    },
                    dependencies: {
                        "poly-decomp": "0.1.1"
                    }
                }
            }
            , {}],
            7: [function(t, e, i) {
                var p = t("../math/vec2");
                t("../utils/Utils");
                function s(t) {
                    this.lowerBound = p.create(),
                    t && t.lowerBound && p.copy(this.lowerBound, t.lowerBound),
                    this.upperBound = p.create(),
                    t && t.upperBound && p.copy(this.upperBound, t.upperBound)
                }
                e.exports = s;
                var f = p.create();
                s.prototype.setFromPoints = function(t, e, i, s) {
                    var n = this.lowerBound
                      , r = this.upperBound;
                    "number" != typeof i && (i = 0),
                    0 !== i ? p.rotate(n, t[0], i) : p.copy(n, t[0]),
                    p.copy(r, n);
                    for (var o = Math.cos(i), a = Math.sin(i), h = 1; h < t.length; h++) {
                        var l = t[h];
                        if (0 !== i) {
                            var c = l[0]
                              , u = l[1];
                            f[0] = o * c - a * u,
                            f[1] = a * c + o * u,
                            l = f
                        }
                        for (var d = 0; d < 2; d++)
                            l[d] > r[d] && (r[d] = l[d]),
                            l[d] < n[d] && (n[d] = l[d])
                    }
                    e && (p.add(this.lowerBound, this.lowerBound, e),
                    p.add(this.upperBound, this.upperBound, e)),
                    s && (this.lowerBound[0] -= s,
                    this.lowerBound[1] -= s,
                    this.upperBound[0] += s,
                    this.upperBound[1] += s)
                }
                ,
                s.prototype.copy = function(t) {
                    p.copy(this.lowerBound, t.lowerBound),
                    p.copy(this.upperBound, t.upperBound)
                }
                ,
                s.prototype.extend = function(t) {
                    for (var e = 2; e--; ) {
                        var i = t.lowerBound[e];
                        this.lowerBound[e] > i && (this.lowerBound[e] = i);
                        var s = t.upperBound[e];
                        this.upperBound[e] < s && (this.upperBound[e] = s)
                    }
                }
                ,
                s.prototype.overlaps = function(t) {
                    var e = this.lowerBound
                      , i = this.upperBound
                      , s = t.lowerBound
                      , n = t.upperBound;
                    return (s[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (s[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1])
                }
                ,
                s.prototype.containsPoint = function(t) {
                    var e = this.lowerBound
                      , i = this.upperBound;
                    return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
                }
                ,
                s.prototype.overlapsRay = function(t) {
                    var e = 1 / t.direction[0]
                      , i = 1 / t.direction[1]
                      , s = (this.lowerBound[0] - t.from[0]) * e
                      , n = (this.upperBound[0] - t.from[0]) * e
                      , r = (this.lowerBound[1] - t.from[1]) * i
                      , o = (this.upperBound[1] - t.from[1]) * i
                      , a = Math.max(Math.max(Math.min(s, n), Math.min(r, o)))
                      , h = Math.min(Math.min(Math.max(s, n), Math.max(r, o)));
                    return h < 0 ? -1 : h < a ? -1 : a
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            8: [function(t, e, i) {
                var n = t("../math/vec2")
                  , r = t("../objects/Body");
                function s(t) {
                    this.type = t,
                    this.result = [],
                    this.world = null,
                    this.boundingVolumeType = s.AABB
                }
                (e.exports = s).AABB = 1,
                s.BOUNDING_CIRCLE = 2,
                s.prototype.setWorld = function(t) {
                    this.world = t
                }
                ,
                s.prototype.getCollisionPairs = function(t) {}
                ;
                var o = n.create();
                s.boundingRadiusCheck = function(t, e) {
                    n.sub(o, t.position, e.position);
                    var i = n.squaredLength(o)
                      , s = t.boundingRadius + e.boundingRadius;
                    return i <= s * s
                }
                ,
                s.aabbCheck = function(t, e) {
                    return t.getAABB().overlaps(e.getAABB())
                }
                ,
                s.prototype.boundingVolumeCheck = function(t, e) {
                    var i;
                    switch (this.boundingVolumeType) {
                    case s.BOUNDING_CIRCLE:
                        i = s.boundingRadiusCheck(t, e);
                        break;
                    case s.AABB:
                        i = s.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                    }
                    return i
                }
                ,
                s.canCollide = function(t, e) {
                    var i = r.KINEMATIC
                      , s = r.STATIC;
                    return (t.type !== s || e.type !== s) && (!(t.type === i && e.type === s || t.type === s && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== r.SLEEPING || e.sleepState !== r.SLEEPING) && !(t.sleepState === r.SLEEPING && e.type === s || e.sleepState === r.SLEEPING && t.type === s))))
                }
                ,
                s.NAIVE = 1,
                s.SAP = 2
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31
            }],
            9: [function(t, e, i) {
                t("../shapes/Circle"),
                t("../shapes/Plane"),
                t("../shapes/Shape"),
                t("../shapes/Particle");
                var h = t("../collision/Broadphase");
                t("../math/vec2");
                function s() {
                    h.call(this, h.NAIVE)
                }
                (((e.exports = s).prototype = new h).constructor = s).prototype.getCollisionPairs = function(t) {
                    for (var e = t.bodies, i = this.result, s = i.length = 0, n = e.length; s !== n; s++)
                        for (var r = e[s], o = 0; o < s; o++) {
                            var a = e[o];
                            h.canCollide(r, a) && this.boundingVolumeCheck(r, a) && i.push(r, a)
                        }
                    return i
                }
                ,
                s.prototype.aabbQuery = function(t, e, i) {
                    i = i || [];
                    for (var s = t.bodies, n = 0; n < s.length; n++) {
                        var r = s[n];
                        r.aabbNeedsUpdate && r.updateAABB(),
                        r.aabb.overlaps(e) && i.push(r)
                    }
                    return i
                }
            }
            , {
                "../collision/Broadphase": 8,
                "../math/vec2": 30,
                "../shapes/Circle": 39,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45
            }],
            10: [function(t, e, i) {
                var X = t("../math/vec2")
                  , W = X.sub
                  , j = X.add
                  , V = X.dot
                  , s = (t("../utils/Utils"),
                t("../utils/ContactEquationPool"))
                  , n = t("../utils/FrictionEquationPool")
                  , r = t("../utils/TupleDictionary")
                  , o = t("../equations/Equation")
                  , a = (t("../equations/ContactEquation"),
                t("../equations/FrictionEquation"),
                t("../shapes/Circle"))
                  , h = t("../shapes/Convex")
                  , l = t("../shapes/Shape")
                  , T = (t("../objects/Body"),
                t("../shapes/Box"));
                e.exports = $;
                var P = X.fromValues(0, 1)
                  , q = X.fromValues(0, 0)
                  , H = X.fromValues(0, 0)
                  , Y = X.fromValues(0, 0)
                  , z = X.fromValues(0, 0)
                  , K = X.fromValues(0, 0)
                  , O = X.fromValues(0, 0)
                  , J = X.fromValues(0, 0)
                  , Q = X.fromValues(0, 0)
                  , Z = X.fromValues(0, 0)
                  , k = X.fromValues(0, 0)
                  , F = X.fromValues(0, 0)
                  , D = X.fromValues(0, 0)
                  , U = X.fromValues(0, 0)
                  , G = X.fromValues(0, 0)
                  , R = X.fromValues(0, 0)
                  , L = X.fromValues(0, 0)
                  , E = X.fromValues(0, 0)
                  , M = X.fromValues(0, 0)
                  , N = [];
                function $() {
                    this.contactEquations = [],
                    this.frictionEquations = [],
                    this.enableFriction = !0,
                    this.enabledEquations = !0,
                    this.slipForce = 10,
                    this.frictionCoefficient = .3,
                    this.surfaceVelocity = 0,
                    this.contactEquationPool = new s({
                        size: 32
                    }),
                    this.frictionEquationPool = new n({
                        size: 64
                    }),
                    this.restitution = 0,
                    this.stiffness = o.DEFAULT_STIFFNESS,
                    this.relaxation = o.DEFAULT_RELAXATION,
                    this.frictionStiffness = o.DEFAULT_STIFFNESS,
                    this.frictionRelaxation = o.DEFAULT_RELAXATION,
                    this.enableFrictionReduction = !0,
                    this.collidingBodiesLastStep = new r,
                    this.contactSkinSize = .01
                }
                var c = X.create()
                  , u = X.create();
                function x(t, e) {
                    X.set(t.vertices[0], .5 * -e.length, -e.radius),
                    X.set(t.vertices[1], .5 * e.length, -e.radius),
                    X.set(t.vertices[2], .5 * e.length, e.radius),
                    X.set(t.vertices[3], .5 * -e.length, e.radius)
                }
                $.prototype.bodiesOverlap = function(t, e) {
                    for (var i = c, s = u, n = 0, r = t.shapes.length; n !== r; n++) {
                        var o = t.shapes[n];
                        t.toWorldFrame(i, o.position);
                        for (var a = 0, h = e.shapes.length; a !== h; a++) {
                            var l = e.shapes[a];
                            if (e.toWorldFrame(s, l.position),
                            this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, s, l.angle + e.angle, !0))
                                return !0
                        }
                    }
                    return !1
                }
                ,
                $.prototype.collidedLastStep = function(t, e) {
                    var i = 0 | t.id
                      , s = 0 | e.id;
                    return !!this.collidingBodiesLastStep.get(i, s)
                }
                ,
                $.prototype.reset = function() {
                    this.collidingBodiesLastStep.reset();
                    for (var t = this.contactEquations, e = t.length; e--; ) {
                        var i = t[e]
                          , s = i.bodyA.id
                          , n = i.bodyB.id;
                        this.collidingBodiesLastStep.set(s, n, !0)
                    }
                    for (var r = this.contactEquations, o = this.frictionEquations, a = 0; a < r.length; a++)
                        this.contactEquationPool.release(r[a]);
                    for (a = 0; a < o.length; a++)
                        this.frictionEquationPool.release(o[a]);
                    this.contactEquations.length = this.frictionEquations.length = 0
                }
                ,
                $.prototype.createContactEquation = function(t, e, i, s) {
                    var n = this.contactEquationPool.get();
                    return n.bodyA = t,
                    n.bodyB = e,
                    n.shapeA = i,
                    n.shapeB = s,
                    n.restitution = this.restitution,
                    n.firstImpact = !this.collidedLastStep(t, e),
                    n.stiffness = this.stiffness,
                    n.relaxation = this.relaxation,
                    n.needsUpdate = !0,
                    n.enabled = this.enabledEquations,
                    n.offset = this.contactSkinSize,
                    n
                }
                ,
                $.prototype.createFrictionEquation = function(t, e, i, s) {
                    var n = this.frictionEquationPool.get();
                    return n.bodyA = t,
                    n.bodyB = e,
                    n.shapeA = i,
                    n.shapeB = s,
                    n.setSlipForce(this.slipForce),
                    n.frictionCoefficient = this.frictionCoefficient,
                    n.relativeVelocity = this.surfaceVelocity,
                    n.enabled = this.enabledEquations,
                    n.needsUpdate = !0,
                    n.stiffness = this.frictionStiffness,
                    n.relaxation = this.frictionRelaxation,
                    n.contactEquations.length = 0,
                    n
                }
                ,
                $.prototype.createFrictionFromContact = function(t) {
                    var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                    return X.copy(e.contactPointA, t.contactPointA),
                    X.copy(e.contactPointB, t.contactPointB),
                    X.rotate90cw(e.t, t.normalA),
                    e.contactEquations.push(t),
                    e
                }
                ,
                $.prototype.createFrictionFromAverage = function(t) {
                    var e = this.contactEquations[this.contactEquations.length - 1]
                      , i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB)
                      , s = e.bodyA;
                    e.bodyB;
                    X.set(i.contactPointA, 0, 0),
                    X.set(i.contactPointB, 0, 0),
                    X.set(i.t, 0, 0);
                    for (var n = 0; n !== t; n++)
                        (e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === s ? (X.add(i.t, i.t, e.normalA),
                        X.add(i.contactPointA, i.contactPointA, e.contactPointA),
                        X.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (X.sub(i.t, i.t, e.normalA),
                        X.add(i.contactPointA, i.contactPointA, e.contactPointB),
                        X.add(i.contactPointB, i.contactPointB, e.contactPointA)),
                        i.contactEquations.push(e);
                    var r = 1 / t;
                    return X.scale(i.contactPointA, i.contactPointA, r),
                    X.scale(i.contactPointB, i.contactPointB, r),
                    X.normalize(i.t, i.t),
                    X.rotate90cw(i.t, i.t),
                    i
                }
                ,
                $.prototype[l.LINE | l.CONVEX] = $.prototype.convexLine = function(t, e, i, s, n, r, o, a, h) {
                    return !h && 0
                }
                ,
                $.prototype[l.LINE | l.BOX] = $.prototype.lineBox = function(t, e, i, s, n, r, o, a, h) {
                    return !h && 0
                }
                ;
                var p = new T({
                    width: 1,
                    height: 1
                })
                  , f = X.create();
                $.prototype[l.CAPSULE | l.CONVEX] = $.prototype[l.CAPSULE | l.BOX] = $.prototype.convexCapsule = function(t, e, i, s, n, r, o, a, h) {
                    var l = f;
                    X.set(l, r.length / 2, 0),
                    X.rotate(l, l, a),
                    X.add(l, l, o);
                    var c = this.circleConvex(n, r, l, a, t, e, i, s, h, r.radius);
                    X.set(l, -r.length / 2, 0),
                    X.rotate(l, l, a),
                    X.add(l, l, o);
                    var u = this.circleConvex(n, r, l, a, t, e, i, s, h, r.radius);
                    if (h && (c || u))
                        return !0;
                    var d = p;
                    return x(d, r),
                    this.convexConvex(t, e, i, s, n, d, o, a, h) + c + u
                }
                ,
                $.prototype[l.CAPSULE | l.LINE] = $.prototype.lineCapsule = function(t, e, i, s, n, r, o, a, h) {
                    return !h && 0
                }
                ;
                var b = X.create()
                  , _ = X.create()
                  , w = new T({
                    width: 1,
                    height: 1
                });
                $.prototype[l.CAPSULE | l.CAPSULE] = $.prototype.capsuleCapsule = function(t, e, i, s, n, r, o, a, h) {
                    for (var l = b, c = _, u = 0, d = 0; d < 2; d++) {
                        X.set(l, (0 === d ? -1 : 1) * e.length / 2, 0),
                        X.rotate(l, l, s),
                        X.add(l, l, i);
                        for (var p = 0; p < 2; p++) {
                            X.set(c, (0 === p ? -1 : 1) * r.length / 2, 0),
                            X.rotate(c, c, a),
                            X.add(c, c, o),
                            this.enableFrictionReduction && (y = this.enableFriction,
                            this.enableFriction = !1);
                            var f = this.circleCircle(t, e, l, s, n, r, c, a, h, e.radius, r.radius);
                            if (this.enableFrictionReduction && (this.enableFriction = y),
                            h && f)
                                return !0;
                            u += f
                        }
                    }
                    this.enableFrictionReduction && (y = this.enableFriction,
                    this.enableFriction = !1);
                    var g = w;
                    x(g, e);
                    var m = this.convexCapsule(t, g, i, s, n, r, o, a, h);
                    if (this.enableFrictionReduction && (this.enableFriction = y),
                    h && m)
                        return !0;
                    if (u += m,
                    this.enableFrictionReduction) {
                        var y = this.enableFriction;
                        this.enableFriction = !1
                    }
                    x(g, r);
                    var v = this.convexCapsule(n, g, o, a, t, e, i, s, h);
                    return this.enableFrictionReduction && (this.enableFriction = y),
                    !(!h || !v) || (u += v,
                    this.enableFrictionReduction && u && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(u)),
                    u)
                }
                ,
                $.prototype[l.LINE | l.LINE] = $.prototype.lineLine = function(t, e, i, s, n, r, o, a, h) {
                    return !h && 0
                }
                ,
                $.prototype[l.PLANE | l.LINE] = $.prototype.planeLine = function(t, e, i, s, n, r, o, a, h) {
                    var l = q
                      , c = H
                      , u = Y
                      , d = z
                      , p = K
                      , f = O
                      , g = J
                      , m = Q
                      , y = Z
                      , v = N
                      , x = 0;
                    X.set(l, -r.length / 2, 0),
                    X.set(c, r.length / 2, 0),
                    X.rotate(u, l, a),
                    X.rotate(d, c, a),
                    j(u, u, o),
                    j(d, d, o),
                    X.copy(l, u),
                    X.copy(c, d),
                    W(p, c, l),
                    X.normalize(f, p),
                    X.rotate90cw(y, f),
                    X.rotate(m, P, s),
                    v[0] = l,
                    v[1] = c;
                    for (var b = 0; b < v.length; b++) {
                        var _ = v[b];
                        W(g, _, i);
                        var w = V(g, m);
                        if (w < 0) {
                            if (h)
                                return !0;
                            var T = this.createContactEquation(t, n, e, r);
                            x++,
                            X.copy(T.normalA, m),
                            X.normalize(T.normalA, T.normalA),
                            X.scale(g, m, w),
                            W(T.contactPointA, _, g),
                            W(T.contactPointA, T.contactPointA, t.position),
                            W(T.contactPointB, _, o),
                            j(T.contactPointB, T.contactPointB, o),
                            W(T.contactPointB, T.contactPointB, n.position),
                            this.contactEquations.push(T),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(T))
                        }
                    }
                    return !h && (this.enableFrictionReduction || x && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(x)),
                    x)
                }
                ,
                $.prototype[l.PARTICLE | l.CAPSULE] = $.prototype.particleCapsule = function(t, e, i, s, n, r, o, a, h) {
                    return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius, 0)
                }
                ,
                $.prototype[l.CIRCLE | l.LINE] = $.prototype.circleLine = function(t, e, i, s, n, r, o, a, h, l, c) {
                    l = l || 0,
                    c = void 0 !== c ? c : e.radius;
                    var u = q
                      , d = H
                      , p = Y
                      , f = z
                      , g = K
                      , m = O
                      , y = J
                      , v = Q
                      , x = Z
                      , b = k
                      , _ = F
                      , w = D
                      , T = U
                      , P = G
                      , C = N;
                    X.set(v, -r.length / 2, 0),
                    X.set(x, r.length / 2, 0),
                    X.rotate(b, v, a),
                    X.rotate(_, x, a),
                    j(b, b, o),
                    j(_, _, o),
                    X.copy(v, b),
                    X.copy(x, _),
                    W(m, x, v),
                    X.normalize(y, m),
                    X.rotate90cw(g, y),
                    W(w, i, v);
                    var S = V(w, g);
                    W(f, v, o),
                    W(T, i, o);
                    var A = c + l;
                    if (Math.abs(S) < A) {
                        X.scale(u, g, S),
                        W(p, i, u),
                        X.scale(d, g, V(g, T)),
                        X.normalize(d, d),
                        X.scale(d, d, l),
                        j(p, p, d);
                        var E = V(y, p)
                          , M = V(y, v)
                          , R = V(y, x);
                        if (M < E && E < R) {
                            if (h)
                                return !0;
                            var L = this.createContactEquation(t, n, e, r);
                            return X.scale(L.normalA, u, -1),
                            X.normalize(L.normalA, L.normalA),
                            X.scale(L.contactPointA, L.normalA, c),
                            j(L.contactPointA, L.contactPointA, i),
                            W(L.contactPointA, L.contactPointA, t.position),
                            W(L.contactPointB, p, o),
                            j(L.contactPointB, L.contactPointB, o),
                            W(L.contactPointB, L.contactPointB, n.position),
                            this.contactEquations.push(L),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(L)),
                            1
                        }
                    }
                    C[0] = v,
                    C[1] = x;
                    for (var B = 0; B < C.length; B++) {
                        var I = C[B];
                        if (W(w, I, i),
                        X.squaredLength(w) < Math.pow(A, 2)) {
                            if (h)
                                return !0;
                            L = this.createContactEquation(t, n, e, r);
                            return X.copy(L.normalA, w),
                            X.normalize(L.normalA, L.normalA),
                            X.scale(L.contactPointA, L.normalA, c),
                            j(L.contactPointA, L.contactPointA, i),
                            W(L.contactPointA, L.contactPointA, t.position),
                            W(L.contactPointB, I, o),
                            X.scale(P, L.normalA, -l),
                            j(L.contactPointB, L.contactPointB, P),
                            j(L.contactPointB, L.contactPointB, o),
                            W(L.contactPointB, L.contactPointB, n.position),
                            this.contactEquations.push(L),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(L)),
                            1
                        }
                    }
                    return 0
                }
                ,
                $.prototype[l.CIRCLE | l.CAPSULE] = $.prototype.circleCapsule = function(t, e, i, s, n, r, o, a, h) {
                    return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius)
                }
                ,
                $.prototype[l.CIRCLE | l.CONVEX] = $.prototype[l.CIRCLE | l.BOX] = $.prototype.circleConvex = function(t, e, i, s, n, r, o, a, h, l) {
                    l = "number" == typeof l ? l : e.radius;
                    for (var c = q, u = H, d = Y, p = z, f = K, g = k, m = F, y = U, v = G, x = R, b = L, _ = !1, w = Number.MAX_VALUE, T = r.vertices, P = 0; P !== T.length + 1; P++) {
                        var C = T[P % T.length]
                          , S = T[(P + 1) % T.length];
                        if (X.rotate(c, C, a),
                        X.rotate(u, S, a),
                        j(c, c, o),
                        j(u, u, o),
                        W(d, u, c),
                        X.normalize(p, d),
                        X.rotate90cw(f, p),
                        X.scale(v, f, -e.radius),
                        j(v, v, i),
                        B(v, r, o, a)) {
                            X.sub(x, c, v);
                            var A = Math.abs(X.dot(x, f));
                            A < w && (X.copy(b, v),
                            w = A,
                            X.scale(y, f, A),
                            X.add(y, y, v),
                            _ = !0)
                        }
                    }
                    if (_) {
                        if (h)
                            return !0;
                        var E = this.createContactEquation(t, n, e, r);
                        return X.sub(E.normalA, b, i),
                        X.normalize(E.normalA, E.normalA),
                        X.scale(E.contactPointA, E.normalA, l),
                        j(E.contactPointA, E.contactPointA, i),
                        W(E.contactPointA, E.contactPointA, t.position),
                        W(E.contactPointB, y, o),
                        j(E.contactPointB, E.contactPointB, o),
                        W(E.contactPointB, E.contactPointB, n.position),
                        this.contactEquations.push(E),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(E)),
                        1
                    }
                    if (0 < l)
                        for (P = 0; P < T.length; P++) {
                            var M = T[P];
                            if (X.rotate(m, M, a),
                            j(m, m, o),
                            W(g, m, i),
                            X.squaredLength(g) < Math.pow(l, 2)) {
                                if (h)
                                    return !0;
                                E = this.createContactEquation(t, n, e, r);
                                return X.copy(E.normalA, g),
                                X.normalize(E.normalA, E.normalA),
                                X.scale(E.contactPointA, E.normalA, l),
                                j(E.contactPointA, E.contactPointA, i),
                                W(E.contactPointA, E.contactPointA, t.position),
                                W(E.contactPointB, m, o),
                                j(E.contactPointB, E.contactPointB, o),
                                W(E.contactPointB, E.contactPointB, n.position),
                                this.contactEquations.push(E),
                                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(E)),
                                1
                            }
                        }
                    return 0
                }
                ;
                var g = X.create()
                  , m = X.create()
                  , y = X.create()
                  , v = X.create();
                function B(t, e, i, s) {
                    for (var n = g, r = m, o = y, a = v, h = t, l = e.vertices, c = null, u = 0; u !== l.length + 1; u++) {
                        var d = l[u % l.length]
                          , p = l[(u + 1) % l.length];
                        X.rotate(n, d, s),
                        X.rotate(r, p, s),
                        j(n, n, i),
                        j(r, r, i),
                        W(o, n, h),
                        W(a, r, h);
                        var f = X.crossLength(o, a);
                        if (null === c && (c = f),
                        f * c <= 0)
                            return !1;
                        c = f
                    }
                    return !0
                }
                $.prototype[l.PARTICLE | l.CONVEX] = $.prototype[l.PARTICLE | l.BOX] = $.prototype.particleConvex = function(t, e, i, s, n, r, o, a, h) {
                    var l = q
                      , c = H
                      , u = Y
                      , d = z
                      , p = K
                      , f = O
                      , g = J
                      , m = k
                      , y = U
                      , v = E
                      , x = M
                      , b = Number.MAX_VALUE
                      , _ = !1
                      , w = r.vertices;
                    if (!B(i, r, o, a))
                        return 0;
                    if (h)
                        return !0;
                    for (var T = 0; T !== w.length + 1; T++) {
                        var P = w[T % w.length]
                          , C = w[(T + 1) % w.length];
                        X.rotate(l, P, a),
                        X.rotate(c, C, a),
                        j(l, l, o),
                        j(c, c, o),
                        W(u, c, l),
                        X.normalize(d, u),
                        X.rotate90cw(p, d),
                        W(m, i, l);
                        V(m, p);
                        W(f, l, o),
                        W(g, i, o),
                        X.sub(v, l, i);
                        var S = Math.abs(X.dot(v, p));
                        S < b && (b = S,
                        X.scale(y, p, S),
                        X.add(y, y, i),
                        X.copy(x, p),
                        _ = !0)
                    }
                    if (_) {
                        var A = this.createContactEquation(t, n, e, r);
                        return X.scale(A.normalA, x, -1),
                        X.normalize(A.normalA, A.normalA),
                        X.set(A.contactPointA, 0, 0),
                        j(A.contactPointA, A.contactPointA, i),
                        W(A.contactPointA, A.contactPointA, t.position),
                        W(A.contactPointB, y, o),
                        j(A.contactPointB, A.contactPointB, o),
                        W(A.contactPointB, A.contactPointB, n.position),
                        this.contactEquations.push(A),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)),
                        1
                    }
                    return 0
                }
                ,
                $.prototype[l.CIRCLE] = $.prototype.circleCircle = function(t, e, i, s, n, r, o, a, h, l, c) {
                    var u = q;
                    l = l || e.radius,
                    c = c || r.radius;
                    W(u, i, o);
                    var d = l + c;
                    if (X.squaredLength(u) > Math.pow(d, 2))
                        return 0;
                    if (h)
                        return !0;
                    var p = this.createContactEquation(t, n, e, r);
                    return W(p.normalA, o, i),
                    X.normalize(p.normalA, p.normalA),
                    X.scale(p.contactPointA, p.normalA, l),
                    X.scale(p.contactPointB, p.normalA, -c),
                    j(p.contactPointA, p.contactPointA, i),
                    W(p.contactPointA, p.contactPointA, t.position),
                    j(p.contactPointB, p.contactPointB, o),
                    W(p.contactPointB, p.contactPointB, n.position),
                    this.contactEquations.push(p),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)),
                    1
                }
                ,
                $.prototype[l.PLANE | l.CONVEX] = $.prototype[l.PLANE | l.BOX] = $.prototype.planeConvex = function(t, e, i, s, n, r, o, a, h) {
                    var l = q
                      , c = H
                      , u = Y
                      , d = 0;
                    X.rotate(c, P, s);
                    for (var p = 0; p !== r.vertices.length; p++) {
                        var f = r.vertices[p];
                        if (X.rotate(l, f, a),
                        j(l, l, o),
                        W(u, l, i),
                        V(u, c) <= 0) {
                            if (h)
                                return !0;
                            d++;
                            var g = this.createContactEquation(t, n, e, r);
                            W(u, l, i),
                            X.copy(g.normalA, c);
                            var m = V(u, g.normalA);
                            X.scale(u, g.normalA, m),
                            W(g.contactPointB, l, n.position),
                            W(g.contactPointA, l, u),
                            W(g.contactPointA, g.contactPointA, t.position),
                            this.contactEquations.push(g),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g))
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && d && this.frictionEquations.push(this.createFrictionFromAverage(d)),
                    d
                }
                ,
                $.prototype[l.PARTICLE | l.PLANE] = $.prototype.particlePlane = function(t, e, i, s, n, r, o, a, h) {
                    var l = q
                      , c = H;
                    a = a || 0,
                    W(l, i, o),
                    X.rotate(c, P, a);
                    var u = V(l, c);
                    if (0 < u)
                        return 0;
                    if (h)
                        return !0;
                    var d = this.createContactEquation(n, t, r, e);
                    return X.copy(d.normalA, c),
                    X.scale(l, d.normalA, u),
                    W(d.contactPointA, i, l),
                    W(d.contactPointA, d.contactPointA, n.position),
                    W(d.contactPointB, i, t.position),
                    this.contactEquations.push(d),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d)),
                    1
                }
                ,
                $.prototype[l.CIRCLE | l.PARTICLE] = $.prototype.circleParticle = function(t, e, i, s, n, r, o, a, h) {
                    var l = q;
                    if (W(l, o, i),
                    X.squaredLength(l) > Math.pow(e.radius, 2))
                        return 0;
                    if (h)
                        return !0;
                    var c = this.createContactEquation(t, n, e, r);
                    return X.copy(c.normalA, l),
                    X.normalize(c.normalA, c.normalA),
                    X.scale(c.contactPointA, c.normalA, e.radius),
                    j(c.contactPointA, c.contactPointA, i),
                    W(c.contactPointA, c.contactPointA, t.position),
                    W(c.contactPointB, o, n.position),
                    this.contactEquations.push(c),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(c)),
                    1
                }
                ;
                var C = new a({
                    radius: 1
                })
                  , S = X.create()
                  , A = X.create();
                X.create();
                $.prototype[l.PLANE | l.CAPSULE] = $.prototype.planeCapsule = function(t, e, i, s, n, r, o, a, h) {
                    var l, c = S, u = A, d = C;
                    X.set(c, -r.length / 2, 0),
                    X.rotate(c, c, a),
                    j(c, c, o),
                    X.set(u, r.length / 2, 0),
                    X.rotate(u, u, a),
                    j(u, u, o),
                    d.radius = r.radius,
                    this.enableFrictionReduction && (l = this.enableFriction,
                    this.enableFriction = !1);
                    var p = this.circlePlane(n, d, c, 0, t, e, i, s, h)
                      , f = this.circlePlane(n, d, u, 0, t, e, i, s, h);
                    if (this.enableFrictionReduction && (this.enableFriction = l),
                    h)
                        return p || f;
                    var g = p + f;
                    return this.enableFrictionReduction && g && this.frictionEquations.push(this.createFrictionFromAverage(g)),
                    g
                }
                ,
                $.prototype[l.CIRCLE | l.PLANE] = $.prototype.circlePlane = function(t, e, i, s, n, r, o, a, h) {
                    var l = t
                      , c = e
                      , u = i
                      , d = n
                      , p = o
                      , f = a;
                    f = f || 0;
                    var g = q
                      , m = H
                      , y = Y;
                    W(g, u, p),
                    X.rotate(m, P, f);
                    var v = V(m, g);
                    if (v > c.radius)
                        return 0;
                    if (h)
                        return !0;
                    var x = this.createContactEquation(d, l, r, e);
                    return X.copy(x.normalA, m),
                    X.scale(x.contactPointB, x.normalA, -c.radius),
                    j(x.contactPointB, x.contactPointB, u),
                    W(x.contactPointB, x.contactPointB, l.position),
                    X.scale(y, x.normalA, v),
                    W(x.contactPointA, g, y),
                    j(x.contactPointA, x.contactPointA, p),
                    W(x.contactPointA, x.contactPointA, d.position),
                    this.contactEquations.push(x),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x)),
                    1
                }
                ,
                $.prototype[l.CONVEX] = $.prototype[l.CONVEX | l.BOX] = $.prototype[l.BOX] = $.prototype.convexConvex = function(t, e, i, s, n, r, o, a, h, l) {
                    var c = q
                      , u = H
                      , d = Y
                      , p = z
                      , f = K
                      , g = J
                      , m = Q
                      , y = Z
                      , v = 0;
                    l = "number" == typeof l ? l : 0;
                    if (!$.findSeparatingAxis(e, i, s, r, o, a, c))
                        return 0;
                    W(m, o, i),
                    0 < V(c, m) && X.scale(c, c, -1);
                    var x = $.getClosestEdge(e, s, c, !0)
                      , b = $.getClosestEdge(r, a, c);
                    if (-1 === x || -1 === b)
                        return 0;
                    for (var _ = 0; _ < 2; _++) {
                        var w, T = x, P = b, C = e, S = r, A = i, E = o, M = s, R = a, L = t, B = n;
                        if (0 === _)
                            w = T,
                            T = P,
                            P = w,
                            w = C,
                            C = S,
                            S = w,
                            w = A,
                            A = E,
                            E = w,
                            w = M,
                            M = R,
                            R = w,
                            w = L,
                            L = B,
                            B = w;
                        for (var I = P; I < P + 2; I++) {
                            var O = S.vertices[(I + S.vertices.length) % S.vertices.length];
                            X.rotate(u, O, R),
                            j(u, u, E);
                            for (var k = 0, F = T - 1; F < T + 2; F++) {
                                var D = C.vertices[(F + C.vertices.length) % C.vertices.length]
                                  , U = C.vertices[(F + 1 + C.vertices.length) % C.vertices.length];
                                X.rotate(d, D, M),
                                X.rotate(p, U, M),
                                j(d, d, A),
                                j(p, p, A),
                                W(f, p, d),
                                X.rotate90cw(y, f),
                                X.normalize(y, y),
                                W(m, u, d);
                                var G = V(y, m);
                                (F === T && G <= l || F !== T && G <= 0) && k++
                            }
                            if (3 <= k) {
                                if (h)
                                    return !0;
                                var N = this.createContactEquation(L, B, C, S);
                                v++;
                                D = C.vertices[T % C.vertices.length],
                                U = C.vertices[(T + 1) % C.vertices.length];
                                X.rotate(d, D, M),
                                X.rotate(p, U, M),
                                j(d, d, A),
                                j(p, p, A),
                                W(f, p, d),
                                X.rotate90cw(N.normalA, f),
                                X.normalize(N.normalA, N.normalA),
                                W(m, u, d);
                                G = V(N.normalA, m);
                                X.scale(g, N.normalA, G),
                                W(N.contactPointA, u, A),
                                W(N.contactPointA, N.contactPointA, g),
                                j(N.contactPointA, N.contactPointA, A),
                                W(N.contactPointA, N.contactPointA, L.position),
                                W(N.contactPointB, u, E),
                                j(N.contactPointB, N.contactPointB, E),
                                W(N.contactPointB, N.contactPointB, B.position),
                                this.contactEquations.push(N),
                                this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(N))
                            }
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && v && this.frictionEquations.push(this.createFrictionFromAverage(v)),
                    v
                }
                ;
                var I = X.fromValues(0, 0);
                $.projectConvexOntoAxis = function(t, e, i, s, n) {
                    var r, o, a = null, h = null, l = I;
                    X.rotate(l, s, -i);
                    for (var c = 0; c < t.vertices.length; c++)
                        r = t.vertices[c],
                        o = V(r, l),
                        (null === a || a < o) && (a = o),
                        (null === h || o < h) && (h = o);
                    if (a < h) {
                        var u = h;
                        h = a,
                        a = u
                    }
                    var d = V(e, s);
                    X.set(n, h + d, a + d)
                }
                ;
                var tt = X.fromValues(0, 0)
                  , et = X.fromValues(0, 0)
                  , it = X.fromValues(0, 0)
                  , st = X.fromValues(0, 0)
                  , nt = X.fromValues(0, 0)
                  , rt = X.fromValues(0, 0);
                $.findSeparatingAxis = function(t, e, i, s, n, r, o) {
                    var a = null
                      , h = !1
                      , l = !1
                      , c = tt
                      , u = et
                      , d = it
                      , p = st
                      , f = nt
                      , g = rt;
                    if (t instanceof T && s instanceof T)
                        for (var m = 0; 2 !== m; m++) {
                            var y = t
                              , v = i;
                            1 === m && (y = s,
                            v = r);
                            for (var x = 0; 2 !== x; x++) {
                                0 === x ? X.set(p, 0, 1) : 1 === x && X.set(p, 1, 0),
                                0 !== v && X.rotate(p, p, v),
                                $.projectConvexOntoAxis(t, e, i, p, f),
                                $.projectConvexOntoAxis(s, n, r, p, g);
                                var b = f
                                  , _ = g;
                                f[0] > g[0] && (_ = f,
                                b = g,
                                !0),
                                h = (w = _[0] - b[1]) <= 0,
                                (null === a || a < w) && (X.copy(o, p),
                                a = w,
                                l = h)
                            }
                        }
                    else
                        for (m = 0; 2 !== m; m++) {
                            y = t,
                            v = i;
                            1 === m && (y = s,
                            v = r);
                            for (x = 0; x !== y.vertices.length; x++) {
                                X.rotate(u, y.vertices[x], v),
                                X.rotate(d, y.vertices[(x + 1) % y.vertices.length], v),
                                W(c, d, u),
                                X.rotate90cw(p, c),
                                X.normalize(p, p),
                                $.projectConvexOntoAxis(t, e, i, p, f),
                                $.projectConvexOntoAxis(s, n, r, p, g);
                                var w;
                                b = f,
                                _ = g;
                                f[0] > g[0] && (_ = f,
                                b = g,
                                !0),
                                h = (w = _[0] - b[1]) <= 0,
                                (null === a || a < w) && (X.copy(o, p),
                                a = w,
                                l = h)
                            }
                        }
                    return l
                }
                ;
                var d = X.fromValues(0, 0)
                  , ot = X.fromValues(0, 0)
                  , at = X.fromValues(0, 0);
                $.getClosestEdge = function(t, e, i, s) {
                    var n = d
                      , r = ot
                      , o = at;
                    X.rotate(n, i, -e),
                    s && X.scale(n, n, -1);
                    for (var a = -1, h = t.vertices.length, l = -1, c = 0; c !== h; c++) {
                        W(r, t.vertices[(c + 1) % h], t.vertices[c % h]),
                        X.rotate90cw(o, r),
                        X.normalize(o, o);
                        var u = V(o, n);
                        (-1 === a || l < u) && (a = c % h,
                        l = u)
                    }
                    return a
                }
                ;
                var ht = X.create()
                  , lt = X.create()
                  , ct = X.create()
                  , ut = X.create()
                  , dt = X.create()
                  , pt = X.create()
                  , ft = X.create();
                $.prototype[l.CIRCLE | l.HEIGHTFIELD] = $.prototype.circleHeightfield = function(t, e, i, s, n, r, o, a, h, l) {
                    var c = r.heights
                      , u = (l = l || e.radius,
                    r.elementWidth)
                      , d = lt
                      , p = ht
                      , f = dt
                      , g = ft
                      , m = pt
                      , y = ct
                      , v = ut
                      , x = Math.floor((i[0] - l - o[0]) / u)
                      , b = Math.ceil((i[0] + l - o[0]) / u);
                    x < 0 && (x = 0),
                    b >= c.length && (b = c.length - 1);
                    for (var _ = c[x], w = c[b], T = x; T < b; T++)
                        c[T] < w && (w = c[T]),
                        c[T] > _ && (_ = c[T]);
                    if (i[1] - l > _)
                        return !h && 0;
                    var P = !1;
                    for (T = x; T < b; T++) {
                        X.set(y, T * u, c[T]),
                        X.set(v, (T + 1) * u, c[T + 1]),
                        X.add(y, y, o),
                        X.add(v, v, o),
                        X.sub(m, v, y),
                        X.rotate(m, m, Math.PI / 2),
                        X.normalize(m, m),
                        X.scale(p, m, -l),
                        X.add(p, p, i),
                        X.sub(d, p, y);
                        var C = X.dot(d, m);
                        if (p[0] >= y[0] && p[0] < v[0] && C <= 0) {
                            if (h)
                                return !0;
                            P = !0,
                            X.scale(d, m, -C),
                            X.add(f, p, d),
                            X.copy(g, m);
                            var S = this.createContactEquation(n, t, r, e);
                            X.copy(S.normalA, g),
                            X.scale(S.contactPointB, S.normalA, -l),
                            j(S.contactPointB, S.contactPointB, i),
                            W(S.contactPointB, S.contactPointB, t.position),
                            X.copy(S.contactPointA, f),
                            X.sub(S.contactPointA, S.contactPointA, n.position),
                            this.contactEquations.push(S),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(S))
                        }
                    }
                    if (P = !1,
                    0 < l)
                        for (T = x; T <= b; T++)
                            if (X.set(y, T * u, c[T]),
                            X.add(y, y, o),
                            X.sub(d, i, y),
                            X.squaredLength(d) < Math.pow(l, 2)) {
                                if (h)
                                    return !0;
                                P = !0;
                                S = this.createContactEquation(n, t, r, e);
                                X.copy(S.normalA, d),
                                X.normalize(S.normalA, S.normalA),
                                X.scale(S.contactPointB, S.normalA, -l),
                                j(S.contactPointB, S.contactPointB, i),
                                W(S.contactPointB, S.contactPointB, t.position),
                                W(S.contactPointA, y, o),
                                j(S.contactPointA, S.contactPointA, o),
                                W(S.contactPointA, S.contactPointA, n.position),
                                this.contactEquations.push(S),
                                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(S))
                            }
                    return P ? 1 : 0
                }
                ;
                var gt = X.create()
                  , mt = X.create()
                  , yt = X.create()
                  , vt = new h({
                    vertices: [X.create(), X.create(), X.create(), X.create()]
                });
                $.prototype[l.BOX | l.HEIGHTFIELD] = $.prototype[l.CONVEX | l.HEIGHTFIELD] = $.prototype.convexHeightfield = function(t, e, i, s, n, r, o, a, h) {
                    var l = r.heights
                      , c = r.elementWidth
                      , u = gt
                      , d = mt
                      , p = yt
                      , f = vt
                      , g = Math.floor((t.aabb.lowerBound[0] - o[0]) / c)
                      , m = Math.ceil((t.aabb.upperBound[0] - o[0]) / c);
                    g < 0 && (g = 0),
                    m >= l.length && (m = l.length - 1);
                    for (var y = l[g], v = l[m], x = g; x < m; x++)
                        l[x] < v && (v = l[x]),
                        l[x] > y && (y = l[x]);
                    if (t.aabb.lowerBound[1] > y)
                        return !h && 0;
                    var b = 0;
                    for (x = g; x < m; x++) {
                        X.set(u, x * c, l[x]),
                        X.set(d, (x + 1) * c, l[x + 1]),
                        X.add(u, u, o),
                        X.add(d, d, o);
                        X.set(p, .5 * (d[0] + u[0]), .5 * (d[1] + u[1] - 100)),
                        X.sub(f.vertices[0], d, p),
                        X.sub(f.vertices[1], u, p),
                        X.copy(f.vertices[2], f.vertices[1]),
                        X.copy(f.vertices[3], f.vertices[0]),
                        f.vertices[2][1] -= 100,
                        f.vertices[3][1] -= 100,
                        b += this.convexConvex(t, e, i, s, n, f, p, 0, h)
                    }
                    return b
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Box": 37,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Shape": 45,
                "../utils/ContactEquationPool": 48,
                "../utils/FrictionEquationPool": 49,
                "../utils/TupleDictionary": 56,
                "../utils/Utils": 57
            }],
            11: [function(t, e, i) {
                e.exports = o;
                var h = t("../math/vec2");
                t("../collision/RaycastResult"),
                t("../shapes/Shape"),
                t("../collision/AABB");
                function o(t) {
                    t = t || {},
                    this.from = t.from ? h.fromValues(t.from[0], t.from[1]) : h.create(),
                    this.to = t.to ? h.fromValues(t.to[0], t.to[1]) : h.create(),
                    this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse,
                    this.skipBackfaces = !!t.skipBackfaces,
                    this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1,
                    this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1,
                    this.mode = void 0 !== t.mode ? t.mode : o.ANY,
                    this.callback = t.callback || function(t) {}
                    ,
                    this.direction = h.create(),
                    this.length = 1,
                    this.update()
                }
                (o.prototype.constructor = o).CLOSEST = 1,
                o.ANY = 2,
                o.ALL = 4,
                o.prototype.update = function() {
                    var t = this.direction;
                    h.sub(t, this.to, this.from),
                    this.length = h.length(t),
                    h.normalize(t, t)
                }
                ,
                o.prototype.intersectBodies = function(t, e) {
                    for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                        var n = e[i]
                          , r = n.getAABB();
                        (0 <= r.overlapsRay(this) || r.containsPoint(this.from)) && this.intersectBody(t, n)
                    }
                }
                ;
                var l = h.create();
                o.prototype.intersectBody = function(t, e) {
                    var i = this.checkCollisionResponse;
                    if (!i || e.collisionResponse)
                        for (var s = l, n = 0, r = e.shapes.length; n < r; n++) {
                            var o = e.shapes[n];
                            if ((!i || o.collisionResponse) && (0 != (this.collisionGroup & o.collisionMask) && 0 != (o.collisionGroup & this.collisionMask))) {
                                h.rotate(s, o.position, e.angle),
                                h.add(s, s, e.position);
                                var a = o.angle + e.angle;
                                if (this.intersectShape(t, o, a, s, e),
                                t.shouldStop(this))
                                    break
                            }
                        }
                }
                ,
                o.prototype.intersectShape = function(t, e, i, s, n) {
                    (function(t, e, i) {
                        h.sub(r, i, t);
                        var s = h.dot(r, e);
                        return h.scale(a, e, s),
                        h.add(a, a, t),
                        h.squaredDistance(i, a)
                    }
                    )(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = n,
                    (this._currentShape = e).raycast(t, this, s, i),
                    this._currentBody = this._currentShape = null)
                }
                ,
                o.prototype.getAABB = function(t) {
                    var e = this.to
                      , i = this.from;
                    h.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])),
                    h.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
                }
                ;
                h.create();
                o.prototype.reportIntersection = function(t, e, i, s) {
                    this.from,
                    this.to;
                    var n = this._currentShape
                      , r = this._currentBody;
                    if (!(this.skipBackfaces && 0 < h.dot(i, this.direction)))
                        switch (this.mode) {
                        case o.ALL:
                            t.set(i, n, r, e, s),
                            this.callback(t);
                            break;
                        case o.CLOSEST:
                            (e < t.fraction || !t.hasHit()) && t.set(i, n, r, e, s);
                            break;
                        case o.ANY:
                            t.set(i, n, r, e, s)
                        }
                }
                ;
                var r = h.create()
                  , a = h.create()
            }
            , {
                "../collision/AABB": 7,
                "../collision/RaycastResult": 12,
                "../math/vec2": 30,
                "../shapes/Shape": 45
            }],
            12: [function(t, e, i) {
                var r = t("../math/vec2")
                  , s = t("../collision/Ray");
                function n() {
                    this.normal = r.create(),
                    this.shape = null,
                    this.body = null,
                    this.faceIndex = -1,
                    this.fraction = -1,
                    this.isStopped = !1
                }
                (e.exports = n).prototype.reset = function() {
                    r.set(this.normal, 0, 0),
                    this.shape = null,
                    this.body = null,
                    this.faceIndex = -1,
                    this.fraction = -1,
                    this.isStopped = !1
                }
                ,
                n.prototype.getHitDistance = function(t) {
                    return r.distance(t.from, t.to) * this.fraction
                }
                ,
                n.prototype.hasHit = function() {
                    return -1 !== this.fraction
                }
                ,
                n.prototype.getHitPoint = function(t, e) {
                    r.lerp(t, e.from, e.to, this.fraction)
                }
                ,
                n.prototype.stop = function() {
                    this.isStopped = !0
                }
                ,
                n.prototype.shouldStop = function(t) {
                    return this.isStopped || -1 !== this.fraction && t.mode === s.ANY
                }
                ,
                n.prototype.set = function(t, e, i, s, n) {
                    r.copy(this.normal, t),
                    this.shape = e,
                    this.body = i,
                    this.fraction = s,
                    this.faceIndex = n
                }
            }
            , {
                "../collision/Ray": 11,
                "../math/vec2": 30
            }],
            13: [function(t, e, i) {
                var s = t("../utils/Utils")
                  , u = t("../collision/Broadphase");
                function n() {
                    u.call(this, u.SAP),
                    this.axisList = [],
                    this.axisIndex = 0;
                    var i = this;
                    this._addBodyHandler = function(t) {
                        i.axisList.push(t.body)
                    }
                    ,
                    this._removeBodyHandler = function(t) {
                        var e = i.axisList.indexOf(t.body);
                        -1 !== e && i.axisList.splice(e, 1)
                    }
                }
                (((e.exports = n).prototype = new u).constructor = n).prototype.setWorld = function(t) {
                    this.axisList.length = 0,
                    s.appendArray(this.axisList, t.bodies),
                    t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler),
                    t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler),
                    this.world = t
                }
                ,
                n.sortAxisList = function(t, e) {
                    e |= 0;
                    for (var i = 1, s = t.length; i < s; i++) {
                        for (var n = t[i], r = i - 1; 0 <= r && !(t[r].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); r--)
                            t[r + 1] = t[r];
                        t[r + 1] = n
                    }
                    return t
                }
                ,
                n.prototype.sortList = function() {
                    var t = this.axisList
                      , e = this.axisIndex;
                    n.sortAxisList(t, e)
                }
                ,
                n.prototype.getCollisionPairs = function(t) {
                    var e = this.axisList
                      , i = this.result
                      , s = this.axisIndex;
                    i.length = 0;
                    for (var n = e.length; n--; ) {
                        var r = e[n];
                        r.aabbNeedsUpdate && r.updateAABB()
                    }
                    this.sortList();
                    for (var o = 0, a = 0 | e.length; o !== a; o++)
                        for (var h = e[o], l = o + 1; l < a; l++) {
                            var c = e[l];
                            if (!(c.aabb.lowerBound[s] <= h.aabb.upperBound[s]))
                                break;
                            u.canCollide(h, c) && this.boundingVolumeCheck(h, c) && i.push(h, c)
                        }
                    return i
                }
                ,
                n.prototype.aabbQuery = function(t, e, i) {
                    i = i || [],
                    this.sortList();
                    var s = this.axisIndex
                      , n = "x";
                    1 === s && (n = "y"),
                    2 === s && (n = "z");
                    for (var r = this.axisList, o = (e.lowerBound[n],
                    e.upperBound[n],
                    0); o < r.length; o++) {
                        var a = r[o];
                        a.aabbNeedsUpdate && a.updateAABB(),
                        a.aabb.overlaps(e) && i.push(a)
                    }
                    return i
                }
            }
            , {
                "../collision/Broadphase": 8,
                "../utils/Utils": 57
            }],
            14: [function(t, e, i) {
                e.exports = s;
                var n = t("../utils/Utils");
                function s(t, e, i, s) {
                    this.type = i,
                    s = n.defaults(s, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }),
                    this.equations = [],
                    this.bodyA = t,
                    this.bodyB = e,
                    this.collideConnected = s.collideConnected,
                    s.wakeUpBodies && (t && t.wakeUp(),
                    e && e.wakeUp())
                }
                s.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!")
                }
                ,
                s.DISTANCE = 1,
                s.GEAR = 2,
                s.LOCK = 3,
                s.PRISMATIC = 4,
                s.REVOLUTE = 5,
                s.prototype.setStiffness = function(t) {
                    for (var e = this.equations, i = 0; i !== e.length; i++) {
                        var s = e[i];
                        s.stiffness = t,
                        s.needsUpdate = !0
                    }
                }
                ,
                s.prototype.setRelaxation = function(t) {
                    for (var e = this.equations, i = 0; i !== e.length; i++) {
                        var s = e[i];
                        s.relaxation = t,
                        s.needsUpdate = !0
                    }
                }
            }
            , {
                "../utils/Utils": 57
            }],
            15: [function(t, e, i) {
                var p = t("./Constraint")
                  , f = t("../equations/Equation")
                  , g = t("../math/vec2")
                  , m = t("../utils/Utils");
                function s(t, e, i) {
                    i = m.defaults(i, {
                        localAnchorA: [0, 0],
                        localAnchorB: [0, 0]
                    }),
                    p.call(this, t, e, p.DISTANCE, i),
                    this.localAnchorA = g.fromValues(i.localAnchorA[0], i.localAnchorA[1]),
                    this.localAnchorB = g.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                    var s, n = this.localAnchorA, r = this.localAnchorB;
                    if (this.distance = 0,
                    "number" == typeof i.distance)
                        this.distance = i.distance;
                    else {
                        var o = g.create()
                          , a = g.create()
                          , h = g.create();
                        g.rotate(o, n, t.angle),
                        g.rotate(a, r, e.angle),
                        g.add(h, e.position, a),
                        g.sub(h, h, o),
                        g.sub(h, h, t.position),
                        this.distance = g.length(h)
                    }
                    s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                    var l = new f(t,e,-s,s);
                    this.equations = [l],
                    this.maxForce = s;
                    h = g.create();
                    var c = g.create()
                      , u = g.create()
                      , d = this;
                    l.computeGq = function() {
                        var t = this.bodyA
                          , e = this.bodyB
                          , i = t.position
                          , s = e.position;
                        return g.rotate(c, n, t.angle),
                        g.rotate(u, r, e.angle),
                        g.add(h, s, u),
                        g.sub(h, h, c),
                        g.sub(h, h, i),
                        g.length(h) - d.distance
                    }
                    ,
                    this.setMaxForce(s),
                    this.upperLimitEnabled = !1,
                    this.upperLimit = 1,
                    this.lowerLimitEnabled = !1,
                    this.lowerLimit = 0,
                    this.position = 0
                }
                ((e.exports = s).prototype = new p).constructor = s;
                var c = g.create()
                  , u = g.create()
                  , d = g.create();
                s.prototype.update = function() {
                    var t = this.equations[0]
                      , e = this.bodyA
                      , i = this.bodyB
                      , s = (this.distance,
                    e.position)
                      , n = i.position
                      , r = this.equations[0]
                      , o = t.G;
                    g.rotate(u, this.localAnchorA, e.angle),
                    g.rotate(d, this.localAnchorB, i.angle),
                    g.add(c, n, d),
                    g.sub(c, c, u),
                    g.sub(c, c, s),
                    this.position = g.length(c);
                    var a = !1;
                    if (this.upperLimitEnabled && this.position > this.upperLimit && (r.maxForce = 0,
                    r.minForce = -this.maxForce,
                    this.distance = this.upperLimit,
                    a = !0),
                    this.lowerLimitEnabled && this.position < this.lowerLimit && (r.maxForce = this.maxForce,
                    r.minForce = 0,
                    this.distance = this.lowerLimit,
                    a = !0),
                    !this.lowerLimitEnabled && !this.upperLimitEnabled || a) {
                        r.enabled = !0,
                        g.normalize(c, c);
                        var h = g.crossLength(u, c)
                          , l = g.crossLength(d, c);
                        o[0] = -c[0],
                        o[1] = -c[1],
                        o[2] = -h,
                        o[3] = c[0],
                        o[4] = c[1],
                        o[5] = l
                    } else
                        r.enabled = !1
                }
                ,
                s.prototype.setMaxForce = function(t) {
                    var e = this.equations[0];
                    e.minForce = -t,
                    e.maxForce = t
                }
                ,
                s.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                }
            }
            , {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Constraint": 14
            }],
            16: [function(t, e, i) {
                var s = t("./Constraint")
                  , n = (t("../equations/Equation"),
                t("../equations/AngleLockEquation"));
                t("../math/vec2");
                function r(t, e, i) {
                    i = i || {},
                    s.call(this, t, e, s.GEAR, i),
                    this.ratio = void 0 !== i.ratio ? i.ratio : 1,
                    this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle,
                    i.angle = this.angle,
                    i.ratio = this.ratio,
                    this.equations = [new n(t,e,i)],
                    void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
                }
                (((e.exports = r).prototype = new s).constructor = r).prototype.update = function() {
                    var t = this.equations[0];
                    t.ratio !== this.ratio && t.setRatio(this.ratio),
                    t.angle = this.angle
                }
                ,
                r.prototype.setMaxTorque = function(t) {
                    this.equations[0].setMaxTorque(t)
                }
                ,
                r.prototype.getMaxTorque = function(t) {
                    return this.equations[0].maxForce
                }
            }
            , {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            17: [function(t, e, i) {
                var d = t("./Constraint")
                  , p = t("../math/vec2")
                  , f = t("../equations/Equation");
                function s(t, e, i) {
                    i = i || {},
                    d.call(this, t, e, d.LOCK, i);
                    var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce
                      , n = (i.localAngleB,
                    new f(t,e,-s,s))
                      , r = new f(t,e,-s,s)
                      , o = new f(t,e,-s,s)
                      , a = p.create()
                      , h = p.create()
                      , l = this;
                    n.computeGq = function() {
                        return p.rotate(a, l.localOffsetB, t.angle),
                        p.sub(h, e.position, t.position),
                        p.sub(h, h, a),
                        h[0]
                    }
                    ,
                    r.computeGq = function() {
                        return p.rotate(a, l.localOffsetB, t.angle),
                        p.sub(h, e.position, t.position),
                        p.sub(h, h, a),
                        h[1]
                    }
                    ;
                    var c = p.create()
                      , u = p.create();
                    o.computeGq = function() {
                        return p.rotate(c, l.localOffsetB, e.angle - l.localAngleB),
                        p.scale(c, c, -1),
                        p.sub(h, t.position, e.position),
                        p.add(h, h, c),
                        p.rotate(u, c, -Math.PI / 2),
                        p.normalize(u, u),
                        p.dot(h, u)
                    }
                    ,
                    this.localOffsetB = p.create(),
                    i.localOffsetB ? p.copy(this.localOffsetB, i.localOffsetB) : (p.sub(this.localOffsetB, e.position, t.position),
                    p.rotate(this.localOffsetB, this.localOffsetB, -t.angle)),
                    this.localAngleB = 0,
                    "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle,
                    this.equations.push(n, r, o),
                    this.setMaxForce(s)
                }
                (((e.exports = s).prototype = new d).constructor = s).prototype.setMaxForce = function(t) {
                    for (var e = this.equations, i = 0; i < this.equations.length; i++)
                        e[i].maxForce = t,
                        e[i].minForce = -t
                }
                ,
                s.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                }
                ;
                var r = p.create()
                  , o = p.create()
                  , a = p.create()
                  , h = p.fromValues(1, 0)
                  , l = p.fromValues(0, 1);
                s.prototype.update = function() {
                    var t = this.equations[0]
                      , e = this.equations[1]
                      , i = this.equations[2]
                      , s = this.bodyA
                      , n = this.bodyB;
                    p.rotate(r, this.localOffsetB, s.angle),
                    p.rotate(o, this.localOffsetB, n.angle - this.localAngleB),
                    p.scale(o, o, -1),
                    p.rotate(a, o, Math.PI / 2),
                    p.normalize(a, a),
                    t.G[0] = -1,
                    t.G[1] = 0,
                    t.G[2] = -p.crossLength(r, h),
                    t.G[3] = 1,
                    e.G[0] = 0,
                    e.G[1] = -1,
                    e.G[2] = -p.crossLength(r, l),
                    e.G[4] = 1,
                    i.G[0] = -a[0],
                    i.G[1] = -a[1],
                    i.G[3] = a[0],
                    i.G[4] = a[1],
                    i.G[5] = p.crossLength(o, a)
                }
            }
            , {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            18: [function(t, e, i) {
                var g = t("./Constraint")
                  , m = t("../equations/ContactEquation")
                  , y = t("../equations/Equation")
                  , v = t("../math/vec2")
                  , x = t("../equations/RotationalLockEquation");
                function s(s, n, t) {
                    t = t || {},
                    g.call(this, s, n, g.PRISMATIC, t);
                    var r = v.fromValues(0, 0)
                      , o = v.fromValues(1, 0)
                      , a = v.fromValues(0, 0);
                    t.localAnchorA && v.copy(r, t.localAnchorA),
                    t.localAxisA && v.copy(o, t.localAxisA),
                    t.localAnchorB && v.copy(a, t.localAnchorB),
                    this.localAnchorA = r,
                    this.localAnchorB = a,
                    this.localAxisA = o;
                    var e = this.maxForce = void 0 !== t.maxForce ? t.maxForce : Number.MAX_VALUE
                      , i = new y(s,n,-e,e)
                      , h = new v.create
                      , l = new v.create
                      , c = new v.create
                      , u = new v.create;
                    if (i.computeGq = function() {
                        return v.dot(c, u)
                    }
                    ,
                    i.updateJacobian = function() {
                        var t = this.G
                          , e = s.position
                          , i = n.position;
                        v.rotate(h, r, s.angle),
                        v.rotate(l, a, n.angle),
                        v.add(c, i, l),
                        v.sub(c, c, e),
                        v.sub(c, c, h),
                        v.rotate(u, o, s.angle + Math.PI / 2),
                        t[0] = -u[0],
                        t[1] = -u[1],
                        t[2] = -v.crossLength(h, u) + v.crossLength(u, c),
                        t[3] = u[0],
                        t[4] = u[1],
                        t[5] = v.crossLength(l, u)
                    }
                    ,
                    this.equations.push(i),
                    !t.disableRotationalLock) {
                        var d = new x(s,n,-e,e);
                        this.equations.push(d)
                    }
                    this.position = 0,
                    this.velocity = 0,
                    this.lowerLimitEnabled = void 0 !== t.lowerLimit,
                    this.upperLimitEnabled = void 0 !== t.upperLimit,
                    this.lowerLimit = void 0 !== t.lowerLimit ? t.lowerLimit : 0,
                    this.upperLimit = void 0 !== t.upperLimit ? t.upperLimit : 1,
                    this.upperLimitEquation = new m(s,n),
                    this.lowerLimitEquation = new m(s,n),
                    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0,
                    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = e,
                    this.motorEquation = new y(s,n),
                    this.motorEnabled = !1,
                    this.motorSpeed = 0;
                    var p = this
                      , f = this.motorEquation;
                    f.computeGW;
                    f.computeGq = function() {
                        return 0
                    }
                    ,
                    f.computeGW = function() {
                        var t = this.G
                          , e = this.bodyA
                          , i = this.bodyB
                          , s = e.velocity
                          , n = i.velocity
                          , r = e.angularVelocity
                          , o = i.angularVelocity;
                        return this.gmult(t, s, r, n, o) + p.motorSpeed
                    }
                }
                ((e.exports = s).prototype = new g).constructor = s;
                var f = v.create()
                  , b = v.create()
                  , _ = v.create()
                  , w = v.create()
                  , T = v.create()
                  , P = v.create();
                s.prototype.update = function() {
                    var t = this.equations
                      , e = t[0]
                      , i = this.upperLimit
                      , s = this.lowerLimit
                      , n = this.upperLimitEquation
                      , r = this.lowerLimitEquation
                      , o = this.bodyA
                      , a = this.bodyB
                      , h = this.localAxisA
                      , l = this.localAnchorA
                      , c = this.localAnchorB;
                    e.updateJacobian(),
                    v.rotate(f, h, o.angle),
                    v.rotate(w, l, o.angle),
                    v.add(b, w, o.position),
                    v.rotate(T, c, a.angle),
                    v.add(_, T, a.position);
                    var u, d = this.position = v.dot(_, f) - v.dot(b, f);
                    if (this.motorEnabled) {
                        var p = this.motorEquation.G;
                        p[0] = f[0],
                        p[1] = f[1],
                        p[2] = v.crossLength(f, T),
                        p[3] = -f[0],
                        p[4] = -f[1],
                        p[5] = -v.crossLength(f, w)
                    }
                    this.upperLimitEnabled && i < d ? (v.scale(n.normalA, f, -1),
                    v.sub(n.contactPointA, b, o.position),
                    v.sub(n.contactPointB, _, a.position),
                    v.scale(P, f, i),
                    v.add(n.contactPointA, n.contactPointA, P),
                    -1 === t.indexOf(n) && t.push(n)) : -1 !== (u = t.indexOf(n)) && t.splice(u, 1);
                    this.lowerLimitEnabled && d < s ? (v.scale(r.normalA, f, 1),
                    v.sub(r.contactPointA, b, o.position),
                    v.sub(r.contactPointB, _, a.position),
                    v.scale(P, f, s),
                    v.sub(r.contactPointB, r.contactPointB, P),
                    -1 === t.indexOf(r) && t.push(r)) : -1 !== (u = t.indexOf(r)) && t.splice(u, 1)
                }
                ,
                s.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation),
                    this.motorEnabled = !0)
                }
                ,
                s.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1),
                        this.motorEnabled = !1
                    }
                }
                ,
                s.prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t,
                    this.lowerLimitEnabled = !0) : (this.lowerLimit = t,
                    this.lowerLimitEnabled = !1),
                    "number" == typeof e ? (this.upperLimit = e,
                    this.upperLimitEnabled = !0) : (this.upperLimit = e,
                    this.upperLimitEnabled = !1)
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            19: [function(t, e, i) {
                var h = t("./Constraint")
                  , l = t("../equations/Equation")
                  , c = t("../equations/RotationalVelocityEquation")
                  , u = t("../equations/RotationalLockEquation")
                  , p = t("../math/vec2");
                e.exports = s;
                var f = p.create()
                  , g = p.create()
                  , m = p.fromValues(1, 0)
                  , y = p.fromValues(0, 1)
                  , d = p.create();
                function s(t, e, i) {
                    i = i || {},
                    h.call(this, t, e, h.REVOLUTE, i);
                    var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                    this.pivotA = p.create(),
                    this.pivotB = p.create(),
                    i.worldPivot ? (p.sub(this.pivotA, i.worldPivot, t.position),
                    p.sub(this.pivotB, i.worldPivot, e.position),
                    p.rotate(this.pivotA, this.pivotA, -t.angle),
                    p.rotate(this.pivotB, this.pivotB, -e.angle)) : (p.copy(this.pivotA, i.localPivotA),
                    p.copy(this.pivotB, i.localPivotB));
                    var n = this.equations = [new l(t,e,-s,s), new l(t,e,-s,s)]
                      , r = n[0]
                      , o = n[1]
                      , a = this;
                    r.computeGq = function() {
                        return p.rotate(f, a.pivotA, t.angle),
                        p.rotate(g, a.pivotB, e.angle),
                        p.add(d, e.position, g),
                        p.sub(d, d, t.position),
                        p.sub(d, d, f),
                        p.dot(d, m)
                    }
                    ,
                    o.computeGq = function() {
                        return p.rotate(f, a.pivotA, t.angle),
                        p.rotate(g, a.pivotB, e.angle),
                        p.add(d, e.position, g),
                        p.sub(d, d, t.position),
                        p.sub(d, d, f),
                        p.dot(d, y)
                    }
                    ,
                    o.minForce = r.minForce = -s,
                    o.maxForce = r.maxForce = s,
                    this.motorEquation = new c(t,e),
                    this.motorEnabled = !1,
                    this.angle = 0,
                    this.lowerLimitEnabled = !1,
                    this.upperLimitEnabled = !1,
                    this.lowerLimit = 0,
                    this.upperLimit = 0,
                    this.upperLimitEquation = new u(t,e),
                    this.lowerLimitEquation = new u(t,e),
                    this.upperLimitEquation.minForce = 0,
                    this.lowerLimitEquation.maxForce = 0
                }
                ((s.prototype = new h).constructor = s).prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t,
                    this.lowerLimitEnabled = !0) : (this.lowerLimit = t,
                    this.lowerLimitEnabled = !1),
                    "number" == typeof e ? (this.upperLimit = e,
                    this.upperLimitEnabled = !0) : (this.upperLimit = e,
                    this.upperLimitEnabled = !1)
                }
                ,
                s.prototype.update = function() {
                    var t, e = this.bodyA, i = this.bodyB, s = this.pivotA, n = this.pivotB, r = this.equations, o = (r[0],
                    r[1],
                    r[0]), a = r[1], h = this.upperLimit, l = this.lowerLimit, c = this.upperLimitEquation, u = this.lowerLimitEquation, d = this.angle = i.angle - e.angle;
                    this.upperLimitEnabled && h < d ? (c.angle = h,
                    -1 === r.indexOf(c) && r.push(c)) : -1 !== (t = r.indexOf(c)) && r.splice(t, 1);
                    this.lowerLimitEnabled && d < l ? (u.angle = l,
                    -1 === r.indexOf(u) && r.push(u)) : -1 !== (t = r.indexOf(u)) && r.splice(t, 1);
                    p.rotate(f, s, e.angle),
                    p.rotate(g, n, i.angle),
                    o.G[0] = -1,
                    o.G[1] = 0,
                    o.G[2] = -p.crossLength(f, m),
                    o.G[3] = 1,
                    o.G[4] = 0,
                    o.G[5] = p.crossLength(g, m),
                    a.G[0] = 0,
                    a.G[1] = -1,
                    a.G[2] = -p.crossLength(f, y),
                    a.G[3] = 0,
                    a.G[4] = 1,
                    a.G[5] = p.crossLength(g, y)
                }
                ,
                s.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation),
                    this.motorEnabled = !0)
                }
                ,
                s.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1),
                        this.motorEnabled = !1
                    }
                }
                ,
                s.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled
                }
                ,
                s.prototype.setMotorSpeed = function(t) {
                    if (this.motorEnabled) {
                        var e = this.equations.indexOf(this.motorEquation);
                        this.equations[e].relativeVelocity = t
                    }
                }
                ,
                s.prototype.getMotorSpeed = function() {
                    return !!this.motorEnabled && this.motorEquation.relativeVelocity
                }
            }
            , {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            20: [function(t, e, i) {
                var s = t("./Equation");
                t("../math/vec2");
                function n(t, e, i) {
                    i = i || {},
                    s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.angle = i.angle || 0,
                    this.ratio = "number" == typeof i.ratio ? i.ratio : 1,
                    this.setRatio(this.ratio)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                }
                ,
                n.prototype.setRatio = function(t) {
                    var e = this.G;
                    e[2] = t,
                    e[5] = -1,
                    this.ratio = t
                }
                ,
                n.prototype.setMaxTorque = function(t) {
                    this.maxForce = t,
                    this.minForce = -t
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            21: [function(t, e, i) {
                var s = t("./Equation")
                  , m = t("../math/vec2");
                function n(t, e) {
                    s.call(this, t, e, 0, Number.MAX_VALUE),
                    this.contactPointA = m.create(),
                    this.penetrationVec = m.create(),
                    this.contactPointB = m.create(),
                    this.normalA = m.create(),
                    this.restitution = 0,
                    this.firstImpact = !1,
                    this.shapeA = null,
                    this.shapeB = null
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeB = function(t, e, i) {
                    var s, n, r = this.bodyA, o = this.bodyB, a = this.contactPointA, h = this.contactPointB, l = r.position, c = o.position, u = this.penetrationVec, d = this.normalA, p = this.G, f = m.crossLength(a, d), g = m.crossLength(h, d);
                    return p[0] = -d[0],
                    p[1] = -d[1],
                    p[2] = -f,
                    p[3] = d[0],
                    p[4] = d[1],
                    p[5] = g,
                    m.add(u, c, h),
                    m.sub(u, u, l),
                    m.sub(u, u, a),
                    s = this.firstImpact && 0 !== this.restitution ? (n = 0,
                    1 / e * (1 + this.restitution) * this.computeGW()) : (n = m.dot(d, u) + this.offset,
                    this.computeGW()),
                    -n * t - s * e - i * this.computeGiMf()
                }
                ;
                var r = m.create()
                  , o = m.create()
                  , a = m.create();
                n.prototype.getVelocityAlongNormal = function() {
                    return this.bodyA.getVelocityAtPoint(r, this.contactPointA),
                    this.bodyB.getVelocityAtPoint(o, this.contactPointB),
                    m.subtract(a, r, o),
                    m.dot(this.normalA, a)
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            22: [function(t, e, i) {
                e.exports = o;
                var u = t("../math/vec2")
                  , r = t("../utils/Utils");
                t("../objects/Body");
                function o(t, e, i, s) {
                    this.minForce = void 0 === i ? -Number.MAX_VALUE : i,
                    this.maxForce = void 0 === s ? Number.MAX_VALUE : s,
                    this.bodyA = t,
                    this.bodyB = e,
                    this.stiffness = o.DEFAULT_STIFFNESS,
                    this.relaxation = o.DEFAULT_RELAXATION,
                    this.G = new r.ARRAY_TYPE(6);
                    for (var n = 0; n < 6; n++)
                        this.G[n] = 0;
                    this.offset = 0,
                    this.a = 0,
                    this.b = 0,
                    this.epsilon = 0,
                    this.timeStep = 1 / 60,
                    this.needsUpdate = !0,
                    this.multiplier = 0,
                    this.relativeVelocity = 0,
                    this.enabled = !0
                }
                (o.prototype.constructor = o).DEFAULT_STIFFNESS = 1e6,
                o.DEFAULT_RELAXATION = 4,
                o.prototype.update = function() {
                    var t = this.stiffness
                      , e = this.relaxation
                      , i = this.timeStep;
                    this.a = 4 / (i * (1 + 4 * e)),
                    this.b = 4 * e / (1 + 4 * e),
                    this.epsilon = 4 / (i * i * t * (1 + 4 * e)),
                    this.needsUpdate = !1
                }
                ,
                o.prototype.gmult = function(t, e, i, s, n) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
                }
                ,
                o.prototype.computeB = function(t, e, i) {
                    var s = this.computeGW();
                    return -this.computeGq() * t - s * e - this.computeGiMf() * i
                }
                ;
                var a = u.create()
                  , h = u.create();
                o.prototype.computeGq = function() {
                    var t = this.G
                      , e = this.bodyA
                      , i = this.bodyB
                      , s = (e.position,
                    i.position,
                    e.angle)
                      , n = i.angle;
                    return this.gmult(t, a, s, h, n) + this.offset
                }
                ,
                o.prototype.computeGW = function() {
                    var t = this.G
                      , e = this.bodyA
                      , i = this.bodyB
                      , s = e.velocity
                      , n = i.velocity
                      , r = e.angularVelocity
                      , o = i.angularVelocity;
                    return this.gmult(t, s, r, n, o) + this.relativeVelocity
                }
                ,
                o.prototype.computeGWlambda = function() {
                    var t = this.G
                      , e = this.bodyA
                      , i = this.bodyB
                      , s = e.vlambda
                      , n = i.vlambda
                      , r = e.wlambda
                      , o = i.wlambda;
                    return this.gmult(t, s, r, n, o)
                }
                ;
                var d = u.create()
                  , p = u.create();
                o.prototype.computeGiMf = function() {
                    var t = this.bodyA
                      , e = this.bodyB
                      , i = t.force
                      , s = t.angularForce
                      , n = e.force
                      , r = e.angularForce
                      , o = t.invMassSolve
                      , a = e.invMassSolve
                      , h = t.invInertiaSolve
                      , l = e.invInertiaSolve
                      , c = this.G;
                    return u.scale(d, i, o),
                    u.multiply(d, t.massMultiplier, d),
                    u.scale(p, n, a),
                    u.multiply(p, e.massMultiplier, p),
                    this.gmult(c, d, s * h, p, r * l)
                }
                ,
                o.prototype.computeGiMGt = function() {
                    var t = this.bodyA
                      , e = this.bodyB
                      , i = t.invMassSolve
                      , s = e.invMassSolve
                      , n = t.invInertiaSolve
                      , r = e.invInertiaSolve
                      , o = this.G;
                    return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * n + o[3] * o[3] * s * e.massMultiplier[0] + o[4] * o[4] * s * e.massMultiplier[1] + o[5] * o[5] * r
                }
                ;
                var f = u.create()
                  , g = u.create()
                  , m = u.create();
                u.create(),
                u.create(),
                u.create();
                o.prototype.addToWlambda = function(t) {
                    var e = this.bodyA
                      , i = this.bodyB
                      , s = f
                      , n = g
                      , r = m
                      , o = e.invMassSolve
                      , a = i.invMassSolve
                      , h = e.invInertiaSolve
                      , l = i.invInertiaSolve
                      , c = this.G;
                    n[0] = c[0],
                    n[1] = c[1],
                    r[0] = c[3],
                    r[1] = c[4],
                    u.scale(s, n, o * t),
                    u.multiply(s, s, e.massMultiplier),
                    u.add(e.vlambda, e.vlambda, s),
                    e.wlambda += h * c[2] * t,
                    u.scale(s, r, a * t),
                    u.multiply(s, s, i.massMultiplier),
                    u.add(i.vlambda, i.vlambda, s),
                    i.wlambda += l * c[5] * t
                }
                ,
                o.prototype.computeInvC = function(t) {
                    return 1 / (this.computeGiMGt() + t)
                }
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            23: [function(t, e, i) {
                var a = t("../math/vec2")
                  , s = t("./Equation");
                t("../utils/Utils");
                function n(t, e, i) {
                    s.call(this, t, e, -i, i),
                    this.contactPointA = a.create(),
                    this.contactPointB = a.create(),
                    this.t = a.create(),
                    this.contactEquations = [],
                    this.shapeA = null,
                    this.shapeB = null,
                    this.frictionCoefficient = .3
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.setSlipForce = function(t) {
                    this.maxForce = t,
                    this.minForce = -t
                }
                ,
                n.prototype.getSlipForce = function() {
                    return this.maxForce
                }
                ,
                n.prototype.computeB = function(t, e, i) {
                    this.bodyA,
                    this.bodyB;
                    var s = this.contactPointA
                      , n = this.contactPointB
                      , r = this.t
                      , o = this.G;
                    return o[0] = -r[0],
                    o[1] = -r[1],
                    o[2] = -a.crossLength(s, r),
                    o[3] = r[0],
                    o[4] = r[1],
                    o[5] = a.crossLength(n, r),
                    -this.computeGW() * e - i * this.computeGiMf()
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Equation": 22
            }],
            24: [function(t, e, i) {
                var n = t("./Equation")
                  , s = t("../math/vec2");
                function r(t, e, i) {
                    i = i || {},
                    n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.angle = i.angle || 0;
                    var s = this.G;
                    s[2] = 1,
                    s[5] = -1
                }
                ((e.exports = r).prototype = new n).constructor = r;
                var o = s.create()
                  , a = s.create()
                  , h = s.fromValues(1, 0)
                  , l = s.fromValues(0, 1);
                r.prototype.computeGq = function() {
                    return s.rotate(o, h, this.bodyA.angle + this.angle),
                    s.rotate(a, l, this.bodyB.angle),
                    s.dot(o, a)
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            25: [function(t, e, i) {
                var s = t("./Equation");
                t("../math/vec2");
                function n(t, e) {
                    s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.relativeVelocity = 1,
                    this.ratio = 1
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeB = function(t, e, i) {
                    var s = this.G;
                    s[2] = -1,
                    s[5] = this.ratio;
                    var n = this.computeGiMf();
                    return -this.computeGW() * e - i * n
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            26: [function(t, e, i) {
                function s() {}
                (e.exports = s).prototype = {
                    constructor: s,
                    on: function(t, e, i) {
                        e.context = i || this,
                        void 0 === this._listeners && (this._listeners = {});
                        var s = this._listeners;
                        return void 0 === s[t] && (s[t] = []),
                        -1 === s[t].indexOf(e) && s[t].push(e),
                        this
                    },
                    has: function(t, e) {
                        if (void 0 === this._listeners)
                            return !1;
                        var i = this._listeners;
                        if (e) {
                            if (void 0 !== i[t] && -1 !== i[t].indexOf(e))
                                return !0
                        } else if (void 0 !== i[t])
                            return !0;
                        return !1
                    },
                    off: function(t, e) {
                        if (void 0 === this._listeners)
                            return this;
                        var i = this._listeners
                          , s = i[t].indexOf(e);
                        return -1 !== s && i[t].splice(s, 1),
                        this
                    },
                    emit: function(t) {
                        if (void 0 === this._listeners)
                            return this;
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var i = 0, s = e.length; i < s; i++) {
                                var n = e[i];
                                n.call(n.context, t)
                            }
                        }
                        return this
                    }
                }
            }
            , {}],
            27: [function(t, e, i) {
                var s = t("./Material")
                  , n = t("../equations/Equation");
                function r(t, e, i) {
                    if (i = i || {},
                    !(t instanceof s && e instanceof s))
                        throw new Error("First two arguments must be Material instances.");
                    this.id = r.idCounter++,
                    this.materialA = t,
                    this.materialB = e,
                    this.friction = void 0 !== i.friction ? Number(i.friction) : .3,
                    this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0,
                    this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : n.DEFAULT_STIFFNESS,
                    this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : n.DEFAULT_RELAXATION,
                    this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : n.DEFAULT_STIFFNESS,
                    this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : n.DEFAULT_RELAXATION,
                    this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0,
                    this.contactSkinSize = .005
                }
                (e.exports = r).idCounter = 0
            }
            , {
                "../equations/Equation": 22,
                "./Material": 28
            }],
            28: [function(t, e, i) {
                function s(t) {
                    this.id = t || s.idCounter++
                }
                (e.exports = s).idCounter = 0
            }
            , {}],
            29: [function(t, e, i) {
                var v = {
                    GetArea: function(t) {
                        if (t.length < 6)
                            return 0;
                        for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2)
                            i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                        return .5 * -(i += (t[0] - t[e]) * (t[1 + e] + t[1]))
                    },
                    Triangulate: function(t) {
                        var e = t.length >> 1;
                        if (e < 3)
                            return [];
                        for (var i = [], s = [], n = 0; n < e; n++)
                            s.push(n);
                        n = 0;
                        for (var r = e; 3 < r; ) {
                            var o = s[(n + 0) % r]
                              , a = s[(n + 1) % r]
                              , h = s[(n + 2) % r]
                              , l = t[2 * o]
                              , c = t[2 * o + 1]
                              , u = t[2 * a]
                              , d = t[2 * a + 1]
                              , p = t[2 * h]
                              , f = t[2 * h + 1]
                              , g = !1;
                            if (v._convex(l, c, u, d, p, f)) {
                                g = !0;
                                for (var m = 0; m < r; m++) {
                                    var y = s[m];
                                    if (y != o && y != a && y != h && v._PointInTriangle(t[2 * y], t[2 * y + 1], l, c, u, d, p, f)) {
                                        g = !1;
                                        break
                                    }
                                }
                            }
                            if (g)
                                i.push(o, a, h),
                                s.splice((n + 1) % r, 1),
                                r--,
                                n = 0;
                            else if (n++ > 3 * r)
                                break
                        }
                        return i.push(s[0], s[1], s[2]),
                        i
                    },
                    _PointInTriangle: function(t, e, i, s, n, r, o, a) {
                        var h = o - i
                          , l = a - s
                          , c = n - i
                          , u = r - s
                          , d = t - i
                          , p = e - s
                          , f = h * h + l * l
                          , g = h * c + l * u
                          , m = h * d + l * p
                          , y = c * c + u * u
                          , v = c * d + u * p
                          , x = 1 / (f * y - g * g)
                          , b = (y * m - g * v) * x
                          , _ = (f * v - g * m) * x;
                        return 0 <= b && 0 <= _ && b + _ < 1
                    },
                    _convex: function(t, e, i, s, n, r) {
                        return 0 <= (e - s) * (n - i) + (i - t) * (r - s)
                    }
                };
                e.exports = v
            }
            , {}],
            30: [function(t, e, i) {
                var o = e.exports = {}
                  , s = t("../utils/Utils");
                o.crossLength = function(t, e) {
                    return t[0] * e[1] - t[1] * e[0]
                }
                ,
                o.crossVZ = function(t, e, i) {
                    return o.rotate(t, e, -Math.PI / 2),
                    o.scale(t, t, i),
                    t
                }
                ,
                o.crossZV = function(t, e, i) {
                    return o.rotate(t, i, Math.PI / 2),
                    o.scale(t, t, e),
                    t
                }
                ,
                o.rotate = function(t, e, i) {
                    if (0 !== i) {
                        var s = Math.cos(i)
                          , n = Math.sin(i)
                          , r = e[0]
                          , o = e[1];
                        t[0] = s * r - n * o,
                        t[1] = n * r + s * o
                    } else
                        t[0] = e[0],
                        t[1] = e[1]
                }
                ,
                o.rotate90cw = function(t, e) {
                    var i = e[0]
                      , s = e[1];
                    t[0] = s,
                    t[1] = -i
                }
                ,
                o.toLocalFrame = function(t, e, i, s) {
                    o.copy(t, e),
                    o.sub(t, t, i),
                    o.rotate(t, t, -s)
                }
                ,
                o.toGlobalFrame = function(t, e, i, s) {
                    o.copy(t, e),
                    o.rotate(t, t, s),
                    o.add(t, t, i)
                }
                ,
                o.vectorToLocalFrame = function(t, e, i) {
                    o.rotate(t, e, -i)
                }
                ,
                o.vectorToGlobalFrame = function(t, e, i) {
                    o.rotate(t, e, i)
                }
                ,
                o.centroid = function(t, e, i, s) {
                    return o.add(t, e, i),
                    o.add(t, t, s),
                    o.scale(t, t, 1 / 3),
                    t
                }
                ,
                o.create = function() {
                    var t = new s.ARRAY_TYPE(2);
                    return t[0] = 0,
                    t[1] = 0,
                    t
                }
                ,
                o.clone = function(t) {
                    var e = new s.ARRAY_TYPE(2);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e
                }
                ,
                o.fromValues = function(t, e) {
                    var i = new s.ARRAY_TYPE(2);
                    return i[0] = t,
                    i[1] = e,
                    i
                }
                ,
                o.copy = function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t
                }
                ,
                o.set = function(t, e, i) {
                    return t[0] = e,
                    t[1] = i,
                    t
                }
                ,
                o.add = function(t, e, i) {
                    return t[0] = e[0] + i[0],
                    t[1] = e[1] + i[1],
                    t
                }
                ,
                o.subtract = function(t, e, i) {
                    return t[0] = e[0] - i[0],
                    t[1] = e[1] - i[1],
                    t
                }
                ,
                o.sub = o.subtract,
                o.multiply = function(t, e, i) {
                    return t[0] = e[0] * i[0],
                    t[1] = e[1] * i[1],
                    t
                }
                ,
                o.mul = o.multiply,
                o.divide = function(t, e, i) {
                    return t[0] = e[0] / i[0],
                    t[1] = e[1] / i[1],
                    t
                }
                ,
                o.div = o.divide,
                o.scale = function(t, e, i) {
                    return t[0] = e[0] * i,
                    t[1] = e[1] * i,
                    t
                }
                ,
                o.distance = function(t, e) {
                    var i = e[0] - t[0]
                      , s = e[1] - t[1];
                    return Math.sqrt(i * i + s * s)
                }
                ,
                o.dist = o.distance,
                o.squaredDistance = function(t, e) {
                    var i = e[0] - t[0]
                      , s = e[1] - t[1];
                    return i * i + s * s
                }
                ,
                o.sqrDist = o.squaredDistance,
                o.length = function(t) {
                    var e = t[0]
                      , i = t[1];
                    return Math.sqrt(e * e + i * i)
                }
                ,
                o.len = o.length,
                o.squaredLength = function(t) {
                    var e = t[0]
                      , i = t[1];
                    return e * e + i * i
                }
                ,
                o.sqrLen = o.squaredLength,
                o.negate = function(t, e) {
                    return t[0] = -e[0],
                    t[1] = -e[1],
                    t
                }
                ,
                o.normalize = function(t, e) {
                    var i = e[0]
                      , s = e[1]
                      , n = i * i + s * s;
                    return 0 < n && (n = 1 / Math.sqrt(n),
                    t[0] = e[0] * n,
                    t[1] = e[1] * n),
                    t
                }
                ,
                o.dot = function(t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                }
                ,
                o.str = function(t) {
                    return "vec2(" + t[0] + ", " + t[1] + ")"
                }
                ,
                o.lerp = function(t, e, i, s) {
                    var n = e[0]
                      , r = e[1];
                    return t[0] = n + s * (i[0] - n),
                    t[1] = r + s * (i[1] - r),
                    t
                }
                ,
                o.reflect = function(t, e, i) {
                    var s = e[0] * i[0] + e[1] * i[1];
                    t[0] = e[0] - 2 * i[0] * s,
                    t[1] = e[1] - 2 * i[1] * s
                }
                ,
                o.getLineSegmentsIntersection = function(t, e, i, s, n) {
                    var r = o.getLineSegmentsIntersectionFraction(e, i, s, n);
                    return !(r < 0) && (t[0] = e[0] + r * (i[0] - e[0]),
                    t[1] = e[1] + r * (i[1] - e[1]),
                    !0)
                }
                ,
                o.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                    var n, r, o = e[0] - t[0], a = e[1] - t[1], h = s[0] - i[0], l = s[1] - i[1];
                    return n = (-a * (t[0] - i[0]) + o * (t[1] - i[1])) / (-h * a + o * l),
                    r = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * a + o * l),
                    0 <= n && n <= 1 && 0 <= r && r <= 1 ? r : -1
                }
            }
            , {
                "../utils/Utils": 57
            }],
            31: [function(t, e, i) {
                var u = t("../math/vec2")
                  , l = t("poly-decomp")
                  , c = t("../shapes/Convex")
                  , s = t("../collision/RaycastResult")
                  , n = t("../collision/Ray")
                  , r = t("../collision/AABB")
                  , o = t("../events/EventEmitter");
                function a(t) {
                    t = t || {},
                    o.call(this),
                    this.id = t.id || ++a._idCounter,
                    this.world = null,
                    this.shapes = [],
                    this.mass = t.mass || 0,
                    this.invMass = 0,
                    this.inertia = 0,
                    this.invInertia = 0,
                    this.invMassSolve = 0,
                    this.invInertiaSolve = 0,
                    this.fixedRotation = !!t.fixedRotation,
                    this.fixedX = !!t.fixedX,
                    this.fixedY = !!t.fixedY,
                    this.massMultiplier = u.create(),
                    this.position = u.fromValues(0, 0),
                    t.position && u.copy(this.position, t.position),
                    this.interpolatedPosition = u.fromValues(0, 0),
                    this.interpolatedAngle = 0,
                    this.previousPosition = u.fromValues(0, 0),
                    this.previousAngle = 0,
                    this.velocity = u.fromValues(0, 0),
                    t.velocity && u.copy(this.velocity, t.velocity),
                    this.vlambda = u.fromValues(0, 0),
                    this.wlambda = 0,
                    this.angle = t.angle || 0,
                    this.angularVelocity = t.angularVelocity || 0,
                    this.force = u.create(),
                    t.force && u.copy(this.force, t.force),
                    this.angularForce = t.angularForce || 0,
                    this.damping = "number" == typeof t.damping ? t.damping : .1,
                    this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1,
                    this.type = a.STATIC,
                    void 0 !== t.type ? this.type = t.type : t.mass ? this.type = a.DYNAMIC : this.type = a.STATIC,
                    this.boundingRadius = 0,
                    this.aabb = new r,
                    this.aabbNeedsUpdate = !0,
                    this.allowSleep = void 0 === t.allowSleep || t.allowSleep,
                    this.wantsToSleep = !1,
                    this.sleepState = a.AWAKE,
                    this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2,
                    this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1,
                    this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1,
                    this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                    this.idleTime = 0,
                    this.timeLastSleepy = 0,
                    this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1,
                    this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10,
                    this.concavePath = null,
                    this._wakeUpAfterNarrowphase = !1,
                    this.updateMassProperties()
                }
                (((e.exports = a).prototype = new o).constructor = a)._idCounter = 0,
                a.prototype.updateSolveMassProperties = function() {
                    this.sleepState === a.SLEEPING || this.type === a.KINEMATIC ? (this.invMassSolve = 0,
                    this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass,
                    this.invInertiaSolve = this.invInertia)
                }
                ,
                a.prototype.setDensity = function(t) {
                    var e = this.getArea();
                    this.mass = e * t,
                    this.updateMassProperties()
                }
                ,
                a.prototype.getArea = function() {
                    for (var t = 0, e = 0; e < this.shapes.length; e++)
                        t += this.shapes[e].area;
                    return t
                }
                ,
                a.prototype.getAABB = function() {
                    return this.aabbNeedsUpdate && this.updateAABB(),
                    this.aabb
                }
                ;
                var h = new r
                  , d = u.create();
                a.prototype.updateAABB = function() {
                    for (var t = this.shapes, e = t.length, i = d, s = this.angle, n = 0; n !== e; n++) {
                        var r = t[n]
                          , o = r.angle + s;
                        u.rotate(i, r.position, s),
                        u.add(i, i, this.position),
                        r.computeAABB(h, i, o),
                        0 === n ? this.aabb.copy(h) : this.aabb.extend(h)
                    }
                    this.aabbNeedsUpdate = !1
                }
                ,
                a.prototype.updateBoundingRadius = function() {
                    for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                        var n = t[s]
                          , r = u.length(n.position)
                          , o = n.boundingRadius;
                        i < r + o && (i = r + o)
                    }
                    this.boundingRadius = i
                }
                ,
                a.prototype.addShape = function(t, e, i) {
                    if (t.body)
                        throw new Error("A shape can only be added to one body.");
                    t.body = this,
                    e ? u.copy(t.position, e) : u.set(t.position, 0, 0),
                    t.angle = i || 0,
                    this.shapes.push(t),
                    this.updateMassProperties(),
                    this.updateBoundingRadius(),
                    this.aabbNeedsUpdate = !0
                }
                ,
                a.prototype.removeShape = function(t) {
                    var e = this.shapes.indexOf(t);
                    return -1 !== e && (this.shapes.splice(e, 1),
                    this.aabbNeedsUpdate = !0,
                    !(t.body = null))
                }
                ,
                a.prototype.updateMassProperties = function() {
                    if (this.type === a.STATIC || this.type === a.KINEMATIC)
                        this.mass = Number.MAX_VALUE,
                        this.invMass = 0,
                        this.inertia = Number.MAX_VALUE,
                        this.invInertia = 0;
                    else {
                        var t = this.shapes
                          , e = t.length
                          , i = this.mass / e
                          , s = 0;
                        if (this.fixedRotation)
                            this.inertia = Number.MAX_VALUE,
                            this.invInertia = 0;
                        else {
                            for (var n = 0; n < e; n++) {
                                var r = t[n]
                                  , o = u.squaredLength(r.position);
                                s += r.computeMomentOfInertia(i) + i * o
                            }
                            this.inertia = s,
                            this.invInertia = 0 < s ? 1 / s : 0
                        }
                        this.invMass = 1 / this.mass,
                        u.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                    }
                }
                ;
                u.create();
                a.prototype.applyForce = function(t, e) {
                    if (u.add(this.force, this.force, t),
                    e) {
                        var i = u.crossLength(e, t);
                        this.angularForce += i
                    }
                }
                ;
                var p = u.create()
                  , f = u.create()
                  , g = u.create();
                a.prototype.applyForceLocal = function(t, e) {
                    e = e || g;
                    var i = p
                      , s = f;
                    this.vectorToWorldFrame(i, t),
                    this.vectorToWorldFrame(s, e),
                    this.applyForce(i, s)
                }
                ;
                var m = u.create();
                a.prototype.applyImpulse = function(t, e) {
                    if (this.type === a.DYNAMIC) {
                        var i = m;
                        if (u.scale(i, t, this.invMass),
                        u.multiply(i, this.massMultiplier, i),
                        u.add(this.velocity, i, this.velocity),
                        e) {
                            var s = u.crossLength(e, t);
                            s *= this.invInertia,
                            this.angularVelocity += s
                        }
                    }
                }
                ;
                var y = u.create()
                  , v = u.create()
                  , x = u.create();
                a.prototype.applyImpulseLocal = function(t, e) {
                    e = e || x;
                    var i = y
                      , s = v;
                    this.vectorToWorldFrame(i, t),
                    this.vectorToWorldFrame(s, e),
                    this.applyImpulse(i, s)
                }
                ,
                a.prototype.toLocalFrame = function(t, e) {
                    u.toLocalFrame(t, e, this.position, this.angle)
                }
                ,
                a.prototype.toWorldFrame = function(t, e) {
                    u.toGlobalFrame(t, e, this.position, this.angle)
                }
                ,
                a.prototype.vectorToLocalFrame = function(t, e) {
                    u.vectorToLocalFrame(t, e, this.angle)
                }
                ,
                a.prototype.vectorToWorldFrame = function(t, e) {
                    u.vectorToGlobalFrame(t, e, this.angle)
                }
                ,
                a.prototype.fromPolygon = function(t, e) {
                    e = e || {};
                    for (var i = this.shapes.length; 0 <= i; --i)
                        this.removeShape(this.shapes[i]);
                    var s, n = new l.Polygon;
                    if (n.vertices = t,
                    n.makeCCW(),
                    "number" == typeof e.removeCollinearPoints && n.removeCollinearPoints(e.removeCollinearPoints),
                    void 0 === e.skipSimpleCheck && !n.isSimple())
                        return !1;
                    this.concavePath = n.vertices.slice(0);
                    for (i = 0; i < this.concavePath.length; i++) {
                        var r = [0, 0];
                        u.copy(r, this.concavePath[i]),
                        this.concavePath[i] = r
                    }
                    s = e.optimalDecomp ? n.decomp() : n.quickDecomp();
                    var o = u.create();
                    for (i = 0; i !== s.length; i++) {
                        for (var a = new c({
                            vertices: s[i].vertices
                        }), h = 0; h !== a.vertices.length; h++) {
                            r = a.vertices[h];
                            u.sub(r, r, a.centerOfMass)
                        }
                        u.scale(o, a.centerOfMass, 1),
                        a.updateTriangles(),
                        a.updateCenterOfMass(),
                        a.updateBoundingRadius(),
                        this.addShape(a, o)
                    }
                    return this.adjustCenterOfMass(),
                    this.aabbNeedsUpdate = !0
                }
                ;
                u.fromValues(0, 0);
                var b = u.fromValues(0, 0)
                  , _ = u.fromValues(0, 0)
                  , w = u.fromValues(0, 0);
                a.prototype.adjustCenterOfMass = function() {
                    var t = b
                      , e = _
                      , i = w
                      , s = 0;
                    u.set(e, 0, 0);
                    for (var n = 0; n !== this.shapes.length; n++) {
                        var r = this.shapes[n];
                        u.scale(t, r.position, r.area),
                        u.add(e, e, t),
                        s += r.area
                    }
                    u.scale(i, e, 1 / s);
                    for (n = 0; n !== this.shapes.length; n++) {
                        r = this.shapes[n];
                        u.sub(r.position, r.position, i)
                    }
                    u.add(this.position, this.position, i);
                    for (n = 0; this.concavePath && n < this.concavePath.length; n++)
                        u.sub(this.concavePath[n], this.concavePath[n], i);
                    this.updateMassProperties(),
                    this.updateBoundingRadius()
                }
                ,
                a.prototype.setZeroForce = function() {
                    u.set(this.force, 0, 0),
                    this.angularForce = 0
                }
                ,
                a.prototype.resetConstraintVelocity = function() {
                    var t = this.vlambda;
                    u.set(t, 0, 0),
                    this.wlambda = 0
                }
                ,
                a.prototype.addConstraintVelocity = function() {
                    var t = this.velocity;
                    u.add(t, t, this.vlambda),
                    this.angularVelocity += this.wlambda
                }
                ,
                a.prototype.applyDamping = function(t) {
                    if (this.type === a.DYNAMIC) {
                        var e = this.velocity;
                        u.scale(e, e, Math.pow(1 - this.damping, t)),
                        this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                    }
                }
                ,
                a.prototype.wakeUp = function() {
                    var t = this.sleepState;
                    this.sleepState = a.AWAKE,
                    this.idleTime = 0,
                    t !== a.AWAKE && this.emit(a.wakeUpEvent)
                }
                ,
                a.prototype.sleep = function() {
                    this.sleepState = a.SLEEPING,
                    this.angularVelocity = 0,
                    this.angularForce = 0,
                    u.set(this.velocity, 0, 0),
                    u.set(this.force, 0, 0),
                    this.emit(a.sleepEvent)
                }
                ,
                a.prototype.sleepTick = function(t, e, i) {
                    if (this.allowSleep && this.type !== a.SLEEPING) {
                        this.wantsToSleep = !1;
                        this.sleepState;
                        var s = u.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2);
                        Math.pow(this.sleepSpeedLimit, 2) <= s ? (this.idleTime = 0,
                        this.sleepState = a.AWAKE) : (this.idleTime += i,
                        this.sleepState = a.SLEEPY),
                        this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                    }
                }
                ,
                a.prototype.overlaps = function(t) {
                    return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
                }
                ;
                var T = u.create()
                  , P = u.create();
                a.prototype.integrate = function(t) {
                    var e = this.invMass
                      , i = this.force
                      , s = this.position
                      , n = this.velocity;
                    u.copy(this.previousPosition, this.position),
                    this.previousAngle = this.angle,
                    this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t),
                    u.scale(T, i, t * e),
                    u.multiply(T, this.massMultiplier, T),
                    u.add(n, T, n),
                    this.integrateToTimeOfImpact(t) || (u.scale(P, n, t),
                    u.add(s, s, P),
                    this.fixedRotation || (this.angle += this.angularVelocity * t)),
                    this.aabbNeedsUpdate = !0
                }
                ;
                var C = new s
                  , S = new n({
                    mode: n.ALL
                })
                  , A = u.create()
                  , E = u.create()
                  , M = u.create()
                  , R = u.create();
                a.prototype.integrateToTimeOfImpact = function(t) {
                    if (this.ccdSpeedThreshold < 0 || u.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2))
                        return !1;
                    u.normalize(A, this.velocity),
                    u.scale(E, this.velocity, t),
                    u.add(E, E, this.position),
                    u.sub(M, E, this.position);
                    var e, i = this.angularVelocity * t, s = u.length(M), n = 1, r = this;
                    if (C.reset(),
                    S.callback = function(t) {
                        t.body !== r && (e = t.body,
                        t.getHitPoint(E, S),
                        u.sub(M, E, r.position),
                        n = u.length(M) / s,
                        t.stop())
                    }
                    ,
                    u.copy(S.from, this.position),
                    u.copy(S.to, E),
                    S.update(),
                    this.world.raycast(C, S),
                    !e)
                        return !1;
                    var o = this.angle;
                    u.copy(R, this.position);
                    for (var a = 0, h = 0, l = 0, c = n; h <= c && a < this.ccdIterations; ) {
                        a++,
                        l = (c - h) / 2,
                        u.scale(P, M, n),
                        u.add(this.position, R, P),
                        this.angle = o + i * n,
                        this.updateAABB(),
                        this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? h = l : c = l
                    }
                    return n = l,
                    u.copy(this.position, R),
                    this.angle = o,
                    u.scale(P, M, n),
                    u.add(this.position, this.position, P),
                    this.fixedRotation || (this.angle += i * n),
                    !0
                }
                ,
                a.prototype.getVelocityAtPoint = function(t, e) {
                    return u.crossVZ(t, e, this.angularVelocity),
                    u.subtract(t, this.velocity, t),
                    t
                }
                ,
                a.sleepyEvent = {
                    type: "sleepy"
                },
                a.sleepEvent = {
                    type: "sleep"
                },
                a.wakeUpEvent = {
                    type: "wakeup"
                },
                a.DYNAMIC = 1,
                a.STATIC = 2,
                a.KINEMATIC = 4,
                a.AWAKE = 0,
                a.SLEEPY = 1,
                a.SLEEPING = 2
            }
            , {
                "../collision/AABB": 7,
                "../collision/Ray": 11,
                "../collision/RaycastResult": 12,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 40,
                "poly-decomp": 5
            }],
            32: [function(t, e, i) {
                var y = t("../math/vec2")
                  , o = t("./Spring");
                t("../utils/Utils");
                function s(t, e, i) {
                    i = i || {},
                    o.call(this, t, e, i),
                    this.localAnchorA = y.fromValues(0, 0),
                    this.localAnchorB = y.fromValues(0, 0),
                    i.localAnchorA && y.copy(this.localAnchorA, i.localAnchorA),
                    i.localAnchorB && y.copy(this.localAnchorB, i.localAnchorB),
                    i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA),
                    i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                    var s = y.create()
                      , n = y.create();
                    this.getWorldAnchorA(s),
                    this.getWorldAnchorB(n);
                    var r = y.distance(s, n);
                    this.restLength = "number" == typeof i.restLength ? i.restLength : r
                }
                (((e.exports = s).prototype = new o).constructor = s).prototype.setWorldAnchorA = function(t) {
                    this.bodyA.toLocalFrame(this.localAnchorA, t)
                }
                ,
                s.prototype.setWorldAnchorB = function(t) {
                    this.bodyB.toLocalFrame(this.localAnchorB, t)
                }
                ,
                s.prototype.getWorldAnchorA = function(t) {
                    this.bodyA.toWorldFrame(t, this.localAnchorA)
                }
                ,
                s.prototype.getWorldAnchorB = function(t) {
                    this.bodyB.toWorldFrame(t, this.localAnchorB)
                }
                ;
                var v = y.create()
                  , x = y.create()
                  , b = y.create()
                  , _ = y.create()
                  , w = y.create()
                  , T = y.create()
                  , P = y.create()
                  , C = y.create()
                  , S = y.create();
                s.prototype.applyForce = function() {
                    var t = this.stiffness
                      , e = this.damping
                      , i = this.restLength
                      , s = this.bodyA
                      , n = this.bodyB
                      , r = v
                      , o = x
                      , a = b
                      , h = _
                      , l = S
                      , c = w
                      , u = T
                      , d = P
                      , p = C;
                    this.getWorldAnchorA(c),
                    this.getWorldAnchorB(u),
                    y.sub(d, c, s.position),
                    y.sub(p, u, n.position),
                    y.sub(r, u, c);
                    var f = y.len(r);
                    y.normalize(o, r),
                    y.sub(a, n.velocity, s.velocity),
                    y.crossZV(l, n.angularVelocity, p),
                    y.add(a, a, l),
                    y.crossZV(l, s.angularVelocity, d),
                    y.sub(a, a, l),
                    y.scale(h, o, -t * (f - i) - e * y.dot(a, o)),
                    y.sub(s.force, s.force, h),
                    y.add(n.force, n.force, h);
                    var g = y.crossLength(d, h)
                      , m = y.crossLength(p, h);
                    s.angularForce -= g,
                    n.angularForce += m
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Spring": 34
            }],
            33: [function(t, e, i) {
                t("../math/vec2");
                var s = t("./Spring");
                function n(t, e, i) {
                    i = i || {},
                    s.call(this, t, e, i),
                    this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.applyForce = function() {
                    var t = this.stiffness
                      , e = this.damping
                      , i = this.restAngle
                      , s = this.bodyA
                      , n = this.bodyB
                      , r = -t * (n.angle - s.angle - i) - e * (n.angularVelocity - s.angularVelocity) * 0;
                    s.angularForce -= r,
                    n.angularForce += r
                }
            }
            , {
                "../math/vec2": 30,
                "./Spring": 34
            }],
            34: [function(t, e, i) {
                t("../math/vec2");
                var s = t("../utils/Utils");
                function n(t, e, i) {
                    i = s.defaults(i, {
                        stiffness: 100,
                        damping: 1
                    }),
                    this.stiffness = i.stiffness,
                    this.damping = i.damping,
                    this.bodyA = t,
                    this.bodyB = e
                }
                (e.exports = n).prototype.applyForce = function() {}
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            35: [function(t, e, i) {
                var s = t("../math/vec2")
                  , n = (t("../utils/Utils"),
                t("../constraints/Constraint"))
                  , r = t("../equations/FrictionEquation")
                  , o = t("../objects/Body");
                function a(t, e) {
                    this.chassisBody = t,
                    this.wheels = [],
                    this.groundBody = new o({
                        mass: 0
                    }),
                    this.world = null;
                    var i = this;
                    this.preStepCallback = function() {
                        i.update()
                    }
                }
                function h(t, e) {
                    e = e || {},
                    this.vehicle = t,
                    this.forwardEquation = new r(t.chassisBody,t.groundBody),
                    this.sideEquation = new r(t.chassisBody,t.groundBody),
                    this.steerValue = 0,
                    this.engineForce = 0,
                    this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5),
                    this.localForwardVector = s.fromValues(0, 1),
                    e.localForwardVector && s.copy(this.localForwardVector, e.localForwardVector),
                    this.localPosition = s.fromValues(0, 0),
                    e.localPosition && s.copy(this.localPosition, e.localPosition),
                    n.apply(this, t.chassisBody, t.groundBody),
                    this.equations.push(this.forwardEquation, this.sideEquation),
                    this.setBrakeForce(0)
                }
                (e.exports = a).prototype.addToWorld = function(t) {
                    (this.world = t).addBody(this.groundBody),
                    t.on("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var i = this.wheels[e];
                        t.addConstraint(i)
                    }
                }
                ,
                a.prototype.removeFromWorld = function() {
                    var t = this.world;
                    t.removeBody(this.groundBody),
                    t.off("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var i = this.wheels[e];
                        t.removeConstraint(i)
                    }
                    this.world = null
                }
                ,
                a.prototype.addWheel = function(t) {
                    var e = new h(this,t);
                    return this.wheels.push(e),
                    e
                }
                ,
                a.prototype.update = function() {
                    for (var t = 0; t < this.wheels.length; t++)
                        this.wheels[t].update()
                }
                ,
                (h.prototype = new n).setBrakeForce = function(t) {
                    this.forwardEquation.setSlipForce(t)
                }
                ,
                h.prototype.setSideFriction = function(t) {
                    this.sideEquation.setSlipForce(t)
                }
                ;
                var l = s.create()
                  , c = s.create();
                h.prototype.getSpeed = function() {
                    return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector),
                    this.vehicle.chassisBody.getVelocityAtPoint(l, c),
                    s.dot(l, c)
                }
                ;
                var u = s.create();
                h.prototype.update = function() {
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector),
                    s.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2),
                    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t),
                    s.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue),
                    s.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue),
                    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition),
                    s.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB),
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition),
                    s.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA),
                    s.normalize(u, this.forwardEquation.t),
                    s.scale(u, u, this.engineForce),
                    this.vehicle.chassisBody.applyForce(u, this.forwardEquation.contactPointA)
                }
            }
            , {
                "../constraints/Constraint": 14,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            36: [function(t, e, i) {
                var s = e.exports = {
                    AABB: t("./collision/AABB"),
                    AngleLockEquation: t("./equations/AngleLockEquation"),
                    Body: t("./objects/Body"),
                    Broadphase: t("./collision/Broadphase"),
                    Capsule: t("./shapes/Capsule"),
                    Circle: t("./shapes/Circle"),
                    Constraint: t("./constraints/Constraint"),
                    ContactEquation: t("./equations/ContactEquation"),
                    ContactEquationPool: t("./utils/ContactEquationPool"),
                    ContactMaterial: t("./material/ContactMaterial"),
                    Convex: t("./shapes/Convex"),
                    DistanceConstraint: t("./constraints/DistanceConstraint"),
                    Equation: t("./equations/Equation"),
                    EventEmitter: t("./events/EventEmitter"),
                    FrictionEquation: t("./equations/FrictionEquation"),
                    FrictionEquationPool: t("./utils/FrictionEquationPool"),
                    GearConstraint: t("./constraints/GearConstraint"),
                    GSSolver: t("./solver/GSSolver"),
                    Heightfield: t("./shapes/Heightfield"),
                    Line: t("./shapes/Line"),
                    LockConstraint: t("./constraints/LockConstraint"),
                    Material: t("./material/Material"),
                    Narrowphase: t("./collision/Narrowphase"),
                    NaiveBroadphase: t("./collision/NaiveBroadphase"),
                    Particle: t("./shapes/Particle"),
                    Plane: t("./shapes/Plane"),
                    Pool: t("./utils/Pool"),
                    RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                    PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                    Ray: t("./collision/Ray"),
                    RaycastResult: t("./collision/RaycastResult"),
                    Box: t("./shapes/Box"),
                    RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                    SAPBroadphase: t("./collision/SAPBroadphase"),
                    Shape: t("./shapes/Shape"),
                    Solver: t("./solver/Solver"),
                    Spring: t("./objects/Spring"),
                    TopDownVehicle: t("./objects/TopDownVehicle"),
                    LinearSpring: t("./objects/LinearSpring"),
                    RotationalSpring: t("./objects/RotationalSpring"),
                    Utils: t("./utils/Utils"),
                    World: t("./world/World"),
                    vec2: t("./math/vec2"),
                    version: t("../package.json").version
                };
                Object.defineProperty(s, "Rectangle", {
                    get: function() {
                        return console.warn("The Rectangle class has been renamed to Box."),
                        this.Box
                    }
                })
            }
            , {
                "../package.json": 6,
                "./collision/AABB": 7,
                "./collision/Broadphase": 8,
                "./collision/NaiveBroadphase": 9,
                "./collision/Narrowphase": 10,
                "./collision/Ray": 11,
                "./collision/RaycastResult": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/LinearSpring": 32,
                "./objects/RotationalSpring": 33,
                "./objects/Spring": 34,
                "./objects/TopDownVehicle": 35,
                "./shapes/Box": 37,
                "./shapes/Capsule": 38,
                "./shapes/Circle": 39,
                "./shapes/Convex": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Line": 42,
                "./shapes/Particle": 43,
                "./shapes/Plane": 44,
                "./shapes/Shape": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./utils/ContactEquationPool": 48,
                "./utils/FrictionEquationPool": 49,
                "./utils/Pool": 55,
                "./utils/Utils": 57,
                "./world/World": 61
            }],
            37: [function(t, e, i) {
                var r = t("../math/vec2")
                  , o = t("./Shape")
                  , a = t("./Convex");
                function s(t) {
                    "number" == typeof t && "number" == typeof arguments[1] && (t = {
                        width: t,
                        height: arguments[1]
                    },
                    console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")),
                    t = t || {};
                    var e = this.width = t.width || 1
                      , i = this.height = t.height || 1
                      , s = [r.fromValues(-e / 2, -i / 2), r.fromValues(e / 2, -i / 2), r.fromValues(e / 2, i / 2), r.fromValues(-e / 2, i / 2)]
                      , n = [r.fromValues(1, 0), r.fromValues(0, 1)];
                    t.vertices = s,
                    t.axes = n,
                    t.type = o.BOX,
                    a.call(this, t)
                }
                (((e.exports = s).prototype = new a).constructor = s).prototype.computeMomentOfInertia = function(t) {
                    var e = this.width
                      , i = this.height;
                    return t * (i * i + e * e) / 12
                }
                ,
                s.prototype.updateBoundingRadius = function() {
                    var t = this.width
                      , e = this.height;
                    this.boundingRadius = Math.sqrt(t * t + e * e) / 2
                }
                ;
                r.create(),
                r.create(),
                r.create(),
                r.create();
                s.prototype.computeAABB = function(t, e, i) {
                    t.setFromPoints(this.vertices, e, i, 0)
                }
                ,
                s.prototype.updateArea = function() {
                    this.area = this.width * this.height
                }
            }
            , {
                "../math/vec2": 30,
                "./Convex": 40,
                "./Shape": 45
            }],
            38: [function(t, e, i) {
                var s = t("./Shape")
                  , w = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && "number" == typeof arguments[1] && (t = {
                        length: t,
                        radius: arguments[1]
                    },
                    console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")),
                    t = t || {},
                    this.length = t.length || 1,
                    this.radius = t.radius || 1,
                    t.type = s.CAPSULE,
                    s.call(this, t)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius
                      , i = this.length + e
                      , s = 2 * e;
                    return t * (s * s + i * i) / 12
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
                }
                ;
                var r = w.create();
                n.prototype.computeAABB = function(t, e, i) {
                    var s = this.radius;
                    w.set(r, this.length / 2, 0),
                    0 !== i && w.rotate(r, r, i),
                    w.set(t.upperBound, Math.max(r[0] + s, -r[0] + s), Math.max(r[1] + s, -r[1] + s)),
                    w.set(t.lowerBound, Math.min(r[0] - s, -r[0] - s), Math.min(r[1] - s, -r[1] - s)),
                    w.add(t.lowerBound, t.lowerBound, e),
                    w.add(t.upperBound, t.upperBound, e)
                }
                ;
                var T = w.create()
                  , P = w.create()
                  , C = w.create()
                  , S = w.create()
                  , A = w.fromValues(0, 1);
                n.prototype.raycast = function(t, e, i, s) {
                    for (var n = e.from, r = e.to, o = (e.direction,
                    T), a = P, h = C, l = S, c = this.length / 2, u = 0; u < 2; u++) {
                        var d = this.radius * (2 * u - 1);
                        if (w.set(h, -c, d),
                        w.set(l, c, d),
                        w.toGlobalFrame(h, h, i, s),
                        w.toGlobalFrame(l, l, i, s),
                        0 <= (f = w.getLineSegmentsIntersectionFraction(n, r, h, l)) && (w.rotate(a, A, s),
                        w.scale(a, a, 2 * u - 1),
                        e.reportIntersection(t, f, a, -1),
                        t.shouldStop(e)))
                            return
                    }
                    var p = Math.pow(this.radius, 2) + Math.pow(c, 2);
                    for (u = 0; u < 2; u++) {
                        w.set(h, c * (2 * u - 1), 0),
                        w.toGlobalFrame(h, h, i, s);
                        var f, g = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2), m = 2 * ((r[0] - n[0]) * (n[0] - h[0]) + (r[1] - n[1]) * (n[1] - h[1])), y = Math.pow(n[0] - h[0], 2) + Math.pow(n[1] - h[1], 2) - Math.pow(this.radius, 2);
                        if (!((f = Math.pow(m, 2) - 4 * g * y) < 0))
                            if (0 === f) {
                                if (w.lerp(o, n, r, f),
                                w.squaredDistance(o, i) > p && (w.sub(a, o, h),
                                w.normalize(a, a),
                                e.reportIntersection(t, f, a, -1),
                                t.shouldStop(e)))
                                    return
                            } else {
                                var v = Math.sqrt(f)
                                  , x = 1 / (2 * g)
                                  , b = (-m - v) * x
                                  , _ = (-m + v) * x;
                                if (0 <= b && b <= 1 && (w.lerp(o, n, r, b),
                                w.squaredDistance(o, i) > p && (w.sub(a, o, h),
                                w.normalize(a, a),
                                e.reportIntersection(t, b, a, -1),
                                t.shouldStop(e))))
                                    return;
                                if (0 <= _ && _ <= 1 && (w.lerp(o, n, r, _),
                                w.squaredDistance(o, i) > p && (w.sub(a, o, h),
                                w.normalize(a, a),
                                e.reportIntersection(t, _, a, -1),
                                t.shouldStop(e))))
                                    return
                            }
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            39: [function(t, e, i) {
                var s = t("./Shape")
                  , y = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && (t = {
                        radius: t
                    },
                    console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")),
                    t = t || {},
                    this.radius = t.radius || 1,
                    t.type = s.CIRCLE,
                    s.call(this, t)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius;
                    return t * e * e / 2
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius
                }
                ,
                n.prototype.computeAABB = function(t, e, i) {
                    var s = this.radius;
                    y.set(t.upperBound, s, s),
                    y.set(t.lowerBound, -s, -s),
                    e && (y.add(t.lowerBound, t.lowerBound, e),
                    y.add(t.upperBound, t.upperBound, e))
                }
                ;
                var v = y.create()
                  , x = y.create();
                n.prototype.raycast = function(t, e, i, s) {
                    var n = e.from
                      , r = e.to
                      , o = this.radius
                      , a = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2)
                      , h = 2 * ((r[0] - n[0]) * (n[0] - i[0]) + (r[1] - n[1]) * (n[1] - i[1]))
                      , l = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(o, 2)
                      , c = Math.pow(h, 2) - 4 * a * l
                      , u = v
                      , d = x;
                    if (!(c < 0))
                        if (0 == c)
                            y.lerp(u, n, r, c),
                            y.sub(d, u, i),
                            y.normalize(d, d),
                            e.reportIntersection(t, c, d, -1);
                        else {
                            var p = Math.sqrt(c)
                              , f = 1 / (2 * a)
                              , g = (-h - p) * f
                              , m = (-h + p) * f;
                            if (0 <= g && g <= 1 && (y.lerp(u, n, r, g),
                            y.sub(d, u, i),
                            y.normalize(d, d),
                            e.reportIntersection(t, g, d, -1),
                            t.shouldStop(e)))
                                return;
                            0 <= m && m <= 1 && (y.lerp(u, n, r, m),
                            y.sub(d, u, i),
                            y.normalize(d, d),
                            e.reportIntersection(t, m, d, -1))
                        }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            40: [function(t, e, i) {
                var h = t("./Shape")
                  , p = t("../math/vec2")
                  , a = t("../math/polyk");
                t("poly-decomp");
                function d(t) {
                    Array.isArray(t) && (t = {
                        vertices: t,
                        axes: arguments[1]
                    },
                    console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")),
                    t = t || {},
                    this.vertices = [];
                    for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                        var s = p.create();
                        p.copy(s, e[i]),
                        this.vertices.push(s)
                    }
                    if (this.axes = [],
                    t.axes)
                        for (i = 0; i < t.axes.length; i++) {
                            var n = p.create();
                            p.copy(n, t.axes[i]),
                            this.axes.push(n)
                        }
                    else
                        for (i = 0; i < this.vertices.length; i++) {
                            var r = this.vertices[i]
                              , o = this.vertices[(i + 1) % this.vertices.length]
                              , a = p.create();
                            p.sub(a, o, r),
                            p.rotate90cw(a, a),
                            p.normalize(a, a),
                            this.axes.push(a)
                        }
                    if (this.centerOfMass = p.fromValues(0, 0),
                    this.triangles = [],
                    this.vertices.length && (this.updateTriangles(),
                    this.updateCenterOfMass()),
                    this.boundingRadius = 0,
                    t.type = h.CONVEX,
                    h.call(this, t),
                    this.updateBoundingRadius(),
                    this.updateArea(),
                    this.area < 0)
                        throw new Error("Convex vertices must be given in conter-clockwise winding.")
                }
                ((e.exports = d).prototype = new h).constructor = d;
                var l = p.create()
                  , o = p.create();
                d.prototype.projectOntoLocalAxis = function(t, e) {
                    for (var i, s, n = null, r = null, o = (t = l,
                    0); o < this.vertices.length; o++)
                        i = this.vertices[o],
                        s = p.dot(i, t),
                        (null === n || n < s) && (n = s),
                        (null === r || s < r) && (r = s);
                    if (n < r) {
                        var a = r;
                        r = n,
                        n = a
                    }
                    p.set(e, r, n)
                }
                ,
                d.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                    var n = o;
                    this.projectOntoLocalAxis(t, s),
                    0 !== i ? p.rotate(n, t, i) : n = t;
                    var r = p.dot(e, n);
                    p.set(s, s[0] + r, s[1] + r)
                }
                ,
                d.prototype.updateTriangles = function() {
                    for (var t = [], e = this.triangles.length = 0; e < this.vertices.length; e++) {
                        var i = this.vertices[e];
                        t.push(i[0], i[1])
                    }
                    var s = a.Triangulate(t);
                    for (e = 0; e < s.length; e += 3) {
                        var n = s[e]
                          , r = s[e + 1]
                          , o = s[e + 2];
                        this.triangles.push([n, r, o])
                    }
                }
                ;
                var f = p.create()
                  , g = p.create()
                  , m = p.create()
                  , y = p.create()
                  , v = p.create();
                p.create(),
                p.create(),
                p.create(),
                p.create();
                d.prototype.updateCenterOfMass = function() {
                    var t = this.triangles
                      , e = this.vertices
                      , i = this.centerOfMass
                      , s = f
                      , n = m
                      , r = y
                      , o = v
                      , a = g;
                    p.set(i, 0, 0);
                    for (var h = 0, l = 0; l !== t.length; l++) {
                        var c = t[l];
                        n = e[c[0]],
                        r = e[c[1]],
                        o = e[c[2]];
                        p.centroid(s, n, r, o);
                        var u = d.triangleArea(n, r, o);
                        h += u,
                        p.scale(a, s, u),
                        p.add(i, i, a)
                    }
                    p.scale(i, i, 1 / h)
                }
                ,
                d.prototype.computeMomentOfInertia = function(t) {
                    for (var e = 0, i = 0, s = this.vertices.length, n = s - 1, r = 0; r < s; n = r,
                    r++) {
                        var o = this.vertices[n]
                          , a = this.vertices[r]
                          , h = Math.abs(p.crossLength(o, a));
                        e += h * (p.dot(a, a) + p.dot(a, o) + p.dot(o, o)),
                        i += h
                    }
                    return t / 6 * (e / i)
                }
                ,
                d.prototype.updateBoundingRadius = function() {
                    for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                        var s = p.squaredLength(t[i]);
                        e < s && (e = s)
                    }
                    this.boundingRadius = Math.sqrt(e)
                }
                ,
                d.triangleArea = function(t, e, i) {
                    return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
                }
                ,
                d.prototype.updateArea = function() {
                    this.updateTriangles(),
                    this.area = 0;
                    for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                        var s = t[i]
                          , n = e[s[0]]
                          , r = e[s[1]]
                          , o = e[s[2]]
                          , a = d.triangleArea(n, r, o);
                        this.area += a
                    }
                }
                ,
                d.prototype.computeAABB = function(t, e, i) {
                    t.setFromPoints(this.vertices, e, i, 0)
                }
                ;
                var x = p.create()
                  , b = p.create()
                  , _ = p.create();
                d.prototype.raycast = function(t, e, i, s) {
                    var n = x
                      , r = b
                      , o = _
                      , a = this.vertices;
                    p.toLocalFrame(n, e.from, i, s),
                    p.toLocalFrame(r, e.to, i, s);
                    for (var h = a.length, l = 0; l < h && !t.shouldStop(e); l++) {
                        var c = a[l]
                          , u = a[(l + 1) % h]
                          , d = p.getLineSegmentsIntersectionFraction(n, r, c, u);
                        0 <= d && (p.sub(o, u, c),
                        p.rotate(o, o, -Math.PI / 2 + s),
                        p.normalize(o, o),
                        e.reportIntersection(t, d, o, l))
                    }
                }
            }
            , {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 45,
                "poly-decomp": 5
            }],
            41: [function(t, e, i) {
                var s = t("./Shape")
                  , m = t("../math/vec2");
                t("../utils/Utils");
                function n(t) {
                    if (Array.isArray(t)) {
                        if (t = {
                            heights: t
                        },
                        "object" == typeof arguments[1])
                            for (var e in arguments[1])
                                t[e] = arguments[1][e];
                        console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                    }
                    t = t || {},
                    this.heights = t.heights ? t.heights.slice(0) : [],
                    this.maxValue = t.maxValue || null,
                    this.minValue = t.minValue || null,
                    this.elementWidth = t.elementWidth || .1,
                    void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(),
                    t.type = s.HEIGHTFIELD,
                    s.call(this, t)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.updateMaxMinValues = function() {
                    for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                        var n = t[s];
                        e < n && (e = n),
                        n < i && (i = n)
                    }
                    this.maxValue = e,
                    this.minValue = i
                }
                ,
                n.prototype.computeMomentOfInertia = function(t) {
                    return Number.MAX_VALUE
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }
                ,
                n.prototype.updateArea = function() {
                    for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++)
                        e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                    this.area = e
                }
                ;
                var r = [m.create(), m.create(), m.create(), m.create()];
                n.prototype.computeAABB = function(t, e, i) {
                    m.set(r[0], 0, this.maxValue),
                    m.set(r[1], this.elementWidth * this.heights.length, this.maxValue),
                    m.set(r[2], this.elementWidth * this.heights.length, this.minValue),
                    m.set(r[3], 0, this.minValue),
                    t.setFromPoints(r, e, i)
                }
                ,
                n.prototype.getLineSegment = function(t, e, i) {
                    var s = this.heights
                      , n = this.elementWidth;
                    m.set(t, i * n, s[i]),
                    m.set(e, (i + 1) * n, s[i + 1])
                }
                ,
                n.prototype.getSegmentIndex = function(t) {
                    return Math.floor(t[0] / this.elementWidth)
                }
                ,
                n.prototype.getClampedSegmentIndex = function(t) {
                    var e = this.getSegmentIndex(t);
                    return e = Math.min(this.heights.length, Math.max(e, 0))
                }
                ;
                m.create();
                var y = m.create()
                  , v = m.create()
                  , x = m.create()
                  , b = m.create()
                  , _ = m.create();
                m.fromValues(0, 1);
                n.prototype.raycast = function(t, e, i, s) {
                    var n = e.from
                      , r = e.to
                      , o = (e.direction,
                    y)
                      , a = v
                      , h = x
                      , l = b
                      , c = _;
                    m.toLocalFrame(l, n, i, s),
                    m.toLocalFrame(c, r, i, s);
                    var u = this.getClampedSegmentIndex(l)
                      , d = this.getClampedSegmentIndex(c);
                    if (d < u) {
                        var p = u;
                        u = d,
                        d = p
                    }
                    for (var f = 0; f < this.heights.length - 1; f++) {
                        this.getLineSegment(a, h, f);
                        var g = m.getLineSegmentsIntersectionFraction(l, c, a, h);
                        if (0 <= g && (m.sub(o, h, a),
                        m.rotate(o, o, s + Math.PI / 2),
                        m.normalize(o, o),
                        e.reportIntersection(t, g, o, -1),
                        t.shouldStop(e)))
                            return
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            42: [function(t, e, i) {
                var s = t("./Shape")
                  , u = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && (t = {
                        length: t
                    },
                    console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")),
                    t = t || {},
                    this.length = t.length || 1,
                    t.type = s.LINE,
                    s.call(this, t)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    return t * Math.pow(this.length, 2) / 12
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2
                }
                ;
                var r = [u.create(), u.create()];
                n.prototype.computeAABB = function(t, e, i) {
                    var s = this.length / 2;
                    u.set(r[0], -s, 0),
                    u.set(r[1], s, 0),
                    t.setFromPoints(r, e, i, 0)
                }
                ;
                u.create();
                var d = u.create()
                  , p = u.create()
                  , f = u.create()
                  , g = u.fromValues(0, 1);
                n.prototype.raycast = function(t, e, i, s) {
                    var n = e.from
                      , r = e.to
                      , o = p
                      , a = f
                      , h = this.length / 2;
                    u.set(o, -h, 0),
                    u.set(a, h, 0),
                    u.toGlobalFrame(o, o, i, s),
                    u.toGlobalFrame(a, a, i, s);
                    var l = u.getLineSegmentsIntersectionFraction(o, a, n, r);
                    if (0 <= l) {
                        var c = d;
                        u.rotate(c, g, s),
                        e.reportIntersection(t, l, c, -1)
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            43: [function(t, e, i) {
                var s = t("./Shape")
                  , n = t("../math/vec2");
                function r(t) {
                    (t = t || {}).type = s.PARTICLE,
                    s.call(this, t)
                }
                (((e.exports = r).prototype = new s).constructor = r).prototype.computeMomentOfInertia = function(t) {
                    return 0
                }
                ,
                r.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0
                }
                ,
                r.prototype.computeAABB = function(t, e, i) {
                    n.copy(t.lowerBound, e),
                    n.copy(t.upperBound, e)
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            44: [function(t, e, i) {
                var s = t("./Shape")
                  , p = t("../math/vec2");
                t("../utils/Utils");
                function n(t) {
                    (t = t || {}).type = s.PLANE,
                    s.call(this, t)
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    return 0
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }
                ,
                n.prototype.computeAABB = function(t, e, i) {
                    var s = i % (2 * Math.PI)
                      , n = p.set
                      , r = t.lowerBound
                      , o = t.upperBound;
                    n(r, -1e7, -1e7),
                    n(o, 1e7, 1e7),
                    0 == s ? o[1] = 0 : s == Math.PI / 2 ? r[0] = 0 : s === Math.PI ? r[1] = 0 : s == 3 * Math.PI / 2 && (o[0] = 0)
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE
                }
                ;
                var f = p.create()
                  , g = (p.create(),
                p.create(),
                p.create())
                  , m = p.create();
                n.prototype.raycast = function(t, e, i, s) {
                    var n = e.from
                      , r = e.to
                      , o = e.direction
                      , a = f
                      , h = g
                      , l = m;
                    p.set(h, 0, 1),
                    p.rotate(h, h, s),
                    p.sub(l, n, i);
                    var c = p.dot(l, h);
                    if (p.sub(l, r, i),
                    !(0 < c * p.dot(l, h) || p.squaredDistance(n, r) < c * c)) {
                        var u = p.dot(h, o);
                        p.sub(a, n, i);
                        var d = -p.dot(h, a) / u / e.length;
                        e.reportIntersection(t, d, h, -1)
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            45: [function(t, e, i) {
                e.exports = n;
                var s = t("../math/vec2");
                function n(t) {
                    t = t || {},
                    this.body = null,
                    this.position = s.fromValues(0, 0),
                    t.position && s.copy(this.position, t.position),
                    this.angle = t.angle || 0,
                    this.type = t.type || 0,
                    this.id = n.idCounter++,
                    this.boundingRadius = 0,
                    this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1,
                    this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                    this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1,
                    this.material = t.material || null,
                    this.area = 0,
                    this.sensor = void 0 !== t.sensor && t.sensor,
                    this.type && this.updateBoundingRadius(),
                    this.updateArea()
                }
                n.idCounter = 0,
                n.CIRCLE = 1,
                n.PARTICLE = 2,
                n.PLANE = 4,
                n.CONVEX = 8,
                n.LINE = 16,
                n.BOX = 32,
                Object.defineProperty(n, "RECTANGLE", {
                    get: function() {
                        return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."),
                        n.BOX
                    }
                }),
                n.CAPSULE = 64,
                n.HEIGHTFIELD = 128,
                n.prototype.computeMomentOfInertia = function(t) {}
                ,
                n.prototype.updateBoundingRadius = function() {}
                ,
                n.prototype.updateArea = function() {}
                ,
                n.prototype.computeAABB = function(t, e, i) {}
                ,
                n.prototype.raycast = function(t, e, i, s) {}
            }
            , {
                "../math/vec2": 30
            }],
            46: [function(t, e, i) {
                var w = t("../math/vec2")
                  , s = t("./Solver")
                  , T = t("../utils/Utils")
                  , P = t("../equations/FrictionEquation");
                function C(t) {
                    s.call(this, t, s.GS),
                    t = t || {},
                    this.iterations = t.iterations || 10,
                    this.tolerance = t.tolerance || 1e-7,
                    this.arrayStep = 30,
                    this.lambda = new T.ARRAY_TYPE(this.arrayStep),
                    this.Bs = new T.ARRAY_TYPE(this.arrayStep),
                    this.invCs = new T.ARRAY_TYPE(this.arrayStep),
                    this.useZeroRHS = !1,
                    this.frictionIterations = void 0 !== t.frictionIterations ? 0 : t.frictionIterations,
                    this.usedIterations = 0
                }
                (((e.exports = C).prototype = new s).constructor = C).prototype.solve = function(t, e) {
                    this.sortEquations();
                    var i = 0
                      , s = this.iterations
                      , n = this.frictionIterations
                      , r = this.equations
                      , o = r.length
                      , a = Math.pow(this.tolerance * o, 2)
                      , h = e.bodies
                      , l = e.bodies.length
                      , c = (w.add,
                    w.set,
                    this.useZeroRHS)
                      , u = this.lambda;
                    if (this.usedIterations = 0,
                    o)
                        for (var d = 0; d !== l; d++) {
                            h[d].updateSolveMassProperties()
                        }
                    u.length < o && (u = this.lambda = new T.ARRAY_TYPE(o + this.arrayStep),
                    this.Bs = new T.ARRAY_TYPE(o + this.arrayStep),
                    this.invCs = new T.ARRAY_TYPE(o + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--; )
                            t[e] = 0
                    }(u);
                    var p, f, g = this.invCs, m = this.Bs;
                    for (u = this.lambda,
                    d = 0; d !== r.length; d++) {
                        var y;
                        (y = r[d]).timeStep === t && !y.needsUpdate || (y.timeStep = t,
                        y.update()),
                        m[d] = y.computeB(y.a, y.b, t),
                        g[d] = y.computeInvC(y.epsilon)
                    }
                    if (0 !== o) {
                        for (d = 0; d !== l; d++) {
                            h[d].resetConstraintVelocity()
                        }
                        if (n) {
                            for (i = 0; i !== n; i++) {
                                for (f = p = 0; f !== o; f++) {
                                    y = r[f];
                                    var v = C.iterateEquation(f, y, y.epsilon, m, g, u, c, t, i);
                                    p += Math.abs(v)
                                }
                                if (this.usedIterations++,
                                p * p <= a)
                                    break
                            }
                            for (C.updateMultipliers(r, u, 1 / t),
                            f = 0; f !== o; f++) {
                                var x = r[f];
                                if (x instanceof P) {
                                    for (var b = 0, _ = 0; _ !== x.contactEquations.length; _++)
                                        b += x.contactEquations[_].multiplier;
                                    b *= x.frictionCoefficient / x.contactEquations.length,
                                    x.maxForce = b,
                                    x.minForce = -b
                                }
                            }
                        }
                        for (i = 0; i !== s; i++) {
                            for (f = p = 0; f !== o; f++) {
                                y = r[f];
                                v = C.iterateEquation(f, y, y.epsilon, m, g, u, c, t, i);
                                p += Math.abs(v)
                            }
                            if (this.usedIterations++,
                            p * p <= a)
                                break
                        }
                        for (d = 0; d !== l; d++)
                            h[d].addConstraintVelocity();
                        C.updateMultipliers(r, u, 1 / t)
                    }
                }
                ,
                C.updateMultipliers = function(t, e, i) {
                    for (var s = t.length; s--; )
                        t[s].multiplier = e[s] * i
                }
                ,
                C.iterateEquation = function(t, e, i, s, n, r, o, a, h) {
                    var l = s[t]
                      , c = n[t]
                      , u = r[t]
                      , d = e.computeGWlambda()
                      , p = e.maxForce
                      , f = e.minForce;
                    o && (l = 0);
                    var g = c * (l - d - i * u)
                      , m = u + g;
                    return m < f * a ? g = f * a - u : p * a < m && (g = p * a - u),
                    r[t] += g,
                    e.addToWlambda(g),
                    g
                }
            }
            , {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Solver": 47
            }],
            47: [function(t, e, i) {
                t("../utils/Utils");
                var s = t("../events/EventEmitter");
                function n(t, e) {
                    t = t || {},
                    s.call(this),
                    this.type = e,
                    this.equations = [],
                    this.equationSortFunction = t.equationSortFunction || !1
                }
                (((e.exports = n).prototype = new s).constructor = n).prototype.solve = function(t, e) {
                    throw new Error("Solver.solve should be implemented by subclasses!")
                }
                ;
                var r = {
                    bodies: []
                };
                n.prototype.solveIsland = function(t, e) {
                    this.removeAllEquations(),
                    e.equations.length && (this.addEquations(e.equations),
                    r.bodies.length = 0,
                    e.getBodies(r.bodies),
                    r.bodies.length && this.solve(t, r))
                }
                ,
                n.prototype.sortEquations = function() {
                    this.equationSortFunction && this.equations.sort(this.equationSortFunction)
                }
                ,
                n.prototype.addEquation = function(t) {
                    t.enabled && this.equations.push(t)
                }
                ,
                n.prototype.addEquations = function(t) {
                    for (var e = 0, i = t.length; e !== i; e++) {
                        var s = t[e];
                        s.enabled && this.equations.push(s)
                    }
                }
                ,
                n.prototype.removeEquation = function(t) {
                    var e = this.equations.indexOf(t);
                    -1 !== e && this.equations.splice(e, 1)
                }
                ,
                n.prototype.removeAllEquations = function() {
                    this.equations.length = 0
                }
                ,
                n.GS = 1,
                n.ISLAND = 2
            }
            , {
                "../events/EventEmitter": 26,
                "../utils/Utils": 57
            }],
            48: [function(t, e, i) {
                var s = t("../equations/ContactEquation")
                  , n = t("./Pool");
                function r() {
                    n.apply(this, arguments)
                }
                (((e.exports = r).prototype = new n).constructor = r).prototype.create = function() {
                    return new s
                }
                ,
                r.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null,
                    this
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "./Pool": 55
            }],
            49: [function(t, e, i) {
                var s = t("../equations/FrictionEquation")
                  , n = t("./Pool");
                function r() {
                    n.apply(this, arguments)
                }
                (((e.exports = r).prototype = new n).constructor = r).prototype.create = function() {
                    return new s
                }
                ,
                r.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null,
                    this
                }
            }
            , {
                "../equations/FrictionEquation": 23,
                "./Pool": 55
            }],
            50: [function(t, e, i) {
                var s = t("../world/IslandNode")
                  , n = t("./Pool");
                function r() {
                    n.apply(this, arguments)
                }
                (((e.exports = r).prototype = new n).constructor = r).prototype.create = function() {
                    return new s
                }
                ,
                r.prototype.destroy = function(t) {
                    return t.reset(),
                    this
                }
            }
            , {
                "../world/IslandNode": 60,
                "./Pool": 55
            }],
            51: [function(t, e, i) {
                var s = t("../world/Island")
                  , n = t("./Pool");
                function r() {
                    n.apply(this, arguments)
                }
                (((e.exports = r).prototype = new n).constructor = r).prototype.create = function() {
                    return new s
                }
                ,
                r.prototype.destroy = function(t) {
                    return t.reset(),
                    this
                }
            }
            , {
                "../world/Island": 58,
                "./Pool": 55
            }],
            52: [function(t, e, i) {
                var s = t("./TupleDictionary")
                  , n = (t("./OverlapKeeperRecord"),
                t("./OverlapKeeperRecordPool"));
                t("./Utils");
                function r() {
                    this.overlappingShapesLastState = new s,
                    this.overlappingShapesCurrentState = new s,
                    this.recordPool = new n({
                        size: 16
                    }),
                    this.tmpDict = new s,
                    this.tmpArray1 = []
                }
                (e.exports = r).prototype.tick = function() {
                    for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--; ) {
                        var s = t.keys[i]
                          , n = t.getByKey(s);
                        e.getByKey(s);
                        n && this.recordPool.release(n)
                    }
                    t.reset(),
                    t.copy(e),
                    e.reset()
                }
                ,
                r.prototype.setOverlapping = function(t, e, i, s) {
                    this.overlappingShapesLastState;
                    var n = this.overlappingShapesCurrentState;
                    if (!n.get(e.id, s.id)) {
                        var r = this.recordPool.get();
                        r.set(t, e, i, s),
                        n.set(e.id, s.id, r)
                    }
                }
                ,
                r.prototype.getNewOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
                }
                ,
                r.prototype.getEndOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
                }
                ,
                r.prototype.bodiesAreOverlapping = function(t, e) {
                    for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--; ) {
                        var n = i.keys[s]
                          , r = i.data[n];
                        if (r.bodyA === t && r.bodyB === e || r.bodyA === e && r.bodyB === t)
                            return !0
                    }
                    return !1
                }
                ,
                r.prototype.getDiff = function(t, e, i) {
                    var s = t
                      , n = e;
                    (i = i || []).length = 0;
                    for (var r = n.keys.length; r--; ) {
                        var o = n.keys[r]
                          , a = n.data[o];
                        if (!a)
                            throw new Error("Key " + o + " had no data!");
                        s.data[o] || i.push(a)
                    }
                    return i
                }
                ,
                r.prototype.isNewOverlap = function(t, e) {
                    var i = 0 | t.id
                      , s = 0 | e.id
                      , n = this.overlappingShapesLastState
                      , r = this.overlappingShapesCurrentState;
                    return !n.get(i, s) && !!r.get(i, s)
                }
                ,
                r.prototype.getNewBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }
                ,
                r.prototype.getEndBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }
                ,
                r.prototype.getBodyDiff = function(t, e) {
                    e = e || [];
                    for (var i = this.tmpDict, s = t.length; s--; ) {
                        var n = t[s];
                        i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                    }
                    for (s = i.keys.length; s--; ) {
                        (n = i.getByKey(i.keys[s])) && e.push(n.bodyA, n.bodyB)
                    }
                    return i.reset(),
                    e
                }
            }
            , {
                "./OverlapKeeperRecord": 53,
                "./OverlapKeeperRecordPool": 54,
                "./TupleDictionary": 56,
                "./Utils": 57
            }],
            53: [function(t, e, i) {
                function n(t, e, i, s) {
                    this.shapeA = e,
                    this.shapeB = s,
                    this.bodyA = t,
                    this.bodyB = i
                }
                (e.exports = n).prototype.set = function(t, e, i, s) {
                    n.call(this, t, e, i, s)
                }
            }
            , {}],
            54: [function(t, e, i) {
                var s = t("./OverlapKeeperRecord")
                  , n = t("./Pool");
                function r() {
                    n.apply(this, arguments)
                }
                (((e.exports = r).prototype = new n).constructor = r).prototype.create = function() {
                    return new s
                }
                ,
                r.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null,
                    this
                }
            }
            , {
                "./OverlapKeeperRecord": 53,
                "./Pool": 55
            }],
            55: [function(t, e, i) {
                function s(t) {
                    t = t || {},
                    this.objects = [],
                    void 0 !== t.size && this.resize(t.size)
                }
                (e.exports = s).prototype.resize = function(t) {
                    for (var e = this.objects; e.length > t; )
                        e.pop();
                    for (; e.length < t; )
                        e.push(this.create());
                    return this
                }
                ,
                s.prototype.get = function() {
                    var t = this.objects;
                    return t.length ? t.pop() : this.create()
                }
                ,
                s.prototype.release = function(t) {
                    return this.destroy(t),
                    this.objects.push(t),
                    this
                }
            }
            , {}],
            56: [function(t, e, i) {
                var s = t("./Utils");
                function n() {
                    this.data = {},
                    this.keys = []
                }
                (e.exports = n).prototype.getKey = function(t, e) {
                    return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | e) < (0 | t) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
                }
                ,
                n.prototype.getByKey = function(t) {
                    return t |= 0,
                    this.data[t]
                }
                ,
                n.prototype.get = function(t, e) {
                    return this.data[this.getKey(t, e)]
                }
                ,
                n.prototype.set = function(t, e, i) {
                    if (!i)
                        throw new Error("No data!");
                    var s = this.getKey(t, e);
                    return this.data[s] || this.keys.push(s),
                    this.data[s] = i,
                    s
                }
                ,
                n.prototype.reset = function() {
                    for (var t = this.data, e = this.keys, i = e.length; i--; )
                        delete t[e[i]];
                    e.length = 0
                }
                ,
                n.prototype.copy = function(t) {
                    this.reset(),
                    s.appendArray(this.keys, t.keys);
                    for (var e = t.keys.length; e--; ) {
                        var i = t.keys[e];
                        this.data[i] = t.data[i]
                    }
                }
            }
            , {
                "./Utils": 57
            }],
            57: [function(t, e, i) {
                function s() {}
                (e.exports = s).appendArray = function(t, e) {
                    if (e.length < 15e4)
                        t.push.apply(t, e);
                    else
                        for (var i = 0, s = e.length; i !== s; ++i)
                            t.push(e[i])
                }
                ,
                s.splice = function(t, e, i) {
                    i = i || 1;
                    for (var s = e, n = t.length - i; s < n; s++)
                        t[s] = t[s + i];
                    t.length = n
                }
                ,
                s.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array,
                s.extend = function(t, e) {
                    for (var i in e)
                        t[i] = e[i]
                }
                ,
                s.defaults = function(t, e) {
                    for (var i in t = t || {},
                    e)
                        i in t || (t[i] = e[i]);
                    return t
                }
            }
            , {}],
            58: [function(t, e, i) {
                var s = t("../objects/Body");
                function n() {
                    this.equations = [],
                    this.bodies = []
                }
                (e.exports = n).prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0
                }
                ;
                var r = [];
                n.prototype.getBodies = function(t) {
                    for (var e = t || [], i = this.equations, s = r.length = 0; s !== i.length; s++) {
                        var n = i[s];
                        -1 === r.indexOf(n.bodyA.id) && (e.push(n.bodyA),
                        r.push(n.bodyA.id)),
                        -1 === r.indexOf(n.bodyB.id) && (e.push(n.bodyB),
                        r.push(n.bodyB.id))
                    }
                    return e
                }
                ,
                n.prototype.wantsToSleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        var e = this.bodies[t];
                        if (e.type === s.DYNAMIC && !e.wantsToSleep)
                            return !1
                    }
                    return !0
                }
                ,
                n.prototype.sleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        this.bodies[t].sleep()
                    }
                    return !0
                }
            }
            , {
                "../objects/Body": 31
            }],
            59: [function(t, e, i) {
                t("../math/vec2"),
                t("./Island"),
                t("./IslandNode");
                var s = t("./../utils/IslandNodePool")
                  , n = t("./../utils/IslandPool")
                  , o = t("../objects/Body");
                function f(t) {
                    this.nodePool = new s({
                        size: 16
                    }),
                    this.islandPool = new n({
                        size: 8
                    }),
                    this.equations = [],
                    this.islands = [],
                    this.nodes = [],
                    this.queue = []
                }
                (e.exports = f).getUnvisitedNode = function(t) {
                    for (var e = t.length, i = 0; i !== e; i++) {
                        var s = t[i];
                        if (!s.visited && s.body.type === o.DYNAMIC)
                            return s
                    }
                    return !1
                }
                ,
                f.prototype.visit = function(t, e, i) {
                    e.push(t.body);
                    for (var s = t.equations.length, n = 0; n !== s; n++) {
                        var r = t.equations[n];
                        -1 === i.indexOf(r) && i.push(r)
                    }
                }
                ,
                f.prototype.bfs = function(t, e, i) {
                    var s = this.queue;
                    for (s.length = 0,
                    s.push(t),
                    t.visited = !0,
                    this.visit(t, e, i); s.length; )
                        for (var n, r = s.pop(); n = f.getUnvisitedNode(r.neighbors); )
                            n.visited = !0,
                            this.visit(n, e, i),
                            n.body.type === o.DYNAMIC && s.push(n)
                }
                ,
                f.prototype.split = function(t) {
                    for (var e = t.bodies, i = this.nodes, s = this.equations; i.length; )
                        this.nodePool.release(i.pop());
                    for (var n = 0; n !== e.length; n++) {
                        var r = this.nodePool.get();
                        r.body = e[n],
                        i.push(r)
                    }
                    for (var o = 0; o !== s.length; o++) {
                        var a = s[o]
                          , h = (n = e.indexOf(a.bodyA),
                        e.indexOf(a.bodyB))
                          , l = i[n]
                          , c = i[h];
                        l.neighbors.push(c),
                        c.neighbors.push(l),
                        l.equations.push(a),
                        c.equations.push(a)
                    }
                    var u, d = this.islands;
                    for (n = 0; n < d.length; n++)
                        this.islandPool.release(d[n]);
                    for (d.length = 0; u = f.getUnvisitedNode(i); ) {
                        var p = this.islandPool.get();
                        this.bfs(u, p.bodies, p.equations),
                        d.push(p)
                    }
                    return d
                }
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./../utils/IslandNodePool": 50,
                "./../utils/IslandPool": 51,
                "./Island": 58,
                "./IslandNode": 60
            }],
            60: [function(t, e, i) {
                function s(t) {
                    this.body = t,
                    this.neighbors = [],
                    this.equations = [],
                    this.visited = !1
                }
                (e.exports = s).prototype.reset = function() {
                    this.equations.length = 0,
                    this.neighbors.length = 0,
                    this.visited = !1,
                    this.body = null
                }
            }
            , {}],
            61: [function(t, e, i) {
                var s = t("../solver/GSSolver")
                  , q = (t("../solver/Solver"),
                t("../collision/Ray"),
                t("../math/vec2"))
                  , y = t("../shapes/Circle")
                  , v = t("../shapes/Convex")
                  , x = (t("../shapes/Line"),
                t("../shapes/Plane"))
                  , b = t("../shapes/Capsule")
                  , _ = t("../shapes/Particle")
                  , n = t("../events/EventEmitter")
                  , H = t("../objects/Body")
                  , r = (t("../shapes/Shape"),
                t("../objects/LinearSpring"),
                t("../material/Material"))
                  , o = t("../material/ContactMaterial")
                  , a = (t("../constraints/DistanceConstraint"),
                t("../constraints/Constraint"),
                t("../constraints/LockConstraint"),
                t("../constraints/RevoluteConstraint"),
                t("../constraints/PrismaticConstraint"),
                t("../constraints/GearConstraint"),
                t("../../package.json"),
                t("../collision/Broadphase"),
                t("../collision/AABB"))
                  , h = t("../collision/SAPBroadphase")
                  , l = t("../collision/Narrowphase")
                  , Y = t("../utils/Utils")
                  , c = t("../utils/OverlapKeeper")
                  , u = t("./IslandManager");
                t("../objects/RotationalSpring");
                function z(t) {
                    n.apply(this),
                    t = t || {},
                    this.springs = [],
                    this.bodies = [],
                    this.disabledBodyCollisionPairs = [],
                    this.solver = t.solver || new s,
                    this.narrowphase = new l(this),
                    this.islandManager = new u,
                    this.gravity = q.fromValues(0, -9.78),
                    t.gravity && q.copy(this.gravity, t.gravity),
                    this.frictionGravity = q.length(this.gravity) || 10,
                    this.useWorldGravityAsFrictionGravity = !0,
                    this.useFrictionGravityOnZeroGravity = !0,
                    this.broadphase = t.broadphase || new h,
                    this.broadphase.setWorld(this),
                    this.constraints = [],
                    this.defaultMaterial = new r,
                    this.defaultContactMaterial = new o(this.defaultMaterial,this.defaultMaterial),
                    this.lastTimeStep = 1 / 60,
                    this.applySpringForces = !0,
                    this.applyDamping = !0,
                    this.applyGravity = !0,
                    this.solveConstraints = !0,
                    this.contactMaterials = [],
                    this.time = 0,
                    this.accumulator = 0,
                    this.stepping = !1,
                    this.bodiesToBeRemoved = [],
                    this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit,
                    this.emitImpactEvent = !0,
                    this._constraintIdCounter = 0,
                    this._bodyIdCounter = 0,
                    this.postStepEvent = {
                        type: "postStep"
                    },
                    this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    },
                    this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    },
                    this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    },
                    this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    },
                    this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    },
                    this.sleepMode = z.NO_SLEEPING,
                    this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    },
                    this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    },
                    this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    },
                    this.overlappingShapesLastState = {
                        keys: []
                    },
                    this.overlappingShapesCurrentState = {
                        keys: []
                    },
                    this.overlapKeeper = new c
                }
                (((e.exports = z).prototype = new Object(n.prototype)).constructor = z).NO_SLEEPING = 1,
                z.BODY_SLEEPING = 2,
                z.ISLAND_SLEEPING = 4,
                z.prototype.addConstraint = function(t) {
                    this.constraints.push(t)
                }
                ,
                z.prototype.addContactMaterial = function(t) {
                    this.contactMaterials.push(t)
                }
                ,
                z.prototype.removeContactMaterial = function(t) {
                    var e = this.contactMaterials.indexOf(t);
                    -1 !== e && Y.splice(this.contactMaterials, e, 1)
                }
                ,
                z.prototype.getContactMaterial = function(t, e) {
                    for (var i = this.contactMaterials, s = 0, n = i.length; s !== n; s++) {
                        var r = i[s];
                        if (r.materialA.id === t.id && r.materialB.id === e.id || r.materialA.id === e.id && r.materialB.id === t.id)
                            return r
                    }
                    return !1
                }
                ,
                z.prototype.removeConstraint = function(t) {
                    var e = this.constraints.indexOf(t);
                    -1 !== e && Y.splice(this.constraints, e, 1)
                }
                ;
                q.create(),
                q.create(),
                q.create(),
                q.create(),
                q.create(),
                q.create();
                var K = q.create()
                  , P = q.fromValues(0, 0)
                  , C = q.fromValues(0, 0);
                q.fromValues(0, 0),
                q.fromValues(0, 0);
                z.prototype.step = function(t, e, i) {
                    if (i = i || 10,
                    0 === (e = e || 0))
                        this.internalStep(t),
                        this.time += t;
                    else {
                        this.accumulator += e;
                        for (var s = 0; this.accumulator >= t && s < i; )
                            this.internalStep(t),
                            this.time += t,
                            this.accumulator -= t,
                            s++;
                        for (var n = this.accumulator % t / t, r = 0; r !== this.bodies.length; r++) {
                            var o = this.bodies[r];
                            q.lerp(o.interpolatedPosition, o.previousPosition, o.position, n),
                            o.interpolatedAngle = o.previousAngle + n * (o.angle - o.previousAngle)
                        }
                    }
                }
                ;
                var J = [];
                z.prototype.internalStep = function(t) {
                    this.stepping = !0;
                    var e = this.springs.length
                      , i = this.springs
                      , s = this.bodies
                      , n = this.gravity
                      , r = this.solver
                      , o = this.bodies.length
                      , a = this.broadphase
                      , h = this.narrowphase
                      , l = this.constraints
                      , c = K
                      , u = (q.scale,
                    q.add)
                      , d = (q.rotate,
                    this.islandManager);
                    if (this.overlapKeeper.tick(),
                    this.lastTimeStep = t,
                    this.useWorldGravityAsFrictionGravity) {
                        var p = q.length(this.gravity);
                        0 === p && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = p)
                    }
                    if (this.applyGravity)
                        for (var f = 0; f !== o; f++) {
                            var g = (m = s[f]).force;
                            m.type === H.DYNAMIC && m.sleepState !== H.SLEEPING && (q.scale(c, n, m.mass * m.gravityScale),
                            u(g, g, c))
                        }
                    if (this.applySpringForces)
                        for (f = 0; f !== e; f++) {
                            i[f].applyForce()
                        }
                    if (this.applyDamping)
                        for (f = 0; f !== o; f++) {
                            var m;
                            (m = s[f]).type === H.DYNAMIC && m.applyDamping(t)
                        }
                    var y = a.getCollisionPairs(this)
                      , v = this.disabledBodyCollisionPairs;
                    for (f = v.length - 2; 0 <= f; f -= 2)
                        for (var x = y.length - 2; 0 <= x; x -= 2)
                            (v[f] === y[x] && v[f + 1] === y[x + 1] || v[f + 1] === y[x] && v[f] === y[x + 1]) && y.splice(x, 2);
                    var b = l.length;
                    for (f = 0; f !== b; f++) {
                        var _ = l[f];
                        if (!_.collideConnected)
                            for (x = y.length - 2; 0 <= x; x -= 2)
                                (_.bodyA === y[x] && _.bodyB === y[x + 1] || _.bodyB === y[x] && _.bodyA === y[x + 1]) && y.splice(x, 2)
                    }
                    this.postBroadphaseEvent.pairs = y,
                    this.emit(this.postBroadphaseEvent),
                    this.postBroadphaseEvent.pairs = null,
                    h.reset(this);
                    f = 0;
                    for (var w = y.length; f !== w; f += 2)
                        for (var T = y[f], P = y[f + 1], C = 0, S = T.shapes.length; C !== S; C++)
                            for (var A = T.shapes[C], E = A.position, M = A.angle, R = 0, L = P.shapes.length; R !== L; R++) {
                                var B = P.shapes[R]
                                  , I = B.position
                                  , O = B.angle
                                  , k = this.defaultContactMaterial;
                                if (A.material && B.material) {
                                    var F = this.getContactMaterial(A.material, B.material);
                                    F && (k = F)
                                }
                                this.runNarrowphase(h, T, A, E, M, P, B, I, O, k, this.frictionGravity)
                            }
                    for (f = 0; f !== o; f++) {
                        (N = s[f])._wakeUpAfterNarrowphase && (N.wakeUp(),
                        N._wakeUpAfterNarrowphase = !1)
                    }
                    if (this.has("endContact")) {
                        this.overlapKeeper.getEndOverlaps(J);
                        var D = this.endContactEvent;
                        for (R = J.length; R--; ) {
                            var U = J[R];
                            D.shapeA = U.shapeA,
                            D.shapeB = U.shapeB,
                            D.bodyA = U.bodyA,
                            D.bodyB = U.bodyB,
                            this.emit(D)
                        }
                        J.length = 0
                    }
                    var G = this.preSolveEvent;
                    G.contactEquations = h.contactEquations,
                    G.frictionEquations = h.frictionEquations,
                    this.emit(G),
                    G.contactEquations = G.frictionEquations = null;
                    b = l.length;
                    for (f = 0; f !== b; f++)
                        l[f].update();
                    if (h.contactEquations.length || h.frictionEquations.length || b)
                        if (this.islandSplit) {
                            for (d.equations.length = 0,
                            Y.appendArray(d.equations, h.contactEquations),
                            Y.appendArray(d.equations, h.frictionEquations),
                            f = 0; f !== b; f++)
                                Y.appendArray(d.equations, l[f].equations);
                            d.split(this);
                            for (f = 0; f !== d.islands.length; f++) {
                                (j = d.islands[f]).equations.length && r.solveIsland(t, j)
                            }
                        } else {
                            for (r.addEquations(h.contactEquations),
                            r.addEquations(h.frictionEquations),
                            f = 0; f !== b; f++)
                                r.addEquations(l[f].equations);
                            this.solveConstraints && r.solve(t, this),
                            r.removeAllEquations()
                        }
                    for (f = 0; f !== o; f++) {
                        var N;
                        (N = s[f]).integrate(t)
                    }
                    for (f = 0; f !== o; f++)
                        s[f].setZeroForce();
                    if (this.emitImpactEvent && this.has("impact")) {
                        var X = this.impactEvent;
                        for (f = 0; f !== h.contactEquations.length; f++) {
                            var W = h.contactEquations[f];
                            W.firstImpact && (X.bodyA = W.bodyA,
                            X.bodyB = W.bodyB,
                            X.shapeA = W.shapeA,
                            X.shapeB = W.shapeB,
                            X.contactEquation = W,
                            this.emit(X))
                        }
                    }
                    if (this.sleepMode === z.BODY_SLEEPING)
                        for (f = 0; f !== o; f++)
                            s[f].sleepTick(this.time, !1, t);
                    else if (this.sleepMode === z.ISLAND_SLEEPING && this.islandSplit) {
                        for (f = 0; f !== o; f++)
                            s[f].sleepTick(this.time, !0, t);
                        for (f = 0; f < this.islandManager.islands.length; f++) {
                            var j;
                            (j = this.islandManager.islands[f]).wantsToSleep() && j.sleep()
                        }
                    }
                    this.stepping = !1;
                    var V = this.bodiesToBeRemoved;
                    for (f = 0; f !== V.length; f++)
                        this.removeBody(V[f]);
                    V.length = 0,
                    this.emit(this.postStepEvent)
                }
                ,
                z.prototype.runNarrowphase = function(t, e, i, s, n, r, o, a, h, l, c) {
                    if (0 != (i.collisionGroup & o.collisionMask) && 0 != (o.collisionGroup & i.collisionMask)) {
                        q.rotate(P, s, e.angle),
                        q.rotate(C, a, r.angle),
                        q.add(P, P, e.position),
                        q.add(C, C, r.position);
                        var u, d = n + e.angle, p = h + r.angle;
                        t.enableFriction = 0 < l.friction,
                        t.frictionCoefficient = l.friction,
                        u = e.type === H.STATIC || e.type === H.KINEMATIC ? r.mass : r.type === H.STATIC || r.type === H.KINEMATIC ? e.mass : e.mass * r.mass / (e.mass + r.mass),
                        t.slipForce = l.friction * c * u,
                        t.restitution = l.restitution,
                        t.surfaceVelocity = l.surfaceVelocity,
                        t.frictionStiffness = l.frictionStiffness,
                        t.frictionRelaxation = l.frictionRelaxation,
                        t.stiffness = l.stiffness,
                        t.relaxation = l.relaxation,
                        t.contactSkinSize = l.contactSkinSize,
                        t.enabledEquations = e.collisionResponse && r.collisionResponse && i.collisionResponse && o.collisionResponse;
                        var f = t[i.type | o.type]
                          , g = 0;
                        if (f) {
                            var m = i.sensor || o.sensor
                              , y = t.frictionEquations.length;
                            g = i.type < o.type ? f.call(t, e, i, P, d, r, o, C, p, m) : f.call(t, r, o, C, p, e, i, P, d, m);
                            var v = t.frictionEquations.length - y;
                            if (g) {
                                if (e.allowSleep && e.type === H.DYNAMIC && e.sleepState === H.SLEEPING && r.sleepState === H.AWAKE && r.type !== H.STATIC) {
                                    var x = q.squaredLength(r.velocity) + Math.pow(r.angularVelocity, 2);
                                    2 * Math.pow(r.sleepSpeedLimit, 2) <= x && (e._wakeUpAfterNarrowphase = !0)
                                }
                                if (r.allowSleep && r.type === H.DYNAMIC && r.sleepState === H.SLEEPING && e.sleepState === H.AWAKE && e.type !== H.STATIC) {
                                    var b = q.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2);
                                    2 * Math.pow(e.sleepSpeedLimit, 2) <= b && (r._wakeUpAfterNarrowphase = !0)
                                }
                                if (this.overlapKeeper.setOverlapping(e, i, r, o),
                                this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, o)) {
                                    var _ = this.beginContactEvent;
                                    if (_.shapeA = i,
                                    _.shapeB = o,
                                    _.bodyA = e,
                                    _.bodyB = r,
                                    _.contactEquations.length = 0,
                                    "number" == typeof g)
                                        for (var w = t.contactEquations.length - g; w < t.contactEquations.length; w++)
                                            _.contactEquations.push(t.contactEquations[w]);
                                    this.emit(_)
                                }
                                if ("number" == typeof g && 1 < v)
                                    for (w = t.frictionEquations.length - v; w < t.frictionEquations.length; w++) {
                                        var T = t.frictionEquations[w];
                                        T.setSlipForce(T.getSlipForce() / v)
                                    }
                            }
                        }
                    }
                }
                ,
                z.prototype.addSpring = function(t) {
                    this.springs.push(t);
                    var e = this.addSpringEvent;
                    e.spring = t,
                    this.emit(e),
                    e.spring = null
                }
                ,
                z.prototype.removeSpring = function(t) {
                    var e = this.springs.indexOf(t);
                    -1 !== e && Y.splice(this.springs, e, 1)
                }
                ,
                z.prototype.addBody = function(t) {
                    if (-1 === this.bodies.indexOf(t)) {
                        this.bodies.push(t);
                        var e = (t.world = this).addBodyEvent;
                        e.body = t,
                        this.emit(e),
                        e.body = null
                    }
                }
                ,
                z.prototype.removeBody = function(t) {
                    if (this.stepping)
                        this.bodiesToBeRemoved.push(t);
                    else {
                        t.world = null;
                        var e = this.bodies.indexOf(t);
                        -1 !== e && (Y.splice(this.bodies, e, 1),
                        (this.removeBodyEvent.body = t).resetConstraintVelocity(),
                        this.emit(this.removeBodyEvent),
                        this.removeBodyEvent.body = null)
                    }
                }
                ,
                z.prototype.getBodyById = function(t) {
                    for (var e = this.bodies, i = 0; i < e.length; i++) {
                        var s = e[i];
                        if (s.id === t)
                            return s
                    }
                    return !1
                }
                ,
                z.prototype.disableBodyCollision = function(t, e) {
                    this.disabledBodyCollisionPairs.push(t, e)
                }
                ,
                z.prototype.enableBodyCollision = function(t, e) {
                    for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                        if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e)
                            return void i.splice(s, 2)
                }
                ,
                z.prototype.clear = function() {
                    this.time = 0,
                    this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                    for (var t = this.constraints, e = t.length - 1; 0 <= e; e--)
                        this.removeConstraint(t[e]);
                    var i = this.bodies;
                    for (e = i.length - 1; 0 <= e; e--)
                        this.removeBody(i[e]);
                    var s = this.springs;
                    for (e = s.length - 1; 0 <= e; e--)
                        this.removeSpring(s[e]);
                    var n = this.contactMaterials;
                    for (e = n.length - 1; 0 <= e; e--)
                        this.removeContactMaterial(n[e]);
                    z.apply(this)
                }
                ;
                var w = q.create()
                  , T = (q.fromValues(0, 0),
                q.fromValues(0, 0));
                z.prototype.hitTest = function(t, e, i) {
                    i = i || 0;
                    var s = new H({
                        position: t
                    })
                      , n = new _
                      , r = t
                      , o = w
                      , a = T;
                    s.addShape(n);
                    for (var h = this.narrowphase, l = [], c = 0, u = e.length; c !== u; c++)
                        for (var d = e[c], p = 0, f = d.shapes.length; p !== f; p++) {
                            var g = d.shapes[p];
                            q.rotate(o, g.position, d.angle),
                            q.add(o, o, d.position);
                            var m = g.angle + d.angle;
                            (g instanceof y && h.circleParticle(d, g, o, m, s, n, r, 0, !0) || g instanceof v && h.particleConvex(s, n, r, 0, d, g, o, m, !0) || g instanceof x && h.particlePlane(s, n, r, 0, d, g, o, m, !0) || g instanceof b && h.particleCapsule(s, n, r, 0, d, g, o, m, !0) || g instanceof _ && q.squaredLength(q.sub(a, o, t)) < i * i) && l.push(d)
                        }
                    return l
                }
                ,
                z.prototype.setGlobalStiffness = function(t) {
                    for (var e = this.constraints, i = 0; i !== e.length; i++)
                        for (var s = e[i], n = 0; n !== s.equations.length; n++) {
                            var r = s.equations[n];
                            r.stiffness = t,
                            r.needsUpdate = !0
                        }
                    var o = this.contactMaterials;
                    for (i = 0; i !== o.length; i++) {
                        (s = o[i]).stiffness = s.frictionStiffness = t
                    }
                    (s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
                }
                ,
                z.prototype.setGlobalRelaxation = function(t) {
                    for (var e = 0; e !== this.constraints.length; e++)
                        for (var i = this.constraints[e], s = 0; s !== i.equations.length; s++) {
                            var n = i.equations[s];
                            n.relaxation = t,
                            n.needsUpdate = !0
                        }
                    for (e = 0; e !== this.contactMaterials.length; e++) {
                        (i = this.contactMaterials[e]).relaxation = i.frictionRelaxation = t
                    }
                    (i = this.defaultContactMaterial).relaxation = i.frictionRelaxation = t
                }
                ;
                var d = new a
                  , p = [];
                z.prototype.raycast = function(t, e) {
                    return e.getAABB(d),
                    this.broadphase.aabbQuery(this, d, p),
                    e.intersectBodies(t, p),
                    p.length = 0,
                    t.hasHit()
                }
            }
            , {
                "../../package.json": 6,
                "../collision/AABB": 7,
                "../collision/Broadphase": 8,
                "../collision/Narrowphase": 10,
                "../collision/Ray": 11,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/LinearSpring": 32,
                "../objects/RotationalSpring": 33,
                "../shapes/Capsule": 38,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Line": 42,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45,
                "../solver/GSSolver": 46,
                "../solver/Solver": 47,
                "../utils/OverlapKeeper": 52,
                "../utils/Utils": 57,
                "./IslandManager": 59
            }]
        }, {}, [36])(36)
    }),
    function() {
        var t = this
          , O = O || {};
        O.DisplayObject = function() {
            this.position = new O.Point(0,0),
            this.scale = new O.Point(1,1),
            this.pivot = new O.Point(0,0),
            this.rotation = 0,
            this.alpha = 1,
            this.visible = !0,
            this.hitArea = null,
            this.renderable = !1,
            this.parent = null,
            this.worldAlpha = 1,
            this.worldTransform = new O.Matrix,
            this.worldPosition = new O.Point(0,0),
            this.worldScale = new O.Point(1,1),
            this.worldRotation = 0,
            this.filterArea = null,
            this._sr = 0,
            this._cr = 1,
            this._bounds = new O.Rectangle(0,0,0,0),
            this._currentBounds = null,
            this._mask = null,
            this._cacheAsBitmap = !1,
            this._cacheIsDirty = !1
        }
        ,
        O.DisplayObject.prototype.constructor = O.DisplayObject,
        O.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--; )
                        this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null,
                this.parent = null,
                this.worldTransform = null,
                this.filterArea = null,
                this.renderable = !1,
                this._bounds = null,
                this._currentBounds = null,
                this._mask = null,
                this._destroyCachedSprite()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game)
                    return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i, s, n, r, o, a, h = e.worldTransform, l = this.worldTransform;
                this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation,
                this._sr = Math.sin(this.rotation),
                this._cr = Math.cos(this.rotation)),
                i = this._cr * this.scale.x,
                s = this._sr * this.scale.x,
                n = -this._sr * this.scale.y,
                r = this._cr * this.scale.y,
                o = this.position.x,
                a = this.position.y,
                (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n,
                a -= this.pivot.x * s + this.pivot.y * r),
                l.a = i * h.a + s * h.c,
                l.b = i * h.b + s * h.d,
                l.c = n * h.a + r * h.c,
                l.d = n * h.b + r * h.d) : (i = this.scale.x,
                r = this.scale.y,
                o = this.position.x - this.pivot.x * i,
                a = this.position.y - this.pivot.y * r,
                l.a = i * h.a,
                l.b = i * h.b,
                l.c = r * h.c,
                l.d = r * h.d),
                l.tx = o * h.a + a * h.c + h.tx,
                l.ty = o * h.b + a * h.d + h.ty;
                var c = i * r - s * n
                  , u = .5 * Math.PI;
                if (i || s) {
                    var d = Math.sqrt(i * i + s * s);
                    this.worldRotation = 0 < s ? Math.acos(i / d) : -Math.acos(i / d),
                    this.worldScale.x = d,
                    this.worldScale.y = c / d
                } else if (n || r) {
                    var p = Math.sqrt(n * n + r * r);
                    this.worldRotation = u - (0 < r ? Math.acos(-n / p) : -Math.acos(n / p)),
                    this.worldScale.x = c / p,
                    this.worldScale.y = p
                } else
                    this.worldScale.x = 0,
                    this.worldScale.y = 0;
                return this.worldAlpha = this.alpha * e.worldAlpha,
                this.worldPosition.x = l.tx,
                this.worldPosition.y = l.ty,
                this._currentBounds = null,
                this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h),
                this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, i) {
                var s = this.getLocalBounds()
                  , n = new Phaser.RenderTexture(this.game,0 | s.width,0 | s.height,i,e,t);
                return O.DisplayObject._tempMatrix.tx = -s.x,
                O.DisplayObject._tempMatrix.ty = -s.y,
                n.render(this, O.DisplayObject._tempMatrix),
                n
            },
            updateCache: function() {
                return this._generateCachedSprite(),
                this
            },
            toGlobal: function(t) {
                return this.updateTransform(),
                this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)),
                this.updateTransform(),
                this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha,
                t.gl ? O.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : O.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)),
                t.height = Math.max(1, Math.ceil(t.height)),
                this.updateTransform(),
                this._cachedSprite)
                    this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var e = 0;
                    this.texture && this.texture.baseTexture && O._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                    var i = new Phaser.RenderTexture(this.game,t.width,t.height,void 0,void 0,void 0,void 0,e);
                    this._cachedSprite = new O.Sprite(i),
                    this._cachedSprite.worldTransform = this.worldTransform
                }
                var s = this._filters;
                this._filters = null,
                this._cachedSprite.filters = s,
                O.DisplayObject._tempMatrix.tx = -t.x,
                O.DisplayObject._tempMatrix.ty = -t.y,
                this._cachedSprite.texture.render(this, O.DisplayObject._tempMatrix, !0),
                this._cachedSprite.anchor.x = -t.x / t.width,
                this._cachedSprite.anchor.y = -t.y / t.height,
                this._filters = s,
                this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0),
                this._cachedSprite = null)
            }
        },
        O.DisplayObject.prototype.displayObjectUpdateTransform = O.DisplayObject.prototype.updateTransform,
        Object.defineProperties(O.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t)
                            return this.visible;
                        do {
                            if (!t.visible)
                                return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1),
                    (this._mask = t) && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)
                            for (var s = t[i].passes, n = 0; n < s.length; n++)
                                e.push(s[n]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t,
                    this.blendMode && this.blendMode === O.blendModes.MULTIPLY && (this.blendMode = O.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(),
                    this._cacheAsBitmap = t)
                }
            }
        }),
        O.DisplayObjectContainer = function() {
            O.DisplayObject.call(this),
            this.children = [],
            this.ignoreChildInput = !1
        }
        ,
        O.DisplayObjectContainer.prototype = Object.create(O.DisplayObject.prototype),
        O.DisplayObjectContainer.prototype.constructor = O.DisplayObjectContainer,
        O.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }
        ,
        O.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (0 <= e && e <= this.children.length)
                return t.parent && t.parent.removeChild(t),
                (t.parent = this).children.splice(e, 0, t),
                t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }
        ,
        O.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t)
                  , s = this.getChildIndex(e);
                if (i < 0 || s < 0)
                    throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e,
                this.children[s] = t
            }
        }
        ,
        O.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e)
                throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }
        ,
        O.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length)
                throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1),
            this.children.splice(e, 0, t)
        }
        ,
        O.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length)
                throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }
        ,
        O.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e)
                return this.removeChildAt(e)
        }
        ,
        O.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0,
            this.children.splice(t, 1)),
            e
        }
        ,
        O.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0),
            void 0 === e && (e = this.children.length);
            var i = e - t;
            if (0 < i && i <= e) {
                for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) {
                    s[n].parent = void 0
                }
                return s
            }
            if (0 == i && 0 === this.children.length)
                return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }
        ,
        O.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(),
            !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++)
                    this.children[t].updateTransform()
        }
        ,
        O.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = O.DisplayObjectContainer.prototype.updateTransform,
        O.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e, i = t && t instanceof O.DisplayObject, s = !0;
            if (i ? s = t instanceof O.DisplayObjectContainer && t.contains(this) : t = this,
            i) {
                var n = t.worldTransform;
                for (t.worldTransform = O.identityMatrix,
                e = 0; e < t.children.length; e++)
                    t.children[e].updateTransform()
            }
            var r, o, a, h = 1 / 0, l = 1 / 0, c = -1 / 0, u = -1 / 0, d = !1;
            for (e = 0; e < this.children.length; e++) {
                this.children[e].visible && (d = !0,
                h = h < (r = this.children[e].getBounds()).x ? h : r.x,
                l = l < r.y ? l : r.y,
                c = (o = r.width + r.x) < c ? c : o,
                u = (a = r.height + r.y) < u ? u : a)
            }
            var p = this._bounds;
            if (!d) {
                var f = (p = new O.Rectangle).x
                  , g = p.width + p.x
                  , m = p.y
                  , y = p.height + p.y
                  , v = this.worldTransform
                  , x = v.a
                  , b = v.b
                  , _ = v.c
                  , w = v.d
                  , T = v.tx
                  , P = v.ty
                  , C = x * g + _ * y + T
                  , S = w * y + b * g + P
                  , A = x * f + _ * y + T
                  , E = w * y + b * f + P
                  , M = x * f + _ * m + T
                  , R = w * m + b * f + P
                  , L = x * g + _ * m + T
                  , B = w * m + b * g + P;
                h = L < (h = M < (h = A < (h = c = C) ? A : h) ? M : h) ? L : h,
                l = B < (l = R < (l = E < (l = u = S) ? E : l) ? R : l) ? B : l,
                c = (c = (c = c < A ? A : c) < M ? M : c) < L ? L : c,
                u = (u = (u = u < E ? E : u) < R ? R : u) < B ? B : u
            }
            if (p.x = h,
            p.y = l,
            p.width = c - h,
            p.height = u - l,
            i)
                for (t.worldTransform = n,
                e = 0; e < t.children.length; e++)
                    t.children[e].updateTransform();
            if (!s) {
                var I = t.getBounds();
                p.x -= I.x,
                p.y -= I.y
            }
            return p
        }
        ,
        O.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }
        ,
        O.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }
        ,
        O.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            var e;
            if (this.visible && !(this.alpha <= 0))
                if (this._cacheAsBitmap)
                    this._renderCachedSprite(t);
                else if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(),
                    t.filterManager.pushFilter(this._filterBlock)),
                    this._mask && (t.spriteBatch.stop(),
                    t.maskManager.pushMask(this.mask, t),
                    t.spriteBatch.start()),
                    e = 0; e < this.children.length; e++)
                        this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(),
                    this._mask && t.maskManager.popMask(this._mask, t),
                    this._filters && t.filterManager.popFilter(),
                    t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++)
                        this.children[e]._renderWebGL(t)
        }
        ,
        O.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha)
                if (this._cacheAsBitmap)
                    this._renderCachedSprite(t);
                else {
                    this._mask && t.maskManager.pushMask(this._mask, t);
                    for (var e = 0; e < this.children.length; e++)
                        this.children[e]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
        }
        ,
        Object.defineProperty(O.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1,
                this._width = t
            }
        }),
        Object.defineProperty(O.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1,
                this._height = t
            }
        }),
        O.Sprite = function(t) {
            O.DisplayObjectContainer.call(this),
            this.anchor = new O.Point,
            this.texture = t || O.Texture.emptyTexture,
            this._width = 0,
            this._height = 0,
            this.tint = 16777215,
            this.cachedTint = -1,
            this.tintedTexture = null,
            this.blendMode = O.blendModes.NORMAL,
            this.shader = null,
            this.exists = !0,
            this.texture.baseTexture.hasLoaded && this.onTextureUpdate(),
            this.renderable = !0
        }
        ,
        O.Sprite.prototype = Object.create(O.DisplayObjectContainer.prototype),
        O.Sprite.prototype.constructor = O.Sprite,
        Object.defineProperty(O.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width,
                this._width = t
            }
        }),
        Object.defineProperty(O.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height,
                this._height = t
            }
        }),
        O.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(),
            this.texture.baseTexture.skipRender = !1,
            this.texture = t,
            this.texture.valid = !0,
            this.cachedTint = -1
        }
        ,
        O.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width),
            this._height && (this.scale.y = this._height / this.texture.frame.height)
        }
        ,
        O.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width
              , i = this.texture.frame.height
              , s = e * (1 - this.anchor.x)
              , n = e * -this.anchor.x
              , r = i * (1 - this.anchor.y)
              , o = i * -this.anchor.y
              , a = t || this.worldTransform
              , h = a.a
              , l = a.b
              , c = a.c
              , u = a.d
              , d = a.tx
              , p = a.ty
              , f = -1 / 0
              , g = -1 / 0
              , m = 1 / 0
              , y = 1 / 0;
            if (0 === l && 0 === c) {
                if (h < 0) {
                    h *= -1;
                    var v = s;
                    s = -n,
                    n = -v
                }
                if (u < 0) {
                    u *= -1;
                    v = r;
                    r = -o,
                    o = -v
                }
                m = h * n + d,
                f = h * s + d,
                y = u * o + p,
                g = u * r + p
            } else {
                var x = h * n + c * o + d
                  , b = u * o + l * n + p
                  , _ = h * s + c * o + d
                  , w = u * o + l * s + p
                  , T = h * s + c * r + d
                  , P = u * r + l * s + p
                  , C = h * n + c * r + d
                  , S = u * r + l * n + p;
                m = C < (m = T < (m = _ < (m = x < m ? x : m) ? _ : m) ? T : m) ? C : m,
                y = S < (y = P < (y = w < (y = b < y ? b : y) ? w : y) ? P : y) ? S : y,
                f = (f = (f = (f = f < x ? x : f) < _ ? _ : f) < T ? T : f) < C ? C : f,
                g = (g = (g = (g = g < b ? b : g) < w ? w : g) < P ? P : g) < S ? S : g
            }
            var A = this._bounds;
            return A.x = m,
            A.width = f - m,
            A.y = y,
            A.height = g - y,
            this._currentBounds = A
        }
        ,
        O.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = O.identityMatrix;
            for (var e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t,
            e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            return i
        }
        ,
        O.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e),
                this._mask || this._filters) {
                    var s = t.spriteBatch;
                    this._filters && (s.flush(),
                    t.filterManager.pushFilter(this._filterBlock)),
                    this._mask && (s.stop(),
                    t.maskManager.pushMask(this.mask, t),
                    s.start()),
                    s.render(this);
                    for (var n = 0; n < this.children.length; n++)
                        this.children[n]._renderWebGL(t);
                    s.stop(),
                    this._mask && t.maskManager.popMask(this._mask, t),
                    this._filters && t.filterManager.popFilter(),
                    s.start()
                } else {
                    t.spriteBatch.render(this);
                    for (n = 0; n < this.children.length; n++)
                        this.children[n]._renderWebGL(t, i)
                }
            }
        }
        ,
        O.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var i = this.worldTransform;
                if (e && (i = e),
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                t.context.globalCompositeOperation = O.blendModesCanvas[t.currentBlendMode]),
                this._mask && t.maskManager.pushMask(this._mask, t),
                this.texture.valid) {
                    var s = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha,
                    t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode,
                    t.context[t.smoothProperty] = t.scaleMode === O.scaleModes.LINEAR);
                    var n = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width
                      , r = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height
                      , o = i.tx * t.resolution + t.shakeX
                      , a = i.ty * t.resolution + t.shakeY
                      , h = this.texture.crop.width
                      , l = this.texture.crop.height;
                    if (this.texture.rotated) {
                        var c = i.a
                          , u = i.b
                          , d = i.c
                          , p = i.d
                          , f = h;
                        o = i.c * l + o,
                        a = i.d * l + a,
                        i.a = 6123233995736766e-32 * c - d,
                        i.b = 6123233995736766e-32 * u - p,
                        i.c = c + 6123233995736766e-32 * d,
                        i.d = u + 6123233995736766e-32 * p,
                        h = l,
                        l = f
                    }
                    if (t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | o, 0 | a),
                    n |= 0,
                    r |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, o, a),
                    n /= s,
                    r /= s,
                    16777215 !== this.tint)
                        !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = O.CanvasTinter.getTintedTexture(this, this.tint),
                        this.cachedTint = this.tint,
                        this.texture.requiresReTint = !1),
                        t.context.drawImage(this.tintedTexture, 0, 0, h, l, n, r, h / s, l / s);
                    else {
                        var g = this.texture.crop.x
                          , m = this.texture.crop.y;
                        h = Math.floor(h),
                        l = Math.floor(l),
                        t.context.drawImage(this.texture.baseTexture.source, g, m, h, l, n, r, h / s, l / s)
                    }
                    for (y = 0; y < this.children.length; y++)
                        this.children[y]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                } else {
                    for (var y = 0; y < this.children.length; y++)
                        this.children[y]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }
        }
        ,
        O.initDefaultShaders = function() {}
        ,
        O.CompileVertexShader = function(t, e) {
            return O._CompileShader(t, e, t.VERTEX_SHADER)
        }
        ,
        O.CompileFragmentShader = function(t, e) {
            return O._CompileShader(t, e, t.FRAGMENT_SHADER)
        }
        ,
        O._CompileShader = function(t, e, i) {
            var s = e;
            Array.isArray(e) && (s = e.join("\n"));
            var n = t.createShader(i);
            return t.shaderSource(n, s),
            t.compileShader(n),
            t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)),
            null)
        }
        ,
        O.compileProgram = function(t, e, i) {
            var s = O.CompileFragmentShader(t, i)
              , n = O.CompileVertexShader(t, e)
              , r = t.createProgram();
            return t.attachShader(r, n),
            t.attachShader(r, s),
            t.linkProgram(r),
            t.getProgramParameter(r, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(r)),
            window.console.log("Could not initialise shaders")),
            r
        }
        ,
        O.PixiShader = function(t) {
            this._UID = Phaser._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = null,
            this.textureCount = 0,
            this.firstRun = !0,
            this.dirty = !0,
            this.attributes = [],
            this.init()
        }
        ,
        O.PixiShader.prototype.constructor = O.PixiShader,
        O.PixiShader.prototype.initMultitexShader = function() {
            var t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n", i = 1; i < this.MAX_TEXTURES; ++i)
                e += "\telse if (vTextureIndex == " + i + ".0) gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;\n";
            this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   else if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) gl_FragColor = BLUE;", "   else if(isnan(vTextureIndex)) gl_FragColor = RED;", "}"];
            var s = O.compileProgram(t, this.vertexSrc || O.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(s),
            this.uSamplerArray = t.getUniformLocation(s, "uSamplerArray[0]"),
            this.projectionVector = t.getUniformLocation(s, "projectionVector"),
            this.offsetVector = t.getUniformLocation(s, "offsetVector"),
            this.dimensions = t.getUniformLocation(s, "dimensions"),
            this.aVertexPosition = t.getAttribLocation(s, "aVertexPosition"),
            this.aTextureCoord = t.getAttribLocation(s, "aTextureCoord"),
            this.colorAttribute = t.getAttribLocation(s, "aColor"),
            this.aTextureIndex = t.getAttribLocation(s, "aTextureIndex");
            var n = []
              , r = t.createTexture();
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, r),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var o = 0; o < this.MAX_TEXTURES; ++o)
                t.activeTexture(t.TEXTURE0 + o),
                t.bindTexture(t.TEXTURE_2D, r),
                n.push(o);
            for (var a in t.activeTexture(t.TEXTURE0),
            t.uniform1iv(this.uSamplerArray, n),
            -1 === this.colorAttribute && (this.colorAttribute = 2),
            this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex],
            this.uniforms)
                this.uniforms[a].uniformLocation = t.getUniformLocation(s, a);
            this.initUniforms(),
            this.program = s
        }
        ,
        O.PixiShader.prototype.initDefaultShader = function() {
            null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
            var t = this.gl
              , e = O.compileProgram(t, this.vertexSrc || O.PixiShader.defaultVertexSrc, this.fragmentSrc);
            for (var i in t.useProgram(e),
            this.uSampler = t.getUniformLocation(e, "uSampler"),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.dimensions = t.getUniformLocation(e, "dimensions"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"),
            -1 === this.colorAttribute && (this.colorAttribute = 2),
            this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex],
            this.uniforms)
                this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
            this.initUniforms(),
            this.program = e
        }
        ,
        O.PixiShader.prototype.init = function(t) {
            O._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
        }
        ,
        O.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) {
                var s = (t = this.uniforms[i]).type;
                "sampler2D" === s ? (t._init = !1,
                null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0,
                t.glValueLength = 1,
                "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s],
                t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
            }
        }
        ,
        O.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e.TEXTURE0 + this.textureCount),
                e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]),
                t.textureData) {
                    var i = t.textureData
                      , s = i.magFilter ? i.magFilter : e.LINEAR
                      , n = i.minFilter ? i.minFilter : e.LINEAR
                      , r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE
                      , o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE
                      , a = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (r = e.REPEAT,
                    o = e.REPEAT),
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY),
                    i.width) {
                        var h = i.width ? i.width : 512
                          , l = i.height ? i.height : 2
                          , c = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                    } else
                        e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                }
                e.uniform1i(t.uniformLocation, this.textureCount),
                t._init = !0,
                this.textureCount++
            }
        }
        ,
        O.PixiShader.prototype.syncUniforms = function() {
            var t;
            this.textureCount = 1;
            var e = this.gl;
            for (var i in this.uniforms)
                1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]),
                t.value.baseTexture._dirty[e.id] ? O.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]),
                e.uniform1i(t.uniformLocation, this.textureCount),
                this.textureCount++) : this.initSampler2D(t))
        }
        ,
        O.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        O.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"],
        O.PixiFastShader = function(t) {
            if (this._UID = Phaser._UID++,
            this.gl = t,
            this.program = null,
            O._enableMultiTextureToggle) {
                t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n", i = 1; i < this.MAX_TEXTURES; ++i)
                    e += "\telse if (vTextureIndex == " + i + ".0) gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;\n";
                this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   else if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) gl_FragColor = BLUE;", "   else if(isnan(vTextureIndex)) gl_FragColor = RED;", "}"]
            } else
                this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
            this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"],
            this.textureCount = 0,
            this.init()
        }
        ,
        O.PixiFastShader.prototype.constructor = O.PixiFastShader,
        O.PixiFastShader.prototype.init = function() {
            var t = this.gl
              , e = O.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e),
            this.uSampler = O._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"),
            O._enableMultiTextureToggle) {
                var i = []
                  , s = t.createTexture();
                t.activeTexture(t.TEXTURE0),
                t.bindTexture(t.TEXTURE_2D, s),
                t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var n = 0; n < this.MAX_TEXTURES; ++n)
                    t.activeTexture(t.TEXTURE0 + n),
                    t.bindTexture(t.TEXTURE_2D, s),
                    i.push(n);
                t.activeTexture(t.TEXTURE0),
                t.uniform1iv(this.uSampler, i)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.dimensions = t.getUniformLocation(e, "dimensions"),
            this.uMatrix = t.getUniformLocation(e, "uMatrix"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"),
            this.aScale = t.getAttribLocation(e, "aScale"),
            this.aRotation = t.getAttribLocation(e, "aRotation"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"),
            -1 === this.colorAttribute && (this.colorAttribute = 2),
            this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex],
            this.program = e
        }
        ,
        O.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        O.StripShader = function(t) {
            if (this._UID = Phaser._UID++,
            this.gl = t,
            this.program = null,
            O._enableMultiTextureToggle) {
                t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);\n", i = 1; i < this.MAX_TEXTURES; ++i)
                    e += "\telse if (vTextureIndex == " + i + ".0) gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) ;\n";
                this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   else if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) gl_FragColor = BLUE;", "   else if(isnan(vTextureIndex)) gl_FragColor = RED;", "}"]
            } else
                this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
            this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"],
            this.init()
        }
        ,
        O.StripShader.prototype.constructor = O.StripShader,
        O.StripShader.prototype.init = function() {
            var t = this.gl
              , e = O.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e),
            this.uSampler = O._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"),
            O._enableMultiTextureToggle) {
                var i = []
                  , s = t.createTexture();
                t.activeTexture(t.TEXTURE0),
                t.bindTexture(t.TEXTURE_2D, s),
                t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var n = 0; n < this.MAX_TEXTURES; ++n)
                    t.activeTexture(t.TEXTURE0 + n),
                    t.bindTexture(t.TEXTURE_2D, s),
                    i.push(n);
                t.activeTexture(t.TEXTURE0),
                t.uniform1iv(this.uSampler, i)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
            this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        O.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attribute = null
        }
        ,
        O.PrimitiveShader = function(t) {
            this._UID = Phaser._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"],
            this.init()
        }
        ,
        O.PrimitiveShader.prototype.constructor = O.PrimitiveShader,
        O.PrimitiveShader.prototype.init = function() {
            var t = this.gl
              , e = O.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.tintColor = t.getUniformLocation(e, "tint"),
            this.flipY = t.getUniformLocation(e, "flipY"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.colorAttribute = t.getAttribLocation(e, "aColor"),
            this.attributes = [this.aVertexPosition, this.colorAttribute],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        O.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attributes = null
        }
        ,
        O.ComplexPrimitiveShader = function(t) {
            this._UID = Phaser._UID++,
            this.gl = t,
            this.program = null,
            this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
            this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"],
            this.init()
        }
        ,
        O.ComplexPrimitiveShader.prototype.constructor = O.ComplexPrimitiveShader,
        O.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl
              , e = O.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e),
            this.projectionVector = t.getUniformLocation(e, "projectionVector"),
            this.offsetVector = t.getUniformLocation(e, "offsetVector"),
            this.tintColor = t.getUniformLocation(e, "tint"),
            this.color = t.getUniformLocation(e, "color"),
            this.flipY = t.getUniformLocation(e, "flipY"),
            this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
            this.attributes = [this.aVertexPosition, this.colorAttribute],
            this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
            this.alpha = t.getUniformLocation(e, "alpha"),
            this.program = e
        }
        ,
        O.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program),
            this.uniforms = null,
            this.gl = null,
            this.attribute = null
        }
        ,
        O.glContexts = [],
        O.instances = [],
        O._enableMultiTextureToggle = !1,
        O.WebGLRenderer = function(t) {
            this.game = t,
            O.defaultRenderer || (O.defaultRenderer = this),
            this.extensions = {},
            this.type = Phaser.WEBGL,
            this.resolution = t.resolution,
            this.transparent = t.transparent,
            this.autoResize = !1,
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.clearBeforeRender = t.clearBeforeRender,
            this.width = t.width,
            this.height = t.height,
            this.view = t.canvas,
            this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            },
            this.projection = new O.Point,
            this.offset = new O.Point,
            this.shaderManager = new O.WebGLShaderManager,
            this.spriteBatch = new O.WebGLSpriteBatch(t),
            this.maskManager = new O.WebGLMaskManager,
            this.filterManager = new O.WebGLFilterManager,
            this.stencilManager = new O.WebGLStencilManager,
            this.blendModeManager = new O.WebGLBlendModeManager,
            this.renderSession = {},
            this.currentBatchedTextures = [],
            this.renderSession.game = this.game,
            this.renderSession.gl = this.gl,
            this.renderSession.drawCount = 0,
            this.renderSession.shaderManager = this.shaderManager,
            this.renderSession.maskManager = this.maskManager,
            this.renderSession.filterManager = this.filterManager,
            this.renderSession.blendModeManager = this.blendModeManager,
            this.renderSession.spriteBatch = this.spriteBatch,
            this.renderSession.stencilManager = this.stencilManager,
            (this.renderSession.renderer = this).renderSession.resolution = this.resolution,
            this.initContext(),
            this.mapBlendModes()
        }
        ,
        O.WebGLRenderer.prototype.constructor = O.WebGLRenderer,
        O.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (!(this.gl = t))
                throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            this.glContextId = t.id = O.WebGLRenderer.glContextId++,
            O.glContexts[this.glContextId] = t,
            O.instances[this.glContextId] = this,
            t.disable(t.DEPTH_TEST),
            t.disable(t.CULL_FACE),
            t.enable(t.BLEND),
            this.shaderManager.setContext(t),
            this.spriteBatch.setContext(t),
            this.maskManager.setContext(t),
            this.filterManager.setContext(t),
            this.blendModeManager.setContext(t),
            this.stencilManager.setContext(t),
            this.renderSession.gl = this.gl,
            this.resize(this.width, this.height),
            this.extensions.compression = {},
            etc1 = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
            pvrtc = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            s3tc = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
            etc1 && (this.extensions.compression.ETC1 = etc1),
            pvrtc && (this.extensions.compression.PVRTC = pvrtc),
            s3tc && (this.extensions.compression.S3TC = s3tc)
        }
        ,
        O.WebGLRenderer.prototype.setTexturePriority = function(t) {
            if (O._enableMultiTextureToggle) {
                function e(t) {
                    return --t,
                    t |= t >> 1,
                    t |= t >> 2,
                    t |= t >> 4,
                    t |= t >> 8,
                    t |= t >> 16,
                    ++t
                }
                for (var i = this.gl, s = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), n = i.getParameter(i.MAX_TEXTURE_SIZE), r = this.game.cache._cache.image, o = null, a = 0; a < this.currentBatchedTextures.length; a++)
                    (o = t[l])in r && (r[o].base.textureIndex = 0);
                for (var h = n - e(Math.max(this.width, this.height)), l = this.currentBatchedTextures.length = 0; l < t.length; ++l)
                    if ((o = t[l])in r) {
                        var c = r[o].base;
                        h -= e(Math.max(c.width, c.height)),
                        c.textureIndex = h <= 0 ? 0 : 1 + l % (s - 1),
                        this.currentBatchedTextures.push(o)
                    }
                return this.currentBatchedTextures
            }
            console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
        }
        ,
        O.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height),
                e.bindFramebuffer(e.FRAMEBUFFER, null),
                this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a),
                e.clear(e.COLOR_BUFFER_BIT)),
                this.offset.x = this.game.camera._shake.x,
                this.offset.y = this.game.camera._shake.y,
                this.renderDisplayObject(t, this.projection)
            }
        }
        ,
        O.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, s) {
            this.renderSession.blendModeManager.setBlendMode(O.blendModes.NORMAL),
            this.renderSession.drawCount = 0,
            this.renderSession.flipY = i ? -1 : 1,
            this.renderSession.projection = e,
            this.renderSession.offset = this.offset,
            this.spriteBatch.begin(this.renderSession),
            this.filterManager.begin(this.renderSession, i),
            t._renderWebGL(this.renderSession, s),
            this.spriteBatch.end()
        }
        ,
        O.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution,
            this.height = e * this.resolution,
            this.view.width = this.width,
            this.view.height = this.height,
            this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
            this.view.style.height = this.height / this.resolution + "px"),
            this.gl.viewport(0, 0, this.width, this.height),
            this.projection.x = this.width / 2 / this.resolution,
            this.projection.y = -this.height / 2 / this.resolution
        }
        ,
        O.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
            if (!t.hasLoaded)
                return !1;
            var e = this.gl
              , i = t.source;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()),
            e.activeTexture(e.TEXTURE0 + t.textureIndex),
            e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
            e.compressedTexImage2D(e.TEXTURE_2D, 0, i.glExtensionFormat, i.width, i.height, 0, i.textureData),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST),
            e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
            !(t._dirty[e.id] = !1)
        }
        ,
        O.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded)
                return !1;
            if (t.source.compressionAlgorithm)
                return this.updateCompressedTexture(t);
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()),
            e.activeTexture(e.TEXTURE0 + t.textureIndex),
            e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST),
            e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === O.scaleModes.LINEAR ? e.LINEAR : e.NEAREST),
            t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
            !(t._dirty[e.id] = !1)
        }
        ,
        O.WebGLRenderer.prototype.destroy = function() {
            O.glContexts[this.glContextId] = null,
            this.projection = null,
            this.offset = null,
            this.shaderManager.destroy(),
            this.spriteBatch.destroy(),
            this.maskManager.destroy(),
            this.filterManager.destroy(),
            this.shaderManager = null,
            this.spriteBatch = null,
            this.maskManager = null,
            this.filterManager = null,
            this.gl = null,
            this.renderSession = null,
            Phaser.CanvasPool.remove(this),
            O.instances[this.glContextId] = null,
            O.WebGLRenderer.glContextId--
        }
        ,
        O.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!O.blendModesWebGL) {
                var e = []
                  , i = O.blendModes;
                e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA],
                e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA],
                e[i.SCREEN] = [t.SRC_ALPHA, t.ONE],
                e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                O.blendModesWebGL = e
            }
        }
        ,
        O.WebGLRenderer.prototype.getMaxTextureUnit = function() {
            var t = this.gl;
            return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        }
        ,
        O.enableMultiTexture = function() {
            O._enableMultiTextureToggle = !0
        }
        ,
        O.WebGLRenderer.glContextId = 0,
        O.WebGLRenderer.textureArray = [],
        O.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }
        ,
        O.WebGLBlendModeManager.prototype.constructor = O.WebGLBlendModeManager,
        O.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        O.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t)
                return !1;
            this.currentBlendMode = t;
            var e = O.blendModesWebGL[this.currentBlendMode];
            return e && this.gl.blendFunc(e[0], e[1]),
            !0
        }
        ,
        O.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }
        ,
        O.WebGLMaskManager = function() {}
        ,
        O.WebGLMaskManager.prototype.constructor = O.WebGLMaskManager,
        O.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        O.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var i = e.gl;
            t.dirty && O.WebGLGraphics.updateGraphics(t, i),
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
        }
        ,
        O.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }
        ,
        O.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }
        ,
        O.WebGLStencilManager = function() {
            this.stencilStack = [],
            this.reverse = !0,
            this.count = 0
        }
        ,
        O.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }
        ,
        O.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var s = this.gl;
            this.bindGraphics(t, e, i),
            0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST),
            s.clear(s.STENCIL_BUFFER_BIT),
            this.reverse = !0,
            this.count = 0),
            this.stencilStack.push(e);
            var n = this.count;
            s.colorMask(!1, !1, !1, !1),
            s.stencilFunc(s.ALWAYS, 0, 255),
            s.stencilOp(s.KEEP, s.KEEP, s.INVERT),
            1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0),
            this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255),
            s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255),
            s.stencilOp(s.KEEP, s.KEEP, s.INCR)),
            s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
            this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255),
            this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255),
            s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255),
            s.stencilOp(s.KEEP, s.KEEP, s.DECR)),
            s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0),
            this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)),
            s.colorMask(!0, !0, !0, !0),
            s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
            this.count++
        }
        ,
        O.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var s, n = this.gl, r = i.projection, o = i.offset;
            1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader,
            i.shaderManager.setShader(s),
            n.uniform1f(s.flipY, i.flipY),
            n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)),
            n.uniform2f(s.projectionVector, r.x, -r.y),
            n.uniform2f(s.offsetVector, -o.x, -o.y),
            n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)),
            n.uniform3fv(s.color, e.color),
            n.uniform1f(s.alpha, t.worldAlpha * e.alpha),
            n.bindBuffer(n.ARRAY_BUFFER, e.buffer),
            n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0)) : (s = i.shaderManager.primitiveShader,
            i.shaderManager.setShader(s),
            n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)),
            n.uniform1f(s.flipY, i.flipY),
            n.uniform2f(s.projectionVector, r.x, -r.y),
            n.uniform2f(s.offsetVector, -o.x, -o.y),
            n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)),
            n.uniform1f(s.alpha, t.worldAlpha),
            n.bindBuffer(n.ARRAY_BUFFER, e.buffer),
            n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0),
            n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8)),
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
        }
        ,
        O.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var s = this.gl;
            if (this.stencilStack.pop(),
            this.count--,
            0 === this.stencilStack.length)
                s.disable(s.STENCIL_TEST);
            else {
                var n = this.count;
                this.bindGraphics(t, e, i),
                s.colorMask(!1, !1, !1, !1),
                1 === e.mode ? (this.reverse = !this.reverse,
                this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255),
                s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255),
                s.stencilOp(s.KEEP, s.KEEP, s.DECR)),
                s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
                s.stencilFunc(s.ALWAYS, 0, 255),
                s.stencilOp(s.KEEP, s.KEEP, s.INVERT),
                s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255),
                s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255),
                s.stencilOp(s.KEEP, s.KEEP, s.INCR)),
                s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0)),
                this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255),
                s.colorMask(!0, !0, !0, !0),
                s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
            }
        }
        ,
        O.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null,
            this.gl = null
        }
        ,
        O.WebGLShaderManager = function() {
            this.maxAttibs = 10,
            this.attribState = [],
            this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++)
                this.attribState[t] = !1;
            this.stack = []
        }
        ,
        O.WebGLShaderManager.prototype.constructor = O.WebGLShaderManager,
        O.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t,
            this.primitiveShader = new O.PrimitiveShader(t),
            this.complexPrimitiveShader = new O.ComplexPrimitiveShader(t),
            this.defaultShader = new O.PixiShader(t),
            this.fastShader = new O.PixiFastShader(t),
            this.stripShader = new O.StripShader(t),
            this.setShader(this.defaultShader)
        }
        ,
        O.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++)
                this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var s = this.gl;
            for (e = 0; e < this.attribState.length; e++)
                this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e],
                this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
        }
        ,
        O.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID,
            this.currentShader = t,
            this.gl.useProgram(t.program),
            this.setAttribs(t.attributes),
            !0)
        }
        ,
        O.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null,
            this.tempAttribState = null,
            this.primitiveShader.destroy(),
            this.complexPrimitiveShader.destroy(),
            this.defaultShader.destroy(),
            this.fastShader.destroy(),
            this.stripShader.destroy(),
            this.gl = null
        }
        ,
        O.WebGLSpriteBatch = function(t) {
            this.game = t,
            this.vertSize = 5,
            this.size = 2e3,
            this.vertexSize = 24;
            var e = this.vertexSize * this.size * 4
              , i = 6 * this.size;
            this.vertices = new ArrayBuffer(e),
            this.positions = new Float32Array(this.vertices),
            this.colors = new Uint32Array(this.vertices),
            this.indices = new Uint16Array(i);
            for (var s = this.lastIndexCount = 0, n = 0; s < i; s += 6,
            n += 4)
                this.indices[s + 0] = n + 0,
                this.indices[s + 1] = n + 1,
                this.indices[s + 2] = n + 2,
                this.indices[s + 3] = n + 0,
                this.indices[s + 4] = n + 2,
                this.indices[s + 5] = n + 3;
            this.drawing = !1,
            this.currentBatchSize = 0,
            this.currentBaseTexture = null,
            this.dirty = !0,
            this.textures = [],
            this.blendModes = [],
            this.shaders = [],
            this.sprites = [],
            this.defaultShader = null
        }
        ,
        O.WebGLSpriteBatch.prototype.setContext = function(t) {
            if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            this.gl = t,
            O._enableMultiTextureToggle) {
                for (var e = "\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n", i = 1; i < this.MAX_TEXTURES; ++i)
                    e += "\telse if (vTextureIndex == " + i + ".0) gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;\n";
                this.defaultShader = new Phaser.Filter(this.game,void 0,["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\telse gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
            } else
                this.defaultShader = new Phaser.Filter(this.game,void 0,["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
            this.vertexBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW),
            this.currentBlendMode = 99999;
            var s = new O.PixiShader(t);
            s.fragmentSrc = this.defaultShader.fragmentSrc,
            s.uniforms = {},
            s.init(),
            this.defaultShader.shaders[t.id] = s
        }
        ,
        O.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t,
            this.shader = this.renderSession.shaderManager.defaultShader,
            this.start()
        }
        ,
        O.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }
        ,
        O.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture
              , s = i.baseTexture
              , n = this.gl;
            O.WebGLRenderer.textureArray[s.textureIndex] != s && (this.flush(),
            n.activeTexture(n.TEXTURE0 + s.textureIndex),
            n.bindTexture(n.TEXTURE_2D, s._glTextures[n.id]),
            O.WebGLRenderer.textureArray[s.textureIndex] = s);
            var r = t.worldTransform;
            e && (r = e),
            this.currentBatchSize >= this.size && (this.flush(),
            this.currentBaseTexture = i.baseTexture);
            var o = i._uvs;
            if (o) {
                var a, h, l, c, u = t.anchor.x, d = t.anchor.y;
                if (i.trim) {
                    var p = i.trim;
                    a = (h = p.x - u * p.width) + i.crop.width,
                    l = (c = p.y - d * p.height) + i.crop.height
                } else
                    a = i.frame.width * (1 - u),
                    h = i.frame.width * -u,
                    l = i.frame.height * (1 - d),
                    c = i.frame.height * -d;
                var f = this.currentBatchSize * this.vertexSize
                  , g = (this.currentBatchSize,
                i.baseTexture.resolution)
                  , m = i.baseTexture.textureIndex
                  , y = r.a / g
                  , v = r.b / g
                  , x = r.c / g
                  , b = r.d / g
                  , _ = r.tx
                  , w = r.ty
                  , T = (i.crop.width,
                i.crop.height);
                if (i.rotated) {
                    var P = r.a
                      , C = r.b
                      , S = r.c
                      , A = r.d
                      , E = h
                      , M = a;
                    _ = r.c * T + _,
                    w = r.d * T + w,
                    y = 6123233995736766e-32 * P - S,
                    v = 6123233995736766e-32 * C - A,
                    x = P + 6123233995736766e-32 * S,
                    b = C + 6123233995736766e-32 * A,
                    i._updateUvsInverted(),
                    a = l,
                    h = c,
                    l = M,
                    c = E
                }
                var R = this.colors
                  , L = this.positions
                  , B = t.tint
                  , I = (B >> 16) + (65280 & B) + ((255 & B) << 16) + (255 * t.worldAlpha << 24);
                this.renderSession.roundPixels ? (L[f++] = y * h + x * c + _ | 0,
                L[f++] = b * c + v * h + w | 0,
                L[f++] = o.x0,
                L[f++] = o.y0,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * a + x * c + _ | 0,
                L[f++] = b * c + v * a + w | 0,
                L[f++] = o.x1,
                L[f++] = o.y1,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * a + x * l + _ | 0,
                L[f++] = b * l + v * a + w | 0,
                L[f++] = o.x2,
                L[f++] = o.y2,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * h + x * l + _ | 0,
                L[f++] = b * l + v * h + w | 0) : (L[f++] = y * h + x * c + _,
                L[f++] = b * c + v * h + w,
                L[f++] = o.x0,
                L[f++] = o.y0,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * a + x * c + _,
                L[f++] = b * c + v * a + w,
                L[f++] = o.x1,
                L[f++] = o.y1,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * a + x * l + _,
                L[f++] = b * l + v * a + w,
                L[f++] = o.x2,
                L[f++] = o.y2,
                R[f++] = I,
                L[f++] = m,
                L[f++] = y * h + x * l + _,
                L[f++] = b * l + v * h + w),
                L[f++] = o.x3,
                L[f++] = o.y3,
                R[f++] = I,
                L[f++] = m,
                this.sprites[this.currentBatchSize++] = t
            }
        }
        ,
        O.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture
              , i = e.baseTexture
              , s = this.gl
              , n = t.texture.baseTexture.textureIndex;
            O.WebGLRenderer.textureArray[n] != i && (this.flush(),
            s.activeTexture(s.TEXTURE0 + n),
            s.bindTexture(s.TEXTURE_2D, i._glTextures[s.id]),
            O.WebGLRenderer.textureArray[n] = i),
            this.currentBatchSize >= this.size && (this.flush(),
            this.currentBaseTexture = e.baseTexture),
            t._uvs || (t._uvs = new O.TextureUvs);
            var r = t._uvs
              , o = e.baseTexture.width
              , a = e.baseTexture.height;
            t.tilePosition.x %= o * t.tileScaleOffset.x,
            t.tilePosition.y %= a * t.tileScaleOffset.y;
            var h = t.tilePosition.x / (o * t.tileScaleOffset.x)
              , l = t.tilePosition.y / (a * t.tileScaleOffset.y)
              , c = t.width / o / (t.tileScale.x * t.tileScaleOffset.x)
              , u = t.height / a / (t.tileScale.y * t.tileScaleOffset.y);
            r.x0 = 0 - h,
            r.y0 = 0 - l,
            r.x1 = 1 * c - h,
            r.y1 = 0 - l,
            r.x2 = 1 * c - h,
            r.y2 = 1 * u - l,
            r.x3 = 0 - h,
            r.y3 = 1 * u - l;
            var d = t.tint
              , p = (d >> 16) + (65280 & d) + ((255 & d) << 16) + (255 * t.worldAlpha << 24)
              , f = this.positions
              , g = this.colors
              , m = t.width
              , y = t.height
              , v = t.anchor.x
              , x = t.anchor.y
              , b = m * (1 - v)
              , _ = m * -v
              , w = y * (1 - x)
              , T = y * -x
              , P = this.currentBatchSize * this.vertexSize
              , C = e.baseTexture.resolution
              , S = t.worldTransform
              , A = S.a / C
              , E = S.b / C
              , M = S.c / C
              , R = S.d / C
              , L = S.tx
              , B = S.ty;
            f[P++] = A * _ + M * T + L,
            f[P++] = R * T + E * _ + B,
            f[P++] = r.x0,
            f[P++] = r.y0,
            g[P++] = p,
            f[P++] = n,
            f[P++] = A * b + M * T + L,
            f[P++] = R * T + E * b + B,
            f[P++] = r.x1,
            f[P++] = r.y1,
            g[P++] = p,
            f[P++] = n,
            f[P++] = A * b + M * w + L,
            f[P++] = R * w + E * b + B,
            f[P++] = r.x2,
            f[P++] = r.y2,
            g[P++] = p,
            f[P++] = n,
            f[P++] = A * _ + M * w + L,
            f[P++] = R * w + E * _ + B,
            f[P++] = r.x3,
            f[P++] = r.y3,
            g[P++] = p,
            f[P++] = n,
            this.sprites[this.currentBatchSize++] = t
        }
        ,
        O.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, e, i, s, n = this.gl;
                if (this.dirty) {
                    this.dirty = !1,
                    t = this.defaultShader.shaders[n.id],
                    n.activeTexture(n.TEXTURE0),
                    n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer),
                    n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    var r = this.vertexSize;
                    n.vertexAttribPointer(t.aVertexPosition, 2, n.FLOAT, !1, r, 0),
                    n.vertexAttribPointer(t.aTextureCoord, 2, n.FLOAT, !1, r, 8),
                    n.vertexAttribPointer(t.colorAttribute, 4, n.UNSIGNED_BYTE, !0, r, 16),
                    n.vertexAttribPointer(t.aTextureIndex, 1, n.FLOAT, !1, r, 20)
                }
                if (this.currentBatchSize > .5 * this.size)
                    n.bufferSubData(n.ARRAY_BUFFER, 0, this.vertices);
                else {
                    n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer);
                    var o = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                    n.bufferSubData(n.ARRAY_BUFFER, 0, o)
                }
                for (var a, h = 0, l = 0, c = null, u = this.renderSession.blendModeManager.currentBlendMode, d = null, p = !1, f = !1, g = 0, m = this.currentBatchSize; g < m; g++) {
                    e = (a = this.sprites[g]).tilingTexture ? a.tilingTexture.baseTexture : a.texture.baseTexture,
                    p = u !== (i = a.blendMode),
                    f = d !== (s = a.shader || this.defaultShader);
                    var y = e.skipRender;
                    if (y && 0 < a.children.length && (y = !1),
                    (p || f) && (this.renderBatch(c, h, l),
                    l = g,
                    h = 0,
                    c = e,
                    p && (u = i,
                    this.renderSession.blendModeManager.setBlendMode(u)),
                    f)) {
                        (t = (d = s).shaders[n.id]) || ((t = new O.PixiShader(n)).fragmentSrc = d.fragmentSrc,
                        t.uniforms = d.uniforms,
                        t.init(),
                        d.shaders[n.id] = t),
                        this.renderSession.shaderManager.setShader(t),
                        t.dirty && t.syncUniforms();
                        var v = this.renderSession.projection;
                        n.uniform2f(t.projectionVector, v.x, v.y);
                        var x = this.renderSession.offset;
                        n.uniform2f(t.offsetVector, x.x, x.y)
                    }
                    h++
                }
                this.renderBatch(c, h, l),
                this.currentBatchSize = 0
            }
        }
        ,
        O.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var s = this.gl;
                t._dirty[s.id] && !this.renderSession.renderer.updateTexture(t) || (s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2),
                this.renderSession.drawCount++)
            }
        }
        ,
        O.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(),
            this.dirty = !0
        }
        ,
        O.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }
        ,
        O.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null,
            this.indices = null,
            this.gl.deleteBuffer(this.vertexBuffer),
            this.gl.deleteBuffer(this.indexBuffer),
            this.currentBaseTexture = null,
            this.gl = null
        }
        ,
        O.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 11,
            this.maxSize = 6e3,
            this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize
              , i = 6 * this.maxSize;
            this.vertices = new Float32Array(e),
            this.indices = new Uint16Array(i),
            this.vertexBuffer = null,
            this.indexBuffer = null;
            for (var s = this.lastIndexCount = 0, n = 0; s < i; s += 6,
            n += 4)
                this.indices[s + 0] = n + 0,
                this.indices[s + 1] = n + 1,
                this.indices[s + 2] = n + 2,
                this.indices[s + 3] = n + 0,
                this.indices[s + 4] = n + 2,
                this.indices[s + 5] = n + 3;
            this.drawing = !1,
            this.currentBatchSize = 0,
            this.currentBaseTexture = null,
            this.currentBlendMode = 0,
            this.renderSession = null,
            this.shader = null,
            this.matrix = null,
            this.setContext(t)
        }
        ,
        O.WebGLFastSpriteBatch.prototype.constructor = O.WebGLFastSpriteBatch,
        O.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t,
            this.vertexBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }
        ,
        O.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e,
            this.shader = this.renderSession.shaderManager.fastShader,
            this.matrix = t.worldTransform.toArray(!0),
            this.start()
        }
        ,
        O.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }
        ,
        O.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children
              , i = e[0];
            if (i.texture._uvs) {
                this.currentBaseTexture = i.texture.baseTexture,
                i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(),
                this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                for (var s = 0, n = e.length; s < n; s++)
                    this.renderSprite(e[s]);
                this.flush()
            }
        }
        ,
        O.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            var e = t.texture.baseTexture
              , i = this.gl
              , s = t.texture.baseTexture.textureIndex;
            if ((O.WebGLRenderer.textureArray[s] == e || !e._glTextures[i.id] || t.texture.baseTexture.skipRender || (this.flush(),
            i.activeTexture(i.TEXTURE0 + s),
            i.bindTexture(i.TEXTURE_2D, e._glTextures[i.id]),
            O.WebGLRenderer.textureArray[s] = e,
            t.texture._uvs)) && t.visible) {
                var n, r, o, a, h, l, c = this.vertices;
                if (n = t.texture._uvs,
                t.texture.frame.width,
                t.texture.frame.height,
                t.texture.trim) {
                    var u = t.texture.trim;
                    r = (o = u.x - t.anchor.x * u.width) + t.texture.crop.width,
                    a = (h = u.y - t.anchor.y * u.height) + t.texture.crop.height
                } else
                    r = t.texture.frame.width * (1 - t.anchor.x),
                    o = t.texture.frame.width * -t.anchor.x,
                    a = t.texture.frame.height * (1 - t.anchor.y),
                    h = t.texture.frame.height * -t.anchor.y;
                l = 4 * this.currentBatchSize * this.vertSize,
                c[l++] = o,
                c[l++] = h,
                c[l++] = t.position.x,
                c[l++] = t.position.y,
                c[l++] = t.scale.x,
                c[l++] = t.scale.y,
                c[l++] = t.rotation,
                c[l++] = n.x0,
                c[l++] = n.y1,
                c[l++] = t.alpha,
                c[l++] = s,
                c[l++] = r,
                c[l++] = h,
                c[l++] = t.position.x,
                c[l++] = t.position.y,
                c[l++] = t.scale.x,
                c[l++] = t.scale.y,
                c[l++] = t.rotation,
                c[l++] = n.x1,
                c[l++] = n.y1,
                c[l++] = t.alpha,
                c[l++] = s,
                c[l++] = r,
                c[l++] = a,
                c[l++] = t.position.x,
                c[l++] = t.position.y,
                c[l++] = t.scale.x,
                c[l++] = t.scale.y,
                c[l++] = t.rotation,
                c[l++] = n.x2,
                c[l++] = n.y2,
                c[l++] = t.alpha,
                c[l++] = s,
                c[l++] = o,
                c[l++] = a,
                c[l++] = t.position.x,
                c[l++] = t.position.y,
                c[l++] = t.scale.x,
                c[l++] = t.scale.y,
                c[l++] = t.rotation,
                c[l++] = n.x3,
                c[l++] = n.y3,
                c[l++] = t.alpha,
                c[l++] = s,
                this.currentBatchSize++,
                this.currentBatchSize >= this.size && this.flush()
            }
        }
        ,
        O.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id]) {
                    if (this.currentBatchSize > .5 * this.size)
                        t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                        t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                    }
                    t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0),
                    this.currentBatchSize = 0,
                    this.renderSession.drawCount++
                } else
                    this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
            }
        }
        ,
        O.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }
        ,
        O.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y),
            t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0),
            t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8),
            t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16),
            t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24),
            t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28),
            t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36),
            t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
        }
        ,
        O.WebGLFilterManager = function() {
            this.filterStack = [],
            this.offsetX = 0,
            this.offsetY = 0
        }
        ,
        O.WebGLFilterManager.prototype.constructor = O.WebGLFilterManager,
        O.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t,
            this.texturePool = [],
            this.initShaderBuffers()
        }
        ,
        O.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t,
            this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x,
            this.height = 2 * -i.y,
            this.buffer = e
        }
        ,
        O.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl
              , i = this.renderSession.projection
              , s = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(),
            t._previous_stencil_mgr = this.renderSession.stencilManager,
            this.renderSession.stencilManager = new O.WebGLStencilManager,
            this.renderSession.stencilManager.setContext(e),
            e.disable(e.STENCIL_TEST),
            this.filterStack.push(t);
            var n = t.filterPasses[0];
            this.offsetX += t._filterArea.x,
            this.offsetY += t._filterArea.y;
            var r = this.texturePool.pop();
            r ? r.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : r = new O.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution),
            e.bindTexture(e.TEXTURE_2D, r.texture);
            var o = t._filterArea
              , a = n.padding;
            o.x -= a,
            o.y -= a,
            o.width += 2 * a,
            o.height += 2 * a,
            o.x < 0 && (o.x = 0),
            o.width > this.width && (o.width = this.width),
            o.y < 0 && (o.y = 0),
            o.height > this.height && (o.height = this.height),
            e.bindFramebuffer(e.FRAMEBUFFER, r.frameBuffer),
            e.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution),
            i.x = o.width / 2,
            i.y = -o.height / 2,
            s.x = -o.x,
            s.y = -o.y,
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.clear(e.COLOR_BUFFER_BIT),
            t._glFilterTexture = r
        }
        ,
        O.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl
              , e = this.filterStack.pop()
              , i = e._filterArea
              , s = e._glFilterTexture
              , n = this.renderSession.projection
              , r = this.renderSession.offset;
            if (1 < e.filterPasses.length) {
                t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution),
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                this.vertexArray[0] = 0,
                this.vertexArray[1] = i.height,
                this.vertexArray[2] = i.width,
                this.vertexArray[3] = i.height,
                this.vertexArray[4] = 0,
                this.vertexArray[5] = 0,
                this.vertexArray[6] = i.width,
                this.vertexArray[7] = 0,
                t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
                t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
                this.uvArray[2] = i.width / this.width,
                this.uvArray[5] = i.height / this.height,
                this.uvArray[6] = i.width / this.width,
                this.uvArray[7] = i.height / this.height,
                t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var o = s
                  , a = this.texturePool.pop();
                (a = a || new O.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution)).resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
                t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer),
                t.clear(t.COLOR_BUFFER_BIT),
                t.disable(t.BLEND);
                for (var h = 0; h < e.filterPasses.length - 1; h++) {
                    var l = e.filterPasses[h];
                    t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer),
                    t.activeTexture(t.TEXTURE0),
                    t.bindTexture(t.TEXTURE_2D, o.texture),
                    this.applyFilterPass(l, i, i.width, i.height);
                    var c = o;
                    o = a,
                    a = c
                }
                t.enable(t.BLEND),
                s = o,
                this.texturePool.push(a)
            }
            var u = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= i.x,
            this.offsetY -= i.y;
            var d = this.width
              , p = this.height
              , f = 0
              , g = 0
              , m = this.buffer;
            if (0 === this.filterStack.length)
                t.colorMask(!0, !0, !0, !0);
            else {
                var y = this.filterStack[this.filterStack.length - 1];
                d = (i = y._filterArea).width,
                p = i.height,
                f = i.x,
                g = i.y,
                m = y._glFilterTexture.frameBuffer
            }
            n.x = d / 2,
            n.y = -p / 2,
            r.x = f,
            r.y = g;
            var v = (i = e._filterArea).x - f
              , x = i.y - g;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            this.vertexArray[0] = v,
            this.vertexArray[1] = x + i.height,
            this.vertexArray[2] = v + i.width,
            this.vertexArray[3] = x + i.height,
            this.vertexArray[4] = v,
            this.vertexArray[5] = x,
            this.vertexArray[6] = v + i.width,
            this.vertexArray[7] = x,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
            t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
            this.uvArray[2] = i.width / this.width,
            this.uvArray[5] = i.height / this.height,
            this.uvArray[6] = i.width / this.width,
            this.uvArray[7] = i.height / this.height,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray),
            t.viewport(0, 0, d * this.renderSession.resolution, p * this.renderSession.resolution),
            t.bindFramebuffer(t.FRAMEBUFFER, m),
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, s.texture),
            this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(),
            this.renderSession.stencilManager = e._previous_stencil_mgr,
            e._previous_stencil_mgr = null,
            0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST),
            this.applyFilterPass(u, i, d, p),
            this.texturePool.push(s),
            e._glFilterTexture = null
        }
        ,
        O.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, s) {
            var n = this.gl
              , r = t.shaders[n.id];
            r || ((r = new O.PixiShader(n)).fragmentSrc = t.fragmentSrc,
            r.uniforms = t.uniforms,
            r.init(!0),
            t.shaders[n.id] = r),
            this.renderSession.shaderManager.setShader(r),
            n.uniform2f(r.projectionVector, i / 2, -s / 2),
            n.uniform2f(r.offsetVector, 0, 0),
            t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width,
            t.uniforms.dimensions.value[1] = this.height,
            t.uniforms.dimensions.value[2] = this.vertexArray[0],
            t.uniforms.dimensions.value[3] = this.vertexArray[5]),
            r.syncUniforms(),
            n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer),
            n.vertexAttribPointer(r.aVertexPosition, 2, n.FLOAT, !1, 0, 0),
            n.bindBuffer(n.ARRAY_BUFFER, this.uvBuffer),
            n.vertexAttribPointer(r.aTextureCoord, 2, n.FLOAT, !1, 0, 0),
            n.bindBuffer(n.ARRAY_BUFFER, this.colorBuffer),
            n.vertexAttribPointer(r.colorAttribute, 2, n.FLOAT, !1, 0, 0),
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0),
            this.renderSession.drawCount++
        }
        ,
        O.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(),
            this.uvBuffer = t.createBuffer(),
            this.colorBuffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW),
            this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
            t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW),
            this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]),
            t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer),
            t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }
        ,
        O.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null,
            this.offsetX = 0;
            for (var e = this.offsetY = 0; e < this.texturePool.length; e++)
                this.texturePool[e].destroy();
            this.texturePool = null,
            t.deleteBuffer(this.vertexBuffer),
            t.deleteBuffer(this.uvBuffer),
            t.deleteBuffer(this.colorBuffer),
            t.deleteBuffer(this.indexBuffer)
        }
        ;
        var l = {
            36054: "Incomplete attachment",
            36055: "Missing attachment",
            36057: "Incomplete dimensions",
            36061: "Framebuffer unsupported"
        };
        function r(t, e, i, s, n) {
            var r, o, a = t.createFramebuffer(), h = t.createRenderbuffer();
            return t.activeTexture(t.TEXTURE0 + n),
            t.bindFramebuffer(t.FRAMEBUFFER, a),
            t.bindRenderbuffer(t.RENDERBUFFER, h),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer),
            r = function(t, e, i, s) {
                var n = t.createTexture();
                return t.bindTexture(t.TEXTURE_2D, n),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === O.scaleModes.LINEAR ? t.LINEAR : t.NEAREST),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === O.scaleModes.LINEAR ? t.LINEAR : t.NEAREST),
                t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null),
                n
            }(t, e, i, s),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0),
            (o = t.checkFramebufferStatus(t.FRAMEBUFFER)) !== t.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", l[o]),
            a.width = e,
            a.height = i,
            a.targetTexture = r,
            a.renderBuffer = h,
            a
        }
        return O.FilterTexture = function(t, e, i, s, n) {
            n = "number" == typeof n ? n : 0,
            this.gl = t,
            this.frameBuffer = r(t, e, i, s || O.scaleModes.DEFAULT, n),
            this.texture = this.frameBuffer.targetTexture,
            this.width = e,
            this.height = i,
            this.renderBuffer = this.frameBuffer.renderBuffer
        }
        ,
        O.FilterTexture.prototype.constructor = O.FilterTexture,
        O.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0),
            t.clear(t.COLOR_BUFFER_BIT)
        }
        ,
        O.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t,
                this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture),
                i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null),
                i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer),
                i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }
        ,
        O.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer),
            t.deleteTexture(this.texture),
            this.frameBuffer = null,
            this.texture = null
        }
        ,
        O.CanvasBuffer = function(t, e) {
            this.width = t,
            this.height = e,
            this.canvas = Phaser.CanvasPool.create(this, this.width, this.height),
            this.context = this.canvas.getContext("2d"),
            this.canvas.width = t,
            this.canvas.height = e
        }
        ,
        O.CanvasBuffer.prototype.constructor = O.CanvasBuffer,
        O.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.clearRect(0, 0, this.width, this.height)
        }
        ,
        O.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t,
            this.height = this.canvas.height = e
        }
        ,
        O.CanvasBuffer.prototype.destroy = function() {
            Phaser.CanvasPool.remove(this)
        }
        ,
        O.CanvasMaskManager = function() {}
        ,
        O.CanvasMaskManager.prototype.constructor = O.CanvasMaskManager,
        O.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var i = e.context;
            i.save();
            var s = t.alpha
              , n = t.worldTransform
              , r = e.resolution;
            i.setTransform(n.a * r, n.b * r, n.c * r, n.d * r, n.tx * r, n.ty * r),
            O.CanvasGraphics.renderGraphicsMask(t, i),
            i.clip(),
            t.worldAlpha = s
        }
        ,
        O.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }
        ,
        O.CanvasTinter = function() {}
        ,
        O.CanvasTinter.getTintedTexture = function(t, e) {
            var i = t.tintedTexture || Phaser.CanvasPool.create(this);
            return O.CanvasTinter.tintMethod(t.texture, e, i),
            i
        }
        ,
        O.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var s = i.getContext("2d")
              , n = t.crop
              , r = n.width
              , o = n.height;
            t.rotated && (r = o,
            o = n.width),
            i.width === r && i.height === o || (i.width = r,
            i.height = o),
            s.clearRect(0, 0, r, o),
            s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6),
            s.fillRect(0, 0, r, o),
            s.globalCompositeOperation = "multiply",
            s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o),
            s.globalCompositeOperation = "destination-atop",
            s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
        }
        ,
        O.CanvasTinter.tintWithPerPixel = function(t, e, i) {
            var s = i.getContext("2d")
              , n = t.crop
              , r = n.width
              , o = n.height;
            t.rotated && (r = o,
            o = n.width),
            i.width === r && i.height === o || (i.width = r,
            i.height = o),
            s.globalCompositeOperation = "copy",
            s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o);
            for (var a = Phaser.Color.hexToRGBArray(e), h = a[0], l = a[1], c = a[2], u = s.getImageData(0, 0, r, o), d = u.data, p = 0; p < d.length; p += 4)
                if (d[p + 0] *= h,
                d[p + 1] *= l,
                d[p + 2] *= c,
                !O.CanvasTinter.canHandleAlpha) {
                    var f = d[p + 3];
                    d[p + 0] /= 255 / f,
                    d[p + 1] /= 255 / f,
                    d[p + 2] /= 255 / f
                }
            s.putImageData(u, 0, 0)
        }
        ,
        O.CanvasRenderer = function(t) {
            this.game = t,
            O.defaultRenderer || (O.defaultRenderer = this),
            this.type = Phaser.CANVAS,
            this.resolution = t.resolution,
            this.clearBeforeRender = t.clearBeforeRender,
            this.transparent = t.transparent,
            this.autoResize = !1,
            this.width = t.width * this.resolution,
            this.height = t.height * this.resolution,
            this.view = t.canvas,
            this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }),
            this.refresh = !0,
            this.count = 0,
            this.maskManager = new O.CanvasMaskManager,
            this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            },
            this.mapBlendModes(),
            this.resize(this.width, this.height)
        }
        ,
        O.CanvasRenderer.prototype.constructor = O.CanvasRenderer,
        O.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.globalAlpha = 1,
            this.renderSession.currentBlendMode = 0,
            this.renderSession.shakeX = this.game.camera._shake.x,
            this.renderSession.shakeY = this.game.camera._shake.y,
            this.context.globalCompositeOperation = "source-over",
            navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black",
            this.context.clear()),
            this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba,
            this.context.fillRect(0, 0, this.width, this.height))),
            this.renderDisplayObject(t)
        }
        ,
        O.CanvasRenderer.prototype.setTexturePriority = function(t) {}
        ,
        O.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0),
            t && this.view.parent && this.view.parent.removeChild(this.view),
            this.view = null,
            this.context = null,
            this.maskManager = null,
            this.renderSession = null
        }
        ,
        O.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution,
            this.height = e * this.resolution,
            this.view.width = this.width,
            this.view.height = this.height,
            this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
            this.view.style.height = this.height / this.resolution + "px"),
            this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === O.scaleModes.LINEAR)
        }
        ,
        O.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context,
            this.renderSession.resolution = this.resolution,
            t._renderCanvas(this.renderSession, i)
        }
        ,
        O.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!O.blendModesCanvas) {
                var t = []
                  , e = O.blendModes
                  , i = this.game.device.canUseMultiply;
                t[e.NORMAL] = "source-over",
                t[e.ADD] = "lighter",
                t[e.MULTIPLY] = i ? "multiply" : "source-over",
                t[e.SCREEN] = i ? "screen" : "source-over",
                t[e.OVERLAY] = i ? "overlay" : "source-over",
                t[e.DARKEN] = i ? "darken" : "source-over",
                t[e.LIGHTEN] = i ? "lighten" : "source-over",
                t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over",
                t[e.COLOR_BURN] = i ? "color-burn" : "source-over",
                t[e.HARD_LIGHT] = i ? "hard-light" : "source-over",
                t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over",
                t[e.DIFFERENCE] = i ? "difference" : "source-over",
                t[e.EXCLUSION] = i ? "exclusion" : "source-over",
                t[e.HUE] = i ? "hue" : "source-over",
                t[e.SATURATION] = i ? "saturation" : "source-over",
                t[e.COLOR] = i ? "color" : "source-over",
                t[e.LUMINOSITY] = i ? "luminosity" : "source-over",
                O.blendModesCanvas = t
            }
        }
        ,
        O.BaseTexture = function(t, e, i) {
            this.resolution = i || 1,
            this.width = 100,
            this.height = 100,
            this.scaleMode = e || O.scaleModes.DEFAULT,
            this.hasLoaded = !1,
            this.source = t,
            this.premultipliedAlpha = !0,
            this._glTextures = [],
            this.mipmap = !1,
            this.textureIndex = 0,
            this._dirty = [!0, !0, !0, !0],
            t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0,
            this.width = this.source.naturalWidth || this.source.width,
            this.height = this.source.naturalHeight || this.source.height,
            this.dirty()),
            this.skipRender = !1,
            this._powerOf2 = !1)
        }
        ,
        O.BaseTexture.prototype.constructor = O.BaseTexture,
        O.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0,
            this.width = t,
            this.height = e,
            this.dirty()
        }
        ,
        O.BaseTexture.prototype.destroy = function() {
            this.source && Phaser.CanvasPool.removeByCanvas(this.source),
            this.source = null,
            this.unloadFromGPU()
        }
        ,
        O.BaseTexture.prototype.updateSourceImage = function(t) {
            console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
        }
        ,
        O.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++)
                this._dirty[t] = !0
        }
        ,
        O.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; 0 <= t; t--) {
                var e = this._glTextures[t]
                  , i = O.glContexts[t];
                i && e && i.deleteTexture(e)
            }
            this._glTextures.length = 0,
            this.dirty()
        }
        ,
        O.BaseTexture.fromCanvas = function(t, e, i) {
            return 0 === t.width && (t.width = 1),
            0 === t.height && (t.height = 1),
            i = i || 1,
            new O.BaseTexture(t,e,i)
        }
        ,
        O.TextureSilentFail = !1,
        O.Texture = function(t, e, i, s) {
            this.noFrame = !1,
            e || (this.noFrame = !0,
            e = new O.Rectangle(0,0,1,1)),
            t instanceof O.Texture && (t = t.baseTexture),
            this.baseTexture = t,
            this.frame = e,
            this.trim = s,
            this.valid = !1,
            this.isTiling = !1,
            this.requiresUpdate = !1,
            this.requiresReTint = !1,
            this._uvs = null,
            this.width = 0,
            this.height = 0,
            this.crop = i || new O.Rectangle(0,0,1,1),
            this.rotated = !1,
            t.hasLoaded && (this.noFrame && (e = new O.Rectangle(0,0,t.width,t.height)),
            this.setFrame(e))
        }
        ,
        O.Texture.prototype.constructor = O.Texture,
        O.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new O.Rectangle(0,0,t.width,t.height)),
            this.setFrame(this.frame)
        }
        ,
        O.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(),
            this.valid = !1
        }
        ,
        O.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1,
            this.frame = t,
            this.width = t.width,
            this.height = t.height,
            this.crop.x = t.x,
            this.crop.y = t.y,
            this.crop.width = t.width,
            this.crop.height = t.height,
            this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height))
                this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded,
                this.trim && (this.width = this.trim.width,
                this.height = this.trim.height,
                this.frame.width = this.trim.width,
                this.frame.height = this.trim.height),
                this.valid && this._updateUvs();
            else {
                if (!O.TextureSilentFail)
                    throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                this.valid = !1
            }
        }
        ,
        O.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new O.TextureUvs);
            var t = this.crop
              , e = this.baseTexture.width
              , i = this.baseTexture.height;
            this._uvs.x0 = t.x / e,
            this._uvs.y0 = t.y / i,
            this._uvs.x1 = (t.x + t.width) / e,
            this._uvs.y1 = t.y / i,
            this._uvs.x2 = (t.x + t.width) / e,
            this._uvs.y2 = (t.y + t.height) / i,
            this._uvs.x3 = t.x / e,
            this._uvs.y3 = (t.y + t.height) / i
        }
        ,
        O.Texture.prototype._updateUvsInverted = function() {
            this._uvs || (this._uvs = new O.TextureUvs);
            var t = this.crop
              , e = this.baseTexture.width
              , i = this.baseTexture.height;
            this._uvs.x0 = t.x / e,
            this._uvs.y0 = t.y / i,
            this._uvs.x1 = (t.x + t.height) / e,
            this._uvs.y1 = t.y / i,
            this._uvs.x2 = (t.x + t.height) / e,
            this._uvs.y2 = (t.y + t.width) / i,
            this._uvs.x3 = t.x / e,
            this._uvs.y3 = (t.y + t.width) / i
        }
        ,
        O.Texture.fromCanvas = function(t, e) {
            var i = O.BaseTexture.fromCanvas(t, e);
            return new O.Texture(i)
        }
        ,
        O.TextureUvs = function() {
            this.x0 = 0,
            this.y0 = 0,
            this.x1 = 0,
            this.y1 = 0,
            this.x2 = 0,
            this.y2 = 0,
            this.x3 = 0,
            this.y3 = 0
        }
        ,
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = O),
        exports.PIXI = O) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = O) : t.PIXI = O,
        O
    }
    .call(this),
    function() {
        var r, t = this, W = W || {
            VERSION: "2.7.7",
            GAMES: [],
            AUTO: 0,
            CANVAS: 1,
            WEBGL: 2,
            HEADLESS: 3,
            WEBGL_MULTI: 4,
            NONE: 0,
            LEFT: 1,
            RIGHT: 2,
            UP: 3,
            DOWN: 4,
            SPRITE: 0,
            BUTTON: 1,
            IMAGE: 2,
            GRAPHICS: 3,
            TEXT: 4,
            TILESPRITE: 5,
            BITMAPTEXT: 6,
            GROUP: 7,
            RENDERTEXTURE: 8,
            TILEMAP: 9,
            TILEMAPLAYER: 10,
            EMITTER: 11,
            POLYGON: 12,
            BITMAPDATA: 13,
            CANVAS_FILTER: 14,
            WEBGL_FILTER: 15,
            ELLIPSE: 16,
            SPRITEBATCH: 17,
            RETROFONT: 18,
            POINTER: 19,
            ROPE: 20,
            CIRCLE: 21,
            RECTANGLE: 22,
            LINE: 23,
            MATRIX: 24,
            POINT: 25,
            ROUNDEDRECTANGLE: 26,
            CREATURE: 27,
            VIDEO: 28,
            PENDING_ATLAS: -1,
            HORIZONTAL: 0,
            VERTICAL: 1,
            LANDSCAPE: 0,
            PORTRAIT: 1,
            ANGLE_UP: 270,
            ANGLE_DOWN: 90,
            ANGLE_LEFT: 180,
            ANGLE_RIGHT: 0,
            ANGLE_NORTH_EAST: 315,
            ANGLE_NORTH_WEST: 225,
            ANGLE_SOUTH_EAST: 45,
            ANGLE_SOUTH_WEST: 135,
            TOP_LEFT: 0,
            TOP_CENTER: 1,
            TOP_RIGHT: 2,
            LEFT_TOP: 3,
            LEFT_CENTER: 4,
            LEFT_BOTTOM: 5,
            CENTER: 6,
            RIGHT_TOP: 7,
            RIGHT_CENTER: 8,
            RIGHT_BOTTOM: 9,
            BOTTOM_LEFT: 10,
            BOTTOM_CENTER: 11,
            BOTTOM_RIGHT: 12,
            blendModes: {
                NORMAL: 0,
                ADD: 1,
                MULTIPLY: 2,
                SCREEN: 3,
                OVERLAY: 4,
                DARKEN: 5,
                LIGHTEN: 6,
                COLOR_DODGE: 7,
                COLOR_BURN: 8,
                HARD_LIGHT: 9,
                SOFT_LIGHT: 10,
                DIFFERENCE: 11,
                EXCLUSION: 12,
                HUE: 13,
                SATURATION: 14,
                COLOR: 15,
                LUMINOSITY: 16
            },
            scaleModes: {
                DEFAULT: 0,
                LINEAR: 0,
                NEAREST: 1
            },
            PIXI: PIXI || {},
            _UID: 0
        };
        if (Math.trunc || (Math.trunc = function(t) {
            return t < 0 ? Math.ceil(t) : Math.floor(t)
        }
        ),
        Function.prototype.bind || (Function.prototype.bind = (r = Array.prototype.slice,
        function(e) {
            var i = this
              , s = r.call(arguments, 1);
            if ("function" != typeof i)
                throw new TypeError;
            function n() {
                var t = s.concat(r.call(arguments));
                i.apply(this instanceof n ? this : e, t)
            }
            return n.prototype = function t(e) {
                if (e && (t.prototype = e),
                !(this instanceof t))
                    return new t
            }(i.prototype),
            n
        }
        )),
        Array.isArray || (Array.isArray = function(t) {
            return "[object Array]" === Object.prototype.toString.call(t)
        }
        ),
        Array.prototype.forEach || (Array.prototype.forEach = function(t) {
            "use strict";
            if (null == this)
                throw new TypeError;
            var e = Object(this)
              , i = e.length >>> 0;
            if ("function" != typeof t)
                throw new TypeError;
            for (var s = 2 <= arguments.length ? arguments[1] : void 0, n = 0; n < i; n++)
                n in e && t.call(s, e[n], n, e)
        }
        ),
        "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            function e(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t),
                        this.length = t;
                        for (var e = 0; e < this.length; e++)
                            this[e] = 0
                    } else {
                        Array.call(this, t.length),
                        this.length = t.length;
                        for (e = 0; e < this.length; e++)
                            this[e] = t[e]
                    }
                }
                ,
                window[t].prototype = e,
                window[t].constructor = window[t]
            }
            e("Float32Array"),
            e("Uint32Array"),
            e("Uint16Array"),
            e("Int16Array"),
            e("ArrayBuffer")
        }
        function s(t, e) {
            this._scaleFactor = t,
            this._deltaMode = e,
            this.originalEvent = null
        }
        for (var i in window.console || (window.console = {},
        window.console.log = window.console.assert = function() {}
        ,
        window.console.warn = window.console.assert = function() {}
        ),
        Object.assign || (Object.assign = function(t, e) {
            "use strict";
            if (null == t)
                throw new TypeError("Cannot convert undefined or null to object");
            for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                if (null != r)
                    for (var o in r)
                        s.call(r, o) && (i[o] = r[o])
            }
            return i
        }
        ),
        W.Utils = {
            reverseString: function(t) {
                return t.split("").reverse().join("")
            },
            getProperty: function(t, e) {
                for (var i = e.split("."), s = i.pop(), n = i.length, r = 1, o = i[0]; r < n && (t = t[o]); )
                    o = i[r],
                    r++;
                return t ? t[s] : null
            },
            setProperty: function(t, e, i) {
                for (var s = e.split("."), n = s.pop(), r = s.length, o = 1, a = s[0]; o < r && (t = t[a]); )
                    a = s[o],
                    o++;
                return t && (t[n] = i),
                t
            },
            chanceRoll: function(t) {
                return void 0 === t && (t = 50),
                0 < t && 100 * Math.random() <= t
            },
            randomChoice: function(t, e) {
                return Math.random() < .5 ? t : e
            },
            parseDimension: function(t, e) {
                var i = 0;
                return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100,
                0 === e ? window.innerWidth * i : window.innerHeight * i) : parseInt(t, 10) : t
            },
            pad: function(t, e, i, s) {
                if (void 0 === e)
                    e = 0;
                if (void 0 === i)
                    i = " ";
                if (void 0 === s)
                    s = 3;
                var n = 0;
                if (e + 1 >= (t = t.toString()).length)
                    switch (s) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t;
                        break;
                    case 3:
                        var r = Math.ceil((n = e - t.length) / 2);
                        t = new Array(1 + (n - r)).join(i) + t + new Array(r + 1).join(i);
                        break;
                    default:
                        t += new Array(e + 1 - t.length).join(i)
                    }
                return t
            },
            isPlainObject: function(t) {
                if ("object" != typeof t || t.nodeType || t === t.window)
                    return !1;
                try {
                    if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf"))
                        return !1
                } catch (t) {
                    return !1
                }
                return !0
            },
            extend: function() {
                var t, e, i, s, n, r, o = arguments[0] || {}, a = 1, h = arguments.length, l = !1;
                for ("boolean" == typeof o && (l = o,
                o = arguments[1] || {},
                a = 2),
                h === a && (o = this,
                --a); a < h; a++)
                    if (null != (t = arguments[a]))
                        for (e in t)
                            i = o[e],
                            o !== (s = t[e]) && (l && s && (W.Utils.isPlainObject(s) || (n = Array.isArray(s))) ? (r = n ? (n = !1,
                            i && Array.isArray(i) ? i : []) : i && W.Utils.isPlainObject(i) ? i : {},
                            o[e] = W.Utils.extend(l, r, s)) : void 0 !== s && (o[e] = s));
                return o
            },
            mixinPrototype: function(t, e, i) {
                void 0 === i && (i = !1);
                for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                    var r = s[n]
                      , o = e[r];
                    !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                }
            },
            mixin: function(t, e) {
                if (!t || "object" != typeof t)
                    return e;
                for (var i in t) {
                    var s = t[i];
                    if (!s.childNodes && !s.cloneNode) {
                        var n = typeof t[i];
                        t[i] && "object" == n ? typeof e[i] == n ? e[i] = W.Utils.mixin(t[i], e[i]) : e[i] = W.Utils.mixin(t[i], new s.constructor) : e[i] = t[i]
                    }
                }
                return e
            }
        },
        W.Circle = function(t, e, i) {
            t = t || 0,
            e = e || 0,
            i = i || 0,
            this.x = t,
            this.y = e,
            this._diameter = i,
            (this._radius = 0) < i && (this._radius = .5 * i),
            this.type = W.CIRCLE
        }
        ,
        W.Circle.prototype = {
            circumference: function() {
                return Math.PI * this._radius * 2
            },
            random: function(t) {
                void 0 === t && (t = new W.Point);
                var e = 2 * Math.PI * Math.random()
                  , i = Math.random() + Math.random()
                  , s = 1 < i ? 2 - i : i
                  , n = s * Math.cos(e)
                  , r = s * Math.sin(e);
                return t.x = this.x + n * this.radius,
                t.y = this.y + r * this.radius,
                t
            },
            getBounds: function() {
                return new W.Rectangle(this.x - this.radius,this.y - this.radius,this.diameter,this.diameter)
            },
            setTo: function(t, e, i) {
                return this.x = t,
                this.y = e,
                this._diameter = i,
                this._radius = .5 * i,
                this
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.diameter)
            },
            copyTo: function(t) {
                return t.x = this.x,
                t.y = this.y,
                t.diameter = this._diameter,
                t
            },
            distance: function(t, e) {
                var i = W.Math.distance(this.x, this.y, t.x, t.y);
                return e ? Math.round(i) : i
            },
            clone: function(t) {
                return null == t ? t = new W.Circle(this.x,this.y,this.diameter) : t.setTo(this.x, this.y, this.diameter),
                t
            },
            contains: function(t, e) {
                return W.Circle.contains(this, t, e)
            },
            circumferencePoint: function(t, e, i) {
                return W.Circle.circumferencePoint(this, t, e, i)
            },
            offset: function(t, e) {
                return this.x += t,
                this.y += e,
                this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            toString: function() {
                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
            }
        },
        W.Circle.prototype.constructor = W.Circle,
        Object.defineProperty(W.Circle.prototype, "diameter", {
            get: function() {
                return this._diameter
            },
            set: function(t) {
                0 < t && (this._diameter = t,
                this._radius = .5 * t)
            }
        }),
        Object.defineProperty(W.Circle.prototype, "radius", {
            get: function() {
                return this._radius
            },
            set: function(t) {
                0 < t && (this._radius = t,
                this._diameter = 2 * t)
            }
        }),
        Object.defineProperty(W.Circle.prototype, "left", {
            get: function() {
                return this.x - this._radius
            },
            set: function(t) {
                t > this.x ? (this._radius = 0,
                this._diameter = 0) : this.radius = this.x - t
            }
        }),
        Object.defineProperty(W.Circle.prototype, "right", {
            get: function() {
                return this.x + this._radius
            },
            set: function(t) {
                t < this.x ? (this._radius = 0,
                this._diameter = 0) : this.radius = t - this.x
            }
        }),
        Object.defineProperty(W.Circle.prototype, "top", {
            get: function() {
                return this.y - this._radius
            },
            set: function(t) {
                t > this.y ? (this._radius = 0,
                this._diameter = 0) : this.radius = this.y - t
            }
        }),
        Object.defineProperty(W.Circle.prototype, "bottom", {
            get: function() {
                return this.y + this._radius
            },
            set: function(t) {
                t < this.y ? (this._radius = 0,
                this._diameter = 0) : this.radius = t - this.y
            }
        }),
        Object.defineProperty(W.Circle.prototype, "area", {
            get: function() {
                return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
            }
        }),
        Object.defineProperty(W.Circle.prototype, "empty", {
            get: function() {
                return 0 === this._diameter
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0)
            }
        }),
        W.Circle.contains = function(t, e, i) {
            return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
        }
        ,
        W.Circle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.diameter === e.diameter
        }
        ,
        W.Circle.intersects = function(t, e) {
            return W.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
        }
        ,
        W.Circle.circumferencePoint = function(t, e, i, s) {
            return void 0 === i && (i = !1),
            void 0 === s && (s = new W.Point),
            !0 === i && (e = W.Math.degToRad(e)),
            s.x = t.x + t.radius * Math.cos(e),
            s.y = t.y + t.radius * Math.sin(e),
            s
        }
        ,
        W.Circle.intersectsRectangle = function(t, e) {
            var i = Math.abs(t.x - e.x - e.halfWidth);
            if (e.halfWidth + t.radius < i)
                return !1;
            var s = Math.abs(t.y - e.y - e.halfHeight);
            if (e.halfHeight + t.radius < s)
                return !1;
            if (i <= e.halfWidth || s <= e.halfHeight)
                return !0;
            var n = i - e.halfWidth
              , r = s - e.halfHeight;
            return n * n + r * r <= t.radius * t.radius
        }
        ,
        PIXI.Circle = W.Circle,
        W.Ellipse = function(t, e, i, s) {
            t = t || 0,
            e = e || 0,
            i = i || 0,
            s = s || 0,
            this.x = t,
            this.y = e,
            this.width = i,
            this.height = s,
            this.type = W.ELLIPSE
        }
        ,
        W.Ellipse.prototype = {
            setTo: function(t, e, i, s) {
                return this.x = t,
                this.y = e,
                this.width = i,
                this.height = s,
                this
            },
            getBounds: function() {
                return new W.Rectangle(this.x - this.width,this.y - this.height,this.width,this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x,
                t.y = this.y,
                t.width = this.width,
                t.height = this.height,
                t
            },
            clone: function(t) {
                return null == t ? t = new W.Ellipse(this.x,this.y,this.width,this.height) : t.setTo(this.x, this.y, this.width, this.height),
                t
            },
            contains: function(t, e) {
                return W.Ellipse.contains(this, t, e)
            },
            random: function(t) {
                void 0 === t && (t = new W.Point);
                var e = Math.random() * Math.PI * 2
                  , i = Math.random();
                return t.x = Math.sqrt(i) * Math.cos(e),
                t.y = Math.sqrt(i) * Math.sin(e),
                t.x = this.x + t.x * this.width / 2,
                t.y = this.y + t.y * this.height / 2,
                t
            },
            toString: function() {
                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
            }
        },
        W.Ellipse.prototype.constructor = W.Ellipse,
        Object.defineProperty(W.Ellipse.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        }),
        Object.defineProperty(W.Ellipse.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t < this.x ? this.width = 0 : this.width = t - this.x
            }
        }),
        Object.defineProperty(W.Ellipse.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }),
        Object.defineProperty(W.Ellipse.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t < this.y ? this.height = 0 : this.height = t - this.y
            }
        }),
        Object.defineProperty(W.Ellipse.prototype, "empty", {
            get: function() {
                return 0 === this.width || 0 === this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }),
        W.Ellipse.contains = function(t, e, i) {
            if (t.width <= 0 || t.height <= 0)
                return !1;
            var s = (e - t.x) / t.width - .5
              , n = (i - t.y) / t.height - .5;
            return (s *= s) + (n *= n) < .25
        }
        ,
        PIXI.Ellipse = W.Ellipse,
        W.Line = function(t, e, i, s) {
            t = t || 0,
            e = e || 0,
            i = i || 0,
            s = s || 0,
            this.start = new W.Point(t,e),
            this.end = new W.Point(i,s),
            this.type = W.LINE
        }
        ,
        W.Line.prototype = {
            setTo: function(t, e, i, s) {
                return this.start.setTo(t, e),
                this.end.setTo(i, s),
                this
            },
            fromSprite: function(t, e, i) {
                return void 0 === i && (i = !1),
                i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.setTo(t.x, t.y, e.x, e.y)
            },
            fromAngle: function(t, e, i, s) {
                return this.start.setTo(t, e),
                this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s),
                this
            },
            rotate: function(t, e) {
                var i = (this.start.x + this.end.x) / 2
                  , s = (this.start.y + this.end.y) / 2;
                return this.start.rotate(i, s, t, e),
                this.end.rotate(i, s, t, e),
                this
            },
            rotateAround: function(t, e, i, s) {
                return this.start.rotate(t, e, i, s),
                this.end.rotate(t, e, i, s),
                this
            },
            intersects: function(t, e, i) {
                return W.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
            },
            reflect: function(t) {
                return W.Line.reflect(this, t)
            },
            midPoint: function(t) {
                return void 0 === t && (t = new W.Point),
                t.x = (this.start.x + this.end.x) / 2,
                t.y = (this.start.y + this.end.y) / 2,
                t
            },
            centerOn: function(t, e) {
                var i = t - (this.start.x + this.end.x) / 2
                  , s = e - (this.start.y + this.end.y) / 2;
                this.start.add(i, s),
                this.end.add(i, s)
            },
            pointOnLine: function(t, e) {
                return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
            },
            pointOnSegment: function(t, e) {
                var i = Math.min(this.start.x, this.end.x)
                  , s = Math.max(this.start.x, this.end.x)
                  , n = Math.min(this.start.y, this.end.y)
                  , r = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(t, e) && i <= t && t <= s && n <= e && e <= r
            },
            random: function(t) {
                void 0 === t && (t = new W.Point);
                var e = Math.random();
                return t.x = this.start.x + e * (this.end.x - this.start.x),
                t.y = this.start.y + e * (this.end.y - this.start.y),
                t
            },
            coordinatesOnLine: function(t, e) {
                void 0 === t && (t = 1),
                void 0 === e && (e = []);
                var i = Math.round(this.start.x)
                  , s = Math.round(this.start.y)
                  , n = Math.round(this.end.x)
                  , r = Math.round(this.end.y)
                  , o = Math.abs(n - i)
                  , a = Math.abs(r - s)
                  , h = i < n ? 1 : -1
                  , l = s < r ? 1 : -1
                  , c = o - a;
                e.push([i, s]);
                for (var u = 1; i !== n || s !== r; ) {
                    var d = c << 1;
                    -a < d && (c -= a,
                    i += h),
                    d < o && (c += o,
                    s += l),
                    u % t == 0 && e.push([i, s]),
                    u++
                }
                return e
            },
            clone: function(t) {
                return null == t ? t = new W.Line(this.start.x,this.start.y,this.end.x,this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y),
                t
            }
        },
        Object.defineProperty(W.Line.prototype, "length", {
            get: function() {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
            }
        }),
        Object.defineProperty(W.Line.prototype, "angle", {
            get: function() {
                return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "perpSlope", {
            get: function() {
                return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
            }
        }),
        Object.defineProperty(W.Line.prototype, "x", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "y", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }),
        Object.defineProperty(W.Line.prototype, "left", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "right", {
            get: function() {
                return Math.max(this.start.x, this.end.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "top", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }),
        Object.defineProperty(W.Line.prototype, "bottom", {
            get: function() {
                return Math.max(this.start.y, this.end.y)
            }
        }),
        Object.defineProperty(W.Line.prototype, "width", {
            get: function() {
                return Math.abs(this.start.x - this.end.x)
            }
        }),
        Object.defineProperty(W.Line.prototype, "height", {
            get: function() {
                return Math.abs(this.start.y - this.end.y)
            }
        }),
        Object.defineProperty(W.Line.prototype, "normalX", {
            get: function() {
                return Math.cos(this.angle - 1.5707963267948966)
            }
        }),
        Object.defineProperty(W.Line.prototype, "normalY", {
            get: function() {
                return Math.sin(this.angle - 1.5707963267948966)
            }
        }),
        Object.defineProperty(W.Line.prototype, "normalAngle", {
            get: function() {
                return W.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
            }
        }),
        W.Line.intersectsPoints = function(t, e, i, s, n, r) {
            void 0 === n && (n = !0),
            void 0 === r && (r = new W.Point);
            var o = e.y - t.y
              , a = s.y - i.y
              , h = t.x - e.x
              , l = i.x - s.x
              , c = e.x * t.y - t.x * e.y
              , u = s.x * i.y - i.x * s.y
              , d = o * l - a * h;
            if (0 == d)
                return null;
            if (r.x = (h * u - l * c) / d,
            r.y = (a * c - o * u) / d,
            n) {
                var p = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y)
                  , f = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / p
                  , g = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / p;
                return 0 <= f && f <= 1 && 0 <= g && g <= 1 ? r : null
            }
            return r
        }
        ,
        W.Line.intersects = function(t, e, i, s) {
            return W.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
        }
        ,
        W.Line.intersectsRectangle = function(t, e) {
            if (0 === t.length || e.empty)
                return !1;
            var i = t.start.x
              , s = t.start.y
              , n = t.end.x
              , r = t.end.y
              , o = e.x
              , a = e.y
              , h = e.right
              , l = e.bottom
              , c = 0;
            if (o <= i && i <= h && a <= s && s <= l || o <= n && n <= h && a <= r && r <= l)
                return !0;
            if (i < o && o <= n) {
                if (a < (c = s + (r - s) * (o - i) / (n - i)) && c <= l)
                    return !0
            } else if (h < i && n <= h && a <= (c = s + (r - s) * (h - i) / (n - i)) && c <= l)
                return !0;
            if (s < a && a <= r) {
                if (o <= (c = i + (n - i) * (a - s) / (r - s)) && c <= h)
                    return !0
            } else if (l < s && r <= l && o <= (c = i + (n - i) * (l - s) / (r - s)) && c <= h)
                return !0;
            return !1
        }
        ,
        W.Line.reflect = function(t, e) {
            return 2 * e.normalAngle - 3.141592653589793 - t.angle
        }
        ,
        W.Matrix = function(t, e, i, s, n, r) {
            null == t && (t = 1),
            null == e && (e = 0),
            null == i && (i = 0),
            null == s && (s = 1),
            null == n && (n = 0),
            null == r && (r = 0),
            this.a = t,
            this.b = e,
            this.c = i,
            this.d = s,
            this.tx = n,
            this.ty = r,
            this.type = W.MATRIX
        }
        ,
        W.Matrix.prototype = {
            fromArray: function(t) {
                return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
            },
            setTo: function(t, e, i, s, n, r) {
                return this.a = t,
                this.b = e,
                this.c = i,
                this.d = s,
                this.tx = n,
                this.ty = r,
                this
            },
            clone: function(t) {
                return null == t ? t = new W.Matrix(this.a,this.b,this.c,this.d,this.tx,this.ty) : (t.a = this.a,
                t.b = this.b,
                t.c = this.c,
                t.d = this.d,
                t.tx = this.tx,
                t.ty = this.ty),
                t
            },
            copyTo: function(t) {
                return t.copyFrom(this),
                t
            },
            copyFrom: function(t) {
                return this.a = t.a,
                this.b = t.b,
                this.c = t.c,
                this.d = t.d,
                this.tx = t.tx,
                this.ty = t.ty,
                this
            },
            toArray: function(t, e) {
                return void 0 === e && (e = new Float32Array(9)),
                t ? (e[0] = this.a,
                e[1] = this.b,
                e[2] = 0,
                e[3] = this.c,
                e[4] = this.d,
                e[5] = 0,
                e[6] = this.tx,
                e[7] = this.ty) : (e[0] = this.a,
                e[1] = this.c,
                e[2] = this.tx,
                e[3] = this.b,
                e[4] = this.d,
                e[5] = this.ty,
                e[6] = 0,
                e[7] = 0),
                e[8] = 1,
                e
            },
            apply: function(t, e) {
                return void 0 === e && (e = new W.Point),
                e.x = this.a * t.x + this.c * t.y + this.tx,
                e.y = this.b * t.x + this.d * t.y + this.ty,
                e
            },
            applyInverse: function(t, e) {
                void 0 === e && (e = new W.Point);
                var i = 1 / (this.a * this.d + this.c * -this.b)
                  , s = t.x
                  , n = t.y;
                return e.x = this.d * i * s + -this.c * i * n + (this.ty * this.c - this.tx * this.d) * i,
                e.y = this.a * i * n + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i,
                e
            },
            translate: function(t, e) {
                return this.tx += t,
                this.ty += e,
                this
            },
            scale: function(t, e) {
                return this.a *= t,
                this.d *= e,
                this.c *= t,
                this.b *= e,
                this.tx *= t,
                this.ty *= e,
                this
            },
            rotate: function(t) {
                var e = Math.cos(t)
                  , i = Math.sin(t)
                  , s = this.a
                  , n = this.c
                  , r = this.tx;
                return this.a = s * e - this.b * i,
                this.b = s * i + this.b * e,
                this.c = n * e - this.d * i,
                this.d = n * i + this.d * e,
                this.tx = r * e - this.ty * i,
                this.ty = r * i + this.ty * e,
                this
            },
            append: function(t) {
                var e = this.a
                  , i = this.b
                  , s = this.c
                  , n = this.d;
                return this.a = t.a * e + t.b * s,
                this.b = t.a * i + t.b * n,
                this.c = t.c * e + t.d * s,
                this.d = t.c * i + t.d * n,
                this.tx = t.tx * e + t.ty * s + this.tx,
                this.ty = t.tx * i + t.ty * n + this.ty,
                this
            },
            identity: function() {
                return this.setTo(1, 0, 0, 1, 0, 0)
            }
        },
        W.identityMatrix = new W.Matrix,
        PIXI.Matrix = W.Matrix,
        PIXI.identityMatrix = W.identityMatrix,
        W.Point = function(t, e) {
            t = t || 0,
            e = e || 0,
            this.x = t,
            this.y = e,
            this.type = W.POINT
        }
        ,
        W.Point.prototype = {
            copyFrom: function(t) {
                return this.setTo(t.x, t.y)
            },
            invert: function() {
                return this.setTo(this.y, this.x)
            },
            setTo: function(t, e) {
                return this.x = t || 0,
                this.y = e || (0 !== e ? this.x : 0),
                this
            },
            set: function(t, e) {
                return this.x = t || 0,
                this.y = e || (0 !== e ? this.x : 0),
                this
            },
            add: function(t, e) {
                return this.x += t,
                this.y += e,
                this
            },
            subtract: function(t, e) {
                return this.x -= t,
                this.y -= e,
                this
            },
            multiply: function(t, e) {
                return this.x *= t,
                this.y *= e,
                this
            },
            divide: function(t, e) {
                return this.x /= t,
                this.y /= e,
                this
            },
            clampX: function(t, e) {
                return this.x = W.Math.clamp(this.x, t, e),
                this
            },
            clampY: function(t, e) {
                return this.y = W.Math.clamp(this.y, t, e),
                this
            },
            clamp: function(t, e) {
                return this.x = W.Math.clamp(this.x, t, e),
                this.y = W.Math.clamp(this.y, t, e),
                this
            },
            clone: function(t) {
                return null == t ? t = new W.Point(this.x,this.y) : t.setTo(this.x, this.y),
                t
            },
            copyTo: function(t) {
                return t.x = this.x,
                t.y = this.y,
                t
            },
            distance: function(t, e) {
                return W.Point.distance(this, t, e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            angle: function(t, e) {
                return void 0 === e && (e = !1),
                e ? W.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
            },
            rotate: function(t, e, i, s, n) {
                return W.Point.rotate(this, t, e, i, s, n)
            },
            getMagnitude: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            getMagnitudeSq: function() {
                return this.x * this.x + this.y * this.y
            },
            setMagnitude: function(t) {
                return this.normalize().multiply(t, t)
            },
            normalize: function() {
                if (!this.isZero()) {
                    var t = this.getMagnitude();
                    this.x /= t,
                    this.y /= t
                }
                return this
            },
            limit: function(t) {
                return this.getMagnitudeSq() > t * t && this.setMagnitude(t),
                this
            },
            isZero: function() {
                return 0 === this.x && 0 === this.y
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            perp: function() {
                return this.setTo(-this.y, this.x)
            },
            rperp: function() {
                return this.setTo(this.y, -this.x)
            },
            normalRightHand: function() {
                return this.setTo(-1 * this.y, this.x)
            },
            floor: function() {
                return this.setTo(Math.floor(this.x), Math.floor(this.y))
            },
            ceil: function() {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
            },
            toString: function() {
                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
            }
        },
        W.Point.prototype.constructor = W.Point,
        W.Point.add = function(t, e, i) {
            return void 0 === i && (i = new W.Point),
            i.x = t.x + e.x,
            i.y = t.y + e.y,
            i
        }
        ,
        W.Point.subtract = function(t, e, i) {
            return void 0 === i && (i = new W.Point),
            i.x = t.x - e.x,
            i.y = t.y - e.y,
            i
        }
        ,
        W.Point.multiply = function(t, e, i) {
            return void 0 === i && (i = new W.Point),
            i.x = t.x * e.x,
            i.y = t.y * e.y,
            i
        }
        ,
        W.Point.divide = function(t, e, i) {
            return void 0 === i && (i = new W.Point),
            i.x = t.x / e.x,
            i.y = t.y / e.y,
            i
        }
        ,
        W.Point.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }
        ,
        W.Point.angle = function(t, e) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }
        ,
        W.Point.negative = function(t, e) {
            return void 0 === e && (e = new W.Point),
            e.setTo(-t.x, -t.y)
        }
        ,
        W.Point.multiplyAdd = function(t, e, i, s) {
            return void 0 === s && (s = new W.Point),
            s.setTo(t.x + e.x * i, t.y + e.y * i)
        }
        ,
        W.Point.interpolate = function(t, e, i, s) {
            return void 0 === s && (s = new W.Point),
            s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
        }
        ,
        W.Point.perp = function(t, e) {
            return void 0 === e && (e = new W.Point),
            e.setTo(-t.y, t.x)
        }
        ,
        W.Point.rperp = function(t, e) {
            return void 0 === e && (e = new W.Point),
            e.setTo(t.y, -t.x)
        }
        ,
        W.Point.distance = function(t, e, i) {
            var s = W.Math.distance(t.x, t.y, e.x, e.y);
            return i ? Math.round(s) : s
        }
        ,
        W.Point.project = function(t, e, i) {
            void 0 === i && (i = new W.Point);
            var s = t.dot(e) / e.getMagnitudeSq();
            return 0 != s && i.setTo(s * e.x, s * e.y),
            i
        }
        ,
        W.Point.projectUnit = function(t, e, i) {
            void 0 === i && (i = new W.Point);
            var s = t.dot(e);
            return 0 !== s && i.setTo(s * e.x, s * e.y),
            i
        }
        ,
        W.Point.normalRightHand = function(t, e) {
            return void 0 === e && (e = new W.Point),
            e.setTo(-1 * t.y, t.x)
        }
        ,
        W.Point.normalize = function(t, e) {
            void 0 === e && (e = new W.Point);
            var i = t.getMagnitude();
            return 0 !== i && e.setTo(t.x / i, t.y / i),
            e
        }
        ,
        W.Point.rotate = function(t, e, i, s, n, r) {
            if (n && (s = W.Math.degToRad(s)),
            void 0 === r) {
                t.subtract(e, i);
                var o = Math.sin(s)
                  , a = Math.cos(s)
                  , h = a * t.x - o * t.y
                  , l = o * t.x + a * t.y;
                t.x = h + e,
                t.y = l + i
            } else {
                var c = s + Math.atan2(t.y - i, t.x - e);
                t.x = e + r * Math.cos(c),
                t.y = i + r * Math.sin(c)
            }
            return t
        }
        ,
        W.Point.centroid = function(t, e) {
            if (void 0 === e && (e = new W.Point),
            "[object Array]" !== Object.prototype.toString.call(t))
                throw new Error("Phaser.Point. Parameter 'points' must be an array");
            var i = t.length;
            if (i < 1)
                throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            if (1 === i)
                return e.copyFrom(t[0]),
                e;
            for (var s = 0; s < i; s++)
                W.Point.add(e, t[s], e);
            return e.divide(i, i),
            e
        }
        ,
        W.Point.parse = function(t, e, i) {
            e = e || "x",
            i = i || "y";
            var s = new W.Point;
            return t[e] && (s.x = parseInt(t[e], 10)),
            t[i] && (s.y = parseInt(t[i], 10)),
            s
        }
        ,
        PIXI.Point = W.Point,
        W.Polygon = function() {
            this.area = 0,
            this._points = [],
            0 < arguments.length && this.setTo.apply(this, arguments),
            this.closed = !0,
            this.flattened = !1,
            this.type = W.POLYGON
        }
        ,
        W.Polygon.prototype = {
            toNumberArray: function(t) {
                void 0 === t && (t = []);
                for (var e = 0; e < this._points.length; e++)
                    "number" == typeof this._points[e] ? (t.push(this._points[e]),
                    t.push(this._points[e + 1]),
                    e++) : (t.push(this._points[e].x),
                    t.push(this._points[e].y));
                return t
            },
            flatten: function() {
                return this._points = this.toNumberArray(),
                this.flattened = !0,
                this
            },
            clone: function(t) {
                var e = this._points.slice();
                return null == t ? t = new W.Polygon(e) : t.setTo(e),
                t
            },
            contains: function(t, e) {
                var i = !1;
                if (this.flattened)
                    for (var s = -2, n = this._points.length - 2; (s += 2) < this._points.length; n = s) {
                        var r = this._points[s]
                          , o = this._points[s + 1]
                          , a = this._points[n]
                          , h = this._points[n + 1];
                        (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                    }
                else
                    for (s = -1,
                    n = this._points.length - 1; ++s < this._points.length; n = s) {
                        r = this._points[s].x,
                        o = this._points[s].y,
                        a = this._points[n].x,
                        h = this._points[n].y;
                        (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                    }
                return i
            },
            setTo: function(t) {
                if (this.area = 0,
                this._points = [],
                0 < arguments.length) {
                    Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                    for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                        if ("number" == typeof t[i]) {
                            var n = new PIXI.Point(t[i],t[i + 1]);
                            i++
                        } else if (Array.isArray(t[i]))
                            n = new PIXI.Point(t[i][0],t[i][1]);
                        else
                            n = new PIXI.Point(t[i].x,t[i].y);
                        this._points.push(n),
                        n.y < e && (e = n.y)
                    }
                    this.calculateArea(e)
                }
                return this
            },
            calculateArea: function(t) {
                for (var e, i, s, n, r = 0, o = this._points.length; r < o; r++)
                    e = this._points[r],
                    i = r === o - 1 ? this._points[0] : this._points[r + 1],
                    s = (e.y - t + (i.y - t)) / 2,
                    n = e.x - i.x,
                    this.area += s * n;
                return this.area
            }
        },
        W.Polygon.prototype.constructor = W.Polygon,
        Object.defineProperty(W.Polygon.prototype, "points", {
            get: function() {
                return this._points
            },
            set: function(t) {
                null != t ? this.setTo(t) : this.setTo()
            }
        }),
        PIXI.Polygon = W.Polygon,
        W.Rectangle = function(t, e, i, s) {
            t = t || 0,
            e = e || 0,
            i = i || 0,
            s = s || 0,
            this.x = t,
            this.y = e,
            this.width = i,
            this.height = s,
            this.type = W.RECTANGLE
        }
        ,
        W.Rectangle.prototype = {
            offset: function(t, e) {
                return this.x += t,
                this.y += e,
                this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            setTo: function(t, e, i, s) {
                return this.x = t,
                this.y = e,
                this.width = i,
                this.height = s,
                this
            },
            scale: function(t, e) {
                return void 0 === e && (e = t),
                this.width *= t,
                this.height *= e,
                this
            },
            centerOn: function(t, e) {
                return this.centerX = t,
                this.centerY = e,
                this
            },
            floor: function() {
                this.x = Math.floor(this.x),
                this.y = Math.floor(this.y)
            },
            floorAll: function() {
                this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.width = Math.floor(this.width),
                this.height = Math.floor(this.height)
            },
            ceil: function() {
                this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y)
            },
            ceilAll: function() {
                this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.width = Math.ceil(this.width),
                this.height = Math.ceil(this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x,
                t.y = this.y,
                t.width = this.width,
                t.height = this.height,
                t
            },
            inflate: function(t, e) {
                return W.Rectangle.inflate(this, t, e)
            },
            size: function(t) {
                return W.Rectangle.size(this, t)
            },
            resize: function(t, e) {
                return this.width = t,
                this.height = e,
                this
            },
            clone: function(t) {
                return W.Rectangle.clone(this, t)
            },
            contains: function(t, e) {
                return W.Rectangle.contains(this, t, e)
            },
            containsRect: function(t) {
                return W.Rectangle.containsRect(t, this)
            },
            equals: function(t) {
                return W.Rectangle.equals(this, t)
            },
            intersection: function(t, e) {
                return W.Rectangle.intersection(this, t, e)
            },
            intersects: function(t) {
                return W.Rectangle.intersects(this, t)
            },
            intersectsRaw: function(t, e, i, s, n) {
                return W.Rectangle.intersectsRaw(this, t, e, i, s, n)
            },
            union: function(t, e) {
                return W.Rectangle.union(this, t, e)
            },
            random: function(t) {
                return void 0 === t && (t = new W.Point),
                t.x = this.randomX,
                t.y = this.randomY,
                t
            },
            getPoint: function(t, e) {
                switch (void 0 === e && (e = new W.Point),
                t) {
                default:
                case W.TOP_LEFT:
                    return e.set(this.x, this.y);
                case W.TOP_CENTER:
                    return e.set(this.centerX, this.y);
                case W.TOP_RIGHT:
                    return e.set(this.right, this.y);
                case W.LEFT_CENTER:
                    return e.set(this.x, this.centerY);
                case W.CENTER:
                    return e.set(this.centerX, this.centerY);
                case W.RIGHT_CENTER:
                    return e.set(this.right, this.centerY);
                case W.BOTTOM_LEFT:
                    return e.set(this.x, this.bottom);
                case W.BOTTOM_CENTER:
                    return e.set(this.centerX, this.bottom);
                case W.BOTTOM_RIGHT:
                    return e.set(this.right, this.bottom)
                }
            },
            toString: function() {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
            }
        },
        Object.defineProperty(W.Rectangle.prototype, "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "halfHeight", {
            get: function() {
                return Math.round(this.height / 2)
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t <= this.y ? this.height = 0 : this.height = t - this.y
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "bottomLeft", {
            get: function() {
                return new W.Point(this.x,this.bottom)
            },
            set: function(t) {
                this.x = t.x,
                this.bottom = t.y
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "bottomRight", {
            get: function() {
                return new W.Point(this.right,this.bottom)
            },
            set: function(t) {
                this.right = t.x,
                this.bottom = t.y
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                t >= this.right ? this.width = 0 : this.width = this.right - t,
                this.x = t
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t <= this.x ? this.width = 0 : this.width = t - this.x
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "volume", {
            get: function() {
                return this.width * this.height
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "perimeter", {
            get: function() {
                return 2 * this.width + 2 * this.height
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "centerX", {
            get: function() {
                return this.x + this.halfWidth
            },
            set: function(t) {
                this.x = t - this.halfWidth
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "centerY", {
            get: function() {
                return this.y + this.halfHeight
            },
            set: function(t) {
                this.y = t - this.halfHeight
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "randomX", {
            get: function() {
                return this.x + Math.random() * this.width
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "randomY", {
            get: function() {
                return this.y + Math.random() * this.height
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                t >= this.bottom ? (this.height = 0,
                this.y = t) : this.height = this.bottom - t
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "topLeft", {
            get: function() {
                return new W.Point(this.x,this.y)
            },
            set: function(t) {
                this.x = t.x,
                this.y = t.y
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "topRight", {
            get: function() {
                return new W.Point(this.x + this.width,this.y)
            },
            set: function(t) {
                this.right = t.x,
                this.y = t.y
            }
        }),
        Object.defineProperty(W.Rectangle.prototype, "empty", {
            get: function() {
                return !this.width || !this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }),
        W.Rectangle.prototype.constructor = W.Rectangle,
        W.Rectangle.inflate = function(t, e, i) {
            return t.x -= e,
            t.width += 2 * e,
            t.y -= i,
            t.height += 2 * i,
            t
        }
        ,
        W.Rectangle.inflatePoint = function(t, e) {
            return W.Rectangle.inflate(t, e.x, e.y)
        }
        ,
        W.Rectangle.size = function(t, e) {
            return null == e ? e = new W.Point(t.width,t.height) : e.setTo(t.width, t.height),
            e
        }
        ,
        W.Rectangle.clone = function(t, e) {
            return null == e ? e = new W.Rectangle(t.x,t.y,t.width,t.height) : e.setTo(t.x, t.y, t.width, t.height),
            e
        }
        ,
        W.Rectangle.contains = function(t, e, i) {
            return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
        }
        ,
        W.Rectangle.containsRaw = function(t, e, i, s, n, r) {
            return t <= n && n < t + i && e <= r && r < e + s
        }
        ,
        W.Rectangle.containsPoint = function(t, e) {
            return W.Rectangle.contains(t, e.x, e.y)
        }
        ,
        W.Rectangle.containsRect = function(t, e) {
            return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
        }
        ,
        W.Rectangle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
        }
        ,
        W.Rectangle.sameDimensions = function(t, e) {
            return t.width === e.width && t.height === e.height
        }
        ,
        W.Rectangle.intersection = function(t, e, i) {
            return void 0 === i && (i = new W.Rectangle),
            W.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x),
            i.y = Math.max(t.y, e.y),
            i.width = Math.min(t.right, e.right) - i.x,
            i.height = Math.min(t.bottom, e.bottom) - i.y),
            i
        }
        ,
        W.Rectangle.intersects = function(t, e) {
            return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
        }
        ,
        W.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
            return void 0 === r && (r = 0),
            !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
        }
        ,
        W.Rectangle.union = function(t, e, i) {
            return void 0 === i && (i = new W.Rectangle),
            i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
        }
        ,
        W.Rectangle.aabb = function(t, e) {
            void 0 === e && (e = new W.Rectangle);
            var i = Number.NEGATIVE_INFINITY
              , s = Number.POSITIVE_INFINITY
              , n = Number.NEGATIVE_INFINITY
              , r = Number.POSITIVE_INFINITY;
            return t.forEach(function(t) {
                t.x > i && (i = t.x),
                t.x < s && (s = t.x),
                t.y > n && (n = t.y),
                t.y < r && (r = t.y)
            }),
            e.setTo(s, r, i - s, n - r),
            e
        }
        ,
        PIXI.Rectangle = W.Rectangle,
        PIXI.EmptyRectangle = new W.Rectangle(0,0,0,0),
        W.RoundedRectangle = function(t, e, i, s, n) {
            void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = 0),
            void 0 === n && (n = 20),
            this.x = t,
            this.y = e,
            this.width = i,
            this.height = s,
            this.radius = n || 20,
            this.type = W.ROUNDEDRECTANGLE
        }
        ,
        W.RoundedRectangle.prototype = {
            clone: function() {
                return new W.RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)
            },
            contains: function(t, e) {
                if (this.width <= 0 || this.height <= 0)
                    return !1;
                var i = this.x;
                if (i <= t && t <= i + this.width) {
                    var s = this.y;
                    if (s <= e && e <= s + this.height)
                        return !0
                }
                return !1
            }
        },
        W.RoundedRectangle.prototype.constructor = W.RoundedRectangle,
        PIXI.RoundedRectangle = W.RoundedRectangle,
        W.Camera = function(t, e, i, s, n, r) {
            this.game = t,
            this.world = t.world,
            this.id = 0,
            this.view = new W.Rectangle(i,s,n,r),
            this.bounds = new W.Rectangle(i,s,n,r),
            this.deadzone = null,
            this.visible = !0,
            this.roundPx = !0,
            this.atLimit = {
                x: !1,
                y: !1
            },
            this.target = null,
            this.displayObject = null,
            this.scale = null,
            this.totalInView = 0,
            this.lerp = new W.Point(1,1),
            this.onShakeComplete = new W.Signal,
            this.onFlashComplete = new W.Signal,
            this.onFadeComplete = new W.Signal,
            this.fx = null,
            this._targetPosition = new W.Point,
            this._edge = 0,
            this._position = new W.Point,
            this._shake = {
                intensity: 0,
                duration: 0,
                horizontal: !1,
                vertical: !1,
                shakeBounds: !0,
                x: 0,
                y: 0
            },
            this._fxDuration = 0,
            this._fxType = 0
        }
        ,
        W.Camera.FOLLOW_LOCKON = 0,
        W.Camera.FOLLOW_PLATFORMER = 1,
        W.Camera.FOLLOW_TOPDOWN = 2,
        W.Camera.FOLLOW_TOPDOWN_TIGHT = 3,
        W.Camera.SHAKE_BOTH = 4,
        W.Camera.SHAKE_HORIZONTAL = 5,
        W.Camera.SHAKE_VERTICAL = 6,
        W.Camera.ENABLE_FX = !0,
        W.Camera.prototype = {
            boot: function() {
                this.displayObject = this.game.world,
                this.scale = this.game.world.scale,
                this.game.camera = this,
                W.Graphics && W.Camera.ENABLE_FX && (this.fx = new W.Graphics(this.game),
                this.game.stage.addChild(this.fx))
            },
            preUpdate: function() {
                this.totalInView = 0
            },
            follow: function(t, e, i, s) {
                var n;
                switch (void 0 === e && (e = W.Camera.FOLLOW_LOCKON),
                void 0 === i && (i = 1),
                void 0 === s && (s = 1),
                this.target = t,
                this.lerp.set(i, s),
                e) {
                case W.Camera.FOLLOW_PLATFORMER:
                    var r = this.width / 8
                      , o = this.height / 3;
                    this.deadzone = new W.Rectangle((this.width - r) / 2,(this.height - o) / 2 - .25 * o,r,o);
                    break;
                case W.Camera.FOLLOW_TOPDOWN:
                    n = Math.max(this.width, this.height) / 4,
                    this.deadzone = new W.Rectangle((this.width - n) / 2,(this.height - n) / 2,n,n);
                    break;
                case W.Camera.FOLLOW_TOPDOWN_TIGHT:
                    n = Math.max(this.width, this.height) / 8,
                    this.deadzone = new W.Rectangle((this.width - n) / 2,(this.height - n) / 2,n,n);
                    break;
                case W.Camera.FOLLOW_LOCKON:
                default:
                    this.deadzone = null
                }
            },
            unfollow: function() {
                this.target = null
            },
            focusOn: function(t) {
                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
            },
            focusOnXY: function(t, e) {
                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
            },
            shake: function(t, e, i, s, n) {
                return void 0 === t && (t = .05),
                void 0 === e && (e = 500),
                void 0 === i && (i = !0),
                void 0 === s && (s = W.Camera.SHAKE_BOTH),
                void 0 === n && (n = !0),
                !(!i && 0 < this._shake.duration) && (this._shake.intensity = t,
                this._shake.duration = e,
                this._shake.shakeBounds = n,
                this._shake.x = 0,
                this._shake.y = 0,
                this._shake.horizontal = s === W.Camera.SHAKE_BOTH || s === W.Camera.SHAKE_HORIZONTAL,
                this._shake.vertical = s === W.Camera.SHAKE_BOTH || s === W.Camera.SHAKE_VERTICAL,
                !0)
            },
            flash: function(t, e, i, s) {
                return void 0 === t && (t = 16777215),
                void 0 === e && (e = 500),
                void 0 === i && (i = !1),
                void 0 === s && (s = 1),
                !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(),
                this.fx.beginFill(t, s),
                this.fx.drawRect(0, 0, this.width, this.height),
                this.fx.endFill(),
                this.fx.alpha = 1,
                this._fxDuration = e,
                !(this._fxType = 0))
            },
            fade: function(t, e, i, s) {
                return void 0 === t && (t = 0),
                void 0 === e && (e = 500),
                void 0 === i && (i = !1),
                void 0 === s && (s = 1),
                !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(),
                this.fx.beginFill(t, s),
                this.fx.drawRect(0, 0, this.width, this.height),
                this.fx.endFill(),
                this.fx.alpha = 0,
                this._fxDuration = e,
                this._fxType = 1,
                !0)
            },
            update: function() {
                0 < this._fxDuration && this.updateFX(),
                0 < this._shake.duration && this.updateShake(),
                this.bounds && this.checkBounds(),
                this.roundPx && (this.view.floor(),
                this._shake.x = Math.floor(this._shake.x),
                this._shake.y = Math.floor(this._shake.y)),
                this.displayObject.position.x = -this.view.x,
                this.displayObject.position.y = -this.view.y
            },
            updateFX: function() {
                0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration,
                this.fx.alpha <= 0 && (this._fxDuration = 0,
                this.fx.alpha = 0,
                this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration,
                1 <= this.fx.alpha && (this._fxDuration = 0,
                this.fx.alpha = 1,
                this.onFadeComplete.dispatch()))
            },
            updateShake: function() {
                this._shake.duration -= this.game.time.elapsedMS,
                this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(),
                this._shake.x = 0,
                this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width),
                this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
            },
            updateTarget: function() {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x,
                this._targetPosition.y = this.view.y + this.target.worldPosition.y,
                this.deadzone ? (this._edge = this._targetPosition.x - this.view.x,
                this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)),
                this._edge = this._targetPosition.y - this.view.y,
                this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x),
                this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)),
                this.bounds && this.checkBounds(),
                this.roundPx && this.view.floor(),
                this.displayObject.position.x = -this.view.x,
                this.displayObject.position.y = -this.view.y
            },
            setBoundsToWorld: function() {
                this.bounds && this.bounds.copyFrom(this.game.world.bounds)
            },
            checkBounds: function() {
                this.atLimit.x = !1,
                this.atLimit.y = !1;
                var t = this.view.x + this._shake.x
                  , e = this.view.right + this._shake.x
                  , i = this.view.y + this._shake.y
                  , s = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0,
                this.view.x = this.bounds.x * this.scale.x,
                this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0,
                this.view.x = this.bounds.right * this.scale.x - this.width,
                this._shake.shakeBounds || (this._shake.x = 0)),
                i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0,
                this.view.y = this.bounds.top * this.scale.y,
                this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0,
                this.view.y = this.bounds.bottom * this.scale.y - this.height,
                this._shake.shakeBounds || (this._shake.y = 0))
            },
            setPosition: function(t, e) {
                this.view.x = t,
                this.view.y = e,
                this.bounds && this.checkBounds()
            },
            setSize: function(t, e) {
                this.view.width = t,
                this.view.height = e
            },
            reset: function() {
                this.target = null,
                this.view.x = 0,
                this.view.y = 0,
                this._shake.duration = 0,
                this.resetFX()
            },
            resetFX: function() {
                this.fx && (this.fx.clear(),
                this.fx.alpha = 0),
                this._fxDuration = 0
            }
        },
        W.Camera.prototype.constructor = W.Camera,
        Object.defineProperty(W.Camera.prototype, "x", {
            get: function() {
                return this.view.x
            },
            set: function(t) {
                this.view.x = t,
                this.bounds && this.checkBounds()
            }
        }),
        Object.defineProperty(W.Camera.prototype, "y", {
            get: function() {
                return this.view.y
            },
            set: function(t) {
                this.view.y = t,
                this.bounds && this.checkBounds()
            }
        }),
        Object.defineProperty(W.Camera.prototype, "position", {
            get: function() {
                return this._position.set(this.view.x, this.view.y),
                this._position
            },
            set: function(t) {
                void 0 !== t.x && (this.view.x = t.x),
                void 0 !== t.y && (this.view.y = t.y),
                this.bounds && this.checkBounds()
            }
        }),
        Object.defineProperty(W.Camera.prototype, "width", {
            get: function() {
                return this.view.width
            },
            set: function(t) {
                this.view.width = t
            }
        }),
        Object.defineProperty(W.Camera.prototype, "height", {
            get: function() {
                return this.view.height
            },
            set: function(t) {
                this.view.height = t
            }
        }),
        Object.defineProperty(W.Camera.prototype, "shakeIntensity", {
            get: function() {
                return this._shake.intensity
            },
            set: function(t) {
                this._shake.intensity = t
            }
        }),
        W.State = function() {
            this.game = null,
            this.key = "",
            this.add = null,
            this.make = null,
            this.camera = null,
            this.cache = null,
            this.input = null,
            this.load = null,
            this.math = null,
            this.sound = null,
            this.scale = null,
            this.stage = null,
            this.state = null,
            this.time = null,
            this.tweens = null,
            this.world = null,
            this.particles = null,
            this.physics = null,
            this.rnd = null
        }
        ,
        W.State.prototype = {
            init: function() {},
            preload: function() {},
            loadUpdate: function() {},
            loadRender: function() {},
            create: function() {},
            update: function() {},
            preRender: function() {},
            render: function() {},
            resize: function() {},
            paused: function() {},
            resumed: function() {},
            pauseUpdate: function() {},
            shutdown: function() {}
        },
        W.State.prototype.constructor = W.State,
        W.StateManager = function(t, e) {
            this.game = t,
            this.states = {},
            (this._pendingState = null) != e && (this._pendingState = e),
            this._clearWorld = !1,
            this._clearCache = !1,
            this._created = !1,
            this._args = [],
            this.current = "",
            this.onStateChange = new W.Signal,
            this.onInitCallback = null,
            this.onPreloadCallback = null,
            this.onCreateCallback = null,
            this.onUpdateCallback = null,
            this.onRenderCallback = null,
            this.onResizeCallback = null,
            this.onPreRenderCallback = null,
            this.onLoadUpdateCallback = null,
            this.onLoadRenderCallback = null,
            this.onPausedCallback = null,
            this.onResumedCallback = null,
            this.onPauseUpdateCallback = null,
            this.onShutDownCallback = null
        }
        ,
        W.StateManager.prototype = {
            boot: function() {
                this.game.onPause.add(this.pause, this),
                this.game.onResume.add(this.resume, this),
                null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
            },
            add: function(t, e, i) {
                var s;
                return void 0 === i && (i = !1),
                e instanceof W.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)),
                this.states[t] = s,
                i && (this.game.isBooted ? this.start(t) : this._pendingState = t),
                s
            },
            remove: function(t) {
                this.current === t && (this.callbackContext = null,
                this.onInitCallback = null,
                this.onShutDownCallback = null,
                this.onPreloadCallback = null,
                this.onLoadRenderCallback = null,
                this.onLoadUpdateCallback = null,
                this.onCreateCallback = null,
                this.onUpdateCallback = null,
                this.onPreRenderCallback = null,
                this.onRenderCallback = null,
                this.onResizeCallback = null,
                this.onPausedCallback = null,
                this.onResumedCallback = null,
                this.onPauseUpdateCallback = null),
                delete this.states[t]
            },
            start: function(t, e, i) {
                void 0 === e && (e = !0),
                void 0 === i && (i = !1),
                this.checkState(t) && (this._pendingState = t,
                this._clearWorld = e,
                this._clearCache = i,
                3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3)))
            },
            restart: function(t, e) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !1),
                this._pendingState = this.current,
                this._clearWorld = t,
                this._clearCache = e,
                2 < arguments.length && (this._args = Array.prototype.slice.call(arguments, 2))
            },
            dummy: function() {},
            preUpdate: function() {
                if (this._pendingState && this.game.isBooted) {
                    var t = this.current;
                    if (this.clearCurrentState(),
                    this.setCurrentState(this._pendingState),
                    this.onStateChange.dispatch(this.current, t),
                    this.current !== this._pendingState)
                        return;
                    this._pendingState = null,
                    this.onPreloadCallback ? (this.game.load.reset(!0),
                    this.onPreloadCallback.call(this.callbackContext, this.game),
                    0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            },
            clearCurrentState: function() {
                this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game),
                this.game.tweens.removeAll(),
                this.game.camera.reset(),
                this.game.input.reset(!0),
                this.game.physics.clear(),
                this.game.time.removeAll(),
                this.game.scale.reset(this._clearWorld),
                this.game.debug && this.game.debug.reset(),
                this._clearWorld && (this.game.world.shutdown(),
                this._clearCache && this.game.cache.destroy()))
            },
            checkState: function(t) {
                return this.states[t] ? !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"),
                !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t),
                !1)
            },
            link: function(t) {
                this.states[t].game = this.game,
                this.states[t].add = this.game.add,
                this.states[t].make = this.game.make,
                this.states[t].camera = this.game.camera,
                this.states[t].cache = this.game.cache,
                this.states[t].input = this.game.input,
                this.states[t].load = this.game.load,
                this.states[t].math = this.game.math,
                this.states[t].sound = this.game.sound,
                this.states[t].scale = this.game.scale,
                (this.states[t].state = this).states[t].stage = this.game.stage,
                this.states[t].time = this.game.time,
                this.states[t].tweens = this.game.tweens,
                this.states[t].world = this.game.world,
                this.states[t].particles = this.game.particles,
                this.states[t].rnd = this.game.rnd,
                this.states[t].physics = this.game.physics,
                this.states[t].key = t
            },
            unlink: function(t) {
                this.states[t] && (this.states[t].game = null,
                this.states[t].add = null,
                this.states[t].make = null,
                this.states[t].camera = null,
                this.states[t].cache = null,
                this.states[t].input = null,
                this.states[t].load = null,
                this.states[t].math = null,
                this.states[t].sound = null,
                this.states[t].scale = null,
                this.states[t].state = null,
                this.states[t].stage = null,
                this.states[t].time = null,
                this.states[t].tweens = null,
                this.states[t].world = null,
                this.states[t].particles = null,
                this.states[t].rnd = null,
                this.states[t].physics = null)
            },
            setCurrentState: function(t) {
                this.callbackContext = this.states[t],
                this.link(t),
                this.onInitCallback = this.states[t].init || this.dummy,
                this.onPreloadCallback = this.states[t].preload || null,
                this.onLoadRenderCallback = this.states[t].loadRender || null,
                this.onLoadUpdateCallback = this.states[t].loadUpdate || null,
                this.onCreateCallback = this.states[t].create || null,
                this.onUpdateCallback = this.states[t].update || null,
                this.onPreRenderCallback = this.states[t].preRender || null,
                this.onRenderCallback = this.states[t].render || null,
                this.onResizeCallback = this.states[t].resize || null,
                this.onPausedCallback = this.states[t].paused || null,
                this.onResumedCallback = this.states[t].resumed || null,
                this.onPauseUpdateCallback = this.states[t].pauseUpdate || null,
                this.onShutDownCallback = this.states[t].shutdown || this.dummy,
                "" !== this.current && this.game.physics.reset(),
                this.current = t,
                this._created = !1,
                this.onInitCallback.apply(this.callbackContext, this._args),
                t === this._pendingState && (this._args = []),
                this.game._kickstart = !0
            },
            getCurrentState: function() {
                return this.states[this.current]
            },
            loadComplete: function() {
                !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game),
                !1 === this._created && this.onCreateCallback ? (this._created = !0,
                this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
            },
            pause: function() {
                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
            },
            resume: function() {
                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
            },
            update: function() {
                this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            pauseUpdate: function() {
                this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            preRender: function(t) {
                this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
            },
            resize: function(t, e) {
                this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
            },
            render: function() {
                this._created ? this.onRenderCallback && (this.game.renderType === W.CANVAS ? (this.game.context.save(),
                this.game.context.setTransform(1, 0, 0, 1, 0, 0),
                this.onRenderCallback.call(this.callbackContext, this.game),
                this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
            },
            destroy: function() {
                this._clearWorld = !0,
                this._clearCache = !0,
                this.clearCurrentState(),
                this.callbackContext = null,
                this.onInitCallback = null,
                this.onShutDownCallback = null,
                this.onPreloadCallback = null,
                this.onLoadRenderCallback = null,
                this.onLoadUpdateCallback = null,
                this.onCreateCallback = null,
                this.onUpdateCallback = null,
                this.onRenderCallback = null,
                this.onPausedCallback = null,
                this.onResumedCallback = null,
                this.onPauseUpdateCallback = null,
                this.game = null,
                this.states = {},
                this._pendingState = null,
                this.current = ""
            }
        },
        W.StateManager.prototype.constructor = W.StateManager,
        Object.defineProperty(W.StateManager.prototype, "created", {
            get: function() {
                return this._created
            }
        }),
        W.Signal = function() {}
        ,
        W.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(t, e) {
                if ("function" != typeof t)
                    throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
            },
            _registerListener: function(t, e, i, s, n) {
                var r, o = this._indexOfListener(t, i);
                if (-1 !== o) {
                    if ((r = this._bindings[o]).isOnce() !== e)
                        throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                } else
                    r = new W.SignalBinding(this,t,e,i,s,n),
                    this._addBinding(r);
                return this.memorize && this._prevParams && r.execute(this._prevParams),
                r
            },
            _addBinding: function(t) {
                this._bindings || (this._bindings = []);
                for (var e = this._bindings.length; e--,
                this._bindings[e] && t._priority <= this._bindings[e]._priority; )
                    ;
                this._bindings.splice(e + 1, 0, t)
            },
            _indexOfListener: function(t, e) {
                if (!this._bindings)
                    return -1;
                void 0 === e && (e = null);
                for (var i, s = this._bindings.length; s--; )
                    if ((i = this._bindings[s])._listener === t && i.context === e)
                        return s;
                return -1
            },
            has: function(t, e) {
                return -1 !== this._indexOfListener(t, e)
            },
            add: function(t, e, i) {
                this.validateListener(t, "add");
                var s = [];
                if (3 < arguments.length)
                    for (var n = 3; n < arguments.length; n++)
                        s.push(arguments[n]);
                return this._registerListener(t, !1, e, i, s)
            },
            addOnce: function(t, e, i) {
                this.validateListener(t, "addOnce");
                var s = [];
                if (3 < arguments.length)
                    for (var n = 3; n < arguments.length; n++)
                        s.push(arguments[n]);
                return this._registerListener(t, !0, e, i, s)
            },
            remove: function(t, e) {
                this.validateListener(t, "remove");
                var i = this._indexOfListener(t, e);
                return -1 !== i && (this._bindings[i]._destroy(),
                this._bindings.splice(i, 1)),
                t
            },
            removeAll: function(t) {
                if (void 0 === t && (t = null),
                this._bindings) {
                    for (var e = this._bindings.length; e--; )
                        t ? this._bindings[e].context === t && (this._bindings[e]._destroy(),
                        this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() {
                return this._bindings ? this._bindings.length : 0
            },
            halt: function() {
                this._shouldPropagate = !1
            },
            dispatch: function() {
                if (this.active && this._bindings) {
                    var t, e = Array.prototype.slice.call(arguments), i = this._bindings.length;
                    if (this.memorize && (this._prevParams = e),
                    i)
                        for (t = this._bindings.slice(),
                        this._shouldPropagate = !0; t[--i] && this._shouldPropagate && !1 !== t[i].execute(e); )
                            ;
                }
            },
            forget: function() {
                this._prevParams && (this._prevParams = null)
            },
            dispose: function() {
                this.removeAll(),
                this._bindings = null,
                this._prevParams && (this._prevParams = null)
            },
            toString: function() {
                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
            }
        },
        Object.defineProperty(W.Signal.prototype, "boundDispatch", {
            get: function() {
                var t = this;
                return this._boundDispatch || (this._boundDispatch = function() {
                    return t.dispatch.apply(t, arguments)
                }
                )
            }
        }),
        W.Signal.prototype.constructor = W.Signal,
        W.SignalBinding = function(t, e, i, s, n, r) {
            this._listener = e,
            i && (this._isOnce = !0),
            null != s && (this.context = s),
            this._signal = t,
            n && (this._priority = n),
            r && r.length && (this._args = r)
        }
        ,
        W.SignalBinding.prototype = {
            context: null,
            _isOnce: !1,
            _priority: 0,
            _args: null,
            callCount: 0,
            active: !0,
            params: null,
            execute: function(t) {
                var e, i;
                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t,
                this._args && (i = i.concat(this._args)),
                e = this._listener.apply(this.context, i),
                this.callCount++,
                this._isOnce && this.detach()),
                e
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
            },
            isBound: function() {
                return !!this._signal && !!this._listener
            },
            isOnce: function() {
                return this._isOnce
            },
            getListener: function() {
                return this._listener
            },
            getSignal: function() {
                return this._signal
            },
            _destroy: function() {
                delete this._signal,
                delete this._listener,
                delete this.context
            },
            toString: function() {
                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
            }
        },
        W.SignalBinding.prototype.constructor = W.SignalBinding,
        W.Filter = function(t, e, i) {
            this.game = t,
            this.type = W.WEBGL_FILTER,
            this.passes = [this],
            this.shaders = [],
            this.dirty = !0,
            this.padding = 0,
            this.prevPoint = new W.Point;
            var s = new Date;
            if (this.uniforms = {
                resolution: {
                    type: "2f",
                    value: {
                        x: 256,
                        y: 256
                    }
                },
                time: {
                    type: "1f",
                    value: 0
                },
                mouse: {
                    type: "2f",
                    value: {
                        x: 0,
                        y: 0
                    }
                },
                date: {
                    type: "4fv",
                    value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
                },
                sampleRate: {
                    type: "1f",
                    value: 44100
                },
                iChannel0: {
                    type: "sampler2D",
                    value: null,
                    textureData: {
                        repeat: !0
                    }
                },
                iChannel1: {
                    type: "sampler2D",
                    value: null,
                    textureData: {
                        repeat: !0
                    }
                },
                iChannel2: {
                    type: "sampler2D",
                    value: null,
                    textureData: {
                        repeat: !0
                    }
                },
                iChannel3: {
                    type: "sampler2D",
                    value: null,
                    textureData: {
                        repeat: !0
                    }
                }
            },
            e)
                for (var n in e)
                    this.uniforms[n] = e[n];
            "string" == typeof i && (i = i.split("\n")),
            this.fragmentSrc = i || []
        }
        ,
        W.Filter.prototype = {
            init: function() {},
            setResolution: function(t, e) {
                this.uniforms.resolution.value.x = t,
                this.uniforms.resolution.value.y = e
            },
            update: function(t) {
                if (t) {
                    var e = t.x / this.game.width
                      , i = 1 - t.y / this.game.height;
                    e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2),
                    this.uniforms.mouse.value.y = i.toFixed(2),
                    this.prevPoint.set(e, i))
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds()
            },
            addToWorld: function(t, e, i, s, n, r) {
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                null != i ? this.width = i : i = this.width,
                null != s ? this.height = s : s = this.height;
                var o = this.game.add.image(t, e, "__default");
                return o.width = i,
                o.height = s,
                o.anchor.set(n, r),
                o.filters = [this],
                o
            },
            syncUniforms: function() {
                for (var t = 0; t < this.shaders.length; t++)
                    this.shaders[t].dirty = !0
            },
            destroy: function() {
                this.passes.length = 0,
                this.shaders.length = 0,
                this.fragmentSrc.length = 0,
                this.game = null,
                this.uniforms = null,
                this.prevPoint = null
            }
        },
        W.Filter.prototype.constructor = W.Filter,
        Object.defineProperty(W.Filter.prototype, "width", {
            get: function() {
                return this.uniforms.resolution.value.x
            },
            set: function(t) {
                this.uniforms.resolution.value.x = t
            }
        }),
        Object.defineProperty(W.Filter.prototype, "height", {
            get: function() {
                return this.uniforms.resolution.value.y
            },
            set: function(t) {
                this.uniforms.resolution.value.y = t
            }
        }),
        W.Plugin = function(t, e) {
            void 0 === e && (e = null),
            this.game = t,
            this.parent = e,
            this.active = !1,
            this.visible = !1,
            this.hasPreUpdate = !1,
            this.hasUpdate = !1,
            this.hasPostUpdate = !1,
            this.hasRender = !1,
            this.hasPostRender = !1
        }
        ,
        W.Plugin.prototype = {
            preUpdate: function() {},
            update: function() {},
            render: function() {},
            postRender: function() {},
            destroy: function() {
                this.game = null,
                this.parent = null,
                this.active = !1,
                this.visible = !1
            }
        },
        W.Plugin.prototype.constructor = W.Plugin,
        W.PluginManager = function(t) {
            this.game = t,
            this.plugins = [],
            this._len = 0,
            this._i = 0
        }
        ,
        W.PluginManager.prototype = {
            add: function(t) {
                var e = Array.prototype.slice.call(arguments, 1)
                  , i = !1;
                return "function" == typeof t ? t = new t(this.game,this) : (t.game = this.game,
                t.parent = this),
                "function" == typeof t.preUpdate && (i = t.hasPreUpdate = !0),
                "function" == typeof t.update && (i = t.hasUpdate = !0),
                "function" == typeof t.postUpdate && (i = t.hasPostUpdate = !0),
                "function" == typeof t.render && (i = t.hasRender = !0),
                "function" == typeof t.postRender && (i = t.hasPostRender = !0),
                i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0),
                (t.hasRender || t.hasPostRender) && (t.visible = !0),
                this._len = this.plugins.push(t),
                "function" == typeof t.init && t.init.apply(t, e),
                t) : null
            },
            remove: function(t, e) {
                for (void 0 === e && (e = !0),
                this._i = this._len; this._i--; )
                    if (this.plugins[this._i] === t)
                        return e && t.destroy(),
                        this.plugins.splice(this._i, 1),
                        void this._len--
            },
            removeAll: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].destroy();
                this.plugins.length = 0,
                this._len = 0
            },
            preUpdate: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
            },
            update: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
            },
            postUpdate: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
            },
            render: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
            },
            postRender: function() {
                for (this._i = this._len; this._i--; )
                    this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
            },
            destroy: function() {
                this.removeAll(),
                this.game = null
            }
        },
        W.PluginManager.prototype.constructor = W.PluginManager,
        W.Stage = function(t) {
            this.game = t,
            PIXI.DisplayObjectContainer.call(this),
            this.name = "_stage_root",
            this.disableVisibilityChange = !1,
            this.exists = !0,
            this.worldTransform = new PIXI.Matrix,
            (this.stage = this).currentRenderOrderID = 0,
            this._hiddenVar = "hidden",
            this._onChange = null,
            this._bgColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                color: 0,
                rgba: "#000000"
            },
            this.game.transparent || (this._bgColor.a = 1),
            t.config && this.parseConfig(t.config)
        }
        ,
        W.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
        W.Stage.prototype.constructor = W.Stage,
        W.Stage.prototype.parseConfig = function(t) {
            t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange),
            t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
        }
        ,
        W.Stage.prototype.boot = function() {
            W.DOM.getOffset(this.game.canvas, this.offset),
            W.Canvas.setUserSelect(this.game.canvas, "none"),
            W.Canvas.setTouchAction(this.game.canvas, "none"),
            this.checkVisibility()
        }
        ,
        W.Stage.prototype.preUpdate = function() {
            for (var t = this.currentRenderOrderID = 0; t < this.children.length; ) {
                var e = this.children[t];
                e.preUpdate(),
                this === e.parent && t++
            }
        }
        ,
        W.Stage.prototype.update = function() {
            for (var t = this.children.length; t--; )
                this.children[t].update()
        }
        ,
        W.Stage.prototype.postUpdate = function() {
            this.game.camera.update(),
            this.game.camera.target && (this.game.camera.target.postUpdate(),
            this.updateTransform(),
            this.game.camera.updateTarget());
            for (var t = 0; t < this.children.length; t++)
                this.children[t].postUpdate();
            this.updateTransform()
        }
        ,
        W.Stage.prototype.updateTransform = function() {
            this.worldAlpha = 1;
            for (var t = 0; t < this.children.length; t++)
                this.children[t].updateTransform()
        }
        ,
        W.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var e = this;
            this._onChange = function(t) {
                return e.visibilityChange(t)
            }
            ,
            this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1),
            window.onblur = this._onChange,
            window.onfocus = this._onChange,
            window.onpagehide = this._onChange,
            window.onpageshow = this._onChange,
            this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                W.Stage.prototype.visibilityChange.call(e, {
                    type: "pause"
                })
            }),
            CocoonJS.App.onActivated.addEventListener(function() {
                W.Stage.prototype.visibilityChange.call(e, {
                    type: "resume"
                })
            }))
        }
        ,
        W.Stage.prototype.visibilityChange = function(t) {
            "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)
        }
        ,
        W.Stage.prototype.setBackgroundColor = function(t) {
            this.game.transparent || (W.Color.valueToColor(t, this._bgColor),
            W.Color.updateColor(this._bgColor),
            this._bgColor.r /= 255,
            this._bgColor.g /= 255,
            this._bgColor.b /= 255,
            this._bgColor.a = 1)
        }
        ,
        W.Stage.prototype.destroy = function() {
            this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1),
            window.onpagehide = null,
            window.onpageshow = null,
            window.onblur = null,
            window.onfocus = null
        }
        ,
        Object.defineProperty(W.Stage.prototype, "backgroundColor", {
            get: function() {
                return this._bgColor.color
            },
            set: function(t) {
                this.setBackgroundColor(t)
            }
        }),
        Object.defineProperty(W.Stage.prototype, "smoothed", {
            get: function() {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
            },
            set: function(t) {
                PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
            }
        }),
        W.Group = function(t, e, i, s, n, r) {
            void 0 === s && (s = !1),
            void 0 === n && (n = !1),
            void 0 === r && (r = W.Physics.ARCADE),
            this.game = t,
            void 0 === e && (e = t.world),
            this.name = i || "group",
            this.z = 0,
            PIXI.DisplayObjectContainer.call(this),
            s ? (this.game.stage.addChild(this),
            this.z = this.game.stage.children.length) : e && (e.addChild(this),
            this.z = e.children.length),
            this.type = W.GROUP,
            this.physicsType = W.GROUP,
            this.alive = !0,
            this.exists = !0,
            this.ignoreDestroy = !1,
            this.pendingDestroy = !1,
            this.classType = W.Sprite,
            this.cursor = null,
            this.inputEnableChildren = !1,
            this.onChildInputDown = new W.Signal,
            this.onChildInputUp = new W.Signal,
            this.onChildInputOver = new W.Signal,
            this.onChildInputOut = new W.Signal,
            this.enableBody = n,
            this.enableBodyDebug = !1,
            this.physicsBodyType = r,
            this.physicsSortDirection = null,
            this.onDestroy = new W.Signal,
            this.cursorIndex = 0,
            this.fixedToCamera = !1,
            this.cameraOffset = new W.Point,
            this.hash = [],
            this._sortProperty = "z"
        }
        ,
        W.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
        W.Group.prototype.constructor = W.Group,
        W.Group.RETURN_NONE = 0,
        W.Group.RETURN_TOTAL = 1,
        W.Group.RETURN_CHILD = 2,
        W.Group.RETURN_ALL = 3,
        W.Group.SORT_ASCENDING = -1,
        W.Group.SORT_DESCENDING = 1,
        W.Group.prototype.add = function(t, e, i) {
            return void 0 === e && (e = !1),
            t.parent === this || (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t),
            void 0 === i ? (t.z = this.children.length,
            this.addChild(t)) : (this.addChildAt(t, i),
            this.updateZ()),
            this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t),
            !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0),
            !e && t.events && t.events.onAddedToGroup$dispatch(t, this),
            null === this.cursor && (this.cursor = t)),
            t
        }
        ,
        W.Group.prototype.addAt = function(t, e, i) {
            return this.add(t, i, e)
        }
        ,
        W.Group.prototype.addToHash = function(t) {
            if (t.parent === this && -1 === this.hash.indexOf(t))
                return this.hash.push(t),
                !0;
            return !1
        }
        ,
        W.Group.prototype.removeFromHash = function(t) {
            if (t) {
                var e = this.hash.indexOf(t);
                if (-1 !== e)
                    return this.hash.splice(e, 1),
                    !0
            }
            return !1
        }
        ,
        W.Group.prototype.addMultiple = function(t, e) {
            if (t instanceof W.Group)
                t.moveAll(this, e);
            else if (Array.isArray(t))
                for (var i = 0; i < t.length; i++)
                    this.add(t[i], e);
            return t
        }
        ,
        W.Group.prototype.getAt = function(t) {
            return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
        }
        ,
        W.Group.prototype.create = function(t, e, i, s, n, r) {
            void 0 === n && (n = !0);
            var o = new this.classType(this.game,t,e,i,s);
            return o.exists = n,
            o.visible = n,
            o.alive = n,
            this.add(o, !1, r)
        }
        ,
        W.Group.prototype.createMultiple = function(s, t, e, n) {
            void 0 === e && (e = 0),
            void 0 === n && (n = !1),
            Array.isArray(t) || (t = [t]),
            Array.isArray(e) || (e = [e]);
            var r = this
              , o = [];
            return t.forEach(function(i) {
                e.forEach(function(t) {
                    for (var e = 0; e < s; e++)
                        o.push(r.create(0, 0, i, t, n))
                })
            }),
            o
        }
        ,
        W.Group.prototype.updateZ = function() {
            for (var t = this.children.length; t--; )
                this.children[t].z = t
        }
        ,
        W.Group.prototype.align = function(t, e, i, s, n, r) {
            if (void 0 === n && (n = W.TOP_LEFT),
            void 0 === r && (r = 0),
            0 === this.children.length || r > this.children.length || -1 === t && -1 === e)
                return !1;
            for (var o = new W.Rectangle(0,0,i,s), a = t * i, h = e * s, l = r; l < this.children.length; l++) {
                var c = this.children[l];
                if (c.alignIn)
                    if (c.alignIn(o, n),
                    -1 === t)
                        o.y += s,
                        o.y === h && (o.x += i,
                        o.y = 0);
                    else if (-1 === e)
                        o.x += i,
                        o.x === a && (o.x = 0,
                        o.y += s);
                    else if (o.x += i,
                    o.x === a && (o.x = 0,
                    o.y += s,
                    o.y === h))
                        return !0
            }
            return !0
        }
        ,
        W.Group.prototype.resetCursor = function(t) {
            if (void 0 === t && (t = 0),
            t > this.children.length - 1 && (t = 0),
            this.cursor)
                return this.cursorIndex = t,
                this.cursor = this.children[this.cursorIndex],
                this.cursor
        }
        ,
        W.Group.prototype.next = function() {
            if (this.cursor)
                return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++,
                this.cursor = this.children[this.cursorIndex],
                this.cursor
        }
        ,
        W.Group.prototype.previous = function() {
            if (this.cursor)
                return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--,
                this.cursor = this.children[this.cursorIndex],
                this.cursor
        }
        ,
        W.Group.prototype.swap = function(t, e) {
            this.swapChildren(t, e),
            this.updateZ()
        }
        ,
        W.Group.prototype.bringToTop = function(t) {
            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0),
            this.add(t, !0)),
            t
        }
        ,
        W.Group.prototype.sendToBack = function(t) {
            return t.parent === this && 0 < this.getIndex(t) && (this.remove(t, !1, !0),
            this.addAt(t, 0, !0)),
            t
        }
        ,
        W.Group.prototype.moveUp = function(t) {
            if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                var e = this.getIndex(t)
                  , i = this.getAt(e + 1);
                i && this.swap(t, i)
            }
            return t
        }
        ,
        W.Group.prototype.moveDown = function(t) {
            if (t.parent === this && 0 < this.getIndex(t)) {
                var e = this.getIndex(t)
                  , i = this.getAt(e - 1);
                i && this.swap(t, i)
            }
            return t
        }
        ,
        W.Group.prototype.xy = function(t, e, i) {
            if (t < 0 || t > this.children.length)
                return -1;
            this.getChildAt(t).x = e,
            this.getChildAt(t).y = i
        }
        ,
        W.Group.prototype.reverse = function() {
            this.children.reverse(),
            this.updateZ()
        }
        ,
        W.Group.prototype.getIndex = function(t) {
            return this.children.indexOf(t)
        }
        ,
        W.Group.prototype.getByName = function(t) {
            for (var e = 0; e < this.children.length; e++)
                if (this.children[e].name === t)
                    return this.children[e];
            return null
        }
        ,
        W.Group.prototype.replace = function(t, e) {
            var i = this.getIndex(t);
            if (-1 !== i)
                return e.parent && (e.parent instanceof W.Group ? e.parent.remove(e) : e.parent.removeChild(e)),
                this.remove(t),
                this.addAt(e, i),
                t
        }
        ,
        W.Group.prototype.hasProperty = function(t, e) {
            var i = e.length;
            return 1 === i && e[0]in t || (2 === i && e[0]in t && e[1]in t[e[0]] || (3 === i && e[0]in t && e[1]in t[e[0]] && e[2]in t[e[0]][e[1]] || 4 === i && e[0]in t && e[1]in t[e[0]] && e[2]in t[e[0]][e[1]] && e[3]in t[e[0]][e[1]][e[2]]))
        }
        ,
        W.Group.prototype.setProperty = function(t, e, i, s, n) {
            if (void 0 === n && (n = !1),
            s = s || 0,
            !this.hasProperty(t, e) && (!n || 0 < s))
                return !1;
            var r = e.length;
            return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)),
            !0
        }
        ,
        W.Group.prototype.checkProperty = function(t, e, i, s) {
            return void 0 === s && (s = !1),
            !(!W.Utils.getProperty(t, e) && s) && W.Utils.getProperty(t, e) === i
        }
        ,
        W.Group.prototype.set = function(t, e, i, s, n, r, o) {
            if (void 0 === o && (o = !1),
            e = e.split("."),
            void 0 === s && (s = !1),
            void 0 === n && (n = !1),
            (!1 === s || s && t.alive) && (!1 === n || n && t.visible))
                return this.setProperty(t, e, i, r, o)
        }
        ,
        W.Group.prototype.setAll = function(t, e, i, s, n, r) {
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            void 0 === r && (r = !1),
            t = t.split("."),
            n = n || 0;
            for (var o = 0; o < this.children.length; o++)
                (!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, r)
        }
        ,
        W.Group.prototype.setAllChildren = function(t, e, i, s, n, r) {
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            void 0 === r && (r = !1),
            n = n || 0;
            for (var o = 0; o < this.children.length; o++)
                (!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && (this.children[o]instanceof W.Group ? this.children[o].setAllChildren(t, e, i, s, n, r) : this.setProperty(this.children[o], t.split("."), e, n, r))
        }
        ,
        W.Group.prototype.checkAll = function(t, e, i, s, n) {
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            void 0 === n && (n = !1);
            for (var r = 0; r < this.children.length; r++)
                if ((!i || i && this.children[r].alive) && (!s || s && this.children[r].visible) && !this.checkProperty(this.children[r], t, e, n))
                    return !1;
            return !0
        }
        ,
        W.Group.prototype.addAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 1)
        }
        ,
        W.Group.prototype.subAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 2)
        }
        ,
        W.Group.prototype.multiplyAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 3)
        }
        ,
        W.Group.prototype.divideAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 4)
        }
        ,
        W.Group.prototype.callAllExists = function(t, e) {
            var i;
            if (2 < arguments.length) {
                i = [];
                for (var s = 2; s < arguments.length; s++)
                    i.push(arguments[s])
            }
            for (s = 0; s < this.children.length; s++)
                this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
        }
        ,
        W.Group.prototype.callbackFromArray = function(t, e, i) {
            if (1 === i) {
                if (t[e[0]])
                    return t[e[0]]
            } else if (2 === i) {
                if (t[e[0]][e[1]])
                    return t[e[0]][e[1]]
            } else if (3 === i) {
                if (t[e[0]][e[1]][e[2]])
                    return t[e[0]][e[1]][e[2]]
            } else if (4 === i) {
                if (t[e[0]][e[1]][e[2]][e[3]])
                    return t[e[0]][e[1]][e[2]][e[3]]
            } else if (t[e])
                return t[e];
            return !1
        }
        ,
        W.Group.prototype.callAll = function(t, e) {
            if (void 0 !== t) {
                var i, s = (t = t.split(".")).length;
                if (null == e || "" === e)
                    e = null;
                else if ("string" == typeof e)
                    var n = (e = e.split(".")).length;
                if (2 < arguments.length) {
                    i = [];
                    for (var r = 2; r < arguments.length; r++)
                        i.push(arguments[r])
                }
                var o = null
                  , a = null;
                for (r = 0; r < this.children.length; r++)
                    o = this.callbackFromArray(this.children[r], t, s),
                    e && o ? (a = this.callbackFromArray(this.children[r], e, n),
                    o && o.apply(a, i)) : o && o.apply(this.children[r], i)
            }
        }
        ,
        W.Group.prototype.preUpdate = function() {
            if (this.pendingDestroy)
                return this.destroy(),
                !1;
            if (!this.exists || !this.parent.exists)
                return !(this.renderOrderID = -1);
            for (var t = 0; t < this.children.length; ) {
                var e = this.children[t];
                e.preUpdate(),
                this === e.parent && t++
            }
            return !0
        }
        ,
        W.Group.prototype.update = function() {
            for (var t = this.children.length; t--; )
                t >= this.children.length && (t = this.children.length - 1),
                this.children[t].update()
        }
        ,
        W.Group.prototype.postUpdate = function() {
            this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
            this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
            for (var t = 0; t < this.children.length; t++)
                this.children[t].postUpdate()
        }
        ,
        W.Group.prototype.filter = function(t, e) {
            for (var i = -1, s = this.children.length, n = []; ++i < s; ) {
                var r = this.children[i];
                (!e || e && r.exists) && t(r, i, this.children) && n.push(r)
            }
            return new W.ArraySet(n)
        }
        ,
        W.Group.prototype.forEach = function(t, e, i) {
            if (void 0 === i && (i = !1),
            arguments.length <= 3)
                for (var s = 0; s < this.children.length; s++)
                    (!i || i && this.children[s].exists) && t.call(e, this.children[s]);
            else {
                var n = [null];
                for (s = 3; s < arguments.length; s++)
                    n.push(arguments[s]);
                for (s = 0; s < this.children.length; s++)
                    (!i || i && this.children[s].exists) && (n[0] = this.children[s],
                    t.apply(e, n))
            }
        }
        ,
        W.Group.prototype.forEachExists = function(t, e) {
            var i;
            if (2 < arguments.length) {
                i = [null];
                for (var s = 2; s < arguments.length; s++)
                    i.push(arguments[s])
            }
            this.iterate("exists", !0, W.Group.RETURN_TOTAL, t, e, i)
        }
        ,
        W.Group.prototype.forEachAlive = function(t, e) {
            var i;
            if (2 < arguments.length) {
                i = [null];
                for (var s = 2; s < arguments.length; s++)
                    i.push(arguments[s])
            }
            this.iterate("alive", !0, W.Group.RETURN_TOTAL, t, e, i)
        }
        ,
        W.Group.prototype.forEachDead = function(t, e) {
            var i;
            if (2 < arguments.length) {
                i = [null];
                for (var s = 2; s < arguments.length; s++)
                    i.push(arguments[s])
            }
            this.iterate("alive", !1, W.Group.RETURN_TOTAL, t, e, i)
        }
        ,
        W.Group.prototype.sort = function(t, e) {
            this.children.length < 2 || (void 0 === t && (t = "z"),
            void 0 === e && (e = W.Group.SORT_ASCENDING),
            this._sortProperty = t,
            e === W.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)),
            this.updateZ())
        }
        ,
        W.Group.prototype.customSort = function(t, e) {
            this.children.length < 2 || (this.children.sort(t.bind(e)),
            this.updateZ())
        }
        ,
        W.Group.prototype.ascendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
        }
        ,
        W.Group.prototype.descendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
        }
        ,
        W.Group.prototype.iterate = function(t, e, i, s, n, r) {
            if (0 === this.children.length) {
                if (i === W.Group.RETURN_TOTAL)
                    return 0;
                if (i === W.Group.RETURN_ALL)
                    return []
            }
            var o = 0;
            if (i === W.Group.RETURN_ALL)
                var a = [];
            for (var h = 0; h < this.children.length; h++)
                if (this.children[h][t] === e) {
                    if (o++,
                    s && (r ? (r[0] = this.children[h],
                    s.apply(n, r)) : s.call(n, this.children[h])),
                    i === W.Group.RETURN_CHILD)
                        return this.children[h];
                    i === W.Group.RETURN_ALL && a.push(this.children[h])
                }
            return i === W.Group.RETURN_TOTAL ? o : i === W.Group.RETURN_ALL ? a : null
        }
        ,
        W.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
            void 0 === e && (e = !1),
            "boolean" != typeof t && (t = !0);
            var o = this.iterate("exists", t, W.Group.RETURN_CHILD);
            return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
        }
        ,
        W.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
            void 0 === t && (t = !1);
            var r = this.iterate("alive", !0, W.Group.RETURN_CHILD);
            return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
        }
        ,
        W.Group.prototype.getFirstDead = function(t, e, i, s, n) {
            void 0 === t && (t = !1);
            var r = this.iterate("alive", !1, W.Group.RETURN_CHILD);
            return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
        }
        ,
        W.Group.prototype.resetChild = function(t, e, i, s, n) {
            return null === t ? null : (void 0 === e && (e = null),
            void 0 === i && (i = null),
            null !== e && null !== i && t.reset(e, i),
            void 0 !== s && t.loadTexture(s, n),
            t)
        }
        ,
        W.Group.prototype.getTop = function() {
            if (0 < this.children.length)
                return this.children[this.children.length - 1]
        }
        ,
        W.Group.prototype.getBottom = function() {
            if (0 < this.children.length)
                return this.children[0]
        }
        ,
        W.Group.prototype.getClosestTo = function(t, e, i) {
            for (var s = Number.MAX_VALUE, n = 0, r = null, o = 0; o < this.children.length; o++) {
                var a = this.children[o];
                a.exists && (n = Math.abs(W.Point.distance(t, a))) < s && (!e || e.call(i, a, n)) && (s = n,
                r = a)
            }
            return r
        }
        ,
        W.Group.prototype.getFurthestFrom = function(t, e, i) {
            for (var s = 0, n = 0, r = null, o = 0; o < this.children.length; o++) {
                var a = this.children[o];
                a.exists && s < (n = Math.abs(W.Point.distance(t, a))) && (!e || e.call(i, a, n)) && (s = n,
                r = a)
            }
            return r
        }
        ,
        W.Group.prototype.countLiving = function() {
            return this.iterate("alive", !0, W.Group.RETURN_TOTAL)
        }
        ,
        W.Group.prototype.countDead = function() {
            return this.iterate("alive", !1, W.Group.RETURN_TOTAL)
        }
        ,
        W.Group.prototype.getRandom = function(t, e) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = this.children.length),
            0 === e ? null : W.ArrayUtils.getRandomItem(this.children, t, e)
        }
        ,
        W.Group.prototype.getRandomExists = function(t, e) {
            var i = this.getAll("exists", !0, t, e);
            return this.game.rnd.pick(i)
        }
        ,
        W.Group.prototype.getAll = function(t, e, i, s) {
            void 0 === i && (i = 0),
            void 0 === s && (s = this.children.length);
            for (var n = [], r = i; r < s; r++) {
                var o = this.children[r];
                t && o[t] === e && n.push(o)
            }
            return n
        }
        ,
        W.Group.prototype.remove = function(t, e, i) {
            if (void 0 === e && (e = !1),
            void 0 === i && (i = !1),
            0 === this.children.length || -1 === this.children.indexOf(t))
                return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
            var s = this.removeChild(t);
            return this.removeFromHash(t),
            this.updateZ(),
            this.cursor === t && this.next(),
            e && s && s.destroy(!0),
            !0
        }
        ,
        W.Group.prototype.moveAll = function(t, e) {
            if (void 0 === e && (e = !1),
            0 < this.children.length && t instanceof W.Group) {
                for (; t.add(this.children[0], e),
                0 < this.children.length; )
                    ;
                this.hash = [],
                this.cursor = null
            }
            return t
        }
        ,
        W.Group.prototype.removeAll = function(t, e, i) {
            if (void 0 === t && (t = !1),
            void 0 === e && (e = !1),
            void 0 === i && (i = !1),
            0 !== this.children.length) {
                do {
                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var s = this.removeChild(this.children[0]);
                    this.removeFromHash(s),
                    t && s && s.destroy(!0, i)
                } while (0 < this.children.length);
                this.hash = [],
                this.cursor = null
            }
        }
        ,
        W.Group.prototype.removeBetween = function(t, e, i, s) {
            if (void 0 === e && (e = this.children.length - 1),
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            0 !== this.children.length) {
                if (e < t || t < 0 || e > this.children.length)
                    return !1;
                for (var n = e; t <= n; ) {
                    !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                    var r = this.removeChild(this.children[n]);
                    this.removeFromHash(r),
                    i && r && r.destroy(!0),
                    this.cursor === this.children[n] && (this.cursor = null),
                    n--
                }
                this.updateZ()
            }
        }
        ,
        W.Group.prototype.destroy = function(t, e) {
            null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0),
            void 0 === e && (e = !1),
            this.onDestroy.dispatch(this, t, e),
            this.removeAll(t),
            this.cursor = null,
            this.filters = null,
            this.pendingDestroy = !1,
            e || (this.parent && this.parent.removeChild(this),
            this.game = null,
            this.exists = !1))
        }
        ,
        Object.defineProperty(W.Group.prototype, "total", {
            get: function() {
                return this.iterate("exists", !0, W.Group.RETURN_TOTAL)
            }
        }),
        Object.defineProperty(W.Group.prototype, "length", {
            get: function() {
                return this.children.length
            }
        }),
        Object.defineProperty(W.Group.prototype, "angle", {
            get: function() {
                return W.Math.radToDeg(this.rotation)
            },
            set: function(t) {
                this.rotation = W.Math.degToRad(t)
            }
        }),
        Object.defineProperty(W.Group.prototype, "centerX", {
            get: function() {
                return this.getBounds(this.parent).centerX
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.x - e.x;
                this.x = t + i - e.halfWidth
            }
        }),
        Object.defineProperty(W.Group.prototype, "centerY", {
            get: function() {
                return this.getBounds(this.parent).centerY
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.y - e.y;
                this.y = t + i - e.halfHeight
            }
        }),
        Object.defineProperty(W.Group.prototype, "left", {
            get: function() {
                return this.getBounds(this.parent).left
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.x - e.x;
                this.x = t + i
            }
        }),
        Object.defineProperty(W.Group.prototype, "right", {
            get: function() {
                return this.getBounds(this.parent).right
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.x - e.x;
                this.x = t + i - e.width
            }
        }),
        Object.defineProperty(W.Group.prototype, "top", {
            get: function() {
                return this.getBounds(this.parent).top
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.y - e.y;
                this.y = t + i
            }
        }),
        Object.defineProperty(W.Group.prototype, "bottom", {
            get: function() {
                return this.getBounds(this.parent).bottom
            },
            set: function(t) {
                var e = this.getBounds(this.parent)
                  , i = this.y - e.y;
                this.y = t + i - e.height
            }
        }),
        W.World = function(t) {
            W.Group.call(this, t, null, "__world", !1),
            this.bounds = new W.Rectangle(0,0,t.width,t.height),
            this.camera = null,
            this._definedSize = !1,
            this._width = t.width,
            this._height = t.height,
            this.game.state.onStateChange.add(this.stateChange, this)
        }
        ,
        W.World.prototype = Object.create(W.Group.prototype),
        W.World.prototype.constructor = W.World,
        W.World.prototype.boot = function() {
            this.camera = new W.Camera(this.game,0,0,0,this.game.width,this.game.height),
            this.game.stage.addChild(this),
            this.camera.boot()
        }
        ,
        W.World.prototype.stateChange = function() {
            this.x = 0,
            this.y = 0,
            this.camera.reset()
        }
        ,
        W.World.prototype.setBounds = function(t, e, i, s) {
            this._definedSize = !0,
            this._width = i,
            this._height = s,
            this.bounds.setTo(t, e, i, s),
            this.x = t,
            this.y = e,
            this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)),
            this.game.physics.setBoundsToWorld()
        }
        ,
        W.World.prototype.resize = function(t, e) {
            this._definedSize && (t < this._width && (t = this._width),
            e < this._height && (e = this._height)),
            this.bounds.width = t,
            this.bounds.height = e,
            this.game.camera.setBoundsToWorld(),
            this.game.physics.setBoundsToWorld()
        }
        ,
        W.World.prototype.shutdown = function() {
            this.destroy(!0, !0)
        }
        ,
        W.World.prototype.wrap = function(t, e, i, s, n) {
            void 0 === e && (e = 0),
            void 0 === i && (i = !1),
            void 0 === s && (s = !0),
            void 0 === n && (n = !0),
            i ? (t.getBounds(),
            s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)),
            n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e),
            n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
        }
        ,
        Object.defineProperty(W.World.prototype, "width", {
            get: function() {
                return this.bounds.width
            },
            set: function(t) {
                t < this.game.width && (t = this.game.width),
                this.bounds.width = t,
                this._width = t,
                this._definedSize = !0
            }
        }),
        Object.defineProperty(W.World.prototype, "height", {
            get: function() {
                return this.bounds.height
            },
            set: function(t) {
                t < this.game.height && (t = this.game.height),
                this.bounds.height = t,
                this._height = t,
                this._definedSize = !0
            }
        }),
        Object.defineProperty(W.World.prototype, "centerX", {
            get: function() {
                return this.bounds.halfWidth + this.bounds.x
            }
        }),
        Object.defineProperty(W.World.prototype, "centerY", {
            get: function() {
                return this.bounds.halfHeight + this.bounds.y
            }
        }),
        Object.defineProperty(W.World.prototype, "randomX", {
            get: function() {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
            }
        }),
        Object.defineProperty(W.World.prototype, "randomY", {
            get: function() {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
            }
        }),
        W.Game = function(t, e, i, s, n, r, o, a) {
            return this.id = W.GAMES.push(this) - 1,
            this.config = null,
            this.physicsConfig = a,
            this.parent = "",
            this.width = 800,
            this.height = 600,
            this.resolution = 1,
            this._width = 800,
            this._height = 600,
            this.transparent = !1,
            this.antialias = !0,
            this.multiTexture = !1,
            this.preserveDrawingBuffer = !1,
            this.clearBeforeRender = !0,
            this.renderer = null,
            this.renderType = W.AUTO,
            this.state = null,
            this.isBooted = !1,
            this.isRunning = !1,
            this.raf = null,
            this.add = null,
            this.make = null,
            this.cache = null,
            this.input = null,
            this.load = null,
            this.math = null,
            this.net = null,
            this.scale = null,
            this.sound = null,
            this.stage = null,
            this.time = null,
            this.tweens = null,
            this.world = null,
            this.physics = null,
            this.plugins = null,
            this.rnd = null,
            this.device = W.Device,
            this.camera = null,
            this.canvas = null,
            this.context = null,
            this.debug = null,
            this.particles = null,
            this.create = null,
            this.lockRender = !1,
            this.stepping = !1,
            this.pendingStep = !1,
            this.stepCount = 0,
            this.onPause = null,
            this.onResume = null,
            this.onBlur = null,
            this.onFocus = null,
            this._paused = !1,
            this._codePaused = !1,
            this.currentUpdateID = 0,
            this.updatesThisFrame = 1,
            this._deltaTime = 0,
            this._lastCount = 0,
            this._spiraling = 0,
            this._kickstart = !0,
            this.fpsProblemNotifier = new W.Signal,
            this.forceSingleUpdate = !0,
            this._nextFpsNotification = 0,
            1 === arguments.length && "object" == typeof t ? this.parseConfig(t) : (this.config = {
                enableDebug: !0
            },
            void 0 !== t && (this._width = t),
            void 0 !== e && (this._height = e),
            void 0 !== i && (this.renderType = i),
            void 0 !== s && (this.parent = s),
            void 0 !== r && (this.transparent = r),
            void 0 !== o && (this.antialias = o),
            this.rnd = new W.RandomDataGenerator([(Date.now() * Math.random()).toString()]),
            this.state = new W.StateManager(this,n)),
            this.device.whenReady(this.boot, this),
            this
        }
        ,
        W.Game.prototype = {
            parseConfig: function(t) {
                void 0 === (this.config = t).enableDebug && (this.config.enableDebug = !0),
                t.width && (this._width = t.width),
                t.height && (this._height = t.height),
                t.renderer && (this.renderType = t.renderer),
                t.parent && (this.parent = t.parent),
                void 0 !== t.transparent && (this.transparent = t.transparent),
                void 0 !== t.antialias && (this.antialias = t.antialias),
                void 0 !== t.multiTexture && (this.multiTexture = t.multiTexture),
                t.resolution && (this.resolution = t.resolution),
                void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer),
                t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                var e = [(Date.now() * Math.random()).toString()];
                t.seed && (e = t.seed),
                this.rnd = new W.RandomDataGenerator(e);
                var i = null;
                t.state && (i = t.state),
                this.state = new W.StateManager(this,i)
            },
            boot: function() {
                this.isBooted || (this.onPause = new W.Signal,
                this.onResume = new W.Signal,
                this.onBlur = new W.Signal,
                this.onFocus = new W.Signal,
                this.isBooted = !0,
                (PIXI.game = this).math = W.Math,
                this.scale = new W.ScaleManager(this,this._width,this._height),
                this.stage = new W.Stage(this),
                this.setUpRenderer(),
                this.world = new W.World(this),
                this.add = new W.GameObjectFactory(this),
                this.make = new W.GameObjectCreator(this),
                this.cache = new W.Cache(this),
                this.load = new W.Loader(this),
                this.time = new W.Time(this),
                this.tweens = new W.TweenManager(this),
                this.input = new W.Input(this),
                this.sound = new W.SoundManager(this),
                this.physics = new W.Physics(this,this.physicsConfig),
                this.particles = new W.Particles(this),
                this.create = new W.Create(this),
                this.plugins = new W.PluginManager(this),
                this.net = new W.Net(this),
                this.time.boot(),
                this.stage.boot(),
                this.world.boot(),
                this.scale.boot(),
                this.input.boot(),
                this.sound.boot(),
                this.state.boot(),
                this.config.enableDebug ? (this.debug = new W.Utils.Debug(this),
                this.debug.boot()) : this.debug = {
                    preUpdate: function() {},
                    update: function() {},
                    reset: function() {}
                },
                this.showDebugHeader(),
                this.isRunning = !0,
                this.config && this.config.forceSetTimeOut ? this.raf = new W.RequestAnimationFrame(this,this.config.forceSetTimeOut) : this.raf = new W.RequestAnimationFrame(this,!1),
                this._kickstart = !0,
                window.focus && (window.PhaserGlobal && (!window.PhaserGlobal || window.PhaserGlobal.stopFocus) || window.focus()),
                this.raf.start())
            },
            showDebugHeader: function() {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var t = W.VERSION
                      , e = "Canvas"
                      , i = "HTML Audio"
                      , s = 1;
                    if (this.renderType === W.WEBGL ? (e = "WebGL",
                    s++) : this.renderType === W.HEADLESS && (e = "Headless"),
                    this.device.webAudio && (i = "WebAudio",
                    s++),
                    this.device.chrome) {
                        for (var n = ["%c %c %c Phaser CE v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], r = 0; r < 3; r++)
                            r < s ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                        console.log.apply(console, n)
                    } else
                        window.console && console.log("Phaser v" + t + " | Pixi.js | " + e + " | " + i + " | http://phaser.io")
                }
            },
            setUpRenderer: function() {
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = W.Canvas.create(this, this.width, this.height, this.config.canvasID, !0),
                this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%",
                this.renderType === W.HEADLESS || this.renderType === W.CANVAS || this.renderType === W.AUTO && !this.device.webGL) {
                    if (!this.device.canvas)
                        throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderer = new PIXI.CanvasRenderer(this),
                    this.context = this.renderer.context,
                    this.renderType === W.AUTO && (this.renderType = W.CANVAS)
                } else
                    !this.multiTexture && this.renderType !== W.WEBGL_MULTI || PIXI.enableMultiTexture(),
                    this.renderType = W.WEBGL,
                    this.renderer = new PIXI.WebGLRenderer(this),
                    this.context = null,
                    this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1),
                    this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === W.CANVAS),
                this.renderType !== W.HEADLESS && (this.stage.smoothed = this.antialias,
                W.Canvas.addToDOM(this.canvas, this.parent, !1),
                W.Canvas.setTouchAction(this.canvas))
            },
            contextLost: function(t) {
                t.preventDefault(),
                this.renderer.contextLost = !0
            },
            contextRestored: function() {
                this.renderer.initContext(),
                this.cache.clearGLTextures(),
                this.renderer.contextLost = !1
            },
            update: function(t) {
                if (this.time.update(t),
                this._kickstart)
                    return this.updateLogic(this.time.desiredFpsMult),
                    this.updateRender(this.time.slowMotion * this.time.desiredFps),
                    void (this._kickstart = !1);
                if (1 < this._spiraling && !this.forceSingleUpdate)
                    this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4,
                    this.fpsProblemNotifier.dispatch()),
                    this._deltaTime = 0,
                    this._spiraling = 0,
                    this.updateRender(this.time.slowMotion * this.time.desiredFps);
                else {
                    var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                    var i = 0;
                    for (this.updatesThisFrame = Math.floor(this._deltaTime / e),
                    this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e,
                    this.currentUpdateID = i,
                    this.updateLogic(this.time.desiredFpsMult),
                    i++,
                    !this.forceSingleUpdate || 1 !== i); )
                        this.time.refresh();
                    i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0),
                    this._lastCount = i,
                    this.updateRender(this._deltaTime / e)
                }
            },
            updateLogic: function(t) {
                this._paused || this.pendingStep ? (this.scale.pauseUpdate(),
                this.state.pauseUpdate(t),
                this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0),
                this.scale.preUpdate(),
                this.debug.preUpdate(),
                this.camera.preUpdate(),
                this.physics.preUpdate(),
                this.state.preUpdate(t),
                this.plugins.preUpdate(t),
                this.stage.preUpdate(),
                this.state.update(),
                this.stage.update(),
                this.tweens.update(),
                this.sound.update(),
                this.input.update(),
                this.physics.update(),
                this.plugins.update(),
                this.stage.postUpdate(),
                this.plugins.postUpdate()),
                this.stage.updateTransform()
            },
            updateRender: function(t) {
                this.lockRender || (this.state.preRender(t),
                this.renderType !== W.HEADLESS && (this.renderer.render(this.stage),
                this.plugins.render(t),
                this.state.render(t)),
                this.plugins.postRender(t))
            },
            enableStep: function() {
                this.stepping = !0,
                this.pendingStep = !1,
                this.stepCount = 0
            },
            disableStep: function() {
                this.stepping = !1,
                this.pendingStep = !1
            },
            step: function() {
                this.pendingStep = !1,
                this.stepCount++
            },
            destroy: function() {
                this.raf.stop(),
                this.state.destroy(),
                this.sound.destroy(),
                this.scale.destroy(),
                this.stage.destroy(),
                this.input.destroy(),
                this.physics.destroy(),
                this.plugins.destroy(),
                this.state = null,
                this.sound = null,
                this.scale = null,
                this.stage = null,
                this.input = null,
                this.physics = null,
                this.plugins = null,
                this.cache = null,
                this.load = null,
                this.time = null,
                this.world = null,
                this.isBooted = !1,
                this.renderer.destroy(!1),
                W.Canvas.removeFromDOM(this.canvas),
                PIXI.defaultRenderer = null,
                W.GAMES[this.id] = null
            },
            gamePaused: function(t) {
                this._paused || (this._paused = !0,
                this.time.gamePaused(),
                this.sound.muteOnPause && this.sound.setMute(),
                this.onPause.dispatch(t),
                this.device.cordova && this.device.iOS && (this.lockRender = !0))
            },
            gameResumed: function(t) {
                this._paused && !this._codePaused && (this._paused = !1,
                this.time.gameResumed(),
                this.input.reset(),
                this.sound.muteOnPause && this.sound.unsetMute(),
                this.onResume.dispatch(t),
                this.device.cordova && this.device.iOS && (this.lockRender = !1))
            },
            focusLoss: function(t) {
                this.onBlur.dispatch(t),
                this.stage.disableVisibilityChange || this.gamePaused(t)
            },
            focusGain: function(t) {
                this.onFocus.dispatch(t),
                this.stage.disableVisibilityChange || this.gameResumed(t)
            }
        },
        W.Game.prototype.constructor = W.Game,
        Object.defineProperty(W.Game.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                !0 === t ? (!1 === this._paused && (this._paused = !0,
                this.sound.setMute(),
                this.time.gamePaused(),
                this.onPause.dispatch(this)),
                this._codePaused = !0) : (this._paused && (this._paused = !1,
                this.input.reset(),
                this.sound.unsetMute(),
                this.time.gameResumed(),
                this.onResume.dispatch(this)),
                this._codePaused = !1)
            }
        }),
        W.Input = function(t) {
            this.game = t,
            this.hitCanvas = null,
            this.hitContext = null,
            this.moveCallbacks = [],
            this.customCandidateHandler = null,
            this.customCandidateHandlerContext = null,
            this.pollRate = 0,
            this.enabled = !0,
            this.multiInputOverride = W.Input.MOUSE_TOUCH_COMBINE,
            this.position = null,
            this.speed = null,
            this.circle = null,
            this.scale = null,
            this.maxPointers = -1,
            this.tapRate = 200,
            this.doubleTapRate = 300,
            this.holdRate = 2e3,
            this.justPressedRate = 200,
            this.justReleasedRate = 200,
            this.recordPointerHistory = !1,
            this.recordRate = 100,
            this.recordLimit = 100,
            this.pointer1 = null,
            this.pointer2 = null,
            this.pointer3 = null,
            this.pointer4 = null,
            this.pointer5 = null,
            this.pointer6 = null,
            this.pointer7 = null,
            this.pointer8 = null,
            this.pointer9 = null,
            this.pointer10 = null,
            this.pointers = [],
            this.activePointer = null,
            this.mousePointer = null,
            this.mouse = null,
            this.keyboard = null,
            this.touch = null,
            this.mspointer = null,
            this.gamepad = null,
            this.resetLocked = !1,
            this.onDown = null,
            this.onUp = null,
            this.onTap = null,
            this.onHold = null,
            this.minPriorityID = 0,
            this.interactiveItems = new W.ArraySet,
            this._localPoint = new W.Point,
            this._pollCounter = 0,
            this._oldPosition = null,
            this._x = 0,
            this._y = 0
        }
        ,
        W.Input.MOUSE_OVERRIDES_TOUCH = 0,
        W.Input.TOUCH_OVERRIDES_MOUSE = 1,
        W.Input.MOUSE_TOUCH_COMBINE = 2,
        W.Input.MAX_POINTERS = 10,
        W.Input.prototype = {
            boot: function() {
                this.mousePointer = new W.Pointer(this.game,0,W.PointerMode.CURSOR),
                this.addPointer(),
                this.addPointer(),
                this.mouse = new W.Mouse(this.game),
                this.touch = new W.Touch(this.game),
                this.mspointer = new W.MSPointer(this.game),
                W.Keyboard && (this.keyboard = new W.Keyboard(this.game)),
                W.Gamepad && (this.gamepad = new W.Gamepad(this.game)),
                this.onDown = new W.Signal,
                this.onUp = new W.Signal,
                this.onTap = new W.Signal,
                this.onHold = new W.Signal,
                this.scale = new W.Point(1,1),
                this.speed = new W.Point,
                this.position = new W.Point,
                this._oldPosition = new W.Point,
                this.circle = new W.Circle(0,0,44),
                this.activePointer = this.mousePointer,
                this.hitCanvas = W.CanvasPool.create(this, 1, 1),
                this.hitContext = this.hitCanvas.getContext("2d"),
                this.mouse.start(),
                this.game.device.mspointer || this.touch.start(),
                this.mspointer.start(),
                this.mousePointer.active = !0,
                this.keyboard && this.keyboard.start();
                var e = this;
                this._onClickTrampoline = function(t) {
                    e.onClickTrampoline(t)
                }
                ,
                this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            },
            destroy: function() {
                this.mouse.stop(),
                this.touch.stop(),
                this.mspointer.stop(),
                this.keyboard && this.keyboard.stop(),
                this.gamepad && this.gamepad.stop(),
                this.moveCallbacks = [],
                W.CanvasPool.remove(this),
                this.game.canvas.removeEventListener("click", this._onClickTrampoline)
            },
            setInteractiveCandidateHandler: function(t, e) {
                this.customCandidateHandler = t,
                this.customCandidateHandlerContext = e
            },
            addMoveCallback: function(t, e) {
                this.moveCallbacks.push({
                    callback: t,
                    context: e
                })
            },
            deleteMoveCallback: function(t, e) {
                for (var i = this.moveCallbacks.length; i--; )
                    if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e)
                        return void this.moveCallbacks.splice(i, 1)
            },
            addPointer: function() {
                if (this.pointers.length >= W.Input.MAX_POINTERS)
                    return console.warn("Phaser.Input.addPointer: Maximum limit of " + W.Input.MAX_POINTERS + " pointers reached."),
                    null;
                var t = this.pointers.length + 1
                  , e = new W.Pointer(this.game,t,W.PointerMode.TOUCH);
                return this.pointers.push(e),
                this["pointer" + t] = e
            },
            update: function() {
                if (this.keyboard && this.keyboard.update(),
                0 < this.pollRate && this._pollCounter < this.pollRate)
                    this._pollCounter++;
                else {
                    this.speed.x = this.position.x - this._oldPosition.x,
                    this.speed.y = this.position.y - this._oldPosition.y,
                    this._oldPosition.copyFrom(this.position),
                    this.mousePointer.update(),
                    this.gamepad && this.gamepad.active && this.gamepad.update();
                    for (var t = 0; t < this.pointers.length; t++)
                        this.pointers[t].update();
                    this._pollCounter = 0
                }
            },
            reset: function(t) {
                if (this.game.isBooted && !this.resetLocked) {
                    void 0 === t && (t = !1),
                    this.mousePointer.reset(),
                    this.keyboard && this.keyboard.reset(t),
                    this.gamepad && this.gamepad.reset();
                    for (var e = 0; e < this.pointers.length; e++)
                        this.pointers[e].reset();
                    "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""),
                    t && (this.onDown.dispose(),
                    this.onUp.dispose(),
                    this.onTap.dispose(),
                    this.onHold.dispose(),
                    this.onDown = new W.Signal,
                    this.onUp = new W.Signal,
                    this.onTap = new W.Signal,
                    this.onHold = new W.Signal,
                    this.moveCallbacks = []),
                    this._pollCounter = 0
                }
            },
            resetSpeed: function(t, e) {
                this._oldPosition.setTo(t, e),
                this.speed.setTo(0, 0)
            },
            startPointer: function(t) {
                if (0 <= this.maxPointers && this.countActivePointers(this.maxPointers) >= this.maxPointers)
                    return null;
                if (!this.pointer1.active)
                    return this.pointer1.start(t);
                if (!this.pointer2.active)
                    return this.pointer2.start(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (!i.active)
                        return i.start(t)
                }
                return null
            },
            updatePointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier)
                    return this.pointer1.move(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier)
                    return this.pointer2.move(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier)
                        return i.move(t)
                }
                return null
            },
            stopPointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier)
                    return this.pointer1.stop(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier)
                    return this.pointer2.stop(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier)
                        return i.stop(t)
                }
                return null
            },
            countActivePointers: function(t) {
                void 0 === t && (t = this.pointers.length);
                for (var e = t, i = 0; i < this.pointers.length && 0 < e; i++) {
                    this.pointers[i].active && e--
                }
                return t - e
            },
            getPointer: function(t) {
                void 0 === t && (t = !1);
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active === t)
                        return i
                }
                return null
            },
            getPointerFromIdentifier: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.identifier === t)
                        return i
                }
                return null
            },
            getPointerFromId: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.pointerId === t)
                        return i
                }
                return null
            },
            getLocalPosition: function(t, e, i) {
                void 0 === i && (i = new W.Point);
                var s = t.worldTransform
                  , n = 1 / (s.a * s.d + s.c * -s.b);
                return i.setTo(s.d * n * e.x + -s.c * n * e.y + (s.ty * s.c - s.tx * s.d) * n, s.a * n * e.y + -s.b * n * e.x + (-s.ty * s.a + s.tx * s.b) * n)
            },
            hitTest: function(t, e, i) {
                if (!t.worldVisible)
                    return !1;
                if (this.getLocalPosition(t, e, this._localPoint),
                i.copyFrom(this._localPoint),
                t.hitArea && t.hitArea.contains)
                    return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if (t instanceof W.TileSprite) {
                    var s = t.width
                      , n = t.height
                      , r = -s * t.anchor.x;
                    if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                        var o = -n * t.anchor.y;
                        if (this._localPoint.y >= o && this._localPoint.y < o + n)
                            return !0
                    }
                } else if (t instanceof PIXI.Sprite) {
                    s = t.texture.frame.width,
                    n = t.texture.frame.height,
                    r = -s * t.anchor.x;
                    if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                        o = -n * t.anchor.y;
                        if (this._localPoint.y >= o && this._localPoint.y < o + n)
                            return !0
                    }
                } else if (t instanceof W.Graphics)
                    for (var a = 0; a < t.graphicsData.length; a++) {
                        var h = t.graphicsData[a];
                        if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y)))
                            return !0
                    }
                for (a = 0; a < t.children.length; a++)
                    if (this.hitTest(t.children[a], e, i))
                        return !0;
                return !1
            },
            onClickTrampoline: function() {
                this.activePointer.processClickTrampolines()
            }
        },
        W.Input.prototype.constructor = W.Input,
        Object.defineProperty(W.Input.prototype, "x", {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = Math.floor(t)
            }
        }),
        Object.defineProperty(W.Input.prototype, "y", {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = Math.floor(t)
            }
        }),
        Object.defineProperty(W.Input.prototype, "pollLocked", {
            get: function() {
                return 0 < this.pollRate && this._pollCounter < this.pollRate
            }
        }),
        Object.defineProperty(W.Input.prototype, "totalInactivePointers", {
            get: function() {
                return this.pointers.length - this.countActivePointers()
            }
        }),
        Object.defineProperty(W.Input.prototype, "totalActivePointers", {
            get: function() {
                return this.countActivePointers()
            }
        }),
        Object.defineProperty(W.Input.prototype, "worldX", {
            get: function() {
                return this.game.camera.view.x + this.x
            }
        }),
        Object.defineProperty(W.Input.prototype, "worldY", {
            get: function() {
                return this.game.camera.view.y + this.y
            }
        }),
        W.Mouse = function(t) {
            this.game = t,
            this.input = t.input,
            this.callbackContext = this.game,
            this.mouseDownCallback = null,
            this.mouseUpCallback = null,
            this.mouseOutCallback = null,
            this.mouseOverCallback = null,
            this.mouseWheelCallback = null,
            this.capture = !1,
            this.button = -1,
            this.wheelDelta = 0,
            this.enabled = !0,
            this.locked = !1,
            this.stopOnGameOut = !1,
            this.pointerLock = new W.Signal,
            this.event = null,
            this._onMouseDown = null,
            this._onMouseMove = null,
            this._onMouseUp = null,
            this._onMouseOut = null,
            this._onMouseOver = null,
            this._onMouseWheel = null,
            this._wheelEvent = null
        }
        ,
        W.Mouse.NO_BUTTON = -1,
        W.Mouse.LEFT_BUTTON = 0,
        W.Mouse.MIDDLE_BUTTON = 1,
        W.Mouse.RIGHT_BUTTON = 2,
        W.Mouse.BACK_BUTTON = 3,
        W.Mouse.FORWARD_BUTTON = 4,
        W.Mouse.WHEEL_UP = 1,
        W.Mouse.WHEEL_DOWN = -1,
        W.Mouse.prototype = {
            start: function() {
                if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                    var e = this;
                    this._onMouseDown = function(t) {
                        return e.onMouseDown(t)
                    }
                    ,
                    this._onMouseMove = function(t) {
                        return e.onMouseMove(t)
                    }
                    ,
                    this._onMouseUp = function(t) {
                        return e.onMouseUp(t)
                    }
                    ,
                    this._onMouseUpGlobal = function(t) {
                        return e.onMouseUpGlobal(t)
                    }
                    ,
                    this._onMouseOutGlobal = function(t) {
                        return e.onMouseOutGlobal(t)
                    }
                    ,
                    this._onMouseOut = function(t) {
                        return e.onMouseOut(t)
                    }
                    ,
                    this._onMouseOver = function(t) {
                        return e.onMouseOver(t)
                    }
                    ,
                    this._onMouseWheel = function(t) {
                        return e.onMouseWheel(t)
                    }
                    ;
                    var t = this.game.canvas;
                    t.addEventListener("mousedown", this._onMouseDown, !0),
                    t.addEventListener("mousemove", this._onMouseMove, !0),
                    t.addEventListener("mouseup", this._onMouseUp, !0),
                    this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0),
                    window.addEventListener("mouseout", this._onMouseOutGlobal, !0),
                    t.addEventListener("mouseover", this._onMouseOver, !0),
                    t.addEventListener("mouseout", this._onMouseOut, !0));
                    var i = this.game.device.wheelEvent;
                    i && (t.addEventListener(i, this._onMouseWheel, !0),
                    "mousewheel" === i ? this._wheelEvent = new s(-.025,1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1,1)))
                }
            },
            onMouseDown: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = 0,
                this.input.mousePointer.start(t))
            },
            onMouseMove: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = 0,
                this.input.mousePointer.move(t))
            },
            onMouseUp: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = 0,
                this.input.mousePointer.stop(t))
            },
            onMouseUpGlobal: function(t) {
                this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t),
                t.identifier = 0,
                this.input.mousePointer.stop(t))
            },
            onMouseOutGlobal: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.input.mousePointer.withinGame = !1,
                this.input.enabled && this.enabled && (this.input.mousePointer.stop(t),
                this.input.mousePointer.leftButton.stop(t),
                this.input.mousePointer.rightButton.stop(t))
            },
            onMouseOut: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.input.mousePointer.withinGame = !1,
                this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0,
                this.input.mousePointer.stop(t))
            },
            onMouseOver: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.input.mousePointer.withinGame = !0,
                this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
            },
            onMouseWheel: function(t) {
                this._wheelEvent && (t = this._wheelEvent.bindEvent(t)),
                this.event = t,
                this.capture && t.preventDefault(),
                this.wheelDelta = W.Math.clamp(-t.deltaY, -1, 1),
                this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
            },
            requestPointerLock: function() {
                if (this.game.device.pointerLock) {
                    var t = this.game.canvas;
                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock,
                    t.requestPointerLock();
                    var e = this;
                    this._pointerLockChange = function(t) {
                        return e.pointerLockChange(t)
                    }
                    ,
                    document.addEventListener("pointerlockchange", this._pointerLockChange, !0),
                    document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0),
                    document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            },
            pointerLockChange: function(t) {
                var e = this.game.canvas;
                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0,
                this.pointerLock.dispatch(!0, t)) : (this.locked = !1,
                this.pointerLock.dispatch(!1, t))
            },
            releasePointerLock: function() {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock,
                document.exitPointerLock(),
                document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
                document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
                document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0),
                t.removeEventListener("mousemove", this._onMouseMove, !0),
                t.removeEventListener("mouseup", this._onMouseUp, !0),
                t.removeEventListener("mouseover", this._onMouseOver, !0),
                t.removeEventListener("mouseout", this._onMouseOut, !0);
                var e = this.game.device.wheelEvent;
                e && t.removeEventListener(e, this._onMouseWheel, !0),
                window.removeEventListener("mouseup", this._onMouseUpGlobal, !0),
                window.removeEventListener("mouseout", this._onMouseOutGlobal, !0),
                document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
                document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
                document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        },
        W.Mouse.prototype.constructor = W.Mouse,
        ((s.prototype = {}).constructor = s).prototype.bindEvent = function(t) {
            if (!s._stubsGenerated && t) {
                function e(e) {
                    return function() {
                        var t = this.originalEvent[e];
                        return "function" != typeof t ? t : t.bind(this.originalEvent)
                    }
                }
                for (var i in t)
                    i in s.prototype || Object.defineProperty(s.prototype, i, {
                        get: e(i)
                    });
                s._stubsGenerated = !0
            }
            return this.originalEvent = t,
            this
        }
        ,
        Object.defineProperties(s.prototype, {
            type: {
                value: "wheel"
            },
            deltaMode: {
                get: function() {
                    return this._deltaMode
                }
            },
            deltaY: {
                get: function() {
                    return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                }
            },
            deltaX: {
                get: function() {
                    return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                }
            },
            deltaZ: {
                value: 0
            }
        }),
        W.MSPointer = function(t) {
            this.game = t,
            this.input = t.input,
            this.callbackContext = this.game,
            this.pointerDownCallback = null,
            this.pointerMoveCallback = null,
            this.pointerUpCallback = null,
            this.capture = !0,
            this.button = -1,
            this.event = null,
            this.enabled = !0,
            this._onMSPointerDown = null,
            this._onMSPointerMove = null,
            this._onMSPointerUp = null,
            this._onMSPointerUpGlobal = null,
            this._onMSPointerOut = null,
            this._onMSPointerOver = null
        }
        ,
        W.MSPointer.prototype = {
            start: function() {
                if (null === this._onMSPointerDown) {
                    var e = this;
                    if (this.game.device.mspointer) {
                        this._onMSPointerDown = function(t) {
                            return e.onPointerDown(t)
                        }
                        ,
                        this._onMSPointerMove = function(t) {
                            return e.onPointerMove(t)
                        }
                        ,
                        this._onMSPointerUp = function(t) {
                            return e.onPointerUp(t)
                        }
                        ,
                        this._onMSPointerUpGlobal = function(t) {
                            return e.onPointerUpGlobal(t)
                        }
                        ,
                        this._onMSPointerOut = function(t) {
                            return e.onPointerOut(t)
                        }
                        ,
                        this._onMSPointerOver = function(t) {
                            return e.onPointerOver(t)
                        }
                        ;
                        var t = this.game.canvas;
                        t.addEventListener("MSPointerDown", this._onMSPointerDown, !1),
                        t.addEventListener("MSPointerMove", this._onMSPointerMove, !1),
                        t.addEventListener("MSPointerUp", this._onMSPointerUp, !1),
                        t.addEventListener("pointerdown", this._onMSPointerDown, !1),
                        t.addEventListener("pointermove", this._onMSPointerMove, !1),
                        t.addEventListener("pointerup", this._onMSPointerUp, !1),
                        t.style["-ms-content-zooming"] = "none",
                        t.style["-ms-touch-action"] = "none",
                        this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
                        t.addEventListener("MSPointerOver", this._onMSPointerOver, !0),
                        t.addEventListener("MSPointerOut", this._onMSPointerOut, !0),
                        window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0),
                        t.addEventListener("pointerover", this._onMSPointerOver, !0),
                        t.addEventListener("pointerout", this._onMSPointerOut, !0))
                    }
                }
            },
            onPointerDown: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = t.pointerId,
                "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
            },
            onPointerMove: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = t.pointerId,
                "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
            },
            onPointerUp: function(t) {
                this.event = t,
                this.capture && t.preventDefault(),
                this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t),
                this.input.enabled && this.enabled && (t.identifier = t.pointerId,
                "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            },
            onPointerUpGlobal: function(t) {
                if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t)
                } else
                    this.onPointerUp(t)
            },
            onPointerOut: function(t) {
                if (this.event = t,
                this.capture && t.preventDefault(),
                "mouse" === t.pointerType || 4 === t.pointerType)
                    this.input.mousePointer.withinGame = !1;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !1)
                }
                this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t),
                this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0,
                e ? e.stop(t) : this.input.mousePointer.stop(t))
            },
            onPointerOver: function(t) {
                if (this.event = t,
                this.capture && t.preventDefault(),
                "mouse" === t.pointerType || 4 === t.pointerType)
                    this.input.mousePointer.withinGame = !0;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !0)
                }
                this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1),
                t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1),
                t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1),
                t.removeEventListener("pointerdown", this._onMSPointerDown, !1),
                t.removeEventListener("pointermove", this._onMSPointerMove, !1),
                t.removeEventListener("pointerup", this._onMSPointerUp, !1),
                window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
                t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0),
                t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0),
                window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0),
                t.removeEventListener("pointerover", this._onMSPointerOver, !0),
                t.removeEventListener("pointerout", this._onMSPointerOut, !0)
            }
        },
        W.MSPointer.prototype.constructor = W.MSPointer,
        W.DeviceButton = function(t, e) {
            this.parent = t,
            this.game = t.game,
            this.event = null,
            this.isDown = !1,
            this.isUp = !0,
            this.timeDown = 0,
            this.timeUp = 0,
            this.repeats = 0,
            this.altKey = !1,
            this.shiftKey = !1,
            this.ctrlKey = !1,
            this.value = 0,
            this.buttonCode = e,
            this.onDown = new W.Signal,
            this.onUp = new W.Signal,
            this.onFloat = new W.Signal
        }
        ,
        W.DeviceButton.prototype = {
            start: function(t, e) {
                this.isDown || (this.isDown = !0,
                this.isUp = !1,
                this.timeDown = this.game.time.time,
                this.repeats = 0,
                this.event = t,
                this.value = e,
                t && (this.altKey = t.altKey,
                this.shiftKey = t.shiftKey,
                this.ctrlKey = t.ctrlKey),
                this.onDown.dispatch(this, e))
            },
            stop: function(t, e) {
                this.isUp || (this.isDown = !1,
                this.isUp = !0,
                this.timeUp = this.game.time.time,
                this.event = t,
                this.value = e,
                t && (this.altKey = t.altKey,
                this.shiftKey = t.shiftKey,
                this.ctrlKey = t.ctrlKey),
                this.onUp.dispatch(this, e))
            },
            padFloat: function(t) {
                this.isDown = !1,
                this.isUp = !1,
                this.value = t,
                this.onFloat.dispatch(this, t)
            },
            justPressed: function(t) {
                return t = t || 250,
                this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || 250,
                this.isUp && this.timeUp + t > this.game.time.time
            },
            reset: function() {
                this.isDown = !1,
                this.isUp = !0,
                this.timeDown = this.game.time.time,
                this.repeats = 0,
                this.altKey = !1,
                this.shiftKey = !1,
                this.ctrlKey = !1
            },
            destroy: function() {
                this.onDown.dispose(),
                this.onUp.dispose(),
                this.onFloat.dispose(),
                this.parent = null,
                this.game = null
            }
        },
        W.DeviceButton.prototype.constructor = W.DeviceButton,
        Object.defineProperty(W.DeviceButton.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }),
        W.Pointer = function(t, e, i) {
            this.game = t,
            this.id = e,
            this.type = W.POINTER,
            this.exists = !0,
            this.identifier = 0,
            this.pointerId = null,
            this.pointerMode = i || W.PointerMode.CURSOR | W.PointerMode.CONTACT,
            this.target = null,
            this.button = null,
            this.leftButton = new W.DeviceButton(this,W.Pointer.LEFT_BUTTON),
            this.middleButton = new W.DeviceButton(this,W.Pointer.MIDDLE_BUTTON),
            this.rightButton = new W.DeviceButton(this,W.Pointer.RIGHT_BUTTON),
            this.backButton = new W.DeviceButton(this,W.Pointer.BACK_BUTTON),
            this.forwardButton = new W.DeviceButton(this,W.Pointer.FORWARD_BUTTON),
            this.eraserButton = new W.DeviceButton(this,W.Pointer.ERASER_BUTTON),
            this._holdSent = !1,
            this._history = [],
            this._nextDrop = 0,
            this._stateReset = !1,
            this.withinGame = !1,
            this.clientX = -1,
            this.clientY = -1,
            this.pageX = -1,
            this.pageY = -1,
            this.screenX = -1,
            this.screenY = -1,
            this.rawMovementX = 0,
            this.rawMovementY = 0,
            this.movementX = 0,
            this.movementY = 0,
            this.x = -1,
            this.y = -1,
            this.isMouse = 0 === e,
            this.isDown = !1,
            this.isUp = !0,
            this.timeDown = 0,
            this.timeUp = 0,
            this.previousTapTime = 0,
            this.totalTouches = 0,
            this.msSinceLastClick = Number.MAX_VALUE,
            this.targetObject = null,
            this.interactiveCandidates = [],
            this.active = !1,
            this.dirty = !1,
            this.position = new W.Point,
            this.positionDown = new W.Point,
            this.positionUp = new W.Point,
            this.circle = new W.Circle(0,0,44),
            this._clickTrampolines = null,
            this._trampolineTargetObject = null
        }
        ,
        W.Pointer.NO_BUTTON = 0,
        W.Pointer.LEFT_BUTTON = 1,
        W.Pointer.RIGHT_BUTTON = 2,
        W.Pointer.MIDDLE_BUTTON = 4,
        W.Pointer.BACK_BUTTON = 8,
        W.Pointer.FORWARD_BUTTON = 16,
        W.Pointer.ERASER_BUTTON = 32,
        W.Pointer.prototype = {
            resetButtons: function() {
                this.isDown = !1,
                this.isUp = !0,
                this.isMouse && (this.leftButton.reset(),
                this.middleButton.reset(),
                this.rightButton.reset(),
                this.backButton.reset(),
                this.forwardButton.reset(),
                this.eraserButton.reset())
            },
            processButtonsDown: function(t, e) {
                W.Pointer.LEFT_BUTTON & t && this.leftButton.start(e),
                W.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e),
                W.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e),
                W.Pointer.BACK_BUTTON & t && this.backButton.start(e),
                W.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e),
                W.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
            },
            processButtonsUp: function(t, e) {
                t === W.Mouse.LEFT_BUTTON && this.leftButton.stop(e),
                t === W.Mouse.RIGHT_BUTTON && this.rightButton.stop(e),
                t === W.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e),
                t === W.Mouse.BACK_BUTTON && this.backButton.stop(e),
                t === W.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e),
                5 === t && this.eraserButton.stop(e)
            },
            updateButtons: function(t) {
                this.button = t.button;
                var e = "down" === t.type.toLowerCase().substr(-4);
                void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t),
                this.rightButton.stop(t)),
                1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t),
                this.rightButton.start(t)),
                this.isUp = !0,
                this.isDown = !1,
                (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1,
                this.isDown = !0)
            },
            start: function(t) {
                var e = this.game.input;
                return t.pointerId && (this.pointerId = t.pointerId),
                this.identifier = t.identifier,
                this.target = t.target,
                this.isMouse ? this.updateButtons(t) : (this.isDown = !0,
                this.isUp = !1),
                this.active = !0,
                this.withinGame = !0,
                this.dirty = !1,
                this._history = [],
                this._clickTrampolines = null,
                this._trampolineTargetObject = null,
                this.msSinceLastClick = this.game.time.time - this.timeDown,
                this.timeDown = this.game.time.time,
                this._holdSent = !1,
                this.move(t, !0),
                this.positionDown.setTo(this.x, this.y),
                (e.multiInputOverride === W.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === W.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === W.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x,
                e.y = this.y,
                e.position.setTo(this.x, this.y),
                e.onDown.dispatch(this, t),
                e.resetSpeed(this.x, this.y)),
                this._stateReset = !1,
                this.totalTouches++,
                null !== this.targetObject && this.targetObject._touchedHandler(this),
                this
            },
            update: function() {
                var t = this.game.input;
                this.active && (this.dirty && (0 < t.interactiveItems.total && this.processInteractiveObjects(!1),
                this.dirty = !1),
                !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === W.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === W.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === W.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this),
                this._holdSent = !0),
                t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate,
                this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }),
                this._history.length > t.recordLimit && this._history.shift()))
            },
            move: function(t, e) {
                var i = this.game.input;
                if (!i.pollLocked) {
                    void 0 === e && (e = !1),
                    void 0 !== t.button && (this.button = t.button),
                    e && this.isMouse && this.updateButtons(t),
                    this.clientX = t.clientX,
                    this.clientY = t.clientY,
                    this.pageX = t.pageX,
                    this.pageY = t.pageY,
                    this.screenX = t.screenX,
                    this.screenY = t.screenY,
                    this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0,
                    this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0,
                    this.movementX += this.rawMovementX,
                    this.movementY += this.rawMovementY),
                    this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x,
                    this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y,
                    this.position.setTo(this.x, this.y),
                    this.circle.x = this.x,
                    this.circle.y = this.y,
                    (i.multiInputOverride === W.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === W.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === W.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this,
                    i.x = this.x,
                    i.y = this.y,
                    i.position.setTo(i.x, i.y),
                    i.circle.x = i.x,
                    i.circle.y = i.y),
                    this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                    for (var s = i.moveCallbacks.length; s--; )
                        i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e);
                    return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? 0 < i.interactiveItems.total && this.processInteractiveObjects(e) : !1 === this.targetObject.update(this) && (this.targetObject = null),
                    this
                }
            },
            processInteractiveObjects: function(t) {
                var e = 0
                  , i = -1
                  , s = null
                  , n = this.game.input.interactiveItems.first;
                for (this.interactiveCandidates = []; n; )
                    n.checked = !1,
                    !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0,
                    (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID,
                    i = n.priorityID,
                    s = n,
                    this.interactiveCandidates.push(n))),
                    n = this.game.input.interactiveItems.next;
                for (n = this.game.input.interactiveItems.first; n; )
                    !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID,
                    i = n.priorityID,
                    s = n,
                    this.interactiveCandidates.push(n)),
                    n = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)),
                this.swapTarget(s, !1),
                null !== this.targetObject
            },
            swapTarget: function(t, e) {
                void 0 === e && (e = !1),
                null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e),
                this.targetObject = null) : null === this.targetObject ? (this.targetObject = t)._pointerOverHandler(this, e) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e),
                this.targetObject = t,
                this.targetObject._pointerOverHandler(this, e))
            },
            leave: function(t) {
                this.withinGame = !1,
                this.move(t, !1)
            },
            stop: function(t) {
                var e = this.game.input;
                if (!this._stateReset || !this.withinGame)
                    return this.timeUp = this.game.time.time,
                    (e.multiInputOverride === W.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === W.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === W.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t),
                    0 <= this.duration && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1),
                    this.previousTapTime = this.timeUp)),
                    this.isMouse ? this.updateButtons(t) : (this.isDown = !1,
                    this.isUp = !0),
                    0 < this.id && (this.active = !1),
                    this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY),
                    this.pointerId = null,
                    this.identifier = null,
                    this.positionUp.setTo(this.x, this.y),
                    !1 === this.isMouse && e.currentPointers--,
                    e.interactiveItems.callAll("_releasedHandler", this),
                    this._clickTrampolines && (this._trampolineTargetObject = this.targetObject),
                    this.targetObject = null,
                    this;
                t.preventDefault()
            },
            justPressed: function(t) {
                return t = t || this.game.input.justPressedRate,
                !0 === this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || this.game.input.justReleasedRate,
                this.isUp && this.timeUp + t > this.game.time.time
            },
            addClickTrampoline: function(t, e, i, s) {
                if (this.isDown) {
                    for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++)
                        if (n[r].name === t) {
                            n.splice(r, 1);
                            break
                        }
                    n.push({
                        name: t,
                        targetObject: this.targetObject,
                        callback: e,
                        callbackContext: i,
                        callbackArgs: s
                    })
                }
            },
            processClickTrampolines: function() {
                var t = this._clickTrampolines;
                if (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                    }
                    this._clickTrampolines = null,
                    this._trampolineTargetObject = null
                }
            },
            reset: function() {
                !1 === this.isMouse && (this.active = !1),
                this.pointerId = null,
                this.identifier = null,
                this.dirty = !1,
                this.totalTouches = 0,
                this._holdSent = !1,
                this._history.length = 0,
                this._stateReset = !0,
                this.resetButtons(),
                this.targetObject && this.targetObject._releasedHandler(this),
                this.targetObject = null
            },
            resetMovement: function() {
                this.movementX = 0,
                this.movementY = 0
            }
        },
        W.Pointer.prototype.constructor = W.Pointer,
        Object.defineProperty(W.Pointer.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }),
        Object.defineProperty(W.Pointer.prototype, "worldX", {
            get: function() {
                return this.game.world.camera.x + this.x
            }
        }),
        Object.defineProperty(W.Pointer.prototype, "worldY", {
            get: function() {
                return this.game.world.camera.y + this.y
            }
        }),
        W.PointerMode = {
            CURSOR: 1,
            CONTACT: 2
        },
        W.Touch = function(t) {
            this.game = t,
            this.enabled = !0,
            this.touchLockCallbacks = [],
            this.callbackContext = this.game,
            this.touchStartCallback = null,
            this.touchMoveCallback = null,
            this.touchEndCallback = null,
            this.touchEnterCallback = null,
            this.touchLeaveCallback = null,
            this.touchCancelCallback = null,
            this.preventDefault = !0,
            this.event = null,
            this._onTouchStart = null,
            this._onTouchMove = null,
            this._onTouchEnd = null,
            this._onTouchEnter = null,
            this._onTouchLeave = null,
            this._onTouchCancel = null,
            this._onTouchMove = null
        }
        ,
        W.Touch.prototype = {
            start: function() {
                if (null === this._onTouchStart) {
                    var e = this;
                    this.game.device.touch && (this._onTouchStart = function(t) {
                        return e.onTouchStart(t)
                    }
                    ,
                    this._onTouchMove = function(t) {
                        return e.onTouchMove(t)
                    }
                    ,
                    this._onTouchEnd = function(t) {
                        return e.onTouchEnd(t)
                    }
                    ,
                    this._onTouchEnter = function(t) {
                        return e.onTouchEnter(t)
                    }
                    ,
                    this._onTouchLeave = function(t) {
                        return e.onTouchLeave(t)
                    }
                    ,
                    this._onTouchCancel = function(t) {
                        return e.onTouchCancel(t)
                    }
                    ,
                    this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1),
                    this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1),
                    this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1),
                    this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1),
                    this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1),
                    this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                }
            },
            consumeDocumentTouches: function() {
                this._documentTouchMove = function(t) {
                    t.preventDefault()
                }
                ,
                document.addEventListener("touchmove", this._documentTouchMove, !1)
            },
            addTouchLockCallback: function(t, e, i) {
                void 0 === i && (i = !1),
                this.touchLockCallbacks.push({
                    callback: t,
                    context: e,
                    onEnd: i
                })
            },
            removeTouchLockCallback: function(t, e) {
                for (var i = this.touchLockCallbacks.length; i--; )
                    if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e)
                        return this.touchLockCallbacks.splice(i, 1),
                        !0;
                return !1
            },
            onTouchStart: function(t) {
                for (var e = this.touchLockCallbacks.length; e--; ) {
                    var i = this.touchLockCallbacks[e];
                    !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                if (this.event = t,
                this.game.input.enabled && this.enabled) {
                    this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t),
                    this.preventDefault && t.preventDefault();
                    for (e = 0; e < t.changedTouches.length; e++)
                        this.game.input.startPointer(t.changedTouches[e])
                }
            },
            onTouchCancel: function(t) {
                if (this.event = t,
                this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t),
                this.game.input.enabled && this.enabled) {
                    this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++)
                        this.game.input.stopPointer(t.changedTouches[e])
                }
            },
            onTouchEnter: function(t) {
                this.event = t,
                this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t),
                this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
            },
            onTouchLeave: function(t) {
                this.event = t,
                this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t),
                this.preventDefault && t.preventDefault()
            },
            onTouchMove: function(t) {
                this.event = t,
                this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t),
                this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++)
                    this.game.input.updatePointer(t.changedTouches[e])
            },
            onTouchEnd: function(t) {
                for (var e = this.touchLockCallbacks.length; e--; ) {
                    var i = this.touchLockCallbacks[e];
                    i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                this.event = t,
                this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t),
                this.preventDefault && t.preventDefault();
                for (e = 0; e < t.changedTouches.length; e++)
                    this.game.input.stopPointer(t.changedTouches[e])
            },
            stop: function() {
                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart),
                this.game.canvas.removeEventListener("touchmove", this._onTouchMove),
                this.game.canvas.removeEventListener("touchend", this._onTouchEnd),
                this.game.canvas.removeEventListener("touchenter", this._onTouchEnter),
                this.game.canvas.removeEventListener("touchleave", this._onTouchLeave),
                this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
            }
        },
        W.Touch.prototype.constructor = W.Touch,
        W.InputHandler = function(t) {
            this.sprite = t,
            this.game = t.game,
            this.enabled = !1,
            this.checked = !1,
            this.priorityID = 0,
            this.useHandCursor = !1,
            this._setHandCursor = !1,
            this.isDragged = !1,
            this.allowHorizontalDrag = !0,
            this.allowVerticalDrag = !0,
            this.bringToTop = !1,
            this.snapOffset = null,
            this.snapOnDrag = !1,
            this.snapOnRelease = !1,
            this.snapX = 0,
            this.snapY = 0,
            this.snapOffsetX = 0,
            this.snapOffsetY = 0,
            this.pixelPerfectOver = !1,
            this.pixelPerfectClick = !1,
            this.pixelPerfectAlpha = 255,
            this.draggable = !1,
            this.boundsRect = null,
            this.boundsSprite = null,
            this.scaleLayer = !1,
            this.dragOffset = new W.Point,
            this.dragFromCenter = !1,
            this.dragStopBlocksInputUp = !1,
            this.dragStartPoint = new W.Point,
            this.dragDistanceThreshold = 0,
            this.dragTimeThreshold = 0,
            this.downPoint = new W.Point,
            this.snapPoint = new W.Point,
            this._dragPoint = new W.Point,
            this._dragPhase = !1,
            this._pendingDrag = !1,
            this._dragTimePass = !1,
            this._dragDistancePass = !1,
            this._wasEnabled = !1,
            this._tempPoint = new W.Point,
            this._pointerData = [],
            this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                camX: 0,
                camY: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        }
        ,
        W.InputHandler.prototype = {
            start: function(t, e) {
                if (t = t || 0,
                void 0 === e && (e = !1),
                !1 === this.enabled) {
                    this.game.input.interactiveItems.add(this),
                    this.useHandCursor = e,
                    this.priorityID = t;
                    for (var i = 0; i < 10; i++)
                        this._pointerData[i] = {
                            id: i,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        };
                    this.snapOffset = new W.Point,
                    this.enabled = !0,
                    this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this),
                this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this),
                this.sprite
            },
            addedToGroup: function() {
                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
            },
            removedFromGroup: function() {
                this._dragPhase || (this.enabled ? (this._wasEnabled = !0,
                this.stop()) : this._wasEnabled = !1)
            },
            reset: function() {
                this.enabled = !1;
                for (var t = 0; t < 10; t++)
                    this._pointerData[t] = {
                        id: t,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    }
            },
            stop: function() {
                !1 !== this.enabled && (this.enabled = !1,
                this.game.input.interactiveItems.remove(this))
            },
            destroy: function() {
                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "",
                this._setHandCursor = !1),
                this.enabled = !1,
                this.game.input.interactiveItems.remove(this),
                this._pointerData.length = 0,
                this.boundsRect = null,
                this.boundsSprite = null,
                this.sprite = null)
            },
            validForInput: function(t, e, i) {
                return void 0 === i && (i = !0),
                !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
            },
            isPixelPerfect: function() {
                return this.pixelPerfectClick || this.pixelPerfectOver
            },
            pointerX: function(t) {
                return t = t || 0,
                this._pointerData[t].x
            },
            pointerY: function(t) {
                return t = t || 0,
                this._pointerData[t].y
            },
            pointerDown: function(t) {
                return t = t || 0,
                this._pointerData[t].isDown
            },
            pointerUp: function(t) {
                return t = t || 0,
                this._pointerData[t].isUp
            },
            pointerTimeDown: function(t) {
                return t = t || 0,
                this._pointerData[t].timeDown
            },
            pointerTimeUp: function(t) {
                return t = t || 0,
                this._pointerData[t].timeUp
            },
            pointerOver: function(t) {
                if (!this.enabled)
                    return !1;
                if (void 0 !== t)
                    return this._pointerData[t].isOver;
                for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOver)
                        return !0;
                return !1
            },
            pointerOut: function(t) {
                if (!this.enabled)
                    return !1;
                if (void 0 !== t)
                    return this._pointerData[t].isOut;
                for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOut)
                        return !0
            },
            pointerTimeOver: function(t) {
                return t = t || 0,
                this._pointerData[t].timeOver
            },
            pointerTimeOut: function(t) {
                return t = t || 0,
                this._pointerData[t].timeOut
            },
            pointerDragged: function(t) {
                return t = t || 0,
                this._pointerData[t].isDragged
            },
            checkPointerDown: function(t, e) {
                return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1),
                !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPointerOver: function(t, e) {
                return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1),
                !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPixel: function(t, e, i) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === t && null === e) {
                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                        t = this._tempPoint.x,
                        e = this._tempPoint.y
                    }
                    if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x),
                    0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y),
                    t += this.sprite.texture.frame.x,
                    e += this.sprite.texture.frame.y,
                    this.sprite.texture.trim && (t -= this.sprite.texture.trim.x,
                    e -= this.sprite.texture.trim.y,
                    t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom))
                        return this._dx = t,
                        this._dy = e,
                        !1;
                    if (this._dx = t,
                    this._dy = e,
                    this.game.input.hitContext.clearRect(0, 0, 1, 1),
                    this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1),
                    this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha)
                        return !0
                }
                return !1
            },
            update: function(t) {
                if (null !== this.sprite && void 0 !== this.sprite.parent)
                    return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = W.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold),
                    this._dragDistancePass && this._dragTimePass && this.startDrag(t),
                    !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x,
                    this._pointerData[t.id].y = t.y - this.sprite.y,
                    !0) : (this._pointerOutHandler(t),
                    !1) : void 0 : (this._pointerOutHandler(t),
                    !1)
            },
            _pointerOverHandler: function(t, e) {
                if (null !== this.sprite) {
                    var i = this._pointerData[t.id];
                    if (!1 === i.isOver || t.dirty) {
                        var s = !1 === i.isOver;
                        i.isOver = !0,
                        i.isOut = !1,
                        i.timeOver = this.game.time.time,
                        i.x = t.x - this.sprite.x,
                        i.y = t.y - this.sprite.y,
                        this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer",
                        this._setHandCursor = !0),
                        !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t),
                        this.sprite.parent && this.sprite.parent.type === W.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                    }
                }
            },
            _pointerOutHandler: function(t, e) {
                if (null !== this.sprite) {
                    var i = this._pointerData[t.id];
                    i.isOver = !1,
                    i.isOut = !0,
                    i.timeOut = this.game.time.time,
                    this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "",
                    this._setHandCursor = !1),
                    !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t),
                    this.sprite && this.sprite.parent && this.sprite.parent.type === W.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                }
            },
            _touchedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (!e.isDown && e.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, t))
                            return;
                        if (e.isDown = !0,
                        e.isUp = !1,
                        e.timeDown = this.game.time.time,
                        this.downPoint.set(t.x, t.y),
                        t.dirty = !0,
                        this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t),
                        this.sprite && this.sprite.parent && this.sprite.parent.type === W.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t),
                        null === this.sprite))
                            return;
                        this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0,
                        this._dragDistancePass = 0 === this.dragDistanceThreshold,
                        0 < this.dragTimeThreshold ? (this._dragTimePass = !1,
                        this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)),
                        this.bringToTop && this.sprite.bringToTop()
                    }
                }
            },
            dragTimeElapsed: function(t) {
                this._dragTimePass = !0,
                this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
            },
            _releasedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (e.isDown && t.isUp) {
                        e.isDown = !1,
                        e.isUp = !0,
                        e.timeUp = this.game.time.time,
                        e.downDuration = e.timeUp - e.timeDown;
                        var i = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i),
                        this.sprite && this.sprite.parent && this.sprite.parent.type === W.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i),
                        i = i && this.checkPointerOver(t)),
                        !(e.isOver = i) && this.useHandCursor && (this.game.canvas.style.cursor = "default",
                        this._setHandCursor = !1),
                        t.dirty = !0,
                        this._pendingDrag = !1,
                        this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                    }
                }
            },
            updateDrag: function(t, e) {
                if (void 0 === e && (e = !1),
                t.isUp)
                    return this.stopDrag(t),
                    !1;
                var i = this.globalToLocal(t)
                  , s = i.x + this._dragPoint.x + this.dragOffset.x
                  , n = i.y + this._dragPoint.y + this.dragOffset.y;
                if (this.sprite.fixedToCamera)
                    this.allowHorizontalDrag && (this.sprite.cameraOffset.x = s),
                    this.allowVerticalDrag && (this.sprite.cameraOffset.y = n),
                    this.boundsRect && this.checkBoundsRect(),
                    this.boundsSprite && this.checkBoundsSprite(),
                    this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY,
                    this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                else {
                    var r = this.game.camera.x - this._pointerData[t.id].camX
                      , o = this.game.camera.y - this._pointerData[t.id].camY;
                    this.allowHorizontalDrag && (this.sprite.x = s + r),
                    this.allowVerticalDrag && (this.sprite.y = n + o),
                    this.boundsRect && this.checkBoundsRect(),
                    this.boundsSprite && this.checkBoundsSprite(),
                    this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY,
                    this.snapPoint.set(this.sprite.x, this.sprite.y))
                }
                return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, s, n, this.snapPoint, e),
                !0
            },
            justOver: function(t, e) {
                return t = t || 0,
                e = e || 500,
                this._pointerData[t].isOver && this.overDuration(t) < e
            },
            justOut: function(t, e) {
                return t = t || 0,
                e = e || 500,
                this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
            },
            justPressed: function(t, e) {
                return t = t || 0,
                e = e || 500,
                this._pointerData[t].isDown && this.downDuration(t) < e
            },
            justReleased: function(t, e) {
                return t = t || 0,
                e = e || 500,
                this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
            },
            overDuration: function(t) {
                return t = t || 0,
                this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
            },
            downDuration: function(t) {
                return t = t || 0,
                this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
            },
            enableDrag: function(t, e, i, s, n, r) {
                void 0 === t && (t = !1),
                void 0 === e && (e = !1),
                void 0 === i && (i = !1),
                void 0 === s && (s = 255),
                void 0 === n && (n = null),
                void 0 === r && (r = null),
                this._dragPoint = new W.Point,
                this.draggable = !0,
                this.bringToTop = e,
                this.dragOffset = new W.Point,
                this.dragFromCenter = t,
                this.pixelPerfectClick = i,
                this.pixelPerfectAlpha = s,
                n && (this.boundsRect = n),
                r && (this.boundsSprite = r)
            },
            disableDrag: function() {
                if (this._pointerData)
                    for (var t = 0; t < 10; t++)
                        this._pointerData[t].isDragged = !1;
                this.draggable = !1,
                this.isDragged = !1,
                this._draggedPointerID = -1,
                this._pendingDrag = !1
            },
            startDrag: function(t) {
                var e = this.sprite.x
                  , i = this.sprite.y
                  , s = this.globalToLocal(t);
                if (this.isDragged = !0,
                this._draggedPointerID = t.id,
                this._pointerData[t.id].camX = this.game.camera.x,
                this._pointerData[t.id].camY = this.game.camera.y,
                this._pointerData[t.id].isDragged = !0,
                this.sprite.fixedToCamera) {
                    if (this.dragFromCenter) {
                        var n = this.sprite.getBounds()
                          , r = this.globalToLocal(new W.Point(n.centerX,n.centerY));
                        this.sprite.cameraOffset.x = s.x + (this.sprite.cameraOffset.x - r.x),
                        this.sprite.cameraOffset.y = s.y + (this.sprite.cameraOffset.y - r.y)
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                } else {
                    if (this.dragFromCenter) {
                        n = this.sprite.getBounds(),
                        r = this.globalToLocal(new W.Point(n.centerX,n.centerY));
                        this.sprite.x = s.x + (this.sprite.x - r.x),
                        this.sprite.y = s.y + (this.sprite.y - r.y)
                    }
                    this._dragPoint.setTo(this.sprite.x - s.x, this.sprite.y - s.y)
                }
                this.updateDrag(t, !0),
                this.bringToTop && (this._dragPhase = !0,
                this.sprite.bringToTop()),
                this.dragStartPoint.set(e, i),
                this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i),
                this._pendingDrag = !1
            },
            globalToLocalX: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x,
                t *= this.game.scale.grid.scaleFluidInversed.x),
                t
            },
            globalToLocalY: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y,
                t *= this.game.scale.grid.scaleFluidInversed.y),
                t
            },
            globalToLocal: function(t) {
                return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                    x: t.x,
                    y: t.y
                }) : t
            },
            stopDrag: function(t) {
                this.isDragged = !1,
                this._draggedPointerID = -1,
                this._pointerData[t.id].isDragged = !1,
                this._dragPhase = !1,
                this._pendingDrag = !1,
                this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)),
                this.sprite.events.onDragStop$dispatch(this.sprite, t),
                !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
            },
            setDragLock: function(t, e) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                this.allowHorizontalDrag = t,
                this.allowVerticalDrag = e
            },
            enableSnap: function(t, e, i, s, n, r) {
                void 0 === i && (i = !0),
                void 0 === s && (s = !1),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                this.snapX = t,
                this.snapY = e,
                this.snapOffsetX = n,
                this.snapOffsetY = r,
                this.snapOnDrag = i,
                this.snapOnRelease = s
            },
            disableSnap: function() {
                this.snapOnDrag = !1,
                this.snapOnRelease = !1
            },
            checkBoundsRect: function() {
                this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width),
                this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)),
                this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
            },
            checkBoundsSprite: function() {
                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width),
                this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)),
                this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
            }
        },
        W.InputHandler.prototype.constructor = W.InputHandler,
        W.Gamepad = function(t) {
            this.game = t,
            this._gamepadIndexMap = {},
            this._rawPads = [],
            this._active = !1,
            this.enabled = !0,
            this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads,
            this._prevRawGamepadTypes = [],
            this._prevTimestamps = [],
            (this.callbackContext = this).onConnectCallback = null,
            this.onDisconnectCallback = null,
            this.onDownCallback = null,
            this.onUpCallback = null,
            this.onAxisCallback = null,
            this.onFloatCallback = null,
            this._ongamepadconnected = null,
            this._gamepaddisconnected = null,
            this._gamepads = [new W.SinglePad(t,this), new W.SinglePad(t,this), new W.SinglePad(t,this), new W.SinglePad(t,this)]
        }
        ,
        W.Gamepad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback,
                this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback,
                this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback,
                this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback,
                this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback,
                this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback,
                this.callbackContext = t)
            },
            start: function() {
                if (!this._active) {
                    this._active = !0;
                    var e = this;
                    this._onGamepadConnected = function(t) {
                        return e.onGamepadConnected(t)
                    }
                    ,
                    this._onGamepadDisconnected = function(t) {
                        return e.onGamepadDisconnected(t)
                    }
                    ,
                    window.addEventListener("gamepadconnected", this._onGamepadConnected, !1),
                    window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                }
            },
            onGamepadConnected: function(t) {
                var e = t.gamepad;
                this._rawPads.push(e),
                this._gamepads[e.index].connect(e)
            },
            onGamepadDisconnected: function(t) {
                var e = t.gamepad;
                for (var i in this._rawPads)
                    this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                this._gamepads[e.index].disconnect()
            },
            update: function() {
                this._pollGamepads(),
                this.pad1.pollStatus(),
                this.pad2.pollStatus(),
                this.pad3.pollStatus(),
                this.pad4.pollStatus()
            },
            _pollGamepads: function() {
                if (this._active) {
                    if (navigator.getGamepads)
                        var t = navigator.getGamepads();
                    else if (navigator.webkitGetGamepads)
                        t = navigator.webkitGetGamepads();
                    else if (navigator.webkitGamepads)
                        t = navigator.webkitGamepads();
                    if (t) {
                        for (var e = !(this._rawPads = []), i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0,
                        this._prevRawGamepadTypes[i] = typeof t[i]),
                        t[i] && this._rawPads.push(t[i]),
                        3 !== i); i++)
                            ;
                        for (var s = 0; s < this._gamepads.length; s++)
                            this._gamepads[s]._rawPad = this._rawPads[s];
                        if (e) {
                            for (var n, r = {
                                rawIndices: {},
                                padIndices: {}
                            }, o = 0; o < this._gamepads.length; o++)
                                if ((n = this._gamepads[o]).connected)
                                    for (var a = 0; a < this._rawPads.length; a++)
                                        this._rawPads[a].index === n.index && (r.rawIndices[n.index] = !0,
                                        r.padIndices[o] = !0);
                            for (var h = 0; h < this._gamepads.length; h++)
                                if (n = this._gamepads[h],
                                !r.padIndices[h]) {
                                    this._rawPads.length < 1 && n.disconnect();
                                    for (var l = 0; l < this._rawPads.length && !r.padIndices[h]; l++) {
                                        var c = this._rawPads[l];
                                        if (c) {
                                            if (r.rawIndices[c.index]) {
                                                n.disconnect();
                                                continue
                                            }
                                            n.connect(c),
                                            r.rawIndices[c.index] = !0,
                                            r.padIndices[h] = !0
                                        } else
                                            n.disconnect()
                                    }
                                }
                        }
                    }
                }
            },
            setDeadZones: function(t) {
                for (var e = 0; e < this._gamepads.length; e++)
                    this._gamepads[e].deadZone = t
            },
            stop: function() {
                this._active = !1,
                window.removeEventListener("gamepadconnected", this._onGamepadConnected),
                window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
            },
            reset: function() {
                this.update();
                for (var t = 0; t < this._gamepads.length; t++)
                    this._gamepads[t].reset()
            },
            justPressed: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justPressed(t, e))
                        return !0;
                return !1
            },
            justReleased: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justReleased(t, e))
                        return !0;
                return !1
            },
            isDown: function(t) {
                for (var e = 0; e < this._gamepads.length; e++)
                    if (!0 === this._gamepads[e].isDown(t))
                        return !0;
                return !1
            },
            destroy: function() {
                this.stop();
                for (var t = 0; t < this._gamepads.length; t++)
                    this._gamepads[t].destroy()
            }
        },
        W.Gamepad.prototype.constructor = W.Gamepad,
        Object.defineProperty(W.Gamepad.prototype, "active", {
            get: function() {
                return this._active
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "supported", {
            get: function() {
                return this._gamepadSupportAvailable
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "padsConnected", {
            get: function() {
                return this._rawPads.length
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "pad1", {
            get: function() {
                return this._gamepads[0]
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "pad2", {
            get: function() {
                return this._gamepads[1]
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "pad3", {
            get: function() {
                return this._gamepads[2]
            }
        }),
        Object.defineProperty(W.Gamepad.prototype, "pad4", {
            get: function() {
                return this._gamepads[3]
            }
        }),
        W.Gamepad.BUTTON_0 = 0,
        W.Gamepad.BUTTON_1 = 1,
        W.Gamepad.BUTTON_2 = 2,
        W.Gamepad.BUTTON_3 = 3,
        W.Gamepad.BUTTON_4 = 4,
        W.Gamepad.BUTTON_5 = 5,
        W.Gamepad.BUTTON_6 = 6,
        W.Gamepad.BUTTON_7 = 7,
        W.Gamepad.BUTTON_8 = 8,
        W.Gamepad.BUTTON_9 = 9,
        W.Gamepad.BUTTON_10 = 10,
        W.Gamepad.BUTTON_11 = 11,
        W.Gamepad.BUTTON_12 = 12,
        W.Gamepad.BUTTON_13 = 13,
        W.Gamepad.BUTTON_14 = 14,
        W.Gamepad.BUTTON_15 = 15,
        W.Gamepad.AXIS_0 = 0,
        W.Gamepad.AXIS_1 = 1,
        W.Gamepad.AXIS_2 = 2,
        W.Gamepad.AXIS_3 = 3,
        W.Gamepad.AXIS_4 = 4,
        W.Gamepad.AXIS_5 = 5,
        W.Gamepad.AXIS_6 = 6,
        W.Gamepad.AXIS_7 = 7,
        W.Gamepad.AXIS_8 = 8,
        W.Gamepad.AXIS_9 = 9,
        W.Gamepad.XBOX360_A = 0,
        W.Gamepad.XBOX360_B = 1,
        W.Gamepad.XBOX360_X = 2,
        W.Gamepad.XBOX360_Y = 3,
        W.Gamepad.XBOX360_LEFT_BUMPER = 4,
        W.Gamepad.XBOX360_RIGHT_BUMPER = 5,
        W.Gamepad.XBOX360_LEFT_TRIGGER = 6,
        W.Gamepad.XBOX360_RIGHT_TRIGGER = 7,
        W.Gamepad.XBOX360_BACK = 8,
        W.Gamepad.XBOX360_START = 9,
        W.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10,
        W.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11,
        W.Gamepad.XBOX360_DPAD_LEFT = 14,
        W.Gamepad.XBOX360_DPAD_RIGHT = 15,
        W.Gamepad.XBOX360_DPAD_UP = 12,
        W.Gamepad.XBOX360_DPAD_DOWN = 13,
        W.Gamepad.XBOX360_STICK_LEFT_X = 0,
        W.Gamepad.XBOX360_STICK_LEFT_Y = 1,
        W.Gamepad.XBOX360_STICK_RIGHT_X = 2,
        W.Gamepad.XBOX360_STICK_RIGHT_Y = 3,
        W.Gamepad.PS3XC_X = 0,
        W.Gamepad.PS3XC_CIRCLE = 1,
        W.Gamepad.PS3XC_SQUARE = 2,
        W.Gamepad.PS3XC_TRIANGLE = 3,
        W.Gamepad.PS3XC_L1 = 4,
        W.Gamepad.PS3XC_R1 = 5,
        W.Gamepad.PS3XC_L2 = 6,
        W.Gamepad.PS3XC_R2 = 7,
        W.Gamepad.PS3XC_SELECT = 8,
        W.Gamepad.PS3XC_START = 9,
        W.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10,
        W.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11,
        W.Gamepad.PS3XC_DPAD_UP = 12,
        W.Gamepad.PS3XC_DPAD_DOWN = 13,
        W.Gamepad.PS3XC_DPAD_LEFT = 14,
        W.Gamepad.PS3XC_DPAD_RIGHT = 15,
        W.Gamepad.PS3XC_STICK_LEFT_X = 0,
        W.Gamepad.PS3XC_STICK_LEFT_Y = 1,
        W.Gamepad.PS3XC_STICK_RIGHT_X = 2,
        W.Gamepad.PS3XC_STICK_RIGHT_Y = 3,
        W.SinglePad = function(t, e) {
            this.game = t,
            this.index = null,
            this.connected = !1,
            (this.callbackContext = this).onConnectCallback = null,
            this.onDisconnectCallback = null,
            this.onDownCallback = null,
            this.onUpCallback = null,
            this.onAxisCallback = null,
            this.onFloatCallback = null,
            this.deadZone = .26,
            this._padParent = e,
            this._rawPad = null,
            this._prevTimestamp = null,
            this._buttons = [],
            this._buttonsLen = 0,
            this._axes = [],
            this._axesLen = 0
        }
        ,
        W.SinglePad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback,
                this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback,
                this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback,
                this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback,
                this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback,
                this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback,
                this.callbackContext = t)
            },
            getButton: function(t) {
                return this._buttons[t] ? this._buttons[t] : null
            },
            pollStatus: function() {
                if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                    for (var t = 0; t < this._buttonsLen; t++) {
                        var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                        e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                    }
                    for (var i = 0; i < this._axesLen; i++) {
                        var s = this._rawPad.axes[i];
                        0 < s && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                    }
                    this._prevTimestamp = this._rawPad.timestamp
                }
            },
            connect: function(t) {
                var e = !this.connected;
                this.connected = !0,
                this.index = t.index,
                this._rawPad = t,
                this._buttons = [],
                this._buttonsLen = t.buttons.length,
                this._axes = [],
                this._axesLen = t.axes.length;
                for (var i = 0; i < this._axesLen; i++)
                    this._axes[i] = t.axes[i];
                for (var s in t.buttons)
                    s = parseInt(s, 10),
                    this._buttons[s] = new W.DeviceButton(this,s);
                e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index),
                e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
            },
            disconnect: function() {
                var t = this.connected
                  , e = this.index;
                this.connected = !1,
                this.index = null,
                this._rawPad = void 0;
                for (var i = 0; i < this._buttonsLen; i++)
                    this._buttons[i].destroy();
                this._buttons = [],
                this._buttonsLen = 0,
                this._axes = [],
                this._axesLen = 0,
                t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e),
                t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
            },
            destroy: function() {
                this._rawPad = void 0;
                for (var t = 0; t < this._buttonsLen; t++)
                    this._buttons[t].destroy();
                this._buttons = [],
                this._buttonsLen = 0,
                this._axes = [],
                this._axesLen = 0,
                this.onConnectCallback = null,
                this.onDisconnectCallback = null,
                this.onDownCallback = null,
                this.onUpCallback = null,
                this.onAxisCallback = null,
                this.onFloatCallback = null
            },
            processAxisChange: function(t, e) {
                this._axes[t] !== e && (this._axes[t] = e,
                this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e),
                this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
            },
            processButtonDown: function(t, e) {
                this._buttons[t] && this._buttons[t].start(null, e),
                this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index),
                this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
            },
            processButtonUp: function(t, e) {
                this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index),
                this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e),
                this._buttons[t] && this._buttons[t].stop(null, e)
            },
            processButtonFloat: function(t, e) {
                this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index),
                this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e),
                this._buttons[t] && this._buttons[t].padFloat(e)
            },
            axis: function(t) {
                return !!this._axes[t] && this._axes[t]
            },
            isDown: function(t) {
                return !!this._buttons[t] && this._buttons[t].isDown
            },
            isUp: function(t) {
                return !!this._buttons[t] && this._buttons[t].isUp
            },
            justReleased: function(t, e) {
                if (this._buttons[t])
                    return this._buttons[t].justReleased(e)
            },
            justPressed: function(t, e) {
                if (this._buttons[t])
                    return this._buttons[t].justPressed(e)
            },
            buttonValue: function(t) {
                return this._buttons[t] ? this._buttons[t].value : null
            },
            reset: function() {
                for (var t = 0; t < this._axes.length; t++)
                    this._axes[t] = 0
            }
        },
        W.SinglePad.prototype.constructor = W.SinglePad,
        W.Key = function(t, e) {
            this.game = t,
            this._enabled = !0,
            this.event = null,
            this.isDown = !1,
            this.isUp = !0,
            this.altKey = !1,
            this.ctrlKey = !1,
            this.shiftKey = !1,
            this.timeDown = 0,
            this.duration = 0,
            this.timeUp = -2500,
            this.durationUp = -2500,
            this.repeats = 0,
            this.keyCode = e,
            this.onDown = new W.Signal,
            this.onHoldCallback = null,
            this.onHoldContext = null,
            this.onUp = new W.Signal,
            this._justDown = !1,
            this._justUp = !1
        }
        ,
        W.Key.prototype = {
            update: function() {
                this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown,
                this.repeats++,
                this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
            },
            processKeyDown: function(t) {
                this._enabled && (this.event = t,
                this.isDown || (this.altKey = t.altKey,
                this.ctrlKey = t.ctrlKey,
                this.shiftKey = t.shiftKey,
                this.isDown = !0,
                this.isUp = !1,
                this.timeDown = this.game.time.time,
                this.duration = 0,
                this.durationUp = this.game.time.time - this.timeUp,
                this.repeats = 0,
                this._justDown = !0,
                this.onDown.dispatch(this)))
            },
            processKeyUp: function(t) {
                this._enabled && (this.event = t,
                this.isUp || (this.isDown = !1,
                this.isUp = !0,
                this.timeUp = this.game.time.time,
                this.duration = this.game.time.time - this.timeDown,
                this.durationUp = 0,
                this._justUp = !0,
                this.onUp.dispatch(this)))
            },
            reset: function(t) {
                void 0 === t && (t = !0),
                this.isDown = !1,
                this.isUp = !0,
                this.timeUp = this.game.time.time,
                this.duration = 0,
                this.durationUp = -2500,
                this._enabled = !0,
                this._justDown = !1,
                this._justUp = !1,
                t && (this.onDown.removeAll(),
                this.onUp.removeAll(),
                this.onHoldCallback = null,
                this.onHoldContext = null)
            },
            downDuration: function(t) {
                return void 0 === t && (t = 50),
                this.isDown && this.duration < t
            },
            upDuration: function(t) {
                return void 0 === t && (t = 50),
                !this.isDown && this.game.time.time - this.timeUp < t
            },
            justPressed: function() {
                return this.isDown && 0 === this.duration
            },
            justReleased: function() {
                return !this.isDown && 0 === this.durationUp
            }
        },
        Object.defineProperty(W.Key.prototype, "justDown", {
            get: function() {
                var t = this._justDown;
                return this._justDown = !1,
                t
            }
        }),
        Object.defineProperty(W.Key.prototype, "justUp", {
            get: function() {
                var t = this._justUp;
                return this._justUp = !1,
                t
            }
        }),
        Object.defineProperty(W.Key.prototype, "enabled", {
            get: function() {
                return this._enabled
            },
            set: function(t) {
                (t = !!t) !== this._enabled && (t || this.reset(!1),
                this._enabled = t)
            }
        }),
        W.Key.prototype.constructor = W.Key,
        W.Keyboard = function(t) {
            this.game = t,
            this.enabled = !0,
            this.event = null,
            this.pressEvent = null,
            (this.callbackContext = this).onDownCallback = null,
            this.onPressCallback = null,
            this.onUpCallback = null,
            this._keys = [],
            this._capture = [],
            this._onKeyDown = null,
            this._onKeyPress = null,
            this._onKeyUp = null,
            this._i = 0,
            this._k = 0
        }
        ,
        W.Keyboard.prototype = {
            addCallbacks: function(t, e, i, s) {
                this.callbackContext = t,
                null != e && (this.onDownCallback = e),
                null != i && (this.onUpCallback = i),
                null != s && (this.onPressCallback = s)
            },
            addKey: function(t) {
                return this._keys[t] || (this._keys[t] = new W.Key(this.game,t),
                this.addKeyCapture(t)),
                this._keys[t]
            },
            addKeys: function(t) {
                var e = {};
                for (var i in t)
                    e[i] = this.addKey(t[i]);
                return e
            },
            removeKey: function(t) {
                this._keys[t] && (this._keys[t] = null,
                this.removeKeyCapture(t))
            },
            createCursorKeys: function() {
                return this.addKeys({
                    up: W.KeyCode.UP,
                    down: W.KeyCode.DOWN,
                    left: W.KeyCode.LEFT,
                    right: W.KeyCode.RIGHT
                })
            },
            start: function() {
                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                    var e = this;
                    this._onKeyDown = function(t) {
                        return e.processKeyDown(t)
                    }
                    ,
                    this._onKeyUp = function(t) {
                        return e.processKeyUp(t)
                    }
                    ,
                    this._onKeyPress = function(t) {
                        return e.processKeyPress(t)
                    }
                    ,
                    window.addEventListener("keydown", this._onKeyDown, !1),
                    window.addEventListener("keyup", this._onKeyUp, !1),
                    window.addEventListener("keypress", this._onKeyPress, !1)
                }
            },
            stop: function() {
                window.removeEventListener("keydown", this._onKeyDown),
                window.removeEventListener("keyup", this._onKeyUp),
                window.removeEventListener("keypress", this._onKeyPress),
                this._onKeyDown = null,
                this._onKeyUp = null,
                this._onKeyPress = null
            },
            destroy: function() {
                this.stop(),
                this.clearCaptures(),
                this._keys.length = 0,
                this._i = 0
            },
            addKeyCapture: function(t) {
                if ("object" == typeof t)
                    for (var e in t)
                        this._capture[t[e]] = !0;
                else
                    this._capture[t] = !0
            },
            removeKeyCapture: function(t) {
                delete this._capture[t]
            },
            clearCaptures: function() {
                this._capture = {}
            },
            update: function() {
                for (this._i = this._keys.length; this._i--; )
                    this._keys[this._i] && this._keys[this._i].update()
            },
            processKeyDown: function(t) {
                if (this.event = t,
                this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(),
                    this._keys[e] || (this._keys[e] = new W.Key(this.game,e)),
                    this._keys[e].processKeyDown(t),
                    this._k = e,
                    this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                }
            },
            processKeyPress: function(t) {
                this.pressEvent = t,
                this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
            },
            processKeyUp: function(t) {
                if (this.event = t,
                this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(),
                    this._keys[e] || (this._keys[e] = new W.Key(this.game,e)),
                    this._keys[e].processKeyUp(t),
                    this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                }
            },
            reset: function(t) {
                void 0 === t && (t = !0),
                this.event = null;
                for (var e = this._keys.length; e--; )
                    this._keys[e] && this._keys[e].reset(t)
            },
            downDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].downDuration(e) : null
            },
            upDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].upDuration(e) : null
            },
            justPressed: function(t) {
                return this._keys[t] ? this._keys[t].justPressed() : null
            },
            justReleased: function(t) {
                return this._keys[t] ? this._keys[t].justReleased() : null
            },
            isDown: function(t) {
                return this._keys[t] ? this._keys[t].isDown : null
            }
        },
        Object.defineProperty(W.Keyboard.prototype, "lastChar", {
            get: function() {
                return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
            }
        }),
        Object.defineProperty(W.Keyboard.prototype, "lastKey", {
            get: function() {
                return this._keys[this._k]
            }
        }),
        W.Keyboard.prototype.constructor = W.Keyboard,
        W.KeyCode = {
            A: "A".charCodeAt(0),
            B: "B".charCodeAt(0),
            C: "C".charCodeAt(0),
            D: "D".charCodeAt(0),
            E: "E".charCodeAt(0),
            F: "F".charCodeAt(0),
            G: "G".charCodeAt(0),
            H: "H".charCodeAt(0),
            I: "I".charCodeAt(0),
            J: "J".charCodeAt(0),
            K: "K".charCodeAt(0),
            L: "L".charCodeAt(0),
            M: "M".charCodeAt(0),
            N: "N".charCodeAt(0),
            O: "O".charCodeAt(0),
            P: "P".charCodeAt(0),
            Q: "Q".charCodeAt(0),
            R: "R".charCodeAt(0),
            S: "S".charCodeAt(0),
            T: "T".charCodeAt(0),
            U: "U".charCodeAt(0),
            V: "V".charCodeAt(0),
            W: "W".charCodeAt(0),
            X: "X".charCodeAt(0),
            Y: "Y".charCodeAt(0),
            Z: "Z".charCodeAt(0),
            ZERO: "0".charCodeAt(0),
            ONE: "1".charCodeAt(0),
            TWO: "2".charCodeAt(0),
            THREE: "3".charCodeAt(0),
            FOUR: "4".charCodeAt(0),
            FIVE: "5".charCodeAt(0),
            SIX: "6".charCodeAt(0),
            SEVEN: "7".charCodeAt(0),
            EIGHT: "8".charCodeAt(0),
            NINE: "9".charCodeAt(0),
            NUMPAD_0: 96,
            NUMPAD_1: 97,
            NUMPAD_2: 98,
            NUMPAD_3: 99,
            NUMPAD_4: 100,
            NUMPAD_5: 101,
            NUMPAD_6: 102,
            NUMPAD_7: 103,
            NUMPAD_8: 104,
            NUMPAD_9: 105,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_ADD: 107,
            NUMPAD_ENTER: 108,
            NUMPAD_SUBTRACT: 109,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            COLON: 186,
            EQUALS: 187,
            COMMA: 188,
            UNDERSCORE: 189,
            PERIOD: 190,
            QUESTION_MARK: 191,
            TILDE: 192,
            OPEN_BRACKET: 219,
            BACKWARD_SLASH: 220,
            CLOSED_BRACKET: 221,
            QUOTES: 222,
            BACKSPACE: 8,
            TAB: 9,
            CLEAR: 12,
            ENTER: 13,
            SHIFT: 16,
            CONTROL: 17,
            ALT: 18,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACEBAR: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PLUS: 43,
            MINUS: 44,
            INSERT: 45,
            DELETE: 46,
            HELP: 47,
            NUM_LOCK: 144
        },
        W.KeyCode)
            W.KeyCode.hasOwnProperty(i) && !i.match(/[a-z]/) && (W.Keyboard[i] = W.KeyCode[i]);
        for (var n in W.Component = function() {}
        ,
        W.Component.Angle = function() {}
        ,
        W.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return W.Math.wrapAngle(W.Math.radToDeg(this.rotation))
                },
                set: function(t) {
                    this.rotation = W.Math.degToRad(W.Math.wrapAngle(t))
                }
            }
        },
        W.Component.Animation = function() {}
        ,
        W.Component.Animation.prototype = {
            play: function(t, e, i, s) {
                if (this.animations)
                    return this.animations.play(t, e, i, s)
            }
        },
        W.Component.AutoCull = function() {}
        ,
        W.Component.AutoCull.prototype = {
            autoCull: !1,
            inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()),
                    this._bounds.x += this.game.camera.view.x,
                    this._bounds.y += this.game.camera.view.y),
                    this.game.world.camera.view.intersects(this._bounds)
                }
            }
        },
        W.Component.Bounds = function() {}
        ,
        W.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            },
            offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            },
            centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                },
                set: function(t) {
                    this.x = t + this.offsetX - .5 * this.width
                }
            },
            centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                },
                set: function(t) {
                    this.y = t + this.offsetY - .5 * this.height
                }
            },
            left: {
                get: function() {
                    return this.x - this.offsetX
                },
                set: function(t) {
                    this.x = t + this.offsetX
                }
            },
            right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                },
                set: function(t) {
                    this.x = t - this.width + this.offsetX
                }
            },
            top: {
                get: function() {
                    return this.y - this.offsetY
                },
                set: function(t) {
                    this.y = t + this.offsetY
                }
            },
            bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                },
                set: function(t) {
                    this.y = t - this.height + this.offsetY
                }
            },
            alignIn: function(t, e, i, s) {
                switch (void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                e) {
                default:
                case W.TOP_LEFT:
                    this.left = t.left - i,
                    this.top = t.top - s;
                    break;
                case W.TOP_CENTER:
                    this.centerX = t.centerX + i,
                    this.top = t.top - s;
                    break;
                case W.TOP_RIGHT:
                    this.right = t.right + i,
                    this.top = t.top - s;
                    break;
                case W.LEFT_CENTER:
                    this.left = t.left - i,
                    this.centerY = t.centerY + s;
                    break;
                case W.CENTER:
                    this.centerX = t.centerX + i,
                    this.centerY = t.centerY + s;
                    break;
                case W.RIGHT_CENTER:
                    this.right = t.right + i,
                    this.centerY = t.centerY + s;
                    break;
                case W.BOTTOM_LEFT:
                    this.left = t.left - i,
                    this.bottom = t.bottom + s;
                    break;
                case W.BOTTOM_CENTER:
                    this.centerX = t.centerX + i,
                    this.bottom = t.bottom + s;
                    break;
                case W.BOTTOM_RIGHT:
                    this.right = t.right + i,
                    this.bottom = t.bottom + s
                }
                return this
            },
            alignTo: function(t, e, i, s) {
                switch (void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                e) {
                default:
                case W.TOP_LEFT:
                    this.left = t.left - i,
                    this.bottom = t.top - s;
                    break;
                case W.TOP_CENTER:
                    this.centerX = t.centerX + i,
                    this.bottom = t.top - s;
                    break;
                case W.TOP_RIGHT:
                    this.right = t.right + i,
                    this.bottom = t.top - s;
                    break;
                case W.LEFT_TOP:
                    this.right = t.left - i,
                    this.top = t.top - s;
                    break;
                case W.LEFT_CENTER:
                    this.right = t.left - i,
                    this.centerY = t.centerY + s;
                    break;
                case W.LEFT_BOTTOM:
                    this.right = t.left - i,
                    this.bottom = t.bottom + s;
                    break;
                case W.RIGHT_TOP:
                    this.left = t.right + i,
                    this.top = t.top - s;
                    break;
                case W.RIGHT_CENTER:
                    this.left = t.right + i,
                    this.centerY = t.centerY + s;
                    break;
                case W.RIGHT_BOTTOM:
                    this.left = t.right + i,
                    this.bottom = t.bottom + s;
                    break;
                case W.BOTTOM_LEFT:
                    this.left = t.left - i,
                    this.top = t.bottom + s;
                    break;
                case W.BOTTOM_CENTER:
                    this.centerX = t.centerX + i,
                    this.top = t.bottom + s;
                    break;
                case W.BOTTOM_RIGHT:
                    this.right = t.right + i,
                    this.top = t.bottom + s
                }
                return this
            }
        },
        W.Group.prototype.alignIn = W.Component.Bounds.prototype.alignIn,
        W.Group.prototype.alignTo = W.Component.Bounds.prototype.alignTo,
        W.Component.BringToTop = function() {}
        ,
        W.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringToTop(this),
            this
        }
        ,
        W.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendToBack(this),
            this
        }
        ,
        W.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this),
            this
        }
        ,
        W.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this),
            this
        }
        ,
        W.Component.Core = function() {}
        ,
        W.Component.Core.install = function(t) {
            W.Utils.mixinPrototype(this, W.Component.Core.prototype),
            this.components = {};
            for (var e = 0; e < t.length; e++) {
                var i = t[e]
                  , s = !1;
                "Destroy" === i && (s = !0),
                W.Utils.mixinPrototype(this, W.Component[i].prototype, s),
                this.components[i] = !0
            }
        }
        ,
        W.Component.Core.init = function(t, e, i, s, n) {
            this.game = t,
            this.key = s,
            this.data = {},
            this.position.set(e, i),
            this.world = new W.Point(e,i),
            this.previousPosition = new W.Point(e,i),
            this.events = new W.Events(this),
            this._bounds = new W.Rectangle,
            this.components.PhysicsBody && (this.body = this.body),
            this.components.Animation && (this.animations = new W.AnimationManager(this)),
            this.components.LoadTexture && null !== s && this.loadTexture(s, n),
            this.components.FixedToCamera && (this.cameraOffset = new W.Point(e,i))
        }
        ,
        W.Component.Core.preUpdate = function() {
            if (!this.pendingDestroy) {
                if (this.previousPosition.set(this.world.x, this.world.y),
                this.previousRotation = this.rotation,
                !this.exists || !this.parent.exists)
                    return !(this.renderOrderID = -1);
                this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty),
                this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++),
                this.animations && this.animations.update(),
                this.body && this.body.preUpdate();
                for (var t = 0; t < this.children.length; ) {
                    var e = this.children[t];
                    e.preUpdate(),
                    this === e.parent && t++
                }
                return !0
            }
            this.destroy()
        }
        ,
        W.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                },
                set: function(t) {
                    t ? (this._exists = !0,
                    this.body && this.body.type === W.Physics.P2JS && this.body.addToWorld(),
                    this.visible = !0) : (this._exists = !1,
                    this.body && this.body.type === W.Physics.P2JS && this.body.removeFromWorld(),
                    this.visible = !1)
                }
            },
            update: function() {},
            postUpdate: function() {
                this.customRender && this.key.render(),
                this.components.PhysicsBody && W.Component.PhysicsBody.postUpdate.call(this),
                this.components.FixedToCamera && W.Component.FixedToCamera.postUpdate.call(this);
                for (var t = 0; t < this.children.length; t++)
                    this.children[t].postUpdate()
            }
        },
        W.Component.Crop = function() {}
        ,
        W.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(t, e) {
                void 0 === e && (e = !1),
                t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new W.Rectangle(t.x,t.y,t.width,t.height) : this.cropRect = t,
                this.updateCrop()) : (this._crop = null,
                this.cropRect = null,
                this.resetFrame())
            },
            updateCrop: function() {
                if (this.cropRect) {
                    var t = this.texture.crop.x
                      , e = this.texture.crop.y
                      , i = this.texture.crop.width
                      , s = this.texture.crop.height;
                    this._crop = W.Rectangle.clone(this.cropRect, this._crop),
                    this._crop.x += this._frame.x,
                    this._crop.y += this._frame.y;
                    var n = Math.max(this._frame.x, this._crop.x)
                      , r = Math.max(this._frame.y, this._crop.y)
                      , o = Math.min(this._frame.right, this._crop.right) - n
                      , a = Math.min(this._frame.bottom, this._crop.bottom) - r;
                    this.texture.crop.x = n,
                    this.texture.crop.y = r,
                    this.texture.crop.width = o,
                    this.texture.crop.height = a,
                    this.texture.frame.width = Math.min(o, this.cropRect.width),
                    this.texture.frame.height = Math.min(a, this.cropRect.height),
                    this.texture.width = this.texture.frame.width,
                    this.texture.height = this.texture.frame.height,
                    this.texture._updateUvs(),
                    16777215 === this.tint || t === n && e === r && i === o && s === a || (this.texture.requiresReTint = !0)
                }
            }
        },
        W.Component.Delta = function() {}
        ,
        W.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            },
            deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            },
            deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        },
        W.Component.Destroy = function() {}
        ,
        W.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(t, e) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === t && (t = !0),
                    void 0 === e && (e = !1),
                    this.destroyPhase = !0,
                    this.events && this.events.onDestroy$dispatch(this),
                    this.parent && (this.parent instanceof W.Group ? this.parent.remove(this) : this.parent.removeChild(this)),
                    this.input && this.input.destroy(),
                    this.animations && this.animations.destroy(),
                    this.body && this.body.destroy(),
                    this.events && this.events.destroy(),
                    this.game.tweens.removeFrom(this);
                    var i = this.children.length;
                    if (t)
                        for (; i--; )
                            this.children[i].destroy(t);
                    else
                        for (; i--; )
                            this.removeChild(this.children[i]);
                    this._crop && (this._crop = null,
                    this.cropRect = null),
                    this._frame && (this._frame = null),
                    W.Video && this.key instanceof W.Video && this.key.onChangeSource.remove(this.resizeFrame, this),
                    W.BitmapText && this._glyphs && (this._glyphs = []),
                    this.alive = !1,
                    this.exists = !1,
                    this.visible = !1,
                    this.filters = null,
                    this.mask = null,
                    this.game = null,
                    this.data = {},
                    this.renderable = !1,
                    this.transformCallback && (this.transformCallback = null,
                    this.transformCallbackContext = null),
                    this.hitArea = null,
                    this.parent = null,
                    this.stage = null,
                    this.worldTransform = null,
                    this.filterArea = null,
                    this._bounds = null,
                    this._currentBounds = null,
                    this._mask = null,
                    this._destroyCachedSprite(),
                    e && this.texture.destroy(!0),
                    this.destroyPhase = !1,
                    this.pendingDestroy = !1
                }
            }
        },
        W.Events = function(t) {
            this.parent = t
        }
        ,
        W.Events.prototype = {
            destroy: function() {
                this._parent = null,
                this._onDestroy && this._onDestroy.dispose(),
                this._onAddedToGroup && this._onAddedToGroup.dispose(),
                this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(),
                this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(),
                this._onKilled && this._onKilled.dispose(),
                this._onRevived && this._onRevived.dispose(),
                this._onEnterBounds && this._onEnterBounds.dispose(),
                this._onOutOfBounds && this._onOutOfBounds.dispose(),
                this._onInputOver && this._onInputOver.dispose(),
                this._onInputOut && this._onInputOut.dispose(),
                this._onInputDown && this._onInputDown.dispose(),
                this._onInputUp && this._onInputUp.dispose(),
                this._onDragStart && this._onDragStart.dispose(),
                this._onDragUpdate && this._onDragUpdate.dispose(),
                this._onDragStop && this._onDragStop.dispose(),
                this._onAnimationStart && this._onAnimationStart.dispose(),
                this._onAnimationComplete && this._onAnimationComplete.dispose(),
                this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onRemovedFromWorld: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        },
        W.Events.prototype.constructor = W.Events,
        W.Events.prototype)
            W.Events.prototype.hasOwnProperty(n) && 0 === n.indexOf("on") && null === W.Events.prototype[n] && function(t, e) {
                "use strict";
                Object.defineProperty(W.Events.prototype, t, {
                    get: function() {
                        return this[e] || (this[e] = new W.Signal)
                    }
                }),
                W.Events.prototype[t + "$dispatch"] = function() {
                    return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
                }
            }(n, "_" + n);
        W.Component.FixedToCamera = function() {}
        ,
        W.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }
        ,
        W.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0,
                    this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new W.Point
        },
        W.Component.Health = function() {}
        ,
        W.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t,
                this.health <= 0 && this.kill()),
                this
            },
            setHealth: function(t) {
                return this.health = t,
                this.health > this.maxHealth && (this.health = this.maxHealth),
                this
            },
            heal: function(t) {
                return this.alive && (this.health += t,
                this.health > this.maxHealth && (this.health = this.maxHealth)),
                this
            }
        },
        W.Component.InCamera = function() {}
        ,
        W.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        },
        W.Component.InputEnabled = function() {}
        ,
        W.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new W.InputHandler(this),
                    this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        },
        W.Component.InWorld = function() {}
        ,
        W.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()),
                this._bounds.x += this.game.camera.view.x,
                this._bounds.y += this.game.camera.view.y,
                this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds))
                        this.renderable = !0,
                        this.body && (this.body.enable = !0),
                        this.game.world.camera.totalInView++;
                    else if (this.renderable = !1,
                    this.body && (this.body.enable = !1),
                    this.outOfCameraBoundsKill)
                        return this.kill(),
                        !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds))
                        this._outOfBoundsFired = !1,
                        this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0,
                    this.events.onOutOfBounds$dispatch(this),
                    this.outOfBoundsKill))
                        return this.kill(),
                        !1
            }
            return !0
        }
        ,
        W.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        },
        W.Component.LifeSpan = function() {}
        ,
        W.Component.LifeSpan.preUpdate = function() {
            return !(0 < this.lifespan && (this.lifespan -= this.game.time.physicsElapsedMS,
            this.lifespan <= 0)) || (this.kill(),
            !1)
        }
        ,
        W.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100),
                this.alive = !0,
                this.exists = !0,
                this.visible = !0,
                "function" == typeof this.setHealth && this.setHealth(t),
                this.events && this.events.onRevived$dispatch(this),
                this
            },
            kill: function() {
                return this.alive = !1,
                this.exists = !1,
                this.visible = !1,
                this.events && this.events.onKilled$dispatch(this),
                this
            }
        },
        W.Component.LoadTexture = function() {}
        ,
        W.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, i) {
                e = t === W.PENDING_ATLAS ? (t = e,
                0) : e || 0,
                (i || void 0 === i) && this.animations && this.animations.stop(),
                this.key = t,
                this.customRender = !1;
                var s = this.game.cache
                  , n = !0
                  , r = !this.texture.baseTexture.scaleMode;
                if (W.RenderTexture && t instanceof W.RenderTexture)
                    this.key = t.key,
                    this.setTexture(t);
                else if (W.BitmapData && t instanceof W.BitmapData)
                    this.customRender = !0,
                    this.setTexture(t.texture),
                    n = s.hasFrameData(t.key, W.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, W.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (W.Video && t instanceof W.Video) {
                    this.customRender = !0;
                    var o = t.texture.valid;
                    this.setTexture(t.texture),
                    this.setFrame(t.texture.frame.clone()),
                    t.onChangeSource.add(this.resizeFrame, this),
                    this.texture.valid = o
                } else if (W.Tilemap && t instanceof W.TilemapLayer)
                    this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture)
                    this.setTexture(t);
                else {
                    var a = s.getImage(t, !0);
                    0 != e && null == a.frameData.getFrameByName(e) && (a = s.getImage(t + "-1", !0)),
                    this.key = a.key,
                    this.setTexture(new PIXI.Texture(a.base)),
                    this.texture.baseTexture.skipRender = "__default" === t,
                    n = !this.animations.loadFrameData(a.frameData, e)
                }
                n && (this._frame = W.Rectangle.clone(this.texture.frame)),
                r || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t,
                this.texture.frame.x = t.x,
                this.texture.frame.y = t.y,
                this.texture.frame.width = t.width,
                this.texture.frame.height = t.height,
                this.texture.crop.x = t.x,
                this.texture.crop.y = t.y,
                this.texture.crop.width = t.width,
                this.texture.crop.height = t.height,
                t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX,
                this.texture.trim.y = t.spriteSourceSizeY,
                this.texture.trim.width = t.sourceSizeW,
                this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                },
                this.texture.width = t.sourceSizeW,
                this.texture.height = t.sourceSizeH,
                this.texture.frame.width = t.sourceSizeW,
                this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null),
                t.rotated && (this.texture.rotated = !0),
                this.cropRect && this.updateCrop(),
                this.texture.requiresReTint = !0,
                this.texture._updateUvs(),
                this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i),
                this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        },
        W.Component.Overlap = function() {}
        ,
        W.Component.Overlap.prototype = {
            overlap: function(t) {
                return W.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        },
        W.Component.PhysicsBody = function() {}
        ,
        W.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y),
            this.worldTransform.tx = this.world.x,
            this.worldTransform.ty = this.world.y,
            this.previousPosition.set(this.world.x, this.world.y),
            this.previousRotation = this.rotation,
            this.body && this.body.preUpdate(),
            this.fresh = !1) : (this.previousPosition.set(this.world.x, this.world.y),
            this.previousRotation = this.rotation,
            !(!this._exists || !this.parent.exists) || !(this.renderOrderID = -1))
        }
        ,
        W.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }
        ,
        W.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t,
                    this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t,
                    this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        },
        W.Component.Reset = function() {}
        ,
        W.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1),
            this.world.set(t, e),
            this.position.set(t, e),
            this.fresh = !0,
            this.exists = !0,
            this.visible = !0,
            this.renderable = !0,
            this.components.InWorld && (this._outOfBoundsFired = !1),
            this.components.LifeSpan && (this.alive = !0,
            this.health = i),
            this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1),
            this
        }
        ,
        W.Component.ScaleMinMax = function() {}
        ,
        W.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x),
                t.d < this.scaleMin.y && (t.d = this.scaleMin.y)),
                this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x),
                t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, i, s) {
                void 0 === e ? e = i = s = t : void 0 === i && (i = s = e,
                e = t),
                null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new W.Point(t,e),
                null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, s) : this.scaleMax = new W.Point(i,s),
                null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform,
                this.transformCallbackContext = this)
            }
        },
        W.Component.Smoothed = function() {}
        ,
        W.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        },
        W.GameObjectFactory = function(t) {
            this.game = t,
            this.world = this.game.world
        }
        ,
        W.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, e, i, s, n) {
                var r = this.game.plugins.add(W.Weapon);
                return n && (r.bulletClass = n),
                r.createBullets(t, e, i, s),
                r
            },
            image: function(t, e, i, s, n) {
                var r;
                return void 0 === n && (n = this.world),
                r = new W.Image(this.game,t,e,i,s),
                n.add(r)
            },
            sprite: function(t, e, i, s, n) {
                return void 0 === n && (n = this.world),
                n.create(t, e, i, s)
            },
            creature: function(t, e, i, s, n) {
                void 0 === n && (n = this.world);
                var r = new W.Creature(this.game,t,e,i,s);
                return n.add(r),
                r
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, e, i, s, n) {
                return new W.Group(this.game,t,e,i,s,n)
            },
            physicsGroup: function(t, e, i, s) {
                return new W.Group(this.game,e,i,s,!0,t)
            },
            spriteBatch: function(t, e, i) {
                return void 0 === t && (t = null),
                void 0 === e && (e = "group"),
                void 0 === i && (i = !1),
                new W.SpriteBatch(this.game,t,e,i)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, e, i, s, n, r, o) {
                return void 0 === o && (o = this.world),
                o.add(new W.TileSprite(this.game,t,e,i,s,n,r))
            },
            rope: function(t, e, i, s, n, r) {
                return void 0 === r && (r = this.world),
                r.add(new W.Rope(this.game,t,e,i,s,n))
            },
            text: function(t, e, i, s, n) {
                return void 0 === n && (n = this.world),
                n.add(new W.Text(this.game,t,e,i,s))
            },
            button: function(t, e, i, s, n, r, o, a, h, l) {
                return void 0 === l && (l = this.world),
                l.add(new W.Button(this.game,t,e,i,s,n,r,o,a,h))
            },
            graphics: function(t, e, i) {
                return void 0 === i && (i = this.world),
                i.add(new W.Graphics(this.game,t,e))
            },
            emitter: function(t, e, i) {
                return this.game.particles.add(new W.Particles.Arcade.Emitter(this.game,t,e,i))
            },
            retroFont: function(t, e, i, s, n, r, o, a, h) {
                return new W.RetroFont(this.game,t,e,i,s,n,r,o,a,h)
            },
            bitmapText: function(t, e, i, s, n, r) {
                return void 0 === r && (r = this.world),
                r.add(new W.BitmapText(this.game,t,e,i,s,n))
            },
            tilemap: function(t, e, i, s, n) {
                return new W.Tilemap(this.game,t,e,i,s,n)
            },
            renderTexture: function(t, e, i, s) {
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid()),
                void 0 === s && (s = !1);
                var n = new W.RenderTexture(this.game,t,e,i);
                return s && this.game.cache.addRenderTexture(i, n),
                n
            },
            video: function(t, e) {
                return new W.Video(this.game,t,e)
            },
            bitmapData: function(t, e, i, s) {
                void 0 === s && (s = !1),
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                var n = new W.BitmapData(this.game,i,t,e);
                return s && this.game.cache.addBitmapData(i, n),
                n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new W.Filter[t](this.game)).init.apply(t, e),
                t
            },
            plugin: function(t) {
                return this.game.plugins.add(t)
            }
        },
        W.GameObjectFactory.prototype.constructor = W.GameObjectFactory,
        W.GameObjectCreator = function(t) {
            this.game = t,
            this.world = this.game.world
        }
        ,
        W.GameObjectCreator.prototype = {
            image: function(t, e, i, s) {
                return new W.Image(this.game,t,e,i,s)
            },
            sprite: function(t, e, i, s) {
                return new W.Sprite(this.game,t,e,i,s)
            },
            tween: function(t) {
                return new W.Tween(t,this.game,this.game.tweens)
            },
            group: function(t, e, i, s, n) {
                return new W.Group(this.game,t,e,i,s,n)
            },
            spriteBatch: function(t, e, i) {
                return void 0 === e && (e = "group"),
                void 0 === i && (i = !1),
                new W.SpriteBatch(this.game,t,e,i)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            tileSprite: function(t, e, i, s, n, r) {
                return new W.TileSprite(this.game,t,e,i,s,n,r)
            },
            rope: function(t, e, i, s, n) {
                return new W.Rope(this.game,t,e,i,s,n)
            },
            text: function(t, e, i, s) {
                return new W.Text(this.game,t,e,i,s)
            },
            button: function(t, e, i, s, n, r, o, a, h) {
                return new W.Button(this.game,t,e,i,s,n,r,o,a,h)
            },
            graphics: function(t, e) {
                return new W.Graphics(this.game,t,e)
            },
            emitter: function(t, e, i) {
                return new W.Particles.Arcade.Emitter(this.game,t,e,i)
            },
            retroFont: function(t, e, i, s, n, r, o, a, h) {
                return new W.RetroFont(this.game,t,e,i,s,n,r,o,a,h)
            },
            bitmapText: function(t, e, i, s, n, r) {
                return new W.BitmapText(this.game,t,e,i,s,n,r)
            },
            tilemap: function(t, e, i, s, n) {
                return new W.Tilemap(this.game,t,e,i,s,n)
            },
            renderTexture: function(t, e, i, s) {
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid()),
                void 0 === s && (s = !1);
                var n = new W.RenderTexture(this.game,t,e,i);
                return s && this.game.cache.addRenderTexture(i, n),
                n
            },
            bitmapData: function(t, e, i, s) {
                void 0 === s && (s = !1),
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                var n = new W.BitmapData(this.game,i,t,e);
                return s && this.game.cache.addBitmapData(i, n),
                n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new W.Filter[t](this.game)).init.apply(t, e),
                t
            }
        },
        W.GameObjectCreator.prototype.constructor = W.GameObjectCreator,
        W.Sprite = function(t, e, i, s, n) {
            e = e || 0,
            i = i || 0,
            s = s || null,
            n = n || null,
            this.type = W.SPRITE,
            this.physicsType = W.SPRITE,
            PIXI.Sprite.call(this, W.Cache.DEFAULT),
            W.Component.Core.init.call(this, t, e, i, s, n)
        }
        ,
        W.Sprite.prototype = Object.create(PIXI.Sprite.prototype),
        W.Sprite.prototype.constructor = W.Sprite,
        W.Component.Core.install.call(W.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
        W.Sprite.prototype.preUpdatePhysics = W.Component.PhysicsBody.preUpdate,
        W.Sprite.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.Sprite.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.Sprite.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.Image = function(t, e, i, s, n) {
            e = e || 0,
            i = i || 0,
            s = s || null,
            n = n || null,
            this.type = W.IMAGE,
            PIXI.Sprite.call(this, W.Cache.DEFAULT),
            W.Component.Core.init.call(this, t, e, i, s, n)
        }
        ,
        W.Image.prototype = Object.create(PIXI.Sprite.prototype),
        W.Image.prototype.constructor = W.Image,
        W.Component.Core.install.call(W.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]),
        W.Image.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.Image.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.Image.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.Image.prototype.preUpdate = function() {
            return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
        }
        ,
        W.Button = function(t, e, i, s, n, r, o, a, h, l) {
            e = e || 0,
            i = i || 0,
            s = s || null,
            n = n || null,
            r = r || this,
            W.Image.call(this, t, e, i, s, a),
            this.type = W.BUTTON,
            this.physicsType = W.SPRITE,
            this._onOverFrame = null,
            this._onOutFrame = null,
            this._onDownFrame = null,
            this._onUpFrame = null,
            this.onOverSound = null,
            this.onOutSound = null,
            this.onDownSound = null,
            this.onUpSound = null,
            this.onOverSoundMarker = "",
            this.onOutSoundMarker = "",
            this.onDownSoundMarker = "",
            this.onUpSoundMarker = "",
            this.onInputOver = new W.Signal,
            this.onInputOut = new W.Signal,
            this.onInputDown = new W.Signal,
            this.onInputUp = new W.Signal,
            this.onOverMouseOnly = !0,
            this.justReleasedPreventsOver = W.PointerMode.TOUCH,
            this.freezeFrames = !1,
            this.forceOut = !1,
            this.inputEnabled = !0,
            this.input.start(0, !0),
            this.input.useHandCursor = !0,
            this.setFrames(o, a, h, l),
            null !== n && this.onInputUp.add(n, r),
            this.events.onInputOver.add(this.onInputOverHandler, this),
            this.events.onInputOut.add(this.onInputOutHandler, this),
            this.events.onInputDown.add(this.onInputDownHandler, this),
            this.events.onInputUp.add(this.onInputUpHandler, this),
            this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }
        ,
        W.Button.prototype = Object.create(W.Image.prototype),
        W.Button.prototype.constructor = W.Button;
        var h = "Over"
          , l = "Out"
          , c = "Down"
          , u = "Up";
        return W.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }
        ,
        W.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }
        ,
        W.Button.prototype.setStateFrame = function(t, e, i) {
            var s = "_on" + t + "Frame";
            null !== e ? (this[s] = e,
            i && this.changeStateFrame(t)) : this[s] = null
        }
        ,
        W.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames)
                return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e,
            !0) : "number" == typeof e && (this.frame = e,
            !0)
        }
        ,
        W.Button.prototype.setFrames = function(t, e, i, s) {
            this.setStateFrame(h, t, this.input.pointerOver()),
            this.setStateFrame(l, e, !this.input.pointerOver()),
            this.setStateFrame(c, i, this.input.pointerDown()),
            this.setStateFrame(u, s, this.input.pointerUp())
        }
        ,
        W.Button.prototype.setStateSound = function(t, e, i) {
            var s = "on" + t + "Sound"
              , n = "on" + t + "SoundMarker";
            e instanceof W.Sound || e instanceof W.AudioSprite ? (this[s] = e,
            this[n] = "string" == typeof i ? i : "") : (this[s] = null,
            this[n] = "")
        }
        ,
        W.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i),
                !0
            }
            return !1
        }
        ,
        W.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
            this.setStateSound(h, t, e),
            this.setStateSound(l, n, r),
            this.setStateSound(c, i, s),
            this.setStateSound(u, o, a)
        }
        ,
        W.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound(h, t, e)
        }
        ,
        W.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound(l, t, e)
        }
        ,
        W.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound(c, t, e)
        }
        ,
        W.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound(u, t, e)
        }
        ,
        W.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(h),
            this.onOverMouseOnly && !e.isMouse || (this.playStateSound(h),
            this.onInputOver && this.onInputOver.dispatch(this, e)))
        }
        ,
        W.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame(l),
            this.playStateSound(l),
            this.onInputOut && this.onInputOut.dispatch(this, e)
        }
        ,
        W.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame(c),
            this.playStateSound(c),
            this.onInputDown && this.onInputDown.dispatch(this, e)
        }
        ,
        W.Button.prototype.onInputUpHandler = function(t, e, i) {
            this.playStateSound(u),
            this.onInputUp && this.onInputUp.dispatch(this, e, i),
            this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame(l) : this.changeStateFrame(u) || (i ? this.changeStateFrame(h) : this.changeStateFrame(l)))
        }
        ,
        W.SpriteBatch = function(t, e, i, s) {
            null == e && (e = t.world),
            W.Group.call(this, t, e, i, s),
            this.type = W.SPRITEBATCH,
            this.fastSpriteBatch = null,
            this.ready = !1
        }
        ,
        W.SpriteBatch.prototype = Object.create(W.Group.prototype),
        W.SpriteBatch.prototype.constructor = W.SpriteBatch,
        W.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl),
            this.ready = !0),
            this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl),
            t.spriteBatch.stop(),
            t.shaderManager.setShader(t.shaderManager.fastShader),
            this.fastSpriteBatch.begin(this, t),
            this.fastSpriteBatch.render(this),
            t.spriteBatch.start())
        }
        ,
        W.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha,
                this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                    var r = this.children[n];
                    if (r.visible) {
                        var o = r.texture
                          , a = o.frame;
                        if (e.globalAlpha = this.worldAlpha * r.alpha,
                        r.rotation % (2 * Math.PI) == 0)
                            s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty),
                            s = !1),
                            e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                        else {
                            s = s || !0,
                            r.displayObjectUpdateTransform();
                            var h = r.worldTransform
                              , l = h.tx * t.resolution + t.shakeX
                              , c = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c),
                            e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                        }
                    }
                }
            }
        }
        ,
        W.BitmapData = function(t, e, i, s, n) {
            void 0 !== i && 0 !== i || (i = 256),
            void 0 !== s && 0 !== s || (s = 256),
            void 0 === n && (n = !1),
            this.game = t,
            this.key = e,
            this.width = i,
            this.height = s,
            this.canvas = W.Canvas.create(this, i, s, null, n),
            this.context = this.canvas.getContext("2d", {
                alpha: !0
            }),
            this.ctx = this.context,
            this.smoothProperty = t.renderType === W.CANVAS ? t.renderer.renderSession.smoothProperty : W.Canvas.getSmoothingPrefix(this.context),
            this.imageData = this.context.getImageData(0, 0, i, s),
            this.data = null,
            this.imageData && (this.data = this.imageData.data),
            this.pixels = null,
            this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
            this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
            this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data),
            this.baseTexture = new PIXI.BaseTexture(this.canvas,null,this.game.resolution),
            this.texture = new PIXI.Texture(this.baseTexture),
            this.frameData = new W.FrameData,
            this.textureFrame = this.frameData.addFrame(new W.Frame(0,0,0,i,s,"bitmapData")),
            this.texture.frame = this.textureFrame,
            this.type = W.BITMAPDATA,
            this.disableTextureUpload = !1,
            this.dirty = !1,
            this.cls = this.clear,
            this._image = null,
            this._pos = new W.Point,
            this._size = new W.Point,
            this._scale = new W.Point,
            this._rotate = 0,
            this._alpha = {
                prev: 1,
                current: 1
            },
            this._anchor = new W.Point,
            this._tempR = 0,
            this._tempG = 0,
            this._tempB = 0,
            this._circle = new W.Circle,
            this._swapCanvas = void 0
        }
        ,
        W.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i),
                0 !== e && this.moveV(e, i),
                this
            },
            moveH: function(t, e) {
                void 0 === e && (e = !0),
                void 0 === this._swapCanvas && (this._swapCanvas = W.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d")
                  , s = this.height
                  , n = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height),
                t < 0) {
                    t = Math.abs(t);
                    var r = this.width - t;
                    e && i.drawImage(n, 0, 0, t, s, r, 0, t, s),
                    i.drawImage(n, t, 0, r, s, 0, 0, r, s)
                } else {
                    r = this.width - t;
                    e && i.drawImage(n, r, 0, t, s, 0, 0, t, s),
                    i.drawImage(n, 0, 0, r, s, t, 0, r, s)
                }
                return this.clear(),
                this.copy(this._swapCanvas)
            },
            moveV: function(t, e) {
                void 0 === e && (e = !0),
                void 0 === this._swapCanvas && (this._swapCanvas = W.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d")
                  , s = this.width
                  , n = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height),
                t < 0) {
                    t = Math.abs(t);
                    var r = this.height - t;
                    e && i.drawImage(n, 0, 0, s, t, 0, r, s, t),
                    i.drawImage(n, 0, t, s, r, 0, 0, s, r)
                } else {
                    r = this.height - t;
                    e && i.drawImage(n, 0, r, s, t, 0, 0, s, t),
                    i.drawImage(n, 0, 0, s, r, 0, t, s, r)
                }
                return this.clear(),
                this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++)
                        t[e].loadTexture && t[e].loadTexture(this);
                else
                    t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)),
                t)
                    return this.resize(t.width, t.height),
                    this.cls(),
                    this.draw(t),
                    this.update(),
                    this
            },
            clear: function(t, e, i, s) {
                return void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                void 0 === i && (i = this.width),
                void 0 === s && (s = this.height),
                this.context.clearRect(t, e, i, s),
                this.dirty = !0,
                this
            },
            fill: function(t, e, i, s) {
                return void 0 === s && (s = 1),
                this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")",
                this.context.fillRect(0, 0, this.width, this.height),
                this.dirty = !0,
                this
            },
            generateTexture: function(i, s, n) {
                var r = this.game.cache
                  , o = new Image;
                if (s && (o.onload = function() {
                    var t = r.addImage(i, "", o)
                      , e = new PIXI.Texture(t.base);
                    s.call(n || null, e),
                    o.onload = null
                }
                ),
                o.src = this.canvas.toDataURL("image/png"),
                s)
                    return null;
                var t = r.addImage(i, "", o);
                return new PIXI.Texture(t.base)
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t,
                this.height = e,
                this.canvas.width = t,
                this.canvas.height = e,
                void 0 !== this._swapCanvas && (this._swapCanvas.width = t,
                this._swapCanvas.height = e),
                this.baseTexture.width = t,
                this.baseTexture.height = e,
                this.textureFrame.width = t,
                this.textureFrame.height = e,
                this.texture.width = t,
                this.texture.height = e,
                this.texture.crop.width = t,
                this.texture.crop.height = e,
                this.update(),
                this.dirty = !0),
                this
            },
            update: function(t, e, i, s) {
                return void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                void 0 === i && (i = Math.max(1, this.width)),
                void 0 === s && (s = Math.max(1, this.height)),
                this.imageData = this.context.getImageData(t, e, i, s),
                this.data = this.imageData.data,
                this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
                this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
                this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data,
                this
            },
            processPixelRGB: function(t, e, i, s, n, r) {
                void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                void 0 === n && (n = this.width),
                void 0 === r && (r = this.height);
                for (var o = i + n, a = s + r, h = W.Color.createColor(), l = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0
                }, c = !1, u = s; u < a; u++)
                    for (var d = i; d < o; d++)
                        W.Color.unpackPixel(this.getPixel32(d, u), h),
                        !1 !== (l = t.call(e, h, d, u)) && null != l && (this.setPixel32(d, u, l.r, l.g, l.b, l.a, !1),
                        c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0),
                this
            },
            processPixel: function(t, e, i, s, n, r) {
                void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                void 0 === n && (n = this.width),
                void 0 === r && (r = this.height);
                for (var o = i + n, a = s + r, h = 0, l = 0, c = !1, u = s; u < a; u++)
                    for (var d = i; d < o; d++)
                        h = this.getPixel32(d, u),
                        (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l,
                        c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0),
                this
            },
            replaceRGB: function(t, e, i, s, n, r, o, a, h) {
                var l = 0
                  , c = 0
                  , u = this.width
                  , d = this.height
                  , p = W.Color.packPixel(t, e, i, s);
                void 0 !== h && h instanceof W.Rectangle && (l = h.x,
                c = h.y,
                u = h.width,
                d = h.height);
                for (var f = 0; f < d; f++)
                    for (var g = 0; g < u; g++)
                        this.getPixel32(l + g, c + f) === p && this.setPixel32(l + g, c + f, n, r, o, a, !1);
                return this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0,
                this
            },
            setHSL: function(t, e, i, s) {
                var n = t || 0 === t
                  , r = e || 0 === e
                  , o = i || 0 === i;
                if (n || r || o) {
                    void 0 === s && (s = new W.Rectangle(0,0,this.width,this.height));
                    for (var a = W.Color.createColor(), h = s.y; h < s.bottom; h++)
                        for (var l = s.x; l < s.right; l++)
                            W.Color.unpackPixel(this.getPixel32(l, h), a, !0),
                            n && (a.h = t),
                            r && (a.s = e),
                            o && (a.l = i),
                            W.Color.HSLtoRGB(a.h, a.s, a.l, a),
                            this.setPixel32(l, h, a.r, a.g, a.b, a.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0),
                    this.dirty = !0,
                    this
                }
            },
            shiftHSL: function(t, e, i, s) {
                if (null == t && (t = !1),
                null == e && (e = !1),
                null == i && (i = !1),
                t || e || i) {
                    void 0 === s && (s = new W.Rectangle(0,0,this.width,this.height));
                    for (var n = W.Color.createColor(), r = s.y; r < s.bottom; r++)
                        for (var o = s.x; o < s.right; o++)
                            W.Color.unpackPixel(this.getPixel32(o, r), n, !0),
                            t && (n.h = this.game.math.wrap(n.h + t, 0, 1)),
                            e && (n.s = this.game.math.clamp(n.s + e, 0, 1)),
                            i && (n.l = this.game.math.clamp(n.l + i, 0, 1)),
                            W.Color.HSLtoRGB(n.h, n.s, n.l, n),
                            this.setPixel32(o, r, n.r, n.g, n.b, n.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0),
                    this.dirty = !0,
                    this
                }
            },
            setPixel32: function(t, e, i, s, n, r, o) {
                return void 0 === o && (o = !0),
                0 <= t && t <= this.width && 0 <= e && e <= this.height && (W.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = r << 24 | n << 16 | s << 8 | i : this.pixels[e * this.width + t] = i << 24 | s << 16 | n << 8 | r,
                o && (this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0)),
                this
            },
            setPixel: function(t, e, i, s, n, r) {
                return this.setPixel32(t, e, i, s, n, 255, r)
            },
            getPixel: function(t, e, i) {
                i = i || W.Color.createColor();
                var s = ~~(t + e * this.width);
                return s *= 4,
                i.r = this.data[s],
                i.g = this.data[++s],
                i.b = this.data[++s],
                i.a = this.data[++s],
                i
            },
            getPixel32: function(t, e) {
                if (0 <= t && t <= this.width && 0 <= e && e <= this.height)
                    return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, e, i, s, n) {
                return W.Color.unpackPixel(this.getPixel32(t, e), i, s, n)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = W.Color.createColor()
                  , i = 0
                  , s = 0
                  , n = 1
                  , r = !1;
                for (1 === t ? (n = -1,
                s = this.height) : 3 === t && (n = -1,
                i = this.width); W.Color.unpackPixel(this.getPixel32(i, s), e),
                0 === t || 1 === t ? ++i === this.width && (i = 0,
                ((s += n) >= this.height || s <= 0) && (r = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0,
                ((i += n) >= this.width || i <= 0) && (r = !0)),
                0 === e.a && !r; )
                    ;
                return e.x = i,
                e.y = s,
                e
            },
            getBounds: function(t) {
                return void 0 === t && (t = new W.Rectangle),
                t.x = this.getFirstPixel(2).x,
                t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y,
                t.width = this.getFirstPixel(3).x - t.x + 1,
                t.height = this.getFirstPixel(1).y - t.y + 1,
                t)
            },
            addToWorld: function(t, e, i, s, n, r) {
                n = n || 1,
                r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, s),
                o.scale.set(n, r),
                o
            },
            copy: function(t, e, i, s, n, r, o, a, h, l, c, u, d, p, f, g, m) {
                if (null == t && (t = this),
                t instanceof W.RenderTexture && (t = t.getCanvas()),
                (this._image = t)instanceof W.Sprite || t instanceof W.Image || t instanceof W.Text || t instanceof PIXI.Sprite)
                    this._pos.set(t.texture.crop.x, t.texture.crop.y),
                    this._size.set(t.texture.crop.width, t.texture.crop.height),
                    this._scale.set(t.scale.x, t.scale.y),
                    this._anchor.set(t.anchor.x, t.anchor.y),
                    this._rotate = t.rotation,
                    this._alpha.current = t.alpha,
                    t.texture instanceof W.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source,
                    null == r && (r = t.x),
                    null == o && (o = t.y),
                    t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width,
                    o += t.texture.trim.y - t.anchor.y * t.texture.trim.height),
                    16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint,
                    t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)),
                    this._image = t.tintedTexture,
                    this._pos.set(0));
                else {
                    if (this._pos.set(0),
                    this._scale.set(1),
                    this._anchor.set(0),
                    this._rotate = 0,
                    this._alpha.current = 1,
                    t instanceof W.BitmapData)
                        this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t)))
                            return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (null == e && (e = 0),
                null == i && (i = 0),
                s && (this._size.x = s),
                n && (this._size.y = n),
                null == r && (r = e),
                null == o && (o = i),
                null == a && (a = this._size.x),
                null == h && (h = this._size.y),
                "number" == typeof l && (this._rotate = l),
                "number" == typeof c && (this._anchor.x = c),
                "number" == typeof u && (this._anchor.y = u),
                "number" == typeof d && (this._scale.x = d),
                "number" == typeof p && (this._scale.y = p),
                "number" == typeof f && (this._alpha.current = f),
                void 0 === g && (g = null),
                void 0 === m && (m = !1),
                !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var y = this.context;
                    return this._alpha.prev = y.globalAlpha,
                    y.save(),
                    y.globalAlpha = this._alpha.current,
                    g && (this.op = g),
                    m && (r |= 0,
                    o |= 0),
                    y.translate(r, o),
                    y.scale(this._scale.x, this._scale.y),
                    y.rotate(this._rotate),
                    y.drawImage(this._image, this._pos.x + e, this._pos.y + i, this._size.x, this._size.y, -a * this._anchor.x, -h * this._anchor.y, a, h),
                    y.restore(),
                    y.globalAlpha = this._alpha.prev,
                    this.dirty = !0,
                    this
                }
            },
            copyTransform: function(t, e, i) {
                if (void 0 === e && (e = null),
                void 0 === i && (i = !1),
                !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha)
                    return this;
                var s = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y),
                this._size.set(t.texture.crop.width, t.texture.crop.height),
                0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y)
                    return this;
                t.texture instanceof W.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var n = s.tx
                  , r = s.ty;
                t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width,
                r += t.texture.trim.y - t.anchor.y * t.texture.trim.height),
                16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint,
                t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)),
                this._image = t.tintedTexture,
                this._pos.set(0)),
                i && (n |= 0,
                r |= 0);
                var o = this.context;
                return this._alpha.prev = o.globalAlpha,
                o.save(),
                o.globalAlpha = this._alpha.current,
                e && (this.op = e),
                o[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR,
                o.setTransform(s.a, s.b, s.c, s.d, n, r),
                o.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y),
                o.restore(),
                o.globalAlpha = this._alpha.prev,
                this.dirty = !0,
                this
            },
            copyRect: function(t, e, i, s, n, r, o) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, o)
            },
            draw: function(t, e, i, s, n, r, o) {
                return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, o)
            },
            drawGroup: function(t, e, i) {
                return 0 < t.total && t.forEachExists(this.drawGroupProxy, this, e, i),
                this
            },
            drawGroupProxy: function(t, e, i) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, e, i),
                t.type === W.GROUP && t.exists)
                    this.drawGroup(t, e, i);
                else if (t.hasOwnProperty("children") && 0 < t.children.length)
                    for (var s = 0; s < t.children.length; s++)
                        t.children[s].exists && this.copyTransform(t.children[s], e, i)
            },
            drawFull: function(t, e, i) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists)
                    return this;
                if (t.type !== W.GROUP && t.type !== W.EMITTER && t.type !== W.BITMAPTEXT)
                    if (t.type === W.GRAPHICS) {
                        var s = t.getBounds();
                        this.ctx.save(),
                        this.ctx.translate(s.x, s.y),
                        PIXI.CanvasGraphics.renderGraphics(t, this.ctx),
                        this.ctx.restore()
                    } else
                        this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, i);
                if (t.children)
                    for (var n = 0; n < t.children.length; n++)
                        this.drawFull(t.children[n], e, i);
                return this
            },
            shadow: function(t, e, i, s) {
                var n = this.context;
                return null == t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t,
                n.shadowBlur = e || 5,
                n.shadowOffsetX = i || 10,
                n.shadowOffsetY = s || 10),
                this
            },
            alphaMask: function(t, e, i, s) {
                return null == s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(),
                null == i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(),
                this
            },
            extract: function(s, n, r, o, a, t, h, l, c) {
                return void 0 === a && (a = 255),
                void 0 === t && (t = !1),
                void 0 === h && (h = n),
                void 0 === l && (l = r),
                void 0 === c && (c = o),
                t && s.resize(this.width, this.height),
                this.processPixelRGB(function(t, e, i) {
                    return t.r === n && t.g === r && t.b === o && s.setPixel32(e, i, h, l, c, a, !1),
                    !1
                }, this),
                s.context.putImageData(s.imageData, 0, 0),
                s.dirty = !0,
                s
            },
            rect: function(t, e, i, s, n) {
                return void 0 !== n && (this.context.fillStyle = n),
                this.context.fillRect(t, e, i, s),
                this
            },
            text: function(t, e, i, s, n, r) {
                void 0 === e && (e = 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = "14px Courier"),
                void 0 === n && (n = "rgb(255,255,255)"),
                void 0 === r && (r = !0);
                var o = this.context
                  , a = o.font;
                return o.font = s,
                r && (o.fillStyle = "rgb(0,0,0)",
                o.fillText(t, e + 1, i + 1)),
                o.fillStyle = n,
                o.fillText(t, e, i),
                o.font = a,
                this
            },
            circle: function(t, e, i, s) {
                var n = this.context;
                return void 0 !== s && (n.fillStyle = s),
                n.beginPath(),
                n.arc(t, e, i, 0, 2 * Math.PI, !1),
                n.closePath(),
                n.fill(),
                this
            },
            line: function(t, e, i, s, n, r) {
                void 0 === n && (n = "#fff"),
                void 0 === r && (r = 1);
                var o = this.context;
                return o.beginPath(),
                o.moveTo(t, e),
                o.lineTo(i, s),
                o.lineWidth = r,
                o.strokeStyle = n,
                o.stroke(),
                o.closePath(),
                this
            },
            textureLine: function(t, e, i) {
                if (void 0 === i && (i = "repeat-x"),
                "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var s = t.length;
                    "no-repeat" === i && s > e.width && (s = e.width);
                    var n = this.context;
                    return n.fillStyle = n.createPattern(e, i),
                    this._circle = new W.Circle(t.start.x,t.start.y,e.height),
                    this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos),
                    n.save(),
                    n.translate(this._pos.x, this._pos.y),
                    n.rotate(t.angle),
                    n.fillRect(0, 0, s, e.height),
                    n.restore(),
                    this.dirty = !0,
                    this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(),
                this.dirty = !1),
                this
            },
            destroy: function() {
                this.frameData.destroy(),
                this.texture.destroy(!0),
                W.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over",
                this
            },
            blendSourceOver: function() {
                return this.op = "source-over",
                this
            },
            blendSourceIn: function() {
                return this.op = "source-in",
                this
            },
            blendSourceOut: function() {
                return this.op = "source-out",
                this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop",
                this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over",
                this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in",
                this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out",
                this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop",
                this
            },
            blendXor: function() {
                return this.op = "xor",
                this
            },
            blendAdd: function() {
                return this.op = "lighter",
                this
            },
            blendMultiply: function() {
                return this.op = "multiply",
                this
            },
            blendScreen: function() {
                return this.op = "screen",
                this
            },
            blendOverlay: function() {
                return this.op = "overlay",
                this
            },
            blendDarken: function() {
                return this.op = "darken",
                this
            },
            blendLighten: function() {
                return this.op = "lighten",
                this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge",
                this
            },
            blendColorBurn: function() {
                return this.op = "color-burn",
                this
            },
            blendHardLight: function() {
                return this.op = "hard-light",
                this
            },
            blendSoftLight: function() {
                return this.op = "soft-light",
                this
            },
            blendDifference: function() {
                return this.op = "difference",
                this
            },
            blendExclusion: function() {
                return this.op = "exclusion",
                this
            },
            blendHue: function() {
                return this.op = "hue",
                this
            },
            blendSaturation: function() {
                return this.op = "saturation",
                this
            },
            blendColor: function() {
                return this.op = "color",
                this
            },
            blendLuminosity: function() {
                return this.op = "luminosity",
                this
            },
            copyBitmapData: function(t, e, i) {
                t.update();
                for (var s, n = 0; n < t.height; n++) {
                    s = (i + n) * this.width + e;
                    for (var r = 0; r < t.width; r++)
                        this.pixels[s + r] = t.pixels[n * t.width + r]
                }
                return this
            }
        },
        Object.defineProperty(W.BitmapData.prototype, "smoothed", {
            get: function() {
                W.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                W.Canvas.setSmoothingEnabled(this.context, t)
            }
        }),
        Object.defineProperty(W.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }),
        W.BitmapData.getTransform = function(t, e, i, s, n, r) {
            return "number" != typeof t && (t = 0),
            "number" != typeof e && (e = 0),
            "number" != typeof i && (i = 1),
            "number" != typeof s && (s = 1),
            "number" != typeof n && (n = 0),
            "number" != typeof r && (r = 0),
            {
                sx: i,
                sy: s,
                scaleX: i,
                scaleY: s,
                skewX: n,
                skewY: r,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }
        ,
        W.BitmapData.prototype.constructor = W.BitmapData,
        W.EarCut = {},
        W.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var s, n, r, o, a, h, l, c = e && e.length, u = c ? e[0] * i : t.length, d = W.EarCut.linkedList(t, 0, u, i, !0), p = [];
            if (!d)
                return p;
            if (c && (d = W.EarCut.eliminateHoles(t, e, d, i)),
            t.length > 80 * i) {
                s = r = t[0],
                n = o = t[1];
                for (var f = i; f < u; f += i)
                    (a = t[f]) < s && (s = a),
                    (h = t[f + 1]) < n && (n = h),
                    r < a && (r = a),
                    o < h && (o = h);
                l = Math.max(r - s, o - n)
            }
            return W.EarCut.earcutLinked(d, p, i, s, n, l),
            p
        }
        ,
        W.EarCut.linkedList = function(t, e, i, s, n) {
            var r, o, a, h = 0;
            for (r = e,
            o = i - s; r < i; r += s)
                h += (t[o] - t[r]) * (t[r + 1] + t[o + 1]),
                o = r;
            if (n === 0 < h)
                for (r = e; r < i; r += s)
                    a = W.EarCut.insertNode(r, t[r], t[r + 1], a);
            else
                for (r = i - s; e <= r; r -= s)
                    a = W.EarCut.insertNode(r, t[r], t[r + 1], a);
            return a
        }
        ,
        W.EarCut.filterPoints = function(t, e) {
            if (!t)
                return t;
            e = e || t;
            var i, s = t;
            do {
                if (i = !1,
                s.steiner || !W.EarCut.equals(s, s.next) && 0 !== W.EarCut.area(s.prev, s, s.next))
                    s = s.next;
                else {
                    if (W.EarCut.removeNode(s),
                    (s = e = s.prev) === s.next)
                        return null;
                    i = !0
                }
            } while (i || s !== e);
            return e
        }
        ,
        W.EarCut.earcutLinked = function(t, e, i, s, n, r, o) {
            if (t) {
                !o && r && W.EarCut.indexCurve(t, s, n, r);
                for (var a, h, l = t; t.prev !== t.next; )
                    if (a = t.prev,
                    h = t.next,
                    r ? W.EarCut.isEarHashed(t, s, n, r) : W.EarCut.isEar(t))
                        e.push(a.i / i),
                        e.push(t.i / i),
                        e.push(h.i / i),
                        W.EarCut.removeNode(t),
                        t = h.next,
                        l = h.next;
                    else if ((t = h) === l) {
                        o ? 1 === o ? (t = W.EarCut.cureLocalIntersections(t, e, i),
                        W.EarCut.earcutLinked(t, e, i, s, n, r, 2)) : 2 === o && W.EarCut.splitEarcut(t, e, i, s, n, r) : W.EarCut.earcutLinked(W.EarCut.filterPoints(t), e, i, s, n, r, 1);
                        break
                    }
            }
        }
        ,
        W.EarCut.isEar = function(t) {
            var e = t.prev
              , i = t
              , s = t.next;
            if (0 <= W.EarCut.area(e, i, s))
                return !1;
            for (var n = t.next.next; n !== t.prev; ) {
                if (W.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, n.x, n.y) && 0 <= W.EarCut.area(n.prev, n, n.next))
                    return !1;
                n = n.next
            }
            return !0
        }
        ,
        W.EarCut.isEarHashed = function(t, e, i, s) {
            var n = t.prev
              , r = t
              , o = t.next;
            if (0 <= W.EarCut.area(n, r, o))
                return !1;
            for (var a = n.x < r.x ? n.x < o.x ? n.x : o.x : r.x < o.x ? r.x : o.x, h = n.y < r.y ? n.y < o.y ? n.y : o.y : r.y < o.y ? r.y : o.y, l = n.x > r.x ? n.x > o.x ? n.x : o.x : r.x > o.x ? r.x : o.x, c = n.y > r.y ? n.y > o.y ? n.y : o.y : r.y > o.y ? r.y : o.y, u = W.EarCut.zOrder(a, h, e, i, s), d = W.EarCut.zOrder(l, c, e, i, s), p = t.nextZ; p && p.z <= d; ) {
                if (p !== t.prev && p !== t.next && W.EarCut.pointInTriangle(n.x, n.y, r.x, r.y, o.x, o.y, p.x, p.y) && 0 <= W.EarCut.area(p.prev, p, p.next))
                    return !1;
                p = p.nextZ
            }
            for (p = t.prevZ; p && p.z >= u; ) {
                if (p !== t.prev && p !== t.next && W.EarCut.pointInTriangle(n.x, n.y, r.x, r.y, o.x, o.y, p.x, p.y) && 0 <= W.EarCut.area(p.prev, p, p.next))
                    return !1;
                p = p.prevZ
            }
            return !0
        }
        ,
        W.EarCut.cureLocalIntersections = function(t, e, i) {
            var s = t;
            do {
                var n = s.prev
                  , r = s.next.next;
                W.EarCut.intersects(n, s, s.next, r) && W.EarCut.locallyInside(n, r) && W.EarCut.locallyInside(r, n) && (e.push(n.i / i),
                e.push(s.i / i),
                e.push(r.i / i),
                W.EarCut.removeNode(s),
                W.EarCut.removeNode(s.next),
                s = t = r),
                s = s.next
            } while (s !== t);
            return s
        }
        ,
        W.EarCut.splitEarcut = function(t, e, i, s, n, r) {
            var o = t;
            do {
                for (var a = o.next.next; a !== o.prev; ) {
                    if (o.i !== a.i && W.EarCut.isValidDiagonal(o, a)) {
                        var h = W.EarCut.splitPolygon(o, a);
                        return o = W.EarCut.filterPoints(o, o.next),
                        h = W.EarCut.filterPoints(h, h.next),
                        W.EarCut.earcutLinked(o, e, i, s, n, r),
                        void W.EarCut.earcutLinked(h, e, i, s, n, r)
                    }
                    a = a.next
                }
                o = o.next
            } while (o !== t)
        }
        ,
        W.EarCut.eliminateHoles = function(t, e, i, s) {
            var n, r, o, a, h, l = [];
            for (n = 0,
            r = e.length; n < r; n++)
                o = e[n] * s,
                a = n < r - 1 ? e[n + 1] * s : t.length,
                (h = W.EarCut.linkedList(t, o, a, s, !1)) === h.next && (h.steiner = !0),
                l.push(W.EarCut.getLeftmost(h));
            for (l.sort(compareX),
            n = 0; n < l.length; n++)
                W.EarCut.eliminateHole(l[n], i),
                i = W.EarCut.filterPoints(i, i.next);
            return i
        }
        ,
        W.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }
        ,
        W.EarCut.eliminateHole = function(t, e) {
            if (e = W.EarCut.findHoleBridge(t, e)) {
                var i = W.EarCut.splitPolygon(e, t);
                W.EarCut.filterPoints(i, i.next)
            }
        }
        ,
        W.EarCut.findHoleBridge = function(t, e) {
            var i, s = e, n = t.x, r = t.y, o = -1 / 0;
            do {
                if (r <= s.y && r >= s.next.y) {
                    var a = s.x + (r - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
                    a <= n && o < a && (o = a,
                    i = s.x < s.next.x ? s : s.next)
                }
                s = s.next
            } while (s !== e);
            if (!i)
                return null;
            if (t.x === i.x)
                return i.prev;
            var h, l = i, c = 1 / 0;
            for (s = i.next; s !== l; )
                n >= s.x && s.x >= i.x && W.EarCut.pointInTriangle(r < i.y ? n : o, r, i.x, i.y, r < i.y ? o : n, r, s.x, s.y) && ((h = Math.abs(r - s.y) / (n - s.x)) < c || h === c && s.x > i.x) && W.EarCut.locallyInside(s, t) && (i = s,
                c = h),
                s = s.next;
            return i
        }
        ,
        W.EarCut.indexCurve = function(t, e, i, s) {
            for (var n = t; null === n.z && (n.z = W.EarCut.zOrder(n.x, n.y, e, i, s)),
            n.prevZ = n.prev,
            n.nextZ = n.next,
            (n = n.next) !== t; )
                ;
            n.prevZ.nextZ = null,
            n.prevZ = null,
            W.EarCut.sortLinked(n)
        }
        ,
        W.EarCut.sortLinked = function(t) {
            var e, i, s, n, r, o, a, h, l = 1;
            do {
                for (i = t,
                r = t = null,
                o = 0; i; ) {
                    for (o++,
                    s = i,
                    e = a = 0; e < l && (a++,
                    s = s.nextZ); e++)
                        ;
                    for (h = l; 0 < a || 0 < h && s; )
                        0 === a ? (s = (n = s).nextZ,
                        h--) : 0 !== h && s ? i.z <= s.z ? (i = (n = i).nextZ,
                        a--) : (s = (n = s).nextZ,
                        h--) : (i = (n = i).nextZ,
                        a--),
                        r ? r.nextZ = n : t = n,
                        n.prevZ = r,
                        r = n;
                    i = s
                }
                r.nextZ = null,
                l *= 2
            } while (1 < o);
            return t
        }
        ,
        W.EarCut.zOrder = function(t, e, i, s, n) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        ,
        W.EarCut.getLeftmost = function(t) {
            for (var e = t, i = t; e.x < i.x && (i = e),
            (e = e.next) !== t; )
                ;
            return i
        }
        ,
        W.EarCut.pointInTriangle = function(t, e, i, s, n, r, o, a) {
            return 0 <= (n - o) * (e - a) - (t - o) * (r - a) && 0 <= (t - o) * (s - a) - (i - o) * (e - a) && 0 <= (i - o) * (r - a) - (n - o) * (s - a)
        }
        ,
        W.EarCut.isValidDiagonal = function(t, e) {
            return W.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !W.EarCut.intersectsPolygon(t, e) && W.EarCut.locallyInside(t, e) && W.EarCut.locallyInside(e, t) && W.EarCut.middleInside(t, e)
        }
        ,
        W.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }
        ,
        W.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }
        ,
        W.EarCut.intersects = function(t, e, i, s) {
            return 0 < W.EarCut.area(t, e, i) != 0 < W.EarCut.area(t, e, s) && 0 < W.EarCut.area(i, s, t) != 0 < W.EarCut.area(i, s, e)
        }
        ,
        W.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && W.EarCut.intersects(i, i.next, t, e))
                    return !0;
                i = i.next
            } while (i !== t);
            return !1
        }
        ,
        W.EarCut.locallyInside = function(t, e) {
            return W.EarCut.area(t.prev, t, t.next) < 0 ? 0 <= W.EarCut.area(t, e, t.next) && 0 <= W.EarCut.area(t, t.prev, e) : W.EarCut.area(t, e, t.prev) < 0 || W.EarCut.area(t, t.next, e) < 0
        }
        ,
        W.EarCut.middleInside = function(t, e) {
            for (var i = t, s = !1, n = (t.x + e.x) / 2, r = (t.y + e.y) / 2; i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s),
            (i = i.next) !== t; )
                ;
            return s
        }
        ,
        W.EarCut.splitPolygon = function(t, e) {
            var i = new W.EarCut.Node(t.i,t.x,t.y)
              , s = new W.EarCut.Node(e.i,e.x,e.y)
              , n = t.next
              , r = e.prev;
            return (t.next = e).prev = t,
            (i.next = n).prev = i,
            (s.next = i).prev = s,
            (r.next = s).prev = r,
            s
        }
        ,
        W.EarCut.insertNode = function(t, e, i, s) {
            var n = new W.EarCut.Node(t,e,i);
            return s ? (n.next = s.next,
            (n.prev = s).next.prev = n,
            s.next = n) : (n.prev = n).next = n,
            n
        }
        ,
        W.EarCut.removeNode = function(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        ,
        W.EarCut.Node = function(t, e, i) {
            this.i = t,
            this.x = e,
            this.y = i,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        ,
        PIXI.WebGLGraphics = function() {}
        ,
        PIXI.WebGLGraphics.stencilBufferLimit = 6,
        PIXI.WebGLGraphics.renderGraphics = function(t, e) {
            var i, s = e.gl, n = e.projection, r = e.offset, o = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, s);
            for (var a = t._webGL[s.id], h = 0; h < a.data.length; h++)
                1 === a.data[h].mode ? (i = a.data[h],
                e.stencilManager.pushStencil(t, i, e),
                s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)),
                e.stencilManager.popStencil(t, i, e)) : (i = a.data[h],
                e.shaderManager.setShader(o),
                o = e.shaderManager.primitiveShader,
                s.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)),
                s.uniform1f(o.flipY, 1),
                s.uniform2f(o.projectionVector, n.x, -n.y),
                s.uniform2f(o.offsetVector, -r.x, -r.y),
                s.uniform3fv(o.tintColor, W.Color.hexToRGBArray(t.tint)),
                s.uniform1f(o.alpha, t.worldAlpha),
                s.bindBuffer(s.ARRAY_BUFFER, i.buffer),
                s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, !1, 24, 0),
                s.vertexAttribPointer(o.colorAttribute, 4, s.FLOAT, !1, 24, 8),
                s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer),
                s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
        }
        ,
        PIXI.WebGLGraphics.updateGraphics = function(t, e) {
            var i, s, n = t._webGL[e.id];
            if (n = n || (t._webGL[e.id] = {
                lastIndex: 0,
                data: [],
                gl: e
            }),
            t.dirty = !1,
            t.clearDirty) {
                for (t.clearDirty = !1,
                i = 0; i < n.data.length; i++) {
                    var r = n.data[i];
                    r.reset(),
                    PIXI.WebGLGraphics.graphicsDataPool.push(r)
                }
                n.data = [],
                n.lastIndex = 0
            }
            for (i = n.lastIndex; i < t.graphicsData.length; i++) {
                var o = t.graphicsData[i];
                if (o.type === W.POLYGON) {
                    if (o.points = o.shape.points.slice(),
                    o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])),
                    o.fill)
                        if (o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                            if (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit)
                                s = PIXI.WebGLGraphics.switchMode(n, 0),
                                PIXI.WebGLGraphics.buildPoly(o, s) || (s = PIXI.WebGLGraphics.switchMode(n, 1),
                                PIXI.WebGLGraphics.buildComplexPoly(o, s));
                            else
                                s = PIXI.WebGLGraphics.switchMode(n, 1),
                                PIXI.WebGLGraphics.buildComplexPoly(o, s);
                    0 < o.lineWidth && (s = PIXI.WebGLGraphics.switchMode(n, 0),
                    PIXI.WebGLGraphics.buildLine(o, s))
                } else
                    s = PIXI.WebGLGraphics.switchMode(n, 0),
                    o.type === W.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(o, s) : o.type === W.CIRCLE || o.type === W.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(o, s) : o.type === W.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(o, s);
                n.lastIndex++
            }
            for (i = 0; i < n.data.length; i++)
                (s = n.data[i]).dirty && s.upload()
        }
        ,
        PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e,
            t.data.push(i)),
            i.dirty = !0,
            i
        }
        ,
        PIXI.WebGLGraphics.buildRectangle = function(t, e) {
            var i = t.shape
              , s = i.x
              , n = i.y
              , r = i.width
              , o = i.height;
            if (t.fill) {
                var a = W.Color.hexToRGBArray(t.fillColor)
                  , h = t.fillAlpha
                  , l = a[0] * h
                  , c = a[1] * h
                  , u = a[2] * h
                  , d = e.points
                  , p = e.indices
                  , f = d.length / 6;
                d.push(s, n),
                d.push(l, c, u, h),
                d.push(s + r, n),
                d.push(l, c, u, h),
                d.push(s, n + o),
                d.push(l, c, u, h),
                d.push(s + r, n + o),
                d.push(l, c, u, h),
                p.push(f, f, 1 + f, 2 + f, 3 + f, 3 + f)
            }
            if (t.lineWidth) {
                var g = t.points;
                t.points = [s, n, s + r, n, s + r, n + o, s, n + o, s, n],
                PIXI.WebGLGraphics.buildLine(t, e),
                t.points = g
            }
        }
        ,
        PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
            var i = t.shape
              , s = i.x
              , n = i.y
              , r = i.width
              , o = i.height
              , a = i.radius
              , h = [];
            if (h.push(s, n + a),
            h = (h = (h = (h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, n + o - a, s, n + o, s + a, n + o))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r - a, n + o, s + r, n + o, s + r, n + o - a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r, n + a, s + r, n, s + r - a, n))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a, n, s, n, s, n + a)),
            t.fill) {
                var l = W.Color.hexToRGBArray(t.fillColor)
                  , c = t.fillAlpha
                  , u = l[0] * c
                  , d = l[1] * c
                  , p = l[2] * c
                  , f = e.points
                  , g = e.indices
                  , m = f.length / 6
                  , y = W.EarCut.Triangulate(h, null, 2)
                  , v = 0;
                for (v = 0; v < y.length; v += 3)
                    g.push(y[v] + m),
                    g.push(y[v] + m),
                    g.push(y[v + 1] + m),
                    g.push(y[v + 2] + m),
                    g.push(y[v + 2] + m);
                for (v = 0; v < h.length; v++)
                    f.push(h[v], h[++v], u, d, p, c)
            }
            if (t.lineWidth) {
                var x = t.points;
                t.points = h,
                PIXI.WebGLGraphics.buildLine(t, e),
                t.points = x
            }
        }
        ,
        PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
            var o, a, h, l, c, u, d = [];
            function p(t, e, i) {
                return t + (e - t) * i
            }
            for (var f = 0, g = 0; g <= 20; g++)
                o = p(t, i, f = g / 20),
                a = p(e, s, f),
                h = p(i, n, f),
                l = p(s, r, f),
                c = p(o, h, f),
                u = p(a, l, f),
                d.push(c, u);
            return d
        }
        ,
        PIXI.WebGLGraphics.buildCircle = function(t, e) {
            var i, s, n = t.shape, r = n.x, o = n.y;
            s = t.type === W.CIRCLE ? (i = n.radius,
            n.radius) : (i = n.width,
            n.height);
            var a = 2 * Math.PI / 40
              , h = 0;
            if (t.fill) {
                var l = W.Color.hexToRGBArray(t.fillColor)
                  , c = t.fillAlpha
                  , u = l[0] * c
                  , d = l[1] * c
                  , p = l[2] * c
                  , f = e.points
                  , g = e.indices
                  , m = f.length / 6;
                for (g.push(m),
                h = 0; h < 41; h++)
                    f.push(r, o, u, d, p, c),
                    f.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * s, u, d, p, c),
                    g.push(m++, m++);
                g.push(m - 1)
            }
            if (t.lineWidth) {
                var y = t.points;
                for (t.points = [],
                h = 0; h < 41; h++)
                    t.points.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * s);
                PIXI.WebGLGraphics.buildLine(t, e),
                t.points = y
            }
        }
        ,
        PIXI.WebGLGraphics.buildLine = function(t, e) {
            var i = 0
              , s = t.points;
            if (0 !== s.length) {
                if (t.lineWidth % 2)
                    for (i = 0; i < s.length; i++)
                        s[i] += .5;
                var n = new PIXI.Point(s[0],s[1])
                  , r = new PIXI.Point(s[s.length - 2],s[s.length - 1]);
                if (n.x === r.x && n.y === r.y) {
                    (s = s.slice()).pop(),
                    s.pop();
                    var o = (r = new PIXI.Point(s[s.length - 2],s[s.length - 1])).x + .5 * (n.x - r.x)
                      , a = r.y + .5 * (n.y - r.y);
                    s.unshift(o, a),
                    s.push(o, a)
                }
                var h, l, c, u, d, p, f, g, m, y, v, x, b, _, w, T, P, C, S, A, E, M, R = e.points, L = e.indices, B = s.length / 2, I = s.length, O = R.length / 6, k = t.lineWidth / 2, F = W.Color.hexToRGBArray(t.lineColor), D = t.lineAlpha, U = F[0] * D, G = F[1] * D, N = F[2] * D;
                for (c = s[0],
                u = s[1],
                d = s[2],
                m = -(u - (p = s[3])),
                y = c - d,
                m /= M = Math.sqrt(m * m + y * y),
                y /= M,
                m *= k,
                y *= k,
                R.push(c - m, u - y, U, G, N, D),
                R.push(c + m, u + y, U, G, N, D),
                i = 1; i < B - 1; i++)
                    c = s[2 * (i - 1)],
                    u = s[2 * (i - 1) + 1],
                    d = s[2 * i],
                    p = s[2 * i + 1],
                    f = s[2 * (i + 1)],
                    g = s[2 * (i + 1) + 1],
                    m = -(u - p),
                    y = c - d,
                    m /= M = Math.sqrt(m * m + y * y),
                    y /= M,
                    m *= k,
                    y *= k,
                    v = -(p - g),
                    x = d - f,
                    v /= M = Math.sqrt(v * v + x * x),
                    x /= M,
                    P = (-m + c) * (-y + p) - (-m + d) * (-y + u),
                    A = (-(v *= k) + f) * (-(x *= k) + p) - (-v + d) * (-x + g),
                    E = (w = -y + u - (-y + p)) * (S = -v + d - (-v + f)) - (C = -x + g - (-x + p)) * (T = -m + d - (-m + c)),
                    Math.abs(E) < .1 ? (E += 10.1,
                    R.push(d - m, p - y, U, G, N, D),
                    R.push(d + m, p + y, U, G, N, D)) : 19600 < ((h = (T * A - S * P) / E) - d) * (h - d) + ((l = (C * P - w * A) / E) - p) + (l - p) ? (b = m - v,
                    _ = y - x,
                    b /= M = Math.sqrt(b * b + _ * _),
                    _ /= M,
                    b *= k,
                    _ *= k,
                    R.push(d - b, p - _),
                    R.push(U, G, N, D),
                    R.push(d + b, p + _),
                    R.push(U, G, N, D),
                    R.push(d - b, p - _),
                    R.push(U, G, N, D),
                    I++) : (R.push(h, l),
                    R.push(U, G, N, D),
                    R.push(d - (h - d), p - (l - p)),
                    R.push(U, G, N, D));
                for (c = s[2 * (B - 2)],
                u = s[2 * (B - 2) + 1],
                d = s[2 * (B - 1)],
                m = -(u - (p = s[2 * (B - 1) + 1])),
                y = c - d,
                m /= M = Math.sqrt(m * m + y * y),
                y /= M,
                m *= k,
                y *= k,
                R.push(d - m, p - y),
                R.push(U, G, N, D),
                R.push(d + m, p + y),
                R.push(U, G, N, D),
                L.push(O),
                i = 0; i < I; i++)
                    L.push(O++);
                L.push(O - 1)
            }
        }
        ,
        PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
            var i = t.points.slice();
            if (!(i.length < 6)) {
                var s = e.indices;
                e.points = i,
                e.alpha = t.fillAlpha,
                e.color = W.Color.hexToRGBArray(t.fillColor);
                for (var n, r, o = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < i.length; c += 2)
                    o = (n = i[c]) < o ? n : o,
                    a = a < n ? n : a,
                    h = (r = i[c + 1]) < h ? r : h,
                    l = l < r ? r : l;
                i.push(o, h, a, h, a, l, o, l);
                var u = i.length / 2;
                for (c = 0; c < u; c++)
                    s.push(c)
            }
        }
        ,
        PIXI.WebGLGraphics.buildPoly = function(t, e) {
            var i = t.points;
            if (!(i.length < 6)) {
                var s = e.points
                  , n = e.indices
                  , r = i.length / 2
                  , o = W.Color.hexToRGBArray(t.fillColor)
                  , a = t.fillAlpha
                  , h = o[0] * a
                  , l = o[1] * a
                  , c = o[2] * a
                  , u = W.EarCut.Triangulate(i, null, 2);
                if (!u)
                    return !1;
                var d = s.length / 6
                  , p = 0;
                for (p = 0; p < u.length; p += 3)
                    n.push(u[p] + d),
                    n.push(u[p] + d),
                    n.push(u[p + 1] + d),
                    n.push(u[p + 2] + d),
                    n.push(u[p + 2] + d);
                for (p = 0; p < r; p++)
                    s.push(i[2 * p], i[2 * p + 1], h, l, c, a);
                return !0
            }
        }
        ,
        PIXI.WebGLGraphics.graphicsDataPool = [],
        PIXI.WebGLGraphicsData = function(t) {
            this.gl = t,
            this.color = [0, 0, 0],
            this.points = [],
            this.indices = [],
            this.buffer = t.createBuffer(),
            this.indexBuffer = t.createBuffer(),
            this.mode = 1,
            this.alpha = 1,
            this.dirty = !0
        }
        ,
        PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [],
            this.indices = []
        }
        ,
        PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new Float32Array(this.points),
            t.bindBuffer(t.ARRAY_BUFFER, this.buffer),
            t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW),
            this.glIndicies = new Uint16Array(this.indices),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW),
            this.dirty = !1
        }
        ,
        PIXI.CanvasGraphics = function() {}
        ,
        PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t),
            t.dirty = !1);
            for (var s = 0; s < t.graphicsData.length; s++) {
                var n = t.graphicsData[s]
                  , r = n.shape
                  , o = n._fillTint
                  , a = n._lineTint;
                if (e.lineWidth = n.lineWidth,
                n.type === W.POLYGON) {
                    e.beginPath();
                    var h = r.points;
                    e.moveTo(h[0], h[1]);
                    for (var l = 1; l < h.length / 2; l++)
                        e.lineTo(h[2 * l], h[2 * l + 1]);
                    r.closed && e.lineTo(h[0], h[1]),
                    h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(),
                    n.fill && (e.globalAlpha = n.fillAlpha * i,
                    e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6),
                    e.fill()),
                    n.lineWidth && (e.globalAlpha = n.lineAlpha * i,
                    e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                    e.stroke())
                } else if (n.type === W.RECTANGLE)
                    !n.fillColor && 0 !== n.fillColor || (e.globalAlpha = n.fillAlpha * i,
                    e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6),
                    e.fillRect(r.x, r.y, r.width, r.height)),
                    n.lineWidth && (e.globalAlpha = n.lineAlpha * i,
                    e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                    e.strokeRect(r.x, r.y, r.width, r.height));
                else if (n.type === W.CIRCLE)
                    e.beginPath(),
                    e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI),
                    e.closePath(),
                    n.fill && (e.globalAlpha = n.fillAlpha * i,
                    e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6),
                    e.fill()),
                    n.lineWidth && (e.globalAlpha = n.lineAlpha * i,
                    e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                    e.stroke());
                else if (n.type === W.ELLIPSE) {
                    var c = 2 * r.width
                      , u = 2 * r.height
                      , d = r.x - c / 2
                      , p = r.y - u / 2;
                    e.beginPath();
                    var f = c / 2 * .5522848
                      , g = u / 2 * .5522848
                      , m = d + c
                      , y = p + u
                      , v = d + c / 2
                      , x = p + u / 2;
                    e.moveTo(d, x),
                    e.bezierCurveTo(d, x - g, v - f, p, v, p),
                    e.bezierCurveTo(v + f, p, m, x - g, m, x),
                    e.bezierCurveTo(m, x + g, v + f, y, v, y),
                    e.bezierCurveTo(v - f, y, d, x + g, d, x),
                    e.closePath(),
                    n.fill && (e.globalAlpha = n.fillAlpha * i,
                    e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6),
                    e.fill()),
                    n.lineWidth && (e.globalAlpha = n.lineAlpha * i,
                    e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                    e.stroke())
                } else if (n.type === W.ROUNDEDRECTANGLE) {
                    var b = r.x
                      , _ = r.y
                      , w = r.width
                      , T = r.height
                      , P = r.radius
                      , C = Math.min(w, T) / 2 | 0;
                    P = C < P ? C : P,
                    e.beginPath(),
                    e.moveTo(b, _ + P),
                    e.lineTo(b, _ + T - P),
                    e.quadraticCurveTo(b, _ + T, b + P, _ + T),
                    e.lineTo(b + w - P, _ + T),
                    e.quadraticCurveTo(b + w, _ + T, b + w, _ + T - P),
                    e.lineTo(b + w, _ + P),
                    e.quadraticCurveTo(b + w, _, b + w - P, _),
                    e.lineTo(b + P, _),
                    e.quadraticCurveTo(b, _, b, _ + P),
                    e.closePath(),
                    !n.fillColor && 0 !== n.fillColor || (e.globalAlpha = n.fillAlpha * i,
                    e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6),
                    e.fill()),
                    n.lineWidth && (e.globalAlpha = n.lineAlpha * i,
                    e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                    e.stroke())
                }
            }
        }
        ,
        PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if (0 !== i) {
                e.beginPath();
                for (var s = 0; s < i; s++) {
                    var n = t.graphicsData[s]
                      , r = n.shape;
                    if (n.type === W.POLYGON) {
                        var o = r.points;
                        e.moveTo(o[0], o[1]);
                        for (var a = 1; a < o.length / 2; a++)
                            e.lineTo(o[2 * a], o[2 * a + 1]);
                        o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                    } else if (n.type === W.RECTANGLE)
                        e.rect(r.x, r.y, r.width, r.height),
                        e.closePath();
                    else if (n.type === W.CIRCLE)
                        e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI),
                        e.closePath();
                    else if (n.type === W.ELLIPSE) {
                        var h = 2 * r.width
                          , l = 2 * r.height
                          , c = r.x - h / 2
                          , u = r.y - l / 2
                          , d = h / 2 * .5522848
                          , p = l / 2 * .5522848
                          , f = c + h
                          , g = u + l
                          , m = c + h / 2
                          , y = u + l / 2;
                        e.moveTo(c, y),
                        e.bezierCurveTo(c, y - p, m - d, u, m, u),
                        e.bezierCurveTo(m + d, u, f, y - p, f, y),
                        e.bezierCurveTo(f, y + p, m + d, g, m, g),
                        e.bezierCurveTo(m - d, g, c, y + p, c, y),
                        e.closePath()
                    } else if (n.type === W.ROUNDEDRECTANGLE) {
                        var v = r.x
                          , x = r.y
                          , b = r.width
                          , _ = r.height
                          , w = r.radius
                          , T = Math.min(b, _) / 2 | 0;
                        w = T < w ? T : w,
                        e.moveTo(v, x + w),
                        e.lineTo(v, x + _ - w),
                        e.quadraticCurveTo(v, x + _, v + w, x + _),
                        e.lineTo(v + b - w, x + _),
                        e.quadraticCurveTo(v + b, x + _, v + b, x + _ - w),
                        e.lineTo(v + b, x + w),
                        e.quadraticCurveTo(v + b, x, v + b - w, x),
                        e.lineTo(v + w, x),
                        e.quadraticCurveTo(v, x, v, x + w),
                        e.closePath()
                    }
                }
            }
        }
        ,
        PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                    var r = t.graphicsData[n]
                      , o = 0 | r.fillColor
                      , a = 0 | r.lineColor;
                    r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255,
                    r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
                }
        }
        ,
        W.GraphicsData = function(t, e, i, s, n, r, o) {
            this.lineWidth = t,
            this.lineColor = e,
            this.lineAlpha = i,
            this._lineTint = e,
            this.fillColor = s,
            this.fillAlpha = n,
            this._fillTint = s,
            this.fill = r,
            this.shape = o,
            this.type = o.type
        }
        ,
        W.GraphicsData.prototype.constructor = W.GraphicsData,
        W.GraphicsData.prototype.clone = function() {
            return new W.GraphicsData(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.fill,this.shape)
        }
        ,
        W.Graphics = function(t, e, i) {
            void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            this.type = W.GRAPHICS,
            this.physicsType = W.SPRITE,
            this.anchor = new W.Point,
            PIXI.DisplayObjectContainer.call(this),
            this.renderable = !0,
            this.fillAlpha = 1,
            this.lineWidth = 0,
            this.lineColor = 0,
            this.graphicsData = [],
            this.tint = 16777215,
            this.blendMode = PIXI.blendModes.NORMAL,
            this.currentPath = null,
            this._webGL = [],
            this.isMask = !1,
            this.boundsPadding = 0,
            this._localBounds = new W.Rectangle(0,0,1,1),
            this.dirty = !0,
            this._boundsDirty = !1,
            this.webGLDirty = !1,
            this.cachedSpriteDirty = !1,
            W.Component.Core.init.call(this, t, e, i, "", null)
        }
        ,
        W.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
        W.Graphics.prototype.constructor = W.Graphics,
        W.Component.Core.install.call(W.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
        W.Graphics.prototype.preUpdatePhysics = W.Component.PhysicsBody.preUpdate,
        W.Graphics.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.Graphics.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.Graphics.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.Graphics.prototype.postUpdate = function() {
            W.Component.PhysicsBody.postUpdate.call(this),
            W.Component.FixedToCamera.postUpdate.call(this),
            this._boundsDirty && (this.updateLocalBounds(),
            this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++)
                this.children[t].postUpdate()
        }
        ,
        W.Graphics.prototype.destroy = function(t) {
            this.clear(),
            W.Component.Destroy.prototype.destroy.call(this, t)
        }
        ,
        W.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var i = new W.Polygon(t);
            if (e) {
                var s = new W.Point(this.game.camera.x - t[0].x,this.game.camera.y - t[0].y)
                  , n = new W.Point(t[1].x - t[0].x,t[1].y - t[0].y)
                  , r = new W.Point(t[1].x - t[2].x,t[1].y - t[2].y).cross(n);
                0 < s.dot(r) && this.drawPolygon(i)
            } else
                this.drawPolygon(i)
        }
        ,
        W.Graphics.prototype.drawTriangles = function(t, e, i) {
            void 0 === i && (i = !1);
            var s, n = new W.Point, r = new W.Point, o = new W.Point, a = [];
            if (e)
                if (t[0]instanceof W.Point)
                    for (s = 0; s < e.length / 3; s++)
                        a.push(t[e[3 * s]]),
                        a.push(t[e[3 * s + 1]]),
                        a.push(t[e[3 * s + 2]]),
                        3 === a.length && (this.drawTriangle(a, i),
                        a = []);
                else
                    for (s = 0; s < e.length; s++)
                        n.x = t[2 * e[s]],
                        n.y = t[2 * e[s] + 1],
                        a.push(n.copyTo({})),
                        3 === a.length && (this.drawTriangle(a, i),
                        a = []);
            else if (t[0]instanceof W.Point)
                for (s = 0; s < t.length / 3; s++)
                    this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], i);
            else
                for (s = 0; s < t.length / 6; s++)
                    n.x = t[6 * s + 0],
                    n.y = t[6 * s + 1],
                    r.x = t[6 * s + 2],
                    r.y = t[6 * s + 3],
                    o.x = t[6 * s + 4],
                    o.y = t[6 * s + 5],
                    this.drawTriangle([n, r, o], i)
        }
        ,
        W.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0,
            this.lineColor = e || 0,
            this.lineAlpha = void 0 === i ? 1 : i,
            this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new W.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth,
            this.currentPath.lineColor = this.lineColor,
            this.currentPath.lineAlpha = this.lineAlpha)),
            this
        }
        ,
        W.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new W.Polygon([t, e])),
            this
        }
        ,
        W.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0),
            this.currentPath.shape.points.push(t, e),
            this.dirty = !0,
            this._boundsDirty = !0,
            this
        }
        ,
        W.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var n, r, o = this.currentPath.shape.points;
            0 === o.length && this.moveTo(0, 0);
            for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c)
                n = a + (t - a) * (l = c / 20),
                r = h + (e - h) * l,
                o.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
            return this.dirty = !0,
            this._boundsDirty = !0,
            this
        }
        ,
        W.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var o, a, h, l, c, u = this.currentPath.shape.points, d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g)
                h = (a = (o = 1 - (f = g / 20)) * o) * o,
                c = (l = f * f) * f,
                u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * n, h * p + 3 * a * f * e + 3 * o * l * s + c * r);
            return this.dirty = !0,
            this._boundsDirty = !0,
            this
        }
        ,
        W.Graphics.prototype.arcTo = function(t, e, i, s, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var r = this.currentPath.shape.points
              , o = r[r.length - 2]
              , a = r[r.length - 1] - e
              , h = o - t
              , l = s - e
              , c = i - t
              , u = Math.abs(a * c - h * l);
            if (u < 1e-8 || 0 === n)
                r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
            else {
                var d = a * a + h * h
                  , p = l * l + c * c
                  , f = a * l + h * c
                  , g = n * Math.sqrt(d) / u
                  , m = n * Math.sqrt(p) / u
                  , y = g * f / d
                  , v = m * f / p
                  , x = g * c + m * h
                  , b = g * l + m * a
                  , _ = h * (m + y)
                  , w = a * (m + y)
                  , T = c * (g + v)
                  , P = l * (g + v)
                  , C = Math.atan2(w - b, _ - x)
                  , S = Math.atan2(P - b, T - x);
                this.arc(x + t, b + e, n, C, S, c * a < h * l)
            }
            return this.dirty = !0,
            this._boundsDirty = !0,
            this
        }
        ,
        W.Graphics.prototype.arc = function(t, e, i, s, n, r, o) {
            if (s === n)
                return this;
            void 0 === r && (r = !1),
            void 0 === o && (o = 40),
            !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
            var a = r ? -1 * (s - n) : n - s
              , h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
            if (0 == a)
                return this;
            var l = t + Math.cos(s) * i
              , c = e + Math.sin(s) * i;
            r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
            for (var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                var x = d + s + p * (v + y * v)
                  , b = Math.cos(x)
                  , _ = -Math.sin(x);
                u.push((f * b + g * _) * i + t, (f * -_ + g * b) * i + e)
            }
            return this.dirty = !0,
            this._boundsDirty = !0,
            this
        }
        ,
        W.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0,
            this.fillColor = t || 0,
            this.fillAlpha = void 0 === e ? 1 : e,
            this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling,
            this.currentPath.fillColor = this.fillColor,
            this.currentPath.fillAlpha = this.fillAlpha),
            this
        }
        ,
        W.Graphics.prototype.endFill = function() {
            return this.filling = !1,
            this.fillColor = null,
            this.fillAlpha = 1,
            this
        }
        ,
        W.Graphics.prototype.drawRect = function(t, e, i, s) {
            return this.drawShape(new W.Rectangle(t,e,i,s)),
            this
        }
        ,
        W.Graphics.prototype.drawRoundedRect = function(t, e, i, s, n) {
            return this.drawShape(new W.RoundedRectangle(t,e,i,s,n)),
            this
        }
        ,
        W.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new W.Circle(t,e,i)),
            this
        }
        ,
        W.Graphics.prototype.drawEllipse = function(t, e, i, s) {
            return this.drawShape(new W.Ellipse(t,e,i,s)),
            this
        }
        ,
        W.Graphics.prototype.drawPolygon = function(t) {
            t instanceof W.Polygon && (t = t.points);
            var e = t;
            if (!Array.isArray(e)) {
                e = new Array(arguments.length);
                for (var i = 0; i < e.length; ++i)
                    e[i] = arguments[i]
            }
            return this.drawShape(new W.Polygon(e)),
            this
        }
        ,
        W.Graphics.prototype.clear = function() {
            return this.lineWidth = 0,
            this.filling = !1,
            this.dirty = !0,
            this._boundsDirty = !0,
            this.clearDirty = !0,
            this.graphicsData = [],
            this.updateLocalBounds(),
            this
        }
        ,
        W.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1),
            void 0 === e && (e = PIXI.scaleModes.DEFAULT),
            void 0 === i && (i = 0);
            var s = this.getBounds();
            s.width += i,
            s.height += i;
            var n = new PIXI.CanvasBuffer(s.width * t,s.height * t)
              , r = PIXI.Texture.fromCanvas(n.canvas, e);
            return r.baseTexture.resolution = t,
            n.context.scale(t, t),
            n.context.translate(-s.x, -s.y),
            PIXI.CanvasGraphics.renderGraphics(this, n.context),
            r
        }
        ,
        W.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap)
                    return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(),
                    this.updateCachedSpriteTexture(),
                    this.cachedSpriteDirty = !1,
                    this.dirty = !1),
                    this._cachedSprite.worldAlpha = this.worldAlpha,
                    void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(),
                t.blendModeManager.setBlendMode(this.blendMode),
                this._mask && t.maskManager.pushMask(this._mask, t),
                this._filters && t.filterManager.pushFilter(this._filterBlock),
                this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0,
                this.webGLDirty = !1),
                PIXI.WebGLGraphics.renderGraphics(this, t),
                this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++)
                        this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(),
                this._mask && t.maskManager.popMask(this.mask, t),
                t.drawCount++,
                t.spriteBatch.start()
            }
        }
        ,
        W.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0,
                this._prevTint = this.tint),
                this._cacheAsBitmap)
                    return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(),
                    this.updateCachedSpriteTexture(),
                    this.cachedSpriteDirty = !1,
                    this.dirty = !1),
                    this._cachedSprite.alpha = this.alpha,
                    void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context
                  , i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]),
                this._mask && t.maskManager.pushMask(this._mask, t);
                var s = t.resolution
                  , n = i.tx * t.resolution + t.shakeX
                  , r = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r),
                PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var o = 0; o < this.children.length; o++)
                    this.children[o]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }
        ,
        W.Graphics.prototype.getBounds = function(t) {
            if (this._currentBounds)
                return this._currentBounds;
            if (!this.renderable)
                return W.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(),
            this.webGLDirty = !0,
            this.cachedSpriteDirty = !0,
            this.dirty = !1);
            var e = this._localBounds
              , i = e.x
              , s = e.width + e.x
              , n = e.y
              , r = e.height + e.y
              , o = t || this.worldTransform
              , a = o.a
              , h = o.b
              , l = o.c
              , c = o.d
              , u = o.tx
              , d = o.ty
              , p = a * s + l * r + u
              , f = c * r + h * s + d
              , g = a * i + l * r + u
              , m = c * r + h * i + d
              , y = a * i + l * n + u
              , v = c * n + h * i + d
              , x = a * s + l * n + u
              , b = c * n + h * s + d
              , _ = p
              , w = f
              , T = p
              , P = f;
            return T = x < (T = y < (T = g < T ? g : T) ? y : T) ? x : T,
            P = b < (P = v < (P = m < P ? m : P) ? v : P) ? b : P,
            _ = (_ = (_ = _ < g ? g : _) < y ? y : _) < x ? x : _,
            w = (w = (w = w < m ? m : w) < v ? v : w) < b ? b : w,
            this._bounds.x = T,
            this._bounds.width = _ - T,
            this._bounds.y = P,
            this._bounds.height = w - P,
            this._currentBounds = this._bounds,
            this._currentBounds
        }
        ,
        W.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = W.identityMatrix;
            for (var e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t,
            e = 0; e < this.children.length; e++)
                this.children[e].updateTransform();
            return i
        }
        ,
        W.Graphics.prototype.containsPoint = function(t, e) {
            void 0 === e && (e = new W.Point),
            this.worldTransform.applyInverse(t, e);
            for (var i = this.graphicsData, s = 0; s < i.length; s++) {
                var n = i[s];
                if (n.fill && (n.shape && n.shape.contains(e.x, e.y)))
                    return !0
            }
            return !1
        }
        ,
        W.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0
              , e = -1 / 0
              , i = 1 / 0
              , s = -1 / 0;
            if (this.graphicsData.length)
                for (var n, r, o, a, h, l, c = 0; c < this.graphicsData.length; c++) {
                    var u = this.graphicsData[c]
                      , d = u.type
                      , p = u.lineWidth;
                    if (n = u.shape,
                    d === W.RECTANGLE || d === W.ROUNDEDRECTANGLE)
                        o = n.x - p / 2,
                        a = n.y - p / 2,
                        t = o < t ? o : t,
                        e = e < o + (h = n.width + p) ? o + h : e,
                        i = a < i ? a : i,
                        s = s < a + (l = n.height + p) ? a + l : s;
                    else if (d === W.CIRCLE)
                        o = n.x,
                        a = n.y,
                        t = o - (h = n.radius + p / 2) < t ? o - h : t,
                        e = e < o + h ? o + h : e,
                        i = a - (l = n.radius + p / 2) < i ? a - l : i,
                        s = s < a + l ? a + l : s;
                    else if (d === W.ELLIPSE)
                        o = n.x,
                        a = n.y,
                        t = o - (h = n.width + p / 2) < t ? o - h : t,
                        e = e < o + h ? o + h : e,
                        i = a - (l = n.height + p / 2) < i ? a - l : i,
                        s = s < a + l ? a + l : s;
                    else {
                        r = n.points;
                        for (var f = 0; f < r.length; f++)
                            r[f]instanceof W.Point ? (o = r[f].x,
                            a = r[f].y) : (o = r[f],
                            a = r[f + 1],
                            f < r.length - 1 && f++),
                            t = o - p < t ? o - p : t,
                            e = e < o + p ? o + p : e,
                            i = a - p < i ? a - p : i,
                            s = s < a + p ? a + p : s
                    }
                }
            else
                s = i = e = t = 0;
            var g = this.boundsPadding;
            this._localBounds.x = t - g,
            this._localBounds.width = e - t + 2 * g,
            this._localBounds.y = i - g,
            this._localBounds.height = s - i + 2 * g
        }
        ,
        W.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite)
                this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width,t.height)
                  , i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i),
                this._cachedSprite.buffer = e,
                this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width,
            this._cachedSprite.anchor.y = -t.y / t.height,
            this._cachedSprite.buffer.context.translate(-t.x, -t.y),
            this.worldAlpha = 1,
            PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context),
            this._cachedSprite.alpha = this.alpha
        }
        ,
        W.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite
              , e = t.texture
              , i = t.buffer.canvas;
            e.baseTexture.width = i.width,
            e.baseTexture.height = i.height,
            e.crop.width = e.frame.width = i.width,
            e.crop.height = e.frame.height = i.height,
            t._width = i.width,
            t._height = i.height,
            e.baseTexture.dirty()
        }
        ,
        W.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0),
            this._cachedSprite = null
        }
        ,
        W.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(),
            this.currentPath = null,
            t instanceof W.Polygon && (t = t.clone()).flatten();
            var e = new W.GraphicsData(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.filling,t);
            return this.graphicsData.push(e),
            e.type === W.POLYGON && (e.shape.closed = this.filling,
            this.currentPath = e),
            this.dirty = !0,
            this._boundsDirty = !0,
            e
        }
        ,
        Object.defineProperty(W.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t,
                this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(),
                this.dirty = !0,
                this.webGLDirty = !0
            }
        }),
        W.RenderTexture = function(t, e, i, s, n, r, o, a) {
            if (void 0 === e && (e = 100),
            void 0 === i && (i = 100),
            void 0 === s && (s = ""),
            void 0 === n && (n = W.scaleModes.DEFAULT),
            void 0 === r && (r = 1),
            void 0 === o && (o = PIXI.defaultRenderer),
            void 0 === a && (a = 0),
            this.game = t,
            this.key = s,
            this.type = W.RENDERTEXTURE,
            this._tempMatrix = new W.Matrix,
            this.width = e,
            this.height = i,
            this.resolution = r,
            this.frame = new W.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution),
            this.crop = this.frame.clone(),
            this.baseTexture = new PIXI.BaseTexture,
            this.baseTexture.width = this.width * this.resolution,
            this.baseTexture.height = this.height * this.resolution,
            this.baseTexture._glTextures = [],
            this.baseTexture.resolution = this.resolution,
            this.baseTexture.scaleMode = n,
            this.baseTexture.hasLoaded = !0,
            PIXI.Texture.call(this, this.baseTexture, this.frame.clone()),
            this.renderer = o,
            this.renderer.type === W.WEBGL) {
                var h = this.renderer.gl;
                this.baseTexture.textureIndex = a,
                this.baseTexture._dirty[h.id] = !1,
                this.textureBuffer = new PIXI.FilterTexture(h,this.width,this.height,this.baseTexture.scaleMode,a),
                this.baseTexture._glTextures[h.id] = this.textureBuffer.texture,
                this.projection = new W.Point(.5 * this.width,.5 * -this.height)
            } else
                this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution,this.height * this.resolution),
                this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0,
            this.tempMatrix = new W.Matrix,
            this._updateUvs()
        }
        ,
        W.RenderTexture.prototype = Object.create(PIXI.Texture.prototype),
        W.RenderTexture.prototype.constructor = W.RenderTexture,
        W.RenderTexture.prototype.renderXY = function(t, e, i, s) {
            t.updateTransform(),
            this._tempMatrix.copyFrom(t.worldTransform),
            this._tempMatrix.tx = e,
            this._tempMatrix.ty = i,
            this.renderer.type === W.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
        }
        ,
        W.RenderTexture.prototype.renderRawXY = function(t, e, i, s) {
            this._tempMatrix.identity().translate(e, i),
            this.renderer.type === W.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
        }
        ,
        W.RenderTexture.prototype.render = function(t, e, i) {
            null == e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e),
            this.renderer.type === W.WEBGL ? this._renderWebGL(t, this._tempMatrix, i) : this._renderCanvas(t, this._tempMatrix, i)
        }
        ,
        W.RenderTexture.prototype.resize = function(t, e, i) {
            t === this.width && e === this.height || (this.valid = 0 < t && 0 < e,
            this.width = t,
            this.height = e,
            this.frame.width = this.crop.width = t * this.resolution,
            this.frame.height = this.crop.height = e * this.resolution,
            i && (this.baseTexture.width = this.width * this.resolution,
            this.baseTexture.height = this.height * this.resolution),
            this.renderer.type === W.WEBGL && (this.projection.x = this.width / 2,
            this.projection.y = -this.height / 2),
            this.valid && this.textureBuffer.resize(this.width, this.height))
        }
        ,
        W.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === W.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            this.textureBuffer.clear())
        }
        ,
        W.RenderTexture.prototype._renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(),
                s.translate(0, 2 * this.projection.y),
                e && s.append(e),
                s.scale(1, -1);
                for (var n = 0; n < t.children.length; n++)
                    t.children[n].updateTransform();
                var r = this.renderer.gl;
                r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution),
                r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                i && this.textureBuffer.clear(),
                this.renderer.spriteBatch.dirty = !0,
                this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e),
                this.renderer.spriteBatch.dirty = !0,
                r.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        ,
        W.RenderTexture.prototype._renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(),
                e && s.append(e);
                for (var n = 0; n < t.children.length; n++)
                    t.children[n].updateTransform();
                i && this.textureBuffer.clear();
                var r = this.renderer.resolution;
                this.renderer.resolution = this.resolution,
                this.renderer.renderDisplayObject(t, this.textureBuffer.context, e),
                this.renderer.resolution = r
            }
        }
        ,
        W.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(),
            t
        }
        ,
        W.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }
        ,
        W.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type !== W.WEBGL)
                return this.textureBuffer.canvas;
            var t = this.renderer.gl
              , e = this.textureBuffer.width
              , i = this.textureBuffer.height
              , s = new Uint8Array(4 * e * i);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, s),
            t.bindFramebuffer(t.FRAMEBUFFER, null);
            var n = new PIXI.CanvasBuffer(e,i)
              , r = n.context.getImageData(0, 0, e, i);
            return r.data.set(s),
            n.context.putImageData(r, 0, 0),
            n.canvas
        }
        ,
        W.Text = function(t, e, i, s, n) {
            e = e || 0,
            i = i || 0,
            s = null == s ? "" : s.toString(),
            n = W.Utils.extend({}, n),
            this.type = W.TEXT,
            this.physicsType = W.SPRITE,
            this.padding = new W.Point,
            this.textBounds = null,
            this.canvas = W.CanvasPool.create(this),
            this.context = this.canvas.getContext("2d"),
            this.colors = [],
            this.strokeColors = [],
            this.fontStyles = [],
            this.fontWeights = [],
            this.autoRound = !1,
            this.useAdvancedWrap = !1,
            this.splitRegExp = /(?:\r\n|\r|\n)/,
            this.characterLimitSize = -1,
            this.characterLimitSuffix = "",
            this._res = t.renderer.resolution,
            this._text = s,
            this._fontComponents = null,
            this._lineSpacing = 0,
            this._charCount = 0,
            this._width = 0,
            this._height = 0,
            W.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)),
            this.setStyle(n),
            "" !== s && this.updateText()
        }
        ,
        W.Text.prototype = Object.create(W.Sprite.prototype),
        W.Text.prototype.constructor = W.Text,
        W.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.Text.prototype.update = function() {}
        ,
        W.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0),
            W.Component.Destroy.prototype.destroy.call(this, t)
        }
        ,
        W.Text.prototype.setShadow = function(t, e, i, s, n, r) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            void 0 === i && (i = "rgba(0, 0, 0, 1)"),
            void 0 === s && (s = 0),
            void 0 === n && (n = !0),
            void 0 === r && (r = !0),
            this.style.shadowOffsetX = t,
            this.style.shadowOffsetY = e,
            this.style.shadowColor = i,
            this.style.shadowBlur = s,
            this.style.shadowStroke = n,
            this.style.shadowFill = r,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1);
            var i = Object.assign({}, t);
            i.font = t.font || "bold 20pt Arial",
            i.backgroundColor = t.backgroundColor || null,
            i.fill = t.fill || "black",
            i.align = t.align || "left",
            i.boundsAlignH = t.boundsAlignH || "left",
            i.boundsAlignV = t.boundsAlignV || "top",
            i.stroke = t.stroke || "black",
            i.strokeThickness = t.strokeThickness || 0,
            i.wordWrap = t.wordWrap || !1,
            i.wordWrapWidth = t.wordWrapWidth || 100,
            i.maxLines = t.maxLines || 0,
            i.shadowOffsetX = t.shadowOffsetX || 0,
            i.shadowOffsetY = t.shadowOffsetY || 0,
            i.shadowColor = t.shadowColor || "rgba(0,0,0,0)",
            i.shadowBlur = t.shadowBlur || 0,
            i.tabs = t.tabs || 0;
            var s = this.fontToComponents(i.font);
            return i.fontStyle && (s.fontStyle = i.fontStyle),
            i.fontVariant && (s.fontVariant = i.fontVariant),
            i.fontWeight && (s.fontWeight = i.fontWeight),
            i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"),
            s.fontSize = i.fontSize),
            this._fontComponents = s,
            i.font = this.componentsToFont(this._fontComponents),
            this.style = i,
            this.dirty = !0,
            e && this.updateText(),
            this
        }
        ,
        W.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res,
            this.context.font = this.style.font;
            var t = this.text;
            -1 < this.characterLimitSize && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix),
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(this.splitRegExp)
              , i = this.style.tabs
              , s = []
              , n = 0
              , r = this.determineFontProperties(this.style.font)
              , o = e.length;
            0 < this.style.maxLines && this.style.maxLines < e.length && (o = this.style.maxLines);
            for (var a = this._charCount = 0; a < o; a++) {
                if (0 === i) {
                    var h = this.style.strokeThickness + this.padding.x;
                    0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width,
                    this.style.wordWrap && (h -= this.context.measureText(" ").width)
                } else {
                    var l = e[a].split(/(?:\t)/);
                    h = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var c = 0, u = 0; u < l.length; u++) {
                            var d = 0;
                            d = 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width),
                            0 < u && (c += i[u - 1]),
                            h = c + d
                        }
                    else
                        for (u = 0; u < l.length; u++) {
                            0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u]).width),
                            h += this.game.math.snapToCeil(h, i) - h
                        }
                }
                s[a] = Math.ceil(h),
                n = Math.max(n, s[a])
            }
            this.canvas.width = n * this._res;
            var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y, m = g * o, y = this._lineSpacing;
            for (y < 0 && Math.abs(y) > g && (y = -g),
            0 !== y && (m += 0 < y ? y * e.length : y * (e.length - 1)),
            this.canvas.height = m * this._res,
            this.context.scale(this._res, this._res),
            navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height),
            this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor,
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)),
            this.context.fillStyle = this.style.fill,
            this.context.font = this.style.font,
            this.context.strokeStyle = this.style.stroke,
            this.context.textBaseline = "alphabetic",
            this.context.lineWidth = this.style.strokeThickness,
            this.context.lineCap = "round",
            this.context.lineJoin = "round",
            a = this._charCount = 0; a < o; a++)
                p = this.style.strokeThickness / 2,
                f = this.style.strokeThickness / 2 + a * g + r.ascent,
                0 < a && (f += y * a),
                "right" === this.style.align ? p += n - s[a] : "center" === this.style.align && (p += (n - s[a]) / 2),
                this.autoRound && (p = Math.round(p),
                f = Math.round(f)),
                0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke),
                0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)),
                this.style.fill && (this.updateShadow(this.style.shadowFill),
                0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
            this.updateTexture(),
            this.dirty = !1
        }
        ,
        W.Text.prototype.renderTabLine = function(t, e, i, s) {
            var n = t.split(/(?:\t)/)
              , r = this.style.tabs
              , o = 0;
            if (Array.isArray(r))
                for (var a = 0, h = 0; h < n.length; h++)
                    0 < h && (a += r[h - 1]),
                    o = e + a,
                    s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
            else
                for (h = 0; h < n.length; h++) {
                    var l = Math.ceil(this.context.measureText(n[h]).width);
                    o = this.game.math.snapToCeil(e, r),
                    s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i),
                    e = o + l
                }
        }
        ,
        W.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX,
            this.context.shadowOffsetY = this.style.shadowOffsetY,
            this.context.shadowColor = this.style.shadowColor,
            this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0,
            this.context.shadowOffsetY = 0,
            this.context.shadowColor = 0,
            this.context.shadowBlur = 0)
        }
        ,
        W.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var s = t[i];
                if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]),
                    this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]),
                    this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]),
                this.updateShadow(this.style.shadowStroke)),
                this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]),
                this.updateShadow(this.style.shadowFill)),
                e += this.context.measureText(s).width,
                this._charCount++
            }
            return Math.ceil(e)
        }
        ,
        W.Text.prototype.updateLine = function(t, e, i) {
            for (var s = 0; s < t.length; s++) {
                var n = t[s];
                if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                    var r = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]),
                    this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]),
                    this.context.font = this.componentsToFont(r)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]),
                this.updateShadow(this.style.shadowStroke),
                this.context.strokeText(n, e, i)),
                this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]),
                this.updateShadow(this.style.shadowFill),
                this.context.fillText(n, e, i)),
                e += this.context.measureText(n).width,
                this._charCount++
            }
        }
        ,
        W.Text.prototype.clearColors = function() {
            return this.colors = [],
            this.strokeColors = [],
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [],
            this.fontWeights = [],
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res,
            this.context.font = this.style.font,
            this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }
        ,
        W.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }
        ,
        W.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
                var a = n[o]
                  , h = "";
                if (a = a.replace(/^ *|\s*$/gi, ""),
                e.measureText(a).width < i)
                    s += a + "\n";
                else {
                    for (var l = i, c = a.split(" "), u = 0; u < c.length; u++) {
                        var d = c[u]
                          , p = d + " "
                          , f = e.measureText(p).width;
                        if (l < f) {
                            if (0 === u) {
                                for (var g = p; g.length && (g = g.slice(0, -1),
                                !((f = e.measureText(g).width) <= l)); )
                                    ;
                                if (!g.length)
                                    throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var m = d.substr(g.length);
                                c[u] = m,
                                h += g
                            }
                            var y = c[u].length ? u : u + 1
                              , v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                            n[o + 1] = v + " " + (n[o + 1] || ""),
                            r = n.length;
                            break
                        }
                        h += p,
                        l -= f
                    }
                    s += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return s = s.replace(/[\s|\n]*$/gi, "")
        }
        ,
        W.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                    var a = this.context.measureText(r[o]).width
                      , h = a + this.context.measureText(" ").width;
                    n < h ? (0 < o && (e += "\n"),
                    e += r[o] + " ",
                    n = this.style.wordWrapWidth - a) : (n -= h,
                    e += r[o] + " ")
                }
                s < i.length - 1 && (e += "\n")
            }
            return e
        }
        ,
        W.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e,
            this.dirty = !0,
            this.parent && this.updateTransform())
        }
        ,
        W.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"),
                {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t),
            {
                font: t
            }
        }
        ,
        W.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e),
            (e = t.fontVariant) && "normal" !== e && i.push(e),
            (e = t.fontWeight) && "normal" !== e && i.push(e),
            (e = t.fontSize) && "medium" !== e && i.push(e),
            (e = t.fontFamily) && i.push(e),
            i.length || i.push(t.font),
            i.join(" ")
        }
        ,
        W.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1),
            this.text = t.toString() || "",
            e ? this.updateText() : this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t))
                return this;
            for (var e = "", i = 0; i < t.length; i++)
                Array.isArray(t[i]) ? (e += t[i].join("\t"),
                i < t.length - 1 && (e += "\n")) : (e += t[i],
                i < t.length - 1 && (e += "\t"));
            return this.text = e,
            this.dirty = !0,
            this
        }
        ,
        W.Text.prototype.setTextBounds = function(t, e, i, s) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, s) : this.textBounds = new W.Rectangle(t,e,i,s),
            this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)),
            this.updateTexture(),
            this
        }
        ,
        W.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture
              , e = this.texture.crop
              , i = this.texture.frame
              , s = this.canvas.width
              , n = this.canvas.height;
            if (t.width = s,
            t.height = n,
            e.width = s,
            e.height = n,
            i.width = s,
            i.height = n,
            this.texture.width = s,
            this.texture.height = n,
            this._width = s,
            this._height = n,
            this.textBounds) {
                var r = this.textBounds.x
                  , o = this.textBounds.y;
                "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2),
                "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2),
                this.pivot.x = -r,
                this.pivot.y = -o
            }
            this.renderable = 0 !== s && 0 !== n,
            this.texture.requiresReTint = !0,
            this.texture.baseTexture.dirty()
        }
        ,
        W.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(),
            this.dirty = !1),
            PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }
        ,
        W.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(),
            this.dirty = !1),
            PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }
        ,
        W.Text.prototype.determineFontProperties = function(t) {
            var e = W.Text.fontPropertiesCache[t];
            if (!e) {
                e = {};
                var i = W.Text.fontPropertiesCanvas
                  , s = W.Text.fontPropertiesContext;
                s.font = t;
                var n = Math.ceil(s.measureText("|Mq").width)
                  , r = Math.ceil(s.measureText("|Mq").width)
                  , o = 2 * r;
                if (r = 1.4 * r | 0,
                i.width = n,
                i.height = o,
                s.fillStyle = "#f00",
                s.fillRect(0, 0, n, o),
                s.font = t,
                s.textBaseline = "alphabetic",
                s.fillStyle = "#000",
                s.fillText("|Mq", 0, r),
                !s.getImageData(0, 0, n, o))
                    return e.ascent = r,
                    e.descent = r + 6,
                    e.fontSize = e.ascent + e.descent,
                    W.Text.fontPropertiesCache[t] = e;
                var a, h, l = s.getImageData(0, 0, n, o).data, c = l.length, u = 4 * n, d = 0, p = !1;
                for (a = 0; a < r; a++) {
                    for (h = 0; h < u; h += 4)
                        if (255 !== l[d + h]) {
                            p = !0;
                            break
                        }
                    if (p)
                        break;
                    d += u
                }
                for (e.ascent = r - a,
                d = c - u,
                p = !1,
                a = o; r < a; a--) {
                    for (h = 0; h < u; h += 4)
                        if (255 !== l[d + h]) {
                            p = !0;
                            break
                        }
                    if (p)
                        break;
                    d -= u
                }
                e.descent = a - r,
                e.descent += 6,
                e.fontSize = e.ascent + e.descent,
                W.Text.fontPropertiesCache[t] = e
            }
            return e
        }
        ,
        W.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(),
            this.dirty = !1),
            PIXI.Sprite.prototype.getBounds.call(this, t)
        }
        ,
        W.Text.prototype.setCharacterLimit = function(t, e) {
            this.characterLimitSuffix = void 0 === e ? "" : e,
            this.characterLimitSize = t,
            this.updateText()
        }
        ,
        Object.defineProperty(W.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "",
                this.dirty = !0,
                this.parent && this.updateTransform())
            }
        }),
        Object.defineProperty(W.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial",
                this._fontComponents = this.fontToComponents(t),
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(),
                /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"),
                this._fontComponents.fontFamily = t,
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof (t = t || "0") && (t += "px"),
                this._fontComponents.fontSize = t,
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal",
                this._fontComponents.fontWeight = t,
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal",
                this._fontComponents.fontStyle = t,
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal",
                this._fontComponents.fontVariant = t,
                this.updateFont(this._fontComponents)
            }
        }),
        Object.defineProperty(W.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                t !== this.style.align && (this.style.align = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t),
                this.dirty = !0,
                this.parent && this.updateTransform())
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t,
                this.dirty = !0)
            }
        }),
        Object.defineProperty(W.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(),
                this.dirty = !1),
                this.scale.x * (this.texture.frame.width / this.resolution)
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width,
                this._width = t
            }
        }),
        Object.defineProperty(W.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(),
                this.dirty = !1),
                this.scale.y * (this.texture.frame.height / this.resolution)
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height,
                this._height = t
            }
        }),
        W.Text.fontPropertiesCache = {},
        W.Text.fontPropertiesCanvas = document.createElement("canvas"),
        W.Text.fontPropertiesContext = W.Text.fontPropertiesCanvas.getContext("2d"),
        W.BitmapText = function(t, e, i, s, n, r, o) {
            e = e || 0,
            i = i || 0,
            s = s || "",
            n = n || "",
            r = r || 32,
            o = o || "left",
            PIXI.DisplayObjectContainer.call(this),
            this.type = W.BITMAPTEXT,
            this.physicsType = W.SPRITE,
            this.textWidth = 0,
            this.textHeight = 0,
            this.anchor = new W.Point,
            this._prevAnchor = new W.Point,
            this._glyphs = [],
            this._maxWidth = 0,
            this._text = n.toString() || "",
            this._data = t.cache.getBitmapFont(s),
            this._font = s,
            this._fontSize = r,
            this._align = o,
            this._tint = 16777215,
            this.updateText(),
            this.dirty = !1,
            W.Component.Core.init.call(this, t, e, i, "", null)
        }
        ,
        W.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
        W.BitmapText.prototype.constructor = W.BitmapText,
        W.Component.Core.install.call(W.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
        W.BitmapText.prototype.preUpdatePhysics = W.Component.PhysicsBody.preUpdate,
        W.BitmapText.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.BitmapText.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.BitmapText.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.BitmapText.prototype.postUpdate = function() {
            W.Component.PhysicsBody.postUpdate.call(this),
            W.Component.FixedToCamera.postUpdate.call(this),
            this.body && this.body.type === W.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }
        ,
        W.BitmapText.prototype.setText = function(t) {
            this.text = t
        }
        ,
        W.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var s = 0, n = 0, r = -1, o = 0, a = null, h = 0 < this._maxWidth ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                var u = c === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(c)))
                    return {
                        width: n,
                        text: i.substr(0, c),
                        end: u,
                        chars: l
                    };
                var d, p = i.charCodeAt(c), f = t.chars[p];
                void 0 === f && (p = 32,
                f = t.chars[p]);
                var g = a && f.kerning[a] ? f.kerning[a] : 0;
                if (/(\s)/.test(i.charAt(c)) && (r = c,
                o = n),
                d = (g + f.texture.width + f.xOffset) * e,
                h && h <= n + d && -1 < r)
                    return {
                        width: o || n,
                        text: i.substr(0, c - (c - r)),
                        end: u,
                        chars: l
                    };
                n += (f.xAdvance + g) * e,
                l.push(s + (f.xOffset + g) * e),
                s += (f.xAdvance + g) * e,
                a = p
            }
            return {
                width: n,
                text: i,
                end: u,
                chars: l
            }
        }
        ,
        W.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i)
                return "";
            for (var s = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), n = 0; n < s.length; n++) {
                for (var r = "", o = s[n], a = 0; a < o.length; a++)
                    r = i.chars[o.charCodeAt(a)] ? r.concat(o[a]) : r.concat(e);
                s[n] = r
            }
            return s.join("\n")
        }
        ,
        W.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text
                  , i = this._fontSize / t.size
                  , s = []
                  , n = 0;
                this.textWidth = 0;
                do {
                    (c = this.scanLine(t, i, e)).y = n,
                    s.push(c),
                    c.width > this.textWidth && (this.textWidth = c.width),
                    n += t.lineHeight * i,
                    e = e.substr(c.text.length + 1)
                } while (!1 === c.end);
                this.textHeight = n;
                for (var r = 0, o = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                    var c = s[l];
                    "right" === this._align ? o = this.textWidth - c.width : "center" === this._align && (o = (this.textWidth - c.width) / 2);
                    for (var u = 0; u < c.text.length; u++) {
                        var d = c.text.charCodeAt(u)
                          , p = t.chars[d];
                        void 0 === p && (d = 32,
                        p = t.chars[d]);
                        var f = this._glyphs[r];
                        f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = c.text[u],
                        this._glyphs.push(f)),
                        f.position.x = c.chars[u] + o - a,
                        f.position.y = c.y + p.yOffset * i - h,
                        f.scale.set(i),
                        f.tint = this.tint,
                        f.texture.requiresReTint = !0,
                        f.cachedTint = 16777215,
                        f.parent || this.addChild(f),
                        r++
                    }
                }
                for (l = r; l < this._glyphs.length; l++)
                    this.removeChild(this._glyphs[l])
            }
        }
        ,
        W.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++)
                this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [],
            this._glyphs = e,
            this.updateText(),
            t - e.length
        }
        ,
        W.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(),
            this.dirty = !1,
            this._prevAnchor.copyFrom(this.anchor)),
            PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
        ,
        Object.defineProperty(W.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t,
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t,
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(),
                this._data = this.game.cache.getBitmapFont(this._font),
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && 0 < t && (this._fontSize = t,
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "",
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t,
                this.updateText())
            }
        }),
        Object.defineProperty(W.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1
            }
        }),
        W.RetroFont = function(t, e, i, s, n, r, o, a, h, l) {
            if (!t.cache.checkImageKey(e))
                return !1;
            null == r && (r = t.cache.getImage(e).width / i),
            this.characterWidth = i,
            this.characterHeight = s,
            this.characterSpacingX = o || 0,
            this.characterSpacingY = a || 0,
            this.characterPerRow = r,
            this.offsetX = h || 0,
            this.offsetY = l || 0,
            this.align = "left",
            this.multiLine = !1,
            this.autoUpperCase = !0,
            this.customSpacingX = 0,
            this.customSpacingY = 0,
            this.fixedWidth = 0,
            this.fontSet = t.cache.getImage(e),
            this._text = "",
            this.grabData = [],
            this.frameData = new W.FrameData;
            for (var c = this.offsetX, u = this.offsetY, d = 0, p = 0; p < n.length; p++) {
                var f = this.frameData.addFrame(new W.Frame(p,c,u,this.characterWidth,this.characterHeight));
                this.grabData[n.charCodeAt(p)] = f.index,
                ++d === this.characterPerRow ? (d = 0,
                c = this.offsetX,
                u += this.characterHeight + this.characterSpacingY) : c += this.characterWidth + this.characterSpacingX
            }
            t.cache.updateFrameData(e, this.frameData),
            this.stamp = new W.Image(t,0,0,e,0),
            W.RenderTexture.call(this, t, 100, 100, "", W.scaleModes.NEAREST),
            this.type = W.RETROFONT
        }
        ,
        W.RetroFont.prototype = Object.create(W.RenderTexture.prototype),
        W.RetroFont.prototype.constructor = W.RetroFont,
        W.RetroFont.ALIGN_LEFT = "left",
        W.RetroFont.ALIGN_RIGHT = "right",
        W.RetroFont.ALIGN_CENTER = "center",
        W.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        W.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        W.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
        W.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
        W.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
        W.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
        W.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
        W.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        W.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
        W.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        W.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
        W.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"),
            this.fixedWidth = t,
            this.align = e
        }
        ,
        W.RetroFont.prototype.setText = function(t, e, i, s, n, r) {
            this.multiLine = e || !1,
            this.customSpacingX = i || 0,
            this.customSpacingY = s || 0,
            this.align = n || "left",
            this.autoUpperCase = !r,
            0 < t.length && (this.text = t)
        }
        ,
        W.RetroFont.prototype.buildRetroFontText = function() {
            var t = 0
              , e = 0;
            if (this.clear(),
            this.multiLine) {
                var i = this._text.split("\n");
                0 < this.fixedWidth ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var s = 0; s < i.length; s++)
                    t = 0,
                    this.align === W.RetroFont.ALIGN_RIGHT ? t = this.width - i[s].length * (this.characterWidth + this.customSpacingX) : this.align === W.RetroFont.ALIGN_CENTER && (t = this.width / 2 - i[s].length * (this.characterWidth + this.customSpacingX) / 2,
                    t += this.customSpacingX / 2),
                    t < 0 && (t = 0),
                    this.pasteLine(i[s], t, e, this.customSpacingX),
                    e += this.characterHeight + this.customSpacingY
            } else
                0 < this.fixedWidth ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0),
                t = 0,
                this.align === W.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === W.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2,
                t += this.customSpacingX / 2),
                t < 0 && (t = 0),
                this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0
        }
        ,
        W.RetroFont.prototype.pasteLine = function(t, e, i, s) {
            for (var n = 0; n < t.length; n++)
                if (" " === t.charAt(n))
                    e += this.characterWidth + s;
                else if (0 <= this.grabData[t.charCodeAt(n)] && (this.stamp.frame = this.grabData[t.charCodeAt(n)],
                this.renderXY(this.stamp, e, i, !1),
                (e += this.characterWidth + s) > this.width))
                    break
        }
        ,
        W.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (0 < this._text.length)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++)
                    e[i].length > t && (t = e[i].length);
            return t
        }
        ,
        W.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var s = this._text[i]
                  , n = s.charCodeAt(0);
                (0 <= this.grabData[n] || !t && "\n" === s) && (e = e.concat(s))
            }
            return e
        }
        ,
        W.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = n.length; r--; )
                    n[r].x += i,
                    n[r].y += s;
                this.buildRetroFontText()
            }
        }
        ,
        Object.defineProperty(W.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e,
                this.removeUnsupportedCharacters(this.multiLine),
                this.buildRetroFontText())
            }
        }),
        Object.defineProperty(W.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t,
                this.buildRetroFontText()
            }
        }),
        W.Rope = function(t, e, i, s, n, r) {
            this.points = [],
            this.points = r,
            this._hasUpdateAnimation = !1,
            this._updateAnimationCallback = null,
            e = e || 0,
            i = i || 0,
            s = s || null,
            n = n || null,
            this.type = W.ROPE,
            this.points = r,
            PIXI.DisplayObjectContainer.call(this),
            this.texture = W.Cache.DEFAULT,
            this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]),
            this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
            this.colors = new Float32Array([1, 1, 1, 1]),
            this.indices = new Uint16Array([0, 1, 2, 3]),
            r && (this.vertices = new Float32Array(4 * r.length),
            this.uvs = new Float32Array(4 * r.length),
            this.colors = new Float32Array(2 * r.length),
            this.indices = new Uint16Array(2 * r.length)),
            this.dirty = !0,
            this.canvasPadding = 0,
            this.drawMode = W.Rope.TRIANGLE_STRIP,
            W.Component.Core.init.call(this, t, e, i, s, n),
            this.refresh()
        }
        ,
        W.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
        W.Rope.prototype.constructor = W.Rope,
        W.Component.Core.install.call(W.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
        W.Rope.prototype.preUpdatePhysics = W.Component.PhysicsBody.preUpdate,
        W.Rope.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.Rope.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.Rope.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.Rope.TRIANGLE_STRIP = 0,
        W.Rope.TRIANGLES = 1,
        W.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }
        ,
        W.Rope.prototype.reset = function(t, e) {
            return W.Component.Reset.prototype.reset.call(this, t, e),
            this
        }
        ,
        W.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs
                  , i = this.indices
                  , s = this.colors;
                this.count -= .2,
                e[0] = 0,
                e[1] = 0,
                e[2] = 0,
                e[3] = 1,
                s[0] = 1,
                s[1] = 1,
                i[0] = 0,
                i[1] = 1;
                for (var n, r, o = t.length, a = 1; a < o; a++)
                    r = a / (o - 1),
                    e[n = 4 * a] = r,
                    e[n + 1] = 0,
                    e[n + 2] = r,
                    e[n + 3] = 1,
                    s[n = 2 * a] = 1,
                    s[n + 1] = 1,
                    i[n = 2 * a] = n,
                    i[n + 1] = n + 1
            }
        }
        ,
        W.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e, i = t[0], s = {
                    x: 0,
                    y: 0
                };
                this.count -= .2;
                for (var n, r, o, a, h = this.vertices, l = t.length, c = 0; c < l; c++)
                    n = t[c],
                    r = 4 * c,
                    e = c < t.length - 1 ? t[c + 1] : n,
                    s.y = -(e.x - i.x),
                    s.x = e.y - i.y,
                    1 < 10 * (1 - c / (l - 1)) && 1,
                    o = Math.sqrt(s.x * s.x + s.y * s.y),
                    a = this.texture.height / 2,
                    s.x /= o,
                    s.y /= o,
                    s.x *= a,
                    s.y *= a,
                    h[r] = n.x + s.x,
                    h[1 + r] = n.y + s.y,
                    h[2 + r] = n.x - s.x,
                    h[3 + r] = n.y - s.y,
                    i = n;
                PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }
        ,
        W.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }
        ,
        W.Rope.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(),
            this._vertexBuffer || this._initWebGL(t),
            t.shaderManager.setShader(t.shaderManager.stripShader),
            this._renderStrip(t),
            t.spriteBatch.start())
        }
        ,
        W.Rope.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(),
            this._indexBuffer = e.createBuffer(),
            this._uvBuffer = e.createBuffer(),
            this._colorBuffer = e.createBuffer(),
            e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }
        ,
        W.Rope.prototype._renderStrip = function(t) {
            var e = t.gl
              , i = t.projection
              , s = t.offset
              , n = t.shaderManager.stripShader
              , r = this.drawMode === W.Rope.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode),
            e.uniformMatrix3fv(n.translationMatrix, !1, this.worldTransform.toArray(!0)),
            e.uniform2f(n.projectionVector, i.x, -i.y),
            e.uniform2f(n.offsetVector, -s.x, -s.y),
            e.uniform1f(n.alpha, this.worldAlpha),
            this.dirty ? (this.dirty = !1,
            e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW),
            e.vertexAttribPointer(n.aVertexPosition, 2, e.FLOAT, !1, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW),
            e.vertexAttribPointer(n.aTextureCoord, 2, e.FLOAT, !1, 0, 0),
            e.activeTexture(e.TEXTURE0),
            this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices),
            e.vertexAttribPointer(n.aVertexPosition, 2, e.FLOAT, !1, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
            e.vertexAttribPointer(n.aTextureCoord, 2, e.FLOAT, !1, 0, 0),
            e.activeTexture(e.TEXTURE0),
            this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)),
            e.drawElements(r, this.indices.length, e.UNSIGNED_SHORT, 0)
        }
        ,
        W.Rope.prototype._renderCanvas = function(t) {
            var e = t.context
              , i = this.worldTransform
              , s = i.tx * t.resolution + t.shakeX
              , n = i.ty * t.resolution + t.shakeY;
            t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | s, 0 | n) : e.setTransform(i.a, i.b, i.c, i.d, s, n),
            this.drawMode === W.Rope.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
        }
        ,
        W.Rope.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices
              , i = this.uvs
              , s = e.length / 2;
            this.count++;
            for (var n = 0; n < s - 2; n++) {
                var r = 2 * n;
                this._renderCanvasDrawTriangle(t, e, i, r, 2 + r, 4 + r)
            }
        }
        ,
        W.Rope.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices
              , i = this.uvs
              , s = this.indices
              , n = s.length;
            this.count++;
            for (var r = 0; r < n; r += 3) {
                var o = 2 * s[r]
                  , a = 2 * s[r + 1]
                  , h = 2 * s[r + 2];
                this._renderCanvasDrawTriangle(t, e, i, o, a, h)
            }
        }
        ,
        W.Rope.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, r) {
            var o = this.texture.baseTexture.source
              , a = this.texture.width
              , h = this.texture.height
              , l = e[s]
              , c = e[n]
              , u = e[r]
              , d = e[s + 1]
              , p = e[n + 1]
              , f = e[r + 1]
              , g = i[s] * a
              , m = i[n] * a
              , y = i[r] * a
              , v = i[s + 1] * h
              , x = i[n + 1] * h
              , b = i[r + 1] * h;
            if (0 < this.canvasPadding) {
                var _ = this.canvasPadding / this.worldTransform.a
                  , w = this.canvasPadding / this.worldTransform.d
                  , T = (l + c + u) / 3
                  , P = (d + p + f) / 3
                  , C = l - T
                  , S = d - P
                  , A = Math.sqrt(C * C + S * S);
                l = T + C / A * (A + _),
                d = P + S / A * (A + w),
                S = p - P,
                c = T + (C = c - T) / (A = Math.sqrt(C * C + S * S)) * (A + _),
                p = P + S / A * (A + w),
                S = f - P,
                u = T + (C = u - T) / (A = Math.sqrt(C * C + S * S)) * (A + _),
                f = P + S / A * (A + w)
            }
            t.save(),
            t.beginPath(),
            t.moveTo(l, d),
            t.lineTo(c, p),
            t.lineTo(u, f),
            t.closePath(),
            t.clip();
            var E = g * x + v * y + m * b - x * y - v * m - g * b
              , M = l * x + v * u + c * b - x * u - v * c - l * b
              , R = g * c + l * y + m * u - c * y - l * m - g * u
              , L = g * x * u + v * c * y + l * m * b - l * x * y - v * m * u - g * c * b
              , B = d * x + v * f + p * b - x * f - v * p - d * b
              , I = g * p + d * y + m * f - p * y - d * m - g * f
              , O = g * x * f + v * p * y + d * m * b - d * x * y - v * m * f - g * p * b;
            t.transform(M / E, B / E, R / E, I / E, L / E, O / E),
            t.drawImage(o, 0, 0),
            t.restore()
        }
        ,
        W.Rope.prototype.renderStripFlat = function(t) {
            var e = this.context
              , i = t.vertices
              , s = i.length / 2;
            this.count++,
            e.beginPath();
            for (var n = 1; n < s - 2; n++) {
                var r = 2 * n
                  , o = i[r]
                  , a = i[2 + r]
                  , h = i[4 + r]
                  , l = i[1 + r]
                  , c = i[3 + r]
                  , u = i[5 + r];
                e.moveTo(o, l),
                e.lineTo(a, c),
                e.lineTo(h, u)
            }
            e.fillStyle = "#FF0000",
            e.fill(),
            e.closePath()
        }
        ,
        W.Rope.prototype.getBounds = function(t) {
            for (var e = t || this.worldTransform, i = e.a, s = e.b, n = e.c, r = e.d, o = e.tx, a = e.ty, h = -1 / 0, l = -1 / 0, c = 1 / 0, u = 1 / 0, d = this.vertices, p = 0; p < d.length; p += 2) {
                var f = d[p]
                  , g = d[p + 1]
                  , m = i * f + n * g + o
                  , y = r * g + s * f + a;
                c = m < c ? m : c,
                u = y < u ? y : u,
                h = h < m ? m : h,
                l = l < y ? y : l
            }
            if (c === -1 / 0 || l === 1 / 0)
                return PIXI.EmptyRectangle;
            var v = this._bounds;
            return v.x = c,
            v.width = h - c,
            v.y = u,
            v.height = l - u,
            this._currentBounds = v
        }
        ,
        Object.defineProperty(W.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                t && "function" == typeof t ? (this._hasUpdateAnimation = !0,
                this._updateAnimation = t) : (this._hasUpdateAnimation = !1,
                this._updateAnimation = null)
            }
        }),
        Object.defineProperty(W.Rope.prototype, "segments", {
            get: function() {
                for (var t, e, i, s, n, r, o, a, h = [], l = 0; l < this.points.length; l++)
                    t = 4 * l,
                    e = this.vertices[t] * this.scale.x,
                    i = this.vertices[1 + t] * this.scale.y,
                    s = this.vertices[4 + t] * this.scale.x,
                    n = this.vertices[3 + t] * this.scale.y,
                    r = W.Math.difference(e, s),
                    o = W.Math.difference(i, n),
                    e += this.world.x,
                    i += this.world.y,
                    a = new W.Rectangle(e,i,r,o),
                    h.push(a);
                return h
            }
        }),
        W.TileSprite = function(t, e, i, s, n, r, o) {
            e = e || 0,
            i = i || 0,
            s = s || 256,
            n = n || 256,
            r = r || null,
            o = o || null;
            var a = t.cache.getImage("__default", !0);
            PIXI.Sprite.call(this, new PIXI.Texture(a.base), s, n),
            this.type = W.TILESPRITE,
            this.physicsType = W.SPRITE,
            this._scroll = new W.Point,
            this.tileScale = new W.Point(1,1),
            this.tileScaleOffset = new W.Point(1,1),
            this.tilePosition = new W.Point,
            this.textureDebug = !1,
            this.canvasBuffer = null,
            this.tilingTexture = null,
            this.tilePattern = null,
            this.refreshTexture = !0,
            this.frameWidth = 0,
            this.frameHeight = 0,
            this._width = s,
            this._height = n,
            W.Component.Core.init.call(this, t, e, i, r, o)
        }
        ,
        W.TileSprite.prototype = Object.create(PIXI.Sprite.prototype),
        W.TileSprite.prototype.constructor = W.TileSprite,
        W.Component.Core.install.call(W.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]),
        W.TileSprite.prototype.preUpdatePhysics = W.Component.PhysicsBody.preUpdate,
        W.TileSprite.prototype.preUpdateLifeSpan = W.Component.LifeSpan.preUpdate,
        W.TileSprite.prototype.preUpdateInWorld = W.Component.InWorld.preUpdate,
        W.TileSprite.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed),
            0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed),
            !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }
        ,
        W.TileSprite.prototype.autoScroll = function(t, e) {
            return this._scroll.set(t, e),
            this
        }
        ,
        W.TileSprite.prototype.stopScroll = function() {
            return this._scroll.set(0, 0),
            this
        }
        ,
        W.TileSprite.prototype.destroy = function(t) {
            W.Component.Destroy.prototype.destroy.call(this, t),
            PIXI.Sprite.prototype.destroy.call(this),
            this.canvasBuffer && (this.canvasBuffer.destroy(),
            this.canvasBuffer = null),
            this.tileScale = null,
            this.tileScaleOffset = null,
            this.tilePosition = null,
            this.tilingTexture && (this.tilingTexture.destroy(!0),
            this.tilingTexture = null)
        }
        ,
        W.TileSprite.prototype.reset = function(t, e) {
            return W.Component.Reset.prototype.reset.call(this, t, e),
            this.tilePosition.x = 0,
            this.tilePosition.y = 0,
            this
        }
        ,
        W.TileSprite.prototype.setTexture = function(t) {
            return this.texture !== t && (this.texture = t,
            this.refreshTexture = !0,
            this.cachedTint = 16777215),
            this
        }
        ,
        W.TileSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(),
                t.maskManager.pushMask(this.mask, t),
                t.spriteBatch.start()),
                this._filters && (t.spriteBatch.flush(),
                t.filterManager.pushFilter(this._filterBlock)),
                this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t),
                    !this.tilingTexture)
                        return;
                    this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex,
                    t.renderer.updateTexture(this.tilingTexture.baseTexture),
                    this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++)
                    this.children[e]._renderWebGL(t);
                var i = !1;
                this._filters && (i = !0,
                t.spriteBatch.stop(),
                t.filterManager.popFilter()),
                this._mask && (i || t.spriteBatch.stop(),
                t.maskManager.popMask(this._mask, t)),
                i && t.spriteBatch.start()
            }
        }
        ,
        W.TileSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t),
                e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform
                  , s = t.resolution
                  , n = i.tx * s + t.shakeX
                  , r = i.ty * s + t.shakeY;
                if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r),
                this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t),
                    !this.tilingTexture)
                        return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var o = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
                var a = this.tilePosition
                  , h = this.tileScale;
                a.x %= this.tilingTexture.baseTexture.width,
                a.y %= this.tilingTexture.baseTexture.height,
                e.scale(h.x, h.y),
                e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height),
                e.fillStyle = this.tilePattern,
                n = -a.x,
                r = -a.y;
                var l = this._width / h.x
                  , c = this._height / h.y;
                t.roundPixels && (n |= 0,
                r |= 0,
                l |= 0,
                c |= 0),
                e.fillRect(n, r, l, c),
                e.scale(1 / h.x, 1 / h.y),
                e.translate(-a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height),
                this._mask && t.maskManager.popMask(t);
                for (var u = 0; u < this.children.length; u++)
                    this.children[u]._renderCanvas(t);
                o !== this.blendMode && (t.currentBlendMode = o,
                e.globalCompositeOperation = PIXI.blendModesCanvas[o])
            }
        }
        ,
        W.TileSprite.prototype.onTextureUpdate = function() {}
        ,
        W.TileSprite.prototype.generateTilingTexture = function(t) {
            if (this.texture.baseTexture.hasLoaded) {
                var e = this.texture
                  , i = e.frame
                  , s = this._frame.sourceSizeW || this._frame.width
                  , n = this._frame.sourceSizeH || this._frame.height
                  , r = 0
                  , o = 0;
                this._frame.trimmed && (r = this._frame.spriteSourceSizeX,
                o = this._frame.spriteSourceSizeY),
                t && (s = W.Math.getNextPowerOfTwo(s),
                n = W.Math.getNextPowerOfTwo(n)),
                this.canvasBuffer ? (this.canvasBuffer.resize(s, n),
                this.tilingTexture.baseTexture.width = s,
                this.tilingTexture.baseTexture.height = n) : (this.canvasBuffer = new PIXI.CanvasBuffer(s,n),
                this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas),
                this.tilingTexture.isTiling = !0),
                this.tilingTexture.needsUpdate = !0,
                this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00",
                this.canvasBuffer.context.strokeRect(0, 0, s, n));
                var a = e.crop.width
                  , h = e.crop.height;
                a === s && h === n || (a = s,
                h = n),
                this.canvasBuffer.context.drawImage(e.baseTexture.source, e.crop.x, e.crop.y, e.crop.width, e.crop.height, r, o, a, h),
                this.tileScaleOffset.x = i.width / s,
                this.tileScaleOffset.y = i.height / n,
                this.refreshTexture = !1,
                this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }
        ,
        W.TileSprite.prototype.getBounds = function() {
            var t = this._width
              , e = this._height
              , i = t * (1 - this.anchor.x)
              , s = t * -this.anchor.x
              , n = e * (1 - this.anchor.y)
              , r = e * -this.anchor.y
              , o = this.worldTransform
              , a = o.a
              , h = o.b
              , l = o.c
              , c = o.d
              , u = o.tx
              , d = o.ty
              , p = a * s + l * r + u
              , f = c * r + h * s + d
              , g = a * i + l * r + u
              , m = c * r + h * i + d
              , y = a * i + l * n + u
              , v = c * n + h * i + d
              , x = a * s + l * n + u
              , b = c * n + h * s + d
              , _ = -1 / 0
              , w = -1 / 0
              , T = 1 / 0
              , P = 1 / 0;
            T = x < (T = y < (T = g < (T = p < T ? p : T) ? g : T) ? y : T) ? x : T,
            P = b < (P = v < (P = m < (P = f < P ? f : P) ? m : P) ? v : P) ? b : P,
            _ = (_ = (_ = (_ = _ < p ? p : _) < g ? g : _) < y ? y : _) < x ? x : _,
            w = (w = (w = (w = w < f ? f : w) < m ? m : w) < v ? v : w) < b ? b : w;
            var C = this._bounds;
            return C.x = T,
            C.width = _ - T,
            C.y = P,
            C.height = w - P,
            this._currentBounds = C
        }
        ,
        Object.defineProperty(W.TileSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }),
        Object.defineProperty(W.TileSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }),
        W.CanvasPool = {
            create: function(t, e, i) {
                var s, n = W.CanvasPool.getFirst();
                if (-1 === n) {
                    var r = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    };
                    W.CanvasPool.pool.push(r),
                    s = r.canvas
                } else
                    W.CanvasPool.pool[n].parent = t,
                    s = W.CanvasPool.pool[n].canvas;
                return void 0 !== e && (s.width = e,
                s.height = i),
                s
            },
            getFirst: function() {
                for (var t = W.CanvasPool.pool, e = 0; e < t.length; e++)
                    if (!t[e].parent)
                        return e;
                return -1
            },
            remove: function(t) {
                for (var e = W.CanvasPool.pool, i = 0; i < e.length; i++)
                    e[i].parent === t && (e[i].parent = null,
                    e[i].canvas.width = 1,
                    e[i].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var e = W.CanvasPool.pool, i = 0; i < e.length; i++)
                    e[i].canvas === t && (e[i].parent = null,
                    e[i].canvas.width = 1,
                    e[i].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = W.CanvasPool.pool, e = 0, i = 0; i < t.length; i++)
                    t[i].parent && e++;
                return e
            },
            getFree: function() {
                for (var t = W.CanvasPool.pool, e = 0, i = 0; i < t.length; i++)
                    t[i].parent || e++;
                return e
            }
        },
        W.CanvasPool.pool = [],
        W.Device = function() {
            this.deviceReadyAt = 0,
            this.initialized = !1,
            this.desktop = !1,
            this.iOS = !1,
            this.iOSVersion = 0,
            this.cocoonJS = !1,
            this.cocoonJSApp = !1,
            this.cordova = !1,
            this.node = !1,
            this.nodeWebkit = !1,
            this.electron = !1,
            this.ejecta = !1,
            this.crosswalk = !1,
            this.android = !1,
            this.chromeOS = !1,
            this.linux = !1,
            this.macOS = !1,
            this.windows = !1,
            this.windowsPhone = !1,
            this.canvas = !1,
            this.canvasBitBltShift = null,
            this.canHandleAlpha = !1,
            this.canUseMultiply = !1,
            this.webGL = !1,
            this.file = !1,
            this.fileSystem = !1,
            this.localStorage = !1,
            this.worker = !1,
            this.css3D = !1,
            this.pointerLock = !1,
            this.typedArray = !1,
            this.vibration = !1,
            this.getUserMedia = !0,
            this.quirksMode = !1,
            this.touch = !1,
            this.mspointer = !1,
            this.wheelEvent = null,
            this.arora = !1,
            this.chrome = !1,
            this.chromeVersion = 0,
            this.epiphany = !1,
            this.firefox = !1,
            this.firefoxVersion = 0,
            this.ie = !1,
            this.ieVersion = 0,
            this.trident = !1,
            this.tridentVersion = 0,
            this.edge = !1,
            this.mobileSafari = !1,
            this.midori = !1,
            this.opera = !1,
            this.safari = !1,
            this.safariVersion = 0,
            this.webApp = !1,
            this.silk = !1,
            this.audioData = !1,
            this.webAudio = !1,
            this.ogg = !1,
            this.opus = !1,
            this.mp3 = !1,
            this.wav = !1,
            this.m4a = !1,
            this.webm = !1,
            this.dolby = !1,
            this.oggVideo = !1,
            this.h264Video = !1,
            this.mp4Video = !1,
            this.webmVideo = !1,
            this.vp9Video = !1,
            this.hlsVideo = !1,
            this.iPhone = !1,
            this.iPhone4 = !1,
            this.iPad = !1,
            this.pixelRatio = 0,
            this.littleEndian = !1,
            this.LITTLE_ENDIAN = !1,
            this.support32bit = !1,
            this.fullscreen = !1,
            this.requestFullscreen = "",
            this.cancelFullscreen = "",
            this.fullscreenKeyboard = !1
        }
        ,
        W.Device = new W.Device,
        W.Device.onInitialized = new W.Signal,
        W.Device.whenReady = function(t, e, i) {
            var s = this._readyCheck;
            if (this.deviceReadyAt || !s)
                t.call(e, this);
            else if (s._monitor || i)
                s._queue = s._queue || [],
                s._queue.push([t, e]);
            else {
                s._monitor = s.bind(this),
                s._queue = s._queue || [],
                s._queue.push([t, e]);
                var n = void 0 !== window.cordova
                  , r = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1),
                window.addEventListener("load", s._monitor, !1))
            }
        }
        ,
        W.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    var e;
                    for (this.deviceReadyAt = Date.now(),
                    document.removeEventListener("deviceready", t._monitor),
                    document.removeEventListener("DOMContentLoaded", t._monitor),
                    window.removeEventListener("load", t._monitor),
                    this._initialize(),
                    this.initialized = !0,
                    this.onInitialized.dispatch(this); e = t._queue.shift(); ) {
                        var i = e[0]
                          , s = e[1];
                        i.call(s, this)
                    }
                    this._readyCheck = null,
                    this._initialize = null,
                    this.onInitialized = null
                }
            } else
                window.setTimeout(t._monitor, 20)
        }
        ,
        W.Device._initialize = function() {
            var n = this;
            !function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? n.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? n.kindle = !0 : /Android/.test(t) ? n.android = !0 : /CrOS/.test(t) ? n.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (n.iOS = !0,
                navigator.appVersion.match(/OS (\d+)/),
                n.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? n.linux = !0 : /Mac OS/.test(t) ? n.macOS = !0 : /Windows/.test(t) && (n.windows = !0),
                (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (n.android = !1,
                n.iOS = !1,
                n.macOS = !1,
                n.windows = !0,
                n.windowsPhone = !0);
                var e = /Silk/.test(t);
                (n.windows || n.macOS || n.linux && !e || n.chromeOS) && (n.desktop = !0),
                (n.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (n.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? n.arora = !0 : /Edge\/\d+/.test(t) ? n.edge = !0 : /Chrome\/(\d+)/.test(t) && !n.windowsPhone ? (n.chrome = !0,
                n.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? n.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (n.firefox = !0,
                n.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && n.iOS ? n.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (n.ie = !0,
                n.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? n.midori = !0 : /Opera/.test(t) ? n.opera = !0 : /Safari\/(\d+)/.test(t) && !n.windowsPhone ? (n.safari = !0,
                /Version\/(\d+)\./.test(t) && (n.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (n.ie = !0,
                n.trident = !0,
                n.tridentVersion = parseInt(RegExp.$1, 10),
                n.ieVersion = parseInt(RegExp.$3, 10)),
                /Silk/.test(t) && (n.silk = !0),
                navigator.standalone && (n.webApp = !0),
                void 0 !== window.cordova && (n.cordova = !0),
                "undefined" != typeof process && "undefined" != typeof require && (n.node = !0),
                n.node && "object" == typeof process.versions && (n.nodeWebkit = !!process.versions["node-webkit"],
                n.electron = !!process.versions.electron),
                navigator.isCocoonJS && (n.cocoonJS = !0),
                n.cocoonJS)
                    try {
                        n.cocoonJSApp = "undefined" != typeof CocoonJS
                    } catch (t) {
                        n.cocoonJSApp = !1
                    }
                void 0 !== window.ejecta && (n.ejecta = !0),
                /Crosswalk/.test(t) && (n.crosswalk = !0)
            }(),
            function() {
                n.audioData = !!window.Audio,
                n.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (!!t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (n.ogg = !0),
                    (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (n.opus = !0),
                    t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (n.mp3 = !0),
                    t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (n.wav = !0),
                    (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (n.m4a = !0),
                    t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (n.webm = !0),
                    "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (n.edge)
                            n.dolby = !0;
                        else if (n.safari && 9 <= n.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                            var e = parseInt(RegExp.$1, 10)
                              , i = parseInt(RegExp.$2, 10);
                            (10 === e && 11 <= i || 10 < e) && (n.dolby = !0)
                        }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    !!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (n.oggVideo = !0),
                    t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.h264Video = !0,
                    n.mp4Video = !0),
                    t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (n.webmVideo = !0),
                    t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (n.vp9Video = !0),
                    t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"), i = {
                    webkitTransform: "-webkit-transform",
                    OTransform: "-o-transform",
                    msTransform: "-ms-transform",
                    MozTransform: "-moz-transform",
                    transform: "transform"
                };
                for (var s in document.body.insertBefore(e, null),
                i)
                    void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)",
                    t = window.getComputedStyle(e).getPropertyValue(i[s]));
                document.body.removeChild(e),
                n.css3D = void 0 !== t && 0 < t.length && "none" !== t
            }(),
            n.pixelRatio = window.devicePixelRatio || 1,
            n.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"),
            n.iPhone4 = 2 === n.pixelRatio && n.iPhone,
            n.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"),
            "undefined" != typeof Int8Array ? n.typedArray = !0 : n.typedArray = !1,
            "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (n.littleEndian = function() {
                var t = new ArrayBuffer(4)
                  , e = new Uint8Array(t)
                  , i = new Uint32Array(t);
                return e[0] = 161,
                e[1] = 178,
                e[2] = 195,
                e[3] = 212,
                3569595041 === i[0] || 2712847316 !== i[0] && null
            }(),
            n.LITTLE_ENDIAN = n.littleEndian),
            n.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== n.littleEndian && function() {
                if (void 0 === Uint8ClampedArray)
                    return !1;
                var t = W.CanvasPool.create(this, 1, 1).getContext("2d");
                if (!t)
                    return !1;
                var e = t.createImageData(1, 1);
                return W.CanvasPool.remove(this),
                e.data instanceof Uint8ClampedArray
            }(),
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate,
            navigator.vibrate && (n.vibration = !0),
            function() {
                n.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS;
                try {
                    n.localStorage = !!localStorage.getItem
                } catch (t) {
                    n.localStorage = !1
                }
                n.file = !!(window.File && window.FileReader && window.FileList && window.Blob),
                n.fileSystem = !!window.requestFileSystem,
                n.webGL = function() {
                    try {
                        var t = document.createElement("canvas");
                        return t.screencanvas = !1,
                        !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                    } catch (t) {
                        return !1
                    }
                }(),
                n.webGL = !!n.webGL,
                n.worker = !!window.Worker,
                n.pointerLock = "pointerLockElement"in document || "mozPointerLockElement"in document || "webkitPointerLockElement"in document,
                n.quirksMode = "CSS1Compat" !== document.compatMode,
                navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia,
                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL,
                n.getUserMedia = n.getUserMedia && !!navigator.getUserMedia && !!window.URL,
                n.firefox && n.firefoxVersion < 21 && (n.getUserMedia = !1),
                !n.iOS && (n.ie || n.firefox || n.chrome) && (n.canvasBitBltShift = !0),
                (n.safari || n.mobileSafari) && (n.canvasBitBltShift = !1)
            }(),
            function() {
                var t = W.CanvasPool.create(this, 6, 1)
                  , e = t.getContext("2d");
                e.fillStyle = "rgba(10, 20, 30, 0.5)",
                e.fillRect(0, 0, 1, 1);
                var i = e.getImageData(0, 0, 1, 1);
                if (i) {
                    e.putImageData(i, 1, 0);
                    var s = e.getImageData(1, 0, 1, 1);
                    n.canHandleAlpha = s.data[0] === i.data[0] && s.data[1] === i.data[1] && s.data[2] === i.data[2] && s.data[3] === i.data[3]
                }
                e.globalCompositeOperation = "multiply",
                n.canUseMultiply = "multiply" === e.globalCompositeOperation,
                W.CanvasPool.removeByCanvas(t),
                PIXI.CanvasTinter.tintMethod = n.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel
            }(),
            function() {
                for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                    if (e[t[i]]) {
                        n.fullscreen = !0,
                        n.requestFullscreen = t[i];
                        break
                    }
                var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                if (n.fullscreen)
                    for (i = 0; i < s.length; i++)
                        if (document[s[i]]) {
                            n.cancelFullscreen = s[i];
                            break
                        }
                window.Element && Element.ALLOW_KEYBOARD_INPUT && (n.fullscreenKeyboard = !0)
            }(),
            ("ontouchstart"in document.documentElement || window.navigator.maxTouchPoints && 1 <= window.navigator.maxTouchPoints) && (n.touch = !0),
            (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (n.mspointer = !0),
            n.cocoonJS || ("onwheel"in window || n.ie && "WheelEvent"in window ? n.wheelEvent = "wheel" : "onmousewheel"in window ? n.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent"in window && (n.wheelEvent = "DOMMouseScroll"))
        }
        ,
        W.Device.canPlayAudio = function(t) {
            return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
        }
        ,
        W.Device.canPlayVideo = function(t) {
            return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
        }
        ,
        W.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(),
            console.profileEnd(),
            console.clear && console.clear(),
            !console.profiles)) && 0 < console.profiles.length
        }
        ,
        W.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }
        ,
        W.Canvas = {
            create: function(t, e, i, s, n) {
                e = e || 256,
                i = i || 256;
                var r = n ? document.createElement("canvas") : W.CanvasPool.create(t, e, i);
                return "string" == typeof s && "" !== s && (r.id = s),
                r.width = e,
                r.height = i,
                r
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)",
                t.style.backgroundColor = e,
                t
            },
            setTouchAction: function(t, e) {
                return e = e || "none",
                t.style.msTouchAction = e,
                t.style["ms-touch-action"] = e,
                t.style["touch-action"] = e,
                t
            },
            setUserSelect: function(t, e) {
                return e = e || "none",
                t.style["-webkit-touch-callout"] = e,
                t.style["-webkit-user-select"] = e,
                t.style["-khtml-user-select"] = e,
                t.style["-moz-user-select"] = e,
                t.style["-ms-user-select"] = e,
                t.style["user-select"] = e,
                t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)",
                t
            },
            addToDOM: function(t, e, i) {
                var s;
                return void 0 === i && (i = !0),
                e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)),
                s = s || document.body,
                i && s.style && (s.style.overflow = "hidden"),
                s.appendChild(t),
                t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, s, n, r, o) {
                return t.setTransform(s, r, o, n, e, i),
                t
            },
            setSmoothingEnabled: function(t, e) {
                var i = W.Canvas.getSmoothingPrefix(t);
                return i && (t[i] = e),
                t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var s = e[i] + "mageSmoothingEnabled";
                    if (s in t)
                        return s
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var e = W.Canvas.getSmoothingPrefix(t);
                if (e)
                    return t[e]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++)
                    t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor",
                t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto",
                t.style.msInterpolationMode = "bicubic",
                t
            }
        },
        W.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1),
            this.game = t,
            this.isRunning = !1,
            this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++)
                window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"],
                window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
            this._isSetTimeOut = !1,
            this._onLoop = null,
            this._timeOutID = null
        }
        ,
        W.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var e = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0,
                this._onLoop = function() {
                    return e.updateSetTimeout()
                }
                ,
                this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1,
                this._onLoop = function(t) {
                    return e.updateRAF(t)
                }
                ,
                this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)),
                this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()),
                this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID),
                this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        },
        W.RequestAnimationFrame.prototype.constructor = W.RequestAnimationFrame,
        W.Math = {
            PI2: 2 * Math.PI,
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            degToRad: function(t) {
                return t * W.Math.DEG_TO_RAD
            },
            radToDeg: function(t) {
                return t * W.Math.RAD_TO_DEG
            },
            getNextPowerOfTwo: function(t) {
                if (0 < t && 0 == (t & t - 1))
                    return t;
                for (var e = 1; e < t; )
                    e <<= 1;
                return e
            },
            isPowerOfTwo: function(t, e) {
                return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
            },
            random: function(t, e) {
                if (void 0 === t && (t = 0),
                void 0 === e && (e = 1),
                t === e)
                    return t;
                if (e < t) {
                    var i = t;
                    t = e,
                    e = i
                }
                return Math.random() * (e - t) + t
            },
            between: function(t, e) {
                if (void 0 === t && (t = 0),
                void 0 === e && (e = 1),
                t === e)
                    return t;
                if (e < t) {
                    var i = t;
                    t = e,
                    e = i
                }
                return t = Math.ceil(t),
                e = Math.floor(e),
                Math.floor(Math.random() * (e - t + 1)) + t
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4),
                Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4),
                t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4),
                e - i < t
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4),
                Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4),
                Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++)
                    t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0),
                0 === e ? t : (t -= i,
                i + (t = e * Math.round(t / e)))
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0),
                0 === e ? t : (t -= i,
                i + (t = e * Math.floor(t / e)))
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0),
                0 === e ? t : (t -= i,
                i + (t = e * Math.ceil(t / e)))
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0),
                void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.round(t * s) / s
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0),
                void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.floor(t * s) / s
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0),
                void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.ceil(t * s) / s
            },
            rotateToAngle: function(t, e, i) {
                return void 0 === i && (i = .05),
                t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= W.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += W.Math.PI2 : e -= W.Math.PI2),
                t < e ? t += i : e < t && (t -= i))),
                t
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 == i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, s) {
                return Math.atan2(s - e, i - t)
            },
            angleBetweenY: function(t, e, i, s) {
                return Math.atan2(i - t, s - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return 0 <= (t %= 2 * Math.PI) ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var s = i - e;
                if (s <= 0)
                    return 0;
                var n = (t - e) % s;
                return n < 0 && (n += s),
                n + e
            },
            wrapValue: function(t, e, i) {
                return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0])
                    var t = arguments[0];
                else
                    t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++)
                    t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0])
                    var t = arguments[0];
                else
                    t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++)
                    t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1])
                    var e = arguments[1];
                else
                    e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++)
                    e[i][t] < e[s][t] && (s = i);
                return e[s][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1])
                    var e = arguments[1];
                else
                    e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++)
                    e[i][t] > e[s][t] && (s = i);
                return e[s][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1
                  , s = i * e
                  , n = Math.floor(s);
                return e < 0 ? this.linear(t[0], t[1], s) : 1 < e ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[i < n + 1 ? i : n + 1], s - n)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, s = t.length - 1, n = 0; n <= s; n++)
                    i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1
                  , s = i * e
                  , n = Math.floor(s);
                return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))),
                this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : 1 < e ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t)
                    return 1;
                for (var e = t; --t; )
                    e *= t;
                return e
            },
            catmullRom: function(t, e, i, s, n) {
                var r = .5 * (i - t)
                  , o = .5 * (s - e)
                  , a = n * n;
                return (2 * e - 2 * i + r + o) * (n * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return 0 < t ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, s) {
                void 0 === e && (e = 1),
                void 0 === i && (i = 1),
                void 0 === s && (s = 1);
                for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], l = 0; l < t; l++)
                    n += (r -= n * o) * o,
                    a[l] = r,
                    h[l] = n;
                return {
                    sin: h,
                    cos: a,
                    length: t
                }
            },
            hypot: function(t, e) {
                return Math.sqrt(t * t + e * e)
            },
            distance: function(t, e, i, s) {
                var n = t - i
                  , r = e - s;
                return Math.sqrt(n * n + r * r)
            },
            distanceSq: function(t, e, i, s) {
                var n = t - i
                  , r = e - s;
                return n * n + r * r
            },
            distancePow: function(t, e, i, s, n) {
                return void 0 === n && (n = 2),
                Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, s, n) {
                return s + (t - e) * (n - s) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : 0 < t ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0),
                e < t || e < i ? 1 : t < i || t < i ? 0 : (t - i) / e
            }
        },
        W.RandomDataGenerator = function(t) {
            void 0 === t && (t = []),
            this.c = 1,
            this.s0 = 0,
            this.s1 = 0,
            this.s2 = 0,
            "string" == typeof t ? this.state(t) : this.sow(t)
        }
        ,
        W.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t,
                this.s0 = this.s1,
                this.s1 = this.s2,
                this.s2 = t - this.c,
                this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "),
                this.s1 = this.hash(this.s0),
                this.s2 = this.hash(this.s1),
                this.c = 1,
                t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i),
                        this.s0 += ~~(this.s0 < 0),
                        this.s1 -= this.hash(i),
                        this.s1 += ~~(this.s1 < 0),
                        this.s2 -= this.hash(i),
                        this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, s;
                for (s = 4022871197,
                t = t.toString(),
                i = 0; i < t.length; i++)
                    e = .02519603282416938 * (s += t.charCodeAt(i)),
                    e -= s = e >>> 0,
                    s = (e *= s) >>> 0,
                    s += 4294967296 * (e -= s);
                return 2.3283064365386963e-10 * (s >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 11102230246251565e-32 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = ""
                  , e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-")
                    ;
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","),
                this.c = parseFloat(t[1]),
                this.s0 = parseFloat(t[2]),
                this.s1 = parseFloat(t[3]),
                this.s2 = parseFloat(t[4])),
                ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        },
        W.RandomDataGenerator.prototype.constructor = W.RandomDataGenerator,
        W.QuadTree = function(t, e, i, s, n, r, o) {
            this.maxObjects = 10,
            this.maxLevels = 4,
            this.level = 0,
            this.bounds = {},
            this.objects = [],
            this.nodes = [],
            this._empty = [],
            this.reset(t, e, i, s, n, r, o)
        }
        ,
        W.QuadTree.prototype = {
            reset: function(t, e, i, s, n, r, o) {
                this.maxObjects = n || 10,
                this.maxLevels = r || 4,
                this.level = o || 0,
                this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: s,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(s / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(s / 2)
                },
                this.objects.length = 0,
                this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new W.QuadTree(this.bounds.right,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
                this.nodes[1] = new W.QuadTree(this.bounds.x,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
                this.nodes[2] = new W.QuadTree(this.bounds.x,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
                this.nodes[3] = new W.QuadTree(this.bounds.right,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t),
                    this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length; )
                            -1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else
                    this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)),
                e
            },
            retrieve: function(t) {
                if (t instanceof W.Rectangle)
                    var e = this.objects
                      , i = this.getIndex(t);
                else {
                    if (!t.body)
                        return this._empty;
                    e = this.objects,
                    i = this.getIndex(t.body)
                }
                return this.nodes[0] && (e = -1 !== i ? e.concat(this.nodes[i].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))),
                e
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--; )
                    this.nodes[t].clear(),
                    this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        },
        W.QuadTree.prototype.constructor = W.QuadTree,
        W.Net = function(t) {
            this.game = t
        }
        ,
        W.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(t) {
                return -1 !== window.location.hostname.indexOf(t)
            },
            updateQueryString: function(t, e, i, s) {
                void 0 === i && (i = !1),
                void 0 !== s && "" !== s || (s = window.location.href);
                var n = ""
                  , r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)","gi");
                if (r.test(s))
                    n = null != e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
                else if (null != e) {
                    var o = -1 !== s.indexOf("?") ? "&" : "?"
                      , a = s.split("#");
                    s = a[0] + o + t + "=" + e,
                    a[1] && (s += "#" + a[1]),
                    n = s
                } else
                    n = s;
                if (!i)
                    return n;
                window.location.href = n
            },
            getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {}
                  , i = location.search.substring(1).split("&");
                for (var s in i) {
                    var n = i[s].split("=");
                    if (1 < n.length) {
                        if (t && t === this.decodeURI(n[0]))
                            return this.decodeURI(n[1]);
                        e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                    }
                }
                return e
            },
            decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        },
        W.Net.prototype.constructor = W.Net,
        W.TweenManager = function(t) {
            this.game = t,
            this.frameBased = !1,
            this._tweens = [],
            this._add = [],
            this.easeMap = {
                Power0: W.Easing.Power0,
                Power1: W.Easing.Power1,
                Power2: W.Easing.Power2,
                Power3: W.Easing.Power3,
                Power4: W.Easing.Power4,
                Linear: W.Easing.Linear.None,
                Quad: W.Easing.Quadratic.Out,
                Cubic: W.Easing.Cubic.Out,
                Quart: W.Easing.Quartic.Out,
                Quint: W.Easing.Quintic.Out,
                Sine: W.Easing.Sinusoidal.Out,
                Expo: W.Easing.Exponential.Out,
                Circ: W.Easing.Circular.Out,
                Elastic: W.Easing.Elastic.Out,
                Back: W.Easing.Back.Out,
                Bounce: W.Easing.Bounce.Out,
                "Quad.easeIn": W.Easing.Quadratic.In,
                "Cubic.easeIn": W.Easing.Cubic.In,
                "Quart.easeIn": W.Easing.Quartic.In,
                "Quint.easeIn": W.Easing.Quintic.In,
                "Sine.easeIn": W.Easing.Sinusoidal.In,
                "Expo.easeIn": W.Easing.Exponential.In,
                "Circ.easeIn": W.Easing.Circular.In,
                "Elastic.easeIn": W.Easing.Elastic.In,
                "Back.easeIn": W.Easing.Back.In,
                "Bounce.easeIn": W.Easing.Bounce.In,
                "Quad.easeOut": W.Easing.Quadratic.Out,
                "Cubic.easeOut": W.Easing.Cubic.Out,
                "Quart.easeOut": W.Easing.Quartic.Out,
                "Quint.easeOut": W.Easing.Quintic.Out,
                "Sine.easeOut": W.Easing.Sinusoidal.Out,
                "Expo.easeOut": W.Easing.Exponential.Out,
                "Circ.easeOut": W.Easing.Circular.Out,
                "Elastic.easeOut": W.Easing.Elastic.Out,
                "Back.easeOut": W.Easing.Back.Out,
                "Bounce.easeOut": W.Easing.Bounce.Out,
                "Quad.easeInOut": W.Easing.Quadratic.InOut,
                "Cubic.easeInOut": W.Easing.Cubic.InOut,
                "Quart.easeInOut": W.Easing.Quartic.InOut,
                "Quint.easeInOut": W.Easing.Quintic.InOut,
                "Sine.easeInOut": W.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": W.Easing.Exponential.InOut,
                "Circ.easeInOut": W.Easing.Circular.InOut,
                "Elastic.easeInOut": W.Easing.Elastic.InOut,
                "Back.easeInOut": W.Easing.Back.InOut,
                "Bounce.easeInOut": W.Easing.Bounce.InOut
            },
            this.game.onPause.add(this._pauseAll, this),
            this.game.onResume.add(this._resumeAll, this)
        }
        ,
        W.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++)
                    this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(t, e) {
                if (void 0 === e && (e = !0),
                Array.isArray(t))
                    for (i = 0,
                    s = t.length; i < s; i++)
                        this.removeFrom(t[i]);
                else if (t.type === W.GROUP && e)
                    for (var i = 0, s = t.children.length; i < s; i++)
                        this.removeFrom(t.children[i]);
                else {
                    for (i = 0,
                    s = this._tweens.length; i < s; i++)
                        t === this._tweens[i].target && this.remove(this._tweens[i]);
                    for (i = 0,
                    s = this._add.length; i < s; i++)
                        t === this._add[i].target && this.remove(this._add[i])
                }
            },
            add: function(t) {
                (t._manager = this)._add.push(t)
            },
            create: function(t) {
                return new W.Tween(t,this.game,this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t);
                -1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length
                  , e = this._tweens.length;
                if (0 === e && 0 === t)
                    return !1;
                for (var i = 0; i < e; )
                    this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1),
                    e--);
                return 0 < t && (this._tweens = this._tweens.concat(this._add),
                this._add.length = 0),
                !0
            },
            isTweening: function(e) {
                return this._tweens.some(function(t) {
                    return t.target === e
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--)
                    this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--)
                    this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--)
                    this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--)
                    this._tweens[t].resume(!0)
            }
        },
        W.TweenManager.prototype.constructor = W.TweenManager,
        W.Tween = function(t, e, i) {
            this.game = e,
            this.target = t,
            this.manager = i,
            this.timeline = [],
            this.reverse = !1,
            this.timeScale = 1,
            this.repeatCounter = 0,
            this.pendingDelete = !1,
            this.onStart = new W.Signal,
            this.onLoop = new W.Signal,
            this.onRepeat = new W.Signal,
            this.onChildComplete = new W.Signal,
            this.onComplete = new W.Signal,
            this.isRunning = !1,
            this.current = 0,
            this.properties = {},
            this.chainedTween = null,
            this.isPaused = !1,
            this.frameBased = i.frameBased,
            this._onUpdateCallback = null,
            this._onUpdateCallbackContext = null,
            this._pausedTime = 0,
            this._codePaused = !1,
            this._hasStarted = !1
        }
        ,
        W.Tween.prototype = {
            to: function(t, e, i, s, n, r, o) {
                return (void 0 === e || e <= 0) && (e = 1e3),
                null == i && (i = W.Easing.Default),
                void 0 === s && (s = !1),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                void 0 === o && (o = !1),
                "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]),
                this.isRunning ? console.warn("Phaser.Tween.to cannot be called after Tween.start") : (this.timeline.push(new W.TweenData(this).to(t, e, i, n, r, o)),
                s && this.start()),
                this
            },
            from: function(t, e, i, s, n, r, o) {
                return void 0 === e && (e = 1e3),
                null == i && (i = W.Easing.Default),
                void 0 === s && (s = !1),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                void 0 === o && (o = !1),
                "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]),
                this.isRunning ? console.warn("Phaser.Tween.from cannot be called after Tween.start") : (this.timeline.push(new W.TweenData(this).from(t, e, i, n, r, o)),
                s && this.start()),
                this
            },
            start: function(t) {
                if (void 0 === t && (t = 0),
                null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning)
                    return this;
                for (var e = 0; e < this.timeline.length; e++)
                    for (var i in this.timeline[e].vEnd)
                        this.properties[i] = this.target[i] || 0,
                        Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (e = 0; e < this.timeline.length; e++)
                    this.timeline[e].loadValues();
                return this.manager.add(this),
                this.isRunning = !0,
                (t < 0 || t > this.timeline.length - 1) && (t = 0),
                this.current = t,
                this.timeline[this.current].start(),
                this
            },
            stop: function(t) {
                return void 0 === t && (t = !1),
                this.isRunning = !1,
                this._onUpdateCallback = null,
                this._onUpdateCallbackContext = null,
                t && (this.onComplete.dispatch(this.target, this),
                this._hasStarted = !1,
                this.chainedTween && this.chainedTween.start()),
                this.manager.remove(this),
                this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length)
                    return this;
                if (void 0 === i && (i = 0),
                -1 === i)
                    for (var s = 0; s < this.timeline.length; s++)
                        this.timeline[s][t] = e;
                else
                    this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0),
                this.updateTweenData("repeatCounter", t, i),
                this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0),
                this.updateTweenData("yoyo", t, i),
                this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]),
                this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(t, e, i) {
                return void 0 === e && (e = W.Math),
                this.updateTweenData("interpolationFunction", t, i),
                this.updateTweenData("interpolationContext", e, i)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0),
                this.repeatCounter = t,
                this
            },
            chain: function() {
                for (var t = arguments.length; t--; )
                    0 < t ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0),
                this.repeatCounter = t ? -1 : 0,
                this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t,
                this._onUpdateCallbackContext = e,
                this
            },
            pause: function() {
                this.isPaused = !0,
                this._codePaused = !0,
                this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0,
                this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1,
                    this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++)
                        this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(t) {
                if (this.pendingDelete || !this.target)
                    return !1;
                if (this.isPaused)
                    return !0;
                var e = this.timeline[this.current].update(t);
                if (e === W.TweenData.PENDING)
                    return !0;
                if (e === W.TweenData.RUNNING)
                    return this._hasStarted || (this.onStart.dispatch(this.target, this),
                    this._hasStarted = !0),
                    null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]),
                    this.isRunning;
                if (e === W.TweenData.LOOPED)
                    return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this),
                    !0;
                if (e === W.TweenData.COMPLETE) {
                    var i = !1;
                    return this.reverse ? (this.current--,
                    this.current < 0 && (this.current = this.timeline.length - 1,
                    i = !0)) : (this.current++,
                    this.current === this.timeline.length && (i = !(this.current = 0))),
                    i ? -1 === this.repeatCounter ? (this.timeline[this.current].start(),
                    this.onLoop.dispatch(this.target, this),
                    !0) : 0 < this.repeatCounter ? (this.repeatCounter--,
                    this.timeline[this.current].start(),
                    this.onRepeat.dispatch(this.target, this),
                    !0) : (this.isRunning = !1,
                    this.onComplete.dispatch(this.target, this),
                    this._hasStarted = !1,
                    this.chainedTween && this.chainedTween.start(),
                    !1) : (this.onChildComplete.dispatch(this.target, this),
                    this.timeline[this.current].start(),
                    !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target)
                    return null;
                void 0 === t && (t = 60),
                void 0 === e && (e = []);
                for (var i = 0; i < this.timeline.length; i++)
                    for (var s in this.timeline[i].vEnd)
                        this.properties[s] = this.target[s] || 0,
                        Array.isArray(this.properties[s]) || (this.properties[s] *= 1);
                for (i = 0; i < this.timeline.length; i++)
                    this.timeline[i].loadValues();
                for (i = 0; i < this.timeline.length; i++)
                    e = e.concat(this.timeline[i].generateData(t));
                return e
            }
        },
        Object.defineProperty(W.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++)
                    t += this.timeline[e].duration;
                return t
            }
        }),
        W.Tween.prototype.constructor = W.Tween,
        W.TweenData = function(t) {
            this.parent = t,
            this.game = t.game,
            this.vStart = {},
            this.vStartCache = {},
            this.vEnd = {},
            this.vEndCache = {},
            this.duration = 1e3,
            this.percent = 0,
            this.value = 0,
            this.repeatCounter = 0,
            this.repeatDelay = 0,
            this.repeatTotal = 0,
            this.interpolate = !1,
            this.yoyo = !1,
            this.yoyoDelay = 0,
            this.inReverse = !1,
            this.delay = 0,
            this.dt = 0,
            this.startTime = null,
            this.easingFunction = W.Easing.Default,
            this.interpolationFunction = W.Math.linearInterpolation,
            this.interpolationContext = W.Math,
            this.isRunning = !1,
            this.isFrom = !1
        }
        ,
        W.TweenData.PENDING = 0,
        W.TweenData.RUNNING = 1,
        W.TweenData.LOOPED = 2,
        W.TweenData.COMPLETE = 3,
        W.TweenData.prototype = {
            to: function(t, e, i, s, n, r) {
                return this.vEnd = t,
                this.duration = e,
                this.easingFunction = i,
                this.delay = s,
                this.repeatTotal = n,
                this.yoyo = r,
                this.isFrom = !1,
                this
            },
            from: function(t, e, i, s, n, r) {
                return this.vEnd = t,
                this.duration = e,
                this.easingFunction = i,
                this.delay = s,
                this.repeatTotal = n,
                this.yoyo = r,
                this.isFrom = !0,
                this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay,
                this.parent.reverse ? this.dt = this.duration : this.dt = 0,
                0 < this.delay ? this.isRunning = !1 : this.isRunning = !0,
                this.isFrom)
                    for (var t in this.vStartCache)
                        this.vStart[t] = this.vEndCache[t],
                        this.vEnd[t] = this.vStartCache[t],
                        this.parent.target[t] = this.vStart[t];
                return this.value = 0,
                this.yoyoCounter = 0,
                this.repeatCounter = this.repeatTotal,
                this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t],
                    Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length)
                            continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)),
                    this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t],
                    this.vStartCache[t] = this.vStart[t],
                    this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(t) {
                if (this.isRunning) {
                    if (t < this.startTime)
                        return W.TweenData.RUNNING
                } else {
                    if (!(t >= this.startTime))
                        return W.TweenData.PENDING;
                    this.isRunning = !0
                }
                var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                for (var i in this.parent.reverse ? (this.dt -= e * this.parent.timeScale,
                this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale,
                this.dt = Math.min(this.dt, this.duration)),
                this.percent = this.dt / this.duration,
                this.value = this.easingFunction(this.percent),
                this.vEnd) {
                    var s = this.vStart[i]
                      , n = this.vEnd[i];
                    Array.isArray(n) ? this.parent.target[i] = this.interpolationFunction.call(this.interpolationContext, n, this.value) : this.parent.target[i] = s + (n - s) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : W.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = []
                  , i = !1
                  , s = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= s,
                    this.dt = Math.max(this.dt, 0)) : (this.dt += s,
                    this.dt = Math.min(this.dt, this.duration)),
                    this.percent = this.dt / this.duration,
                    this.value = this.easingFunction(this.percent);
                    var n = {};
                    for (var r in this.vEnd) {
                        var o = this.vStart[r]
                          , a = this.vEnd[r];
                        Array.isArray(a) ? n[r] = this.interpolationFunction(a, this.value) : n[r] = o + (a - o) * this.value
                    }
                    e.push(n),
                    (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(),
                    e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var t in this.vStartCache)
                            this.vStart[t] = this.vStartCache[t],
                            this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1,
                        W.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter)
                    return W.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var t in this.vStartCache)
                        this.vStart[t] = this.vEndCache[t],
                        this.vEnd[t] = this.vStartCache[t];
                else {
                    for (var t in this.vStartCache)
                        this.vStart[t] = this.vStartCache[t],
                        this.vEnd[t] = this.vEndCache[t];
                    0 < this.repeatCounter && this.repeatCounter--
                }
                return this.startTime = this.game.time.time,
                this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay),
                this.parent.reverse ? this.dt = this.duration : this.dt = 0,
                W.TweenData.LOOPED
            }
        },
        W.TweenData.prototype.constructor = W.TweenData,
        W.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                    .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                    -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                    .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                    i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                    .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                    (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    return t * t * (2.70158 * t - 1.70158)
                },
                Out: function(t) {
                    return --t * t * (2.70158 * t + 1.70158) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((1 + e) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + e) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - W.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * W.Easing.Bounce.In(2 * t) : .5 * W.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        },
        W.Easing.Default = W.Easing.Linear.None,
        W.Easing.Power0 = W.Easing.Linear.None,
        W.Easing.Power1 = W.Easing.Quadratic.Out,
        W.Easing.Power2 = W.Easing.Cubic.Out,
        W.Easing.Power3 = W.Easing.Quartic.Out,
        W.Easing.Power4 = W.Easing.Quintic.Out,
        W.Time = function(t) {
            this.game = t,
            this.time = 0,
            this.prevTime = 0,
            this.now = 0,
            this.elapsed = 0,
            this.elapsedMS = 0,
            this.physicsElapsed = 1 / 60,
            this.physicsElapsedMS = 1 / 60 * 1e3,
            this.desiredFpsMult = 1 / 60,
            this._desiredFps = 60,
            this.suggestedFps = this.desiredFps,
            this.slowMotion = 1,
            this.advancedTiming = !1,
            this.frames = 0,
            this.fps = 0,
            this.fpsMin = 1e3,
            this.fpsMax = 0,
            this.msMin = 1e3,
            this.msMax = 0,
            this.pauseDuration = 0,
            this.timeToCall = 0,
            this.timeExpected = 0,
            this.events = new W.Timer(this.game,!1),
            this._frameCount = 0,
            this._elapsedAccumulator = 0,
            this._started = 0,
            this._timeLastSecond = 0,
            this._pauseStarted = 0,
            this._justResumed = !1,
            this._timers = []
        }
        ,
        W.Time.prototype = {
            boot: function() {
                this._started = Date.now(),
                this.time = Date.now(),
                this.events.start(),
                this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t),
                t
            },
            create: function(t) {
                void 0 === t && (t = !0);
                var e = new W.Timer(this.game,t);
                return this._timers.push(e),
                e
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++)
                    this._timers[t].destroy();
                this._timers = [],
                this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(),
                this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time;
                this.time = Date.now(),
                this.elapsedMS = this.time - e,
                this.prevTime = this.now,
                this.now = t,
                this.elapsed = this.now - this.prevTime,
                this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))),
                this.timeExpected = t + this.timeToCall),
                this.advancedTiming && this.updateAdvancedTiming(),
                this.game.paused || (this.events.update(this.time),
                this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var t = 0, e = this._timers.length; t < e; )
                    this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1),
                    e--)
            },
            updateAdvancedTiming: function() {
                this._frameCount++,
                this._elapsedAccumulator += this.elapsed,
                this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)),
                this._frameCount = 0,
                this._elapsedAccumulator = 0),
                this.msMin = Math.min(this.msMin, this.elapsed),
                this.msMax = Math.max(this.msMax, this.elapsed),
                this.frames++,
                this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)),
                this.fpsMin = Math.min(this.fpsMin, this.fps),
                this.fpsMax = Math.max(this.fpsMax, this.fps),
                this._timeLastSecond = this.now,
                this.frames = 0)
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(),
                this.events.pause();
                for (var t = this._timers.length; t--; )
                    this._timers[t]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(),
                this.pauseDuration = this.time - this._pauseStarted,
                this.events.resume();
                for (var t = this._timers.length; t--; )
                    this._timers[t]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time,
                this.removeAll()
            }
        },
        Object.defineProperty(W.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t,
                this.physicsElapsed = 1 / t,
                this.physicsElapsedMS = 1e3 * this.physicsElapsed,
                this.desiredFpsMult = 1 / t
            }
        }),
        W.Time.prototype.constructor = W.Time,
        W.Timer = function(t, e) {
            void 0 === e && (e = !0),
            this.game = t,
            this.running = !1,
            this.autoDestroy = e,
            this.expired = !1,
            this.elapsed = 0,
            this.events = [],
            this.onComplete = new W.Signal,
            this.nextTick = 0,
            this.timeCap = 1e3,
            this.paused = !1,
            this._codePaused = !1,
            this._started = 0,
            this._pauseStarted = 0,
            this._pauseTotal = 0,
            this._now = Date.now(),
            this._len = 0,
            this._marked = 0,
            this._i = 0,
            this._diff = 0,
            this._newTick = 0
        }
        ,
        W.Timer.MINUTE = 6e4,
        W.Timer.SECOND = 1e3,
        W.Timer.HALF = 500,
        W.Timer.QUARTER = 250,
        W.Timer.prototype = {
            create: function(t, e, i, s, n, r) {
                var o = t = Math.round(t);
                0 === this._now ? o += this.game.time.time : o += this._now;
                var a = new W.TimerEvent(this,t,o,i,e,s,n,r);
                return this.events.push(a),
                this.order(),
                this.expired = !1,
                a
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, s) {
                return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.time + (t || 0),
                    this.running = !0;
                    for (var e = 0; e < this.events.length; e++)
                        this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1,
                void 0 === t && (t = !0),
                t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t)
                        return this.events[e].pendingDelete = !0;
                return !1
            },
            order: function() {
                0 < this.events.length && (this.events.sort(this.sortHandler),
                this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--; )
                    this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length,
                this._i = 0
            },
            update: function(t) {
                if (this.paused)
                    return !0;
                if (this.elapsed = t - this._now,
                this._now = t,
                this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed),
                this._marked = 0,
                this.clearPendingEvents(),
                this.running && this._now >= this.nextTick && 0 < this._len) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete; )
                        this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick),
                        this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay),
                        !0 === this.events[this._i].loop ? this.events[this._i].tick = this._newTick : 0 < this.events[this._i].repeatCount ? (this.events[this._i].repeatCount--,
                        this.events[this._i].tick = this._newTick) : (this._marked++,
                        this.events[this._i].pendingDelete = !0),
                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args),
                        this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0,
                    this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0,
                this.paused || (this._pauseStarted = this.game.time.time,
                this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time,
                this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0),
                        this.events[e].tick = this._now + i
                    }
                var s = this.nextTick - t;
                this.nextTick = s < 0 ? this._now : this._now + s
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now,
                    this._now = t,
                    this.adjustEvents(this._pauseStarted),
                    this.paused = !1,
                    this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(),
                this.events.length = 0,
                this._len = 0,
                this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(),
                this.running = !1,
                this.events = [],
                this._len = 0,
                this._i = 0
            }
        },
        Object.defineProperty(W.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }),
        Object.defineProperty(W.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }),
        Object.defineProperty(W.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }),
        Object.defineProperty(W.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }),
        Object.defineProperty(W.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }),
        W.Timer.prototype.constructor = W.Timer,
        W.TimerEvent = function(t, e, i, s, n, r, o, a) {
            this.timer = t,
            this.delay = e,
            this.tick = i,
            this.repeatCount = s - 1,
            this.loop = n,
            this.callback = r,
            this.callbackContext = o,
            this.args = a,
            this.pendingDelete = !1
        }
        ,
        W.TimerEvent.prototype.constructor = W.TimerEvent,
        W.AnimationManager = function(t) {
            this.sprite = t,
            this.game = t.game,
            this.currentFrame = null,
            this.currentAnim = null,
            this.updateIfVisible = !0,
            this.isLoaded = !1,
            this._frameData = null,
            this._anims = {},
            this._outputFrames = []
        }
        ,
        W.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t)
                    return !1;
                if (this.isLoaded)
                    for (var i in this._anims)
                        this._anims[i].updateFrameData(t);
                return this._frameData = t,
                null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e,
                this.isLoaded = !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(),
                this.isLoaded)
                    for (var i in this._anims)
                        this._anims[i].updateFrameData(this._frameData);
                return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e,
                this.isLoaded = !0
            },
            add: function(t, e, i, s, n) {
                return e = e || [],
                i = i || 60,
                void 0 === s && (s = !1),
                void 0 === n && (n = !(!e || "number" != typeof e[0])),
                this._outputFrames = [],
                this._frameData.getFrameIndexes(e, n, this._outputFrames),
                this._anims[t] = new W.Animation(this.game,this.sprite,t,this._frameData,this._outputFrames,i,s),
                this.currentAnim = this._anims[t],
                this.sprite.tilingTexture && (this.sprite.refreshTexture = !0),
                this._anims[t]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total)
                            return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i]))
                        return !1;
                return !0
            },
            play: function(t, e, i, s) {
                if (this._anims[t])
                    return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1,
                    this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(),
                    this.currentAnim = this._anims[t],
                    this.currentAnim.paused = !1,
                    this.currentFrame = this.currentAnim.currentFrame,
                    this.currentAnim.play(e, i, s))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1),
                !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame,
                !0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t),
                this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t),
                this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                var t = null;
                for (var t in this._anims)
                    this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {},
                this._outputFrames = [],
                this._frameData = null,
                this.currentAnim = null,
                this.currentFrame = null,
                this.sprite = null,
                this.game = null
            }
        },
        W.AnimationManager.prototype.constructor = W.AnimationManager,
        Object.defineProperty(W.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }),
        Object.defineProperty(W.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }),
        Object.defineProperty(W.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }),
        Object.defineProperty(W.AnimationManager.prototype, "name", {
            get: function() {
                if (this.currentAnim)
                    return this.currentAnim.name
            }
        }),
        Object.defineProperty(W.AnimationManager.prototype, "frame", {
            get: function() {
                if (this.currentFrame)
                    return this.currentFrame.index
            },
            set: function(t) {
                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t),
                this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }),
        Object.defineProperty(W.AnimationManager.prototype, "frameName", {
            get: function() {
                if (this.currentFrame)
                    return this.currentFrame.name
            },
            set: function(t) {
                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t),
                this.currentFrame && (this._frameIndex = this.currentFrame.index,
                this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + t)
            }
        }),
        W.Animation = function(t, e, i, s, n, r, o) {
            void 0 === o && (o = !1),
            this.game = t,
            this._parent = e,
            this._frameData = s,
            this.name = i,
            this._frames = [],
            this._frames = this._frames.concat(n),
            this.delay = 1e3 / r,
            this.loop = o,
            this.loopCount = 0,
            this.killOnComplete = !1,
            this.isFinished = !1,
            this.isPlaying = !1,
            this.isPaused = !1,
            this._pauseStartTime = 0,
            this._frameIndex = 0,
            this._frameDiff = 0,
            this._frameSkip = 1,
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.onStart = new W.Signal,
            this.onUpdate = null,
            this.onComplete = new W.Signal,
            this.onLoop = new W.Signal,
            this.isReversed = !1,
            this.game.onPause.add(this.onPause, this),
            this.game.onResume.add(this.onResume, this)
        }
        ,
        W.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t),
                "boolean" == typeof e && (this.loop = e),
                void 0 !== i && (this.killOnComplete = i),
                this.isPlaying = !0,
                this.isFinished = !1,
                this.paused = !1,
                this.loopCount = 0,
                this._timeLastFrame = this.game.time.time,
                this._timeNextFrame = this.game.time.time + this.delay,
                this._frameIndex = this.isReversed ? this._frames.length - 1 : 0,
                this.updateCurrentFrame(!1, !0),
                this._parent.events.onAnimationStart$dispatch(this._parent, this),
                this.onStart.dispatch(this._parent, this),
                (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame,
                this
            },
            restart: function() {
                this.isPlaying = !0,
                this.isFinished = !1,
                this.paused = !1,
                this.loopCount = 0,
                this._timeLastFrame = this.game.time.time,
                this._timeNextFrame = this.game.time.time + this.delay,
                this._frameIndex = 0,
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
                this._parent.setFrame(this.currentFrame),
                (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame,
                this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed,
                this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this),
                this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1),
                "string" == typeof t)
                    for (var s = 0; s < this._frames.length; s++)
                        this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                else if ("number" == typeof t)
                    if (e)
                        i = t;
                    else
                        for (s = 0; s < this._frames.length; s++)
                            this._frames[s] === t && (i = s);
                if (i) {
                    var n = this.isReversed ? -1 : 1;
                    this._frameIndex = i - n,
                    this._timeNextFrame = this.game.time.time,
                    this.update()
                }
            },
            stop: function(t, e) {
                void 0 === t && (t = !1),
                void 0 === e && (e = !1),
                this.isPlaying = !1,
                this.isFinished = !0,
                this.paused = !1,
                t && (this.currentFrame = this._frameData.getFrame(this._frames[0]),
                this._parent.setFrame(this.currentFrame)),
                e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this),
                this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1,
                this._frameDiff = this.game.time.time - this._timeNextFrame,
                this._timeLastFrame = this.game.time.time,
                this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay),
                this._frameDiff -= this._frameSkip * this.delay),
                this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff),
                this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip,
                !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length,
                this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex),
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
                this.currentFrame && this._parent.setFrame(this.currentFrame),
                this.loopCount++,
                this._parent.events.onAnimationLoop$dispatch(this._parent, this),
                this.onLoop.dispatch(this._parent, this),
                !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame),
                !!this._frameData)) : (this.complete(),
                !1) : this.updateCurrentFrame(!0)))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1),
                !this._frameData)
                    return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
                this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame),
                !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame),
                !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1),
                e !== this._frameIndex && (this._frameIndex = e,
                this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++),
                e !== this._frameIndex && (this._frameIndex = e,
                this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t,
                this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this),
                this.game.onResume.remove(this.onResume, this),
                this.game = null,
                this._parent = null,
                this._frames = null,
                this._frameData = null,
                this.currentFrame = null,
                this.isPlaying = !1,
                this.onStart.dispose(),
                this.onLoop.dispose(),
                this.onComplete.dispose(),
                this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1,
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
                this.isPlaying = !1,
                this.isFinished = !0,
                this.paused = !1,
                this._parent.events.onAnimationComplete$dispatch(this._parent, this),
                this.onComplete.dispatch(this._parent, this),
                this.killOnComplete && this._parent.kill()
            }
        },
        W.Animation.prototype.constructor = W.Animation,
        Object.defineProperty(W.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                (this.isPaused = t) ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }),
        Object.defineProperty(W.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }),
        Object.defineProperty(W.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }),
        Object.defineProperty(W.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]),
                null !== this.currentFrame && (this._frameIndex = t,
                this._parent.setFrame(this.currentFrame),
                this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }),
        Object.defineProperty(W.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                0 < t && (this.delay = 1e3 / t)
            }
        }),
        Object.defineProperty(W.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new W.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(),
                this.onUpdate = null)
            }
        }),
        W.Animation.generateFrameNames = function(t, e, i, s, n) {
            void 0 === s && (s = "");
            var r = []
              , o = "";
            if (e < i)
                for (var a = e; a <= i; a++)
                    o = t + (o = "number" == typeof n ? W.Utils.pad(a.toString(), n, "0", 1) : a.toString()) + s,
                    r.push(o);
            else
                for (a = e; i <= a; a--)
                    o = t + (o = "number" == typeof n ? W.Utils.pad(a.toString(), n, "0", 1) : a.toString()) + s,
                    r.push(o);
            return r
        }
        ,
        W.Frame = function(t, e, i, s, n, r) {
            this.index = t,
            this.x = e,
            this.y = i,
            this.width = s,
            this.height = n,
            0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'),
            this.name = r,
            this.centerX = Math.floor(s / 2),
            this.centerY = Math.floor(n / 2),
            this.distance = W.Math.distance(0, 0, s, n),
            this.rotated = !1,
            this.trimmed = !1,
            this.sourceSizeW = s,
            this.sourceSizeH = n,
            this.spriteSourceSizeX = 0,
            this.spriteSourceSizeY = 0,
            this.spriteSourceSizeW = 0,
            this.spriteSourceSizeH = 0,
            this.right = this.x + this.width,
            this.bottom = this.y + this.height
        }
        ,
        W.Frame.prototype = {
            resize: function(t, e) {
                this.width = t,
                this.height = e,
                this.centerX = Math.floor(t / 2),
                this.centerY = Math.floor(e / 2),
                this.distance = W.Math.distance(0, 0, t, e),
                this.sourceSizeW = t,
                this.sourceSizeH = e,
                this.right = this.x + t,
                this.bottom = this.y + e
            },
            setTrim: function(t, e, i, s, n, r, o) {
                (this.trimmed = t) && (this.sourceSizeW = e,
                this.sourceSizeH = i,
                this.centerX = Math.floor(e / 2),
                this.centerY = Math.floor(i / 2),
                this.spriteSourceSizeX = s,
                this.spriteSourceSizeY = n,
                this.spriteSourceSizeW = r,
                this.spriteSourceSizeH = o)
            },
            clone: function() {
                var t = new W.Frame(this.index,this.x,this.y,this.width,this.height,this.name);
                for (var e in this)
                    this.hasOwnProperty(e) && (t[e] = this[e]);
                return t
            },
            getRect: function(t) {
                return void 0 === t ? t = new W.Rectangle(this.x,this.y,this.width,this.height) : t.setTo(this.x, this.y, this.width, this.height),
                t
            }
        },
        W.Frame.prototype.constructor = W.Frame,
        W.FrameData = function() {
            this._frames = [],
            this._frameNames = []
        }
        ,
        W.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length,
                this._frames.push(t),
                "" !== t.name && (this._frameNames[t.name] = t.index),
                t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0),
                this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var t = new W.FrameData, e = 0; e < this._frames.length; e++)
                    t._frames.push(this._frames[e].clone());
                for (var i in this._frameNames)
                    this._frameNames.hasOwnProperty(i) && t._frameNames.push(this._frameNames[i]);
                return t
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var s = t; s <= e; s++)
                    i.push(this._frames[s]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0),
                void 0 === i && (i = []),
                void 0 === t || 0 === t.length)
                    for (var s = 0; s < this._frames.length; s++)
                        i.push(this._frames[s]);
                else
                    for (s = 0; s < t.length; s++)
                        e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0),
                void 0 === i && (i = []),
                void 0 === t || 0 === t.length)
                    for (var s = 0; s < this._frames.length; s++)
                        i.push(this._frames[s].index);
                else
                    for (s = 0; s < t.length; s++)
                        e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                return i
            },
            destroy: function() {
                this._frames = null,
                this._frameNames = null
            }
        },
        W.FrameData.prototype.constructor = W.FrameData,
        Object.defineProperty(W.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }),
        W.AnimationParser = {
            spriteSheet: function(t, e, i, s, n, r, o, a) {
                void 0 === n && (n = -1),
                void 0 === r && (r = 0),
                void 0 === o && (o = 0),
                void 0 === a && (a = 0);
                var h = e;
                if ("string" == typeof e && (h = t.cache.getImage(e)),
                null === h)
                    return null;
                var l = h.width
                  , c = h.height;
                i <= 0 && (i = Math.floor(-l / Math.min(-1, i))),
                s <= 0 && (s = Math.floor(-c / Math.min(-1, s)));
                var u = Math.floor((l - r) / (i + o)) * Math.floor((c - r) / (s + o));
                if (u < a || a < -u)
                    return console.warn("Phaser.AnimationParser.spriteSheet: skipFrames = " + a.toString() + " is larger than total sprite number " + u.toString()),
                    null;
                if (a < 0 && (a = u + a),
                -1 !== n && (u = a + n),
                0 === l || 0 === c || l < i || c < s || 0 === u)
                    return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"),
                    null;
                for (var d = new W.FrameData, p = r, f = r, g = 0; g < u; g++)
                    d.addFrame(new W.Frame(g,p,f,i,s,"")),
                    l < (p += i + o) + i && (p = r,
                    f += s + o);
                return d
            },
            JSONData: function(t, e) {
                if (!e.frames)
                    return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"),
                    void console.log(e);
                for (var i, s = new W.FrameData, n = e.frames, r = 0; r < n.length; r++)
                    i = s.addFrame(new W.Frame(r,n[r].frame.x,n[r].frame.y,n[r].frame.w,n[r].frame.h,n[r].filename)),
                    n[r].trimmed && i.setTrim(n[r].trimmed, n[r].sourceSize.w, n[r].sourceSize.h, n[r].spriteSourceSize.x, n[r].spriteSourceSize.y, n[r].spriteSourceSize.w, n[r].spriteSourceSize.h),
                    n[r].rotated && (i.rotated = !0);
                return s
            },
            JSONDataPyxel: function(t, e) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                    if (!e[t])
                        return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'),
                        void console.log(e)
                }),
                1 !== e.layers.length)
                    return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."),
                    void console.log(e);
                for (var i = new W.FrameData, s = e.tileheight, n = e.tilewidth, r = e.layers[0].tiles, o = 0; o < r.length; o++)
                    i.addFrame(new W.Frame(o,r[o].x,r[o].y,n,s,"frame_" + o)).setTrim(!1);
                return i
            },
            JSONDataHash: function(t, e) {
                if (!e.frames)
                    return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"),
                    void console.log(e);
                var i, s = new W.FrameData, n = e.frames, r = 0;
                for (var o in n)
                    i = s.addFrame(new W.Frame(r,n[o].frame.x,n[o].frame.y,n[o].frame.w,n[o].frame.h,o)),
                    n[o].trimmed && i.setTrim(n[o].trimmed, n[o].sourceSize.w, n[o].sourceSize.h, n[o].spriteSourceSize.x, n[o].spriteSourceSize.y, n[o].spriteSourceSize.w, n[o].spriteSourceSize.h),
                    n[o].rotated && (i.rotated = !0),
                    r++;
                return s
            },
            XMLData: function(t, e) {
                if (e.getElementsByTagName("TextureAtlas")) {
                    for (var i, s, n, r, o, a, h, l, c, u, d, p = new W.FrameData, f = e.getElementsByTagName("SubTexture"), g = 0; g < f.length; g++)
                        s = (n = f[g].attributes).name.value,
                        r = parseInt(n.x.value, 10),
                        o = parseInt(n.y.value, 10),
                        a = parseInt(n.width.value, 10),
                        h = parseInt(n.height.value, 10),
                        c = l = null,
                        n.frameX && (l = Math.abs(parseInt(n.frameX.value, 10)),
                        c = Math.abs(parseInt(n.frameY.value, 10)),
                        u = parseInt(n.frameWidth.value, 10),
                        d = parseInt(n.frameHeight.value, 10)),
                        i = p.addFrame(new W.Frame(g,r,o,a,h,s)),
                        null === l && null === c || i.setTrim(!0, a, h, l, c, u, d);
                    return p
                }
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
            }
        },
        W.Cache = function(t) {
            this.game = t,
            this.autoResolveURL = !1,
            this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {},
                compressedTexture: {}
            },
            this._urlMap = {},
            this._urlResolver = new Image,
            this._urlTemp = null,
            this.onSoundUnlock = new W.Signal,
            this._cacheMap = [],
            this._cacheMap[W.Cache.CANVAS] = this._cache.canvas,
            this._cacheMap[W.Cache.IMAGE] = this._cache.image,
            this._cacheMap[W.Cache.TEXTURE] = this._cache.texture,
            this._cacheMap[W.Cache.SOUND] = this._cache.sound,
            this._cacheMap[W.Cache.TEXT] = this._cache.text,
            this._cacheMap[W.Cache.PHYSICS] = this._cache.physics,
            this._cacheMap[W.Cache.TILEMAP] = this._cache.tilemap,
            this._cacheMap[W.Cache.BINARY] = this._cache.binary,
            this._cacheMap[W.Cache.BITMAPDATA] = this._cache.bitmapData,
            this._cacheMap[W.Cache.BITMAPFONT] = this._cache.bitmapFont,
            this._cacheMap[W.Cache.JSON] = this._cache.json,
            this._cacheMap[W.Cache.XML] = this._cache.xml,
            this._cacheMap[W.Cache.VIDEO] = this._cache.video,
            this._cacheMap[W.Cache.SHADER] = this._cache.shader,
            this._cacheMap[W.Cache.RENDER_TEXTURE] = this._cache.renderTexture,
            this.addDefaultImage(),
            this.addMissingImage()
        }
        ,
        W.Cache.CANVAS = 1,
        W.Cache.IMAGE = 2,
        W.Cache.TEXTURE = 3,
        W.Cache.SOUND = 4,
        W.Cache.TEXT = 5,
        W.Cache.PHYSICS = 6,
        W.Cache.TILEMAP = 7,
        W.Cache.BINARY = 8,
        W.Cache.BITMAPDATA = 9,
        W.Cache.BITMAPFONT = 10,
        W.Cache.JSON = 11,
        W.Cache.XML = 12,
        W.Cache.VIDEO = 13,
        W.Cache.SHADER = 14,
        W.Cache.RENDER_TEXTURE = 15,
        W.Cache.DEFAULT = null,
        W.Cache.MISSING = null,
        W.Cache.prototype = {
            addCompressedTextureMetaData: function(t, e, i, s) {
                this.checkImageKey(t) && this.removeImage(t);
                var n = i in W.LoaderParser ? W.LoaderParser[i](s) : s
                  , r = {
                    key: t,
                    url: e,
                    data: n,
                    base: new PIXI.BaseTexture(n,null,this.game.resolution),
                    frame: new W.Frame(0,0,0,n.width,n.height,t),
                    frameData: new W.FrameData,
                    fileFormat: i
                };
                return r.frameData.addFrame(new W.Frame(0,0,0,n.width,n.height,e)),
                this._cache.image[t] = r,
                this._resolveURL(e, r),
                r
            },
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")),
                this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(t, e, i) {
                this.checkImageKey(t) && this.removeImage(t),
                !1 === i.complete && console.warn('Phaser.Cache.addImage: Image "' + t + "\" hasn't been retrieved yet");
                var s = {
                    key: t,
                    url: e,
                    data: i,
                    base: new PIXI.BaseTexture(i,null,this.game.resolution),
                    frame: new W.Frame(0,0,0,i.width,i.height,t),
                    frameData: new W.FrameData
                };
                return s.frameData.addFrame(new W.Frame(0,0,0,i.width,i.height,e)),
                this._cache.image[t] = s,
                this._resolveURL(e, s),
                "__default" === t ? W.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (W.Cache.MISSING = new PIXI.Texture(s.base)),
                s
            },
            addDefaultImage: function() {
                var e = this
                  , i = new Image;
                i.onload = function() {
                    var t = e.addImage("__default", null, i);
                    t.base.skipRender = !0,
                    W.Cache.DEFAULT = new PIXI.Texture(t.base),
                    i.onload = null
                }
                ,
                i.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="
            },
            addMissingImage: function() {
                var e = this
                  , i = new Image;
                i.onload = function() {
                    var t = e.addImage("__missing", null, i);
                    W.Cache.MISSING = new PIXI.Texture(t.base),
                    i.onload = null
                }
                ,
                i.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="
            },
            addSound: function(t, e, i, s, n) {
                void 0 === s && (n = !(s = !0)),
                void 0 === n && (n = !(s = !1));
                var r = !1;
                n && (r = !0),
                this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: r,
                    webAudio: s,
                    audioTag: n,
                    locked: this.game.sound.touchLocked
                },
                this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                },
                this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, s) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: s
                },
                this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, s) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: s
                },
                this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(t, e, i) {
                return e.key = t,
                void 0 === i && (i = new W.FrameData).addFrame(e.textureFrame),
                this._cache.bitmapData[t] = {
                    data: e,
                    frameData: i
                },
                e
            },
            addBitmapFont: function(t, e, i, s, n, r, o) {
                var a = {
                    url: e,
                    data: i,
                    font: null,
                    base: new PIXI.BaseTexture(i,null,this.game.resolution)
                };
                void 0 === r && (r = 0),
                void 0 === o && (o = 0),
                a.font = "json" === n ? W.LoaderParser.jsonBitmapFont(s, a.base, r, o, !1, this.game.resolution) : W.LoaderParser.xmlBitmapFont(s, a.base, r, o, !1, this.game.resolution),
                this._cache.bitmapFont[t] = a,
                this._resolveURL(e, a)
            },
            addBitmapFontFromAtlas: function(t, e, i, s, n, r, o) {
                var a = this.getFrameByName(e, i);
                if (a) {
                    var h, l = {
                        font: null,
                        base: this.getBaseTexture(e),
                        frame: a
                    };
                    void 0 === r && (r = 0),
                    void 0 === o && (o = 0),
                    "json" === n ? (h = this.getJSON(s),
                    l.font = W.LoaderParser.jsonBitmapFont(h, l.base, r, o, a, this.game.resolution)) : (h = this.getXML(s),
                    l.font = W.LoaderParser.xmlBitmapFont(h, l.base, r, o, a, this.game.resolution)),
                    this._cache.bitmapFont[t] = l
                }
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                },
                this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                },
                this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, s) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: s,
                    locked: !0
                },
                this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                },
                this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(t, e) {
                this._cache.renderTexture[t] = {
                    texture: e,
                    frame: new W.Frame(0,0,0,e.width,e.height,"","")
                }
            },
            addSpriteSheet: function(t, e, i, s, n, r, o, a, h) {
                void 0 === r && (r = -1),
                void 0 === o && (o = 0),
                void 0 === a && (a = 0);
                var l = {
                    key: t,
                    url: e,
                    data: i,
                    frameWidth: s,
                    frameHeight: n,
                    margin: o,
                    spacing: a,
                    base: new PIXI.BaseTexture(i,null,this.game.resolution),
                    frameData: W.AnimationParser.spriteSheet(this.game, i, s, n, r, o, a, h)
                };
                this._cache.image[t] = l,
                this._resolveURL(e, l)
            },
            addTextureAtlas: function(t, e, i, s, n) {
                var r = {
                    key: t,
                    url: e,
                    data: i,
                    base: new PIXI.BaseTexture(i,null,this.game.resolution)
                };
                n === W.Loader.TEXTURE_ATLAS_XML_STARLING ? r.frameData = W.AnimationParser.XMLData(this.game, s, t) : n === W.Loader.TEXTURE_ATLAS_JSON_PYXEL ? r.frameData = W.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? r.frameData = W.AnimationParser.JSONData(this.game, s, t) : r.frameData = W.AnimationParser.JSONDataHash(this.game, s, t),
                this._cache.image[t] = r,
                this._resolveURL(e, r)
            },
            reloadSound: function(t) {
                var e = this
                  , i = this.getSound(t);
                i && (i.data.src = i.url,
                i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1),
                i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1,
                this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var s = this.getSound(t);
                s && (s[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e,
                i.decoded = !0,
                i.isDecoding = !1
            },
            isSoundDecoded: function(t) {
                var e = this.getItem(t, W.Cache.SOUND, "isSoundDecoded");
                if (e)
                    return e.decoded
            },
            isSoundReady: function(t) {
                var e = this.getItem(t, W.Cache.SOUND, "isSoundDecoded");
                if (e)
                    return e.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(t) {
                return this.checkKey(W.Cache.CANVAS, t)
            },
            checkImageKey: function(t) {
                return this.checkKey(W.Cache.IMAGE, t)
            },
            checkTextureKey: function(t) {
                return this.checkKey(W.Cache.TEXTURE, t)
            },
            checkSoundKey: function(t) {
                return this.checkKey(W.Cache.SOUND, t)
            },
            checkTextKey: function(t) {
                return this.checkKey(W.Cache.TEXT, t)
            },
            checkPhysicsKey: function(t) {
                return this.checkKey(W.Cache.PHYSICS, t)
            },
            checkTilemapKey: function(t) {
                return this.checkKey(W.Cache.TILEMAP, t)
            },
            checkBinaryKey: function(t) {
                return this.checkKey(W.Cache.BINARY, t)
            },
            checkBitmapDataKey: function(t) {
                return this.checkKey(W.Cache.BITMAPDATA, t)
            },
            checkBitmapFontKey: function(t) {
                return this.checkKey(W.Cache.BITMAPFONT, t)
            },
            checkJSONKey: function(t) {
                return this.checkKey(W.Cache.JSON, t)
            },
            checkXMLKey: function(t) {
                return this.checkKey(W.Cache.XML, t)
            },
            checkVideoKey: function(t) {
                return this.checkKey(W.Cache.VIDEO, t)
            },
            checkShaderKey: function(t) {
                return this.checkKey(W.Cache.SHADER, t)
            },
            checkRenderTextureKey: function(t) {
                return this.checkKey(W.Cache.RENDER_TEXTURE, t)
            },
            getItem: function(t, e, i, s) {
                return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'),
                null)
            },
            getCanvas: function(t) {
                return this.getItem(t, W.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(t, e) {
                null == t && (t = "__default"),
                void 0 === e && (e = !1);
                var i = this.getItem(t, W.Cache.IMAGE, "getImage");
                return null === i && (i = this.getItem("__missing", W.Cache.IMAGE, "getImage")),
                e ? i : i.data
            },
            getTextureFrame: function(t) {
                return this.getItem(t, W.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(t) {
                return this.getItem(t, W.Cache.SOUND, "getSound")
            },
            getSoundData: function(t) {
                return this.getItem(t, W.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(t) {
                return this.getItem(t, W.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(t, e, i) {
                var s = this.getItem(t, W.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === s || null == e)
                    return s;
                if (s[e]) {
                    var n = s[e];
                    if (!n || !i)
                        return n;
                    for (var r in n)
                        if ((r = n[r]).fixtureKey === i)
                            return r;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + i + " in " + t + '"')
                } else
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                return null
            },
            getTilemapData: function(t) {
                return this.getItem(t, W.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(t) {
                return this.getItem(t, W.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(t) {
                return this.getItem(t, W.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(t) {
                return this.getItem(t, W.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(t, e) {
                var i = this.getItem(t, W.Cache.JSON, "getJSON", "data");
                return i ? e ? W.Utils.extend(!0, Array.isArray(i) ? [] : {}, i) : i : null
            },
            getXML: function(t) {
                return this.getItem(t, W.Cache.XML, "getXML", "data")
            },
            getVideo: function(t) {
                return this.getItem(t, W.Cache.VIDEO, "getVideo")
            },
            getShader: function(t) {
                return this.getItem(t, W.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(t) {
                return this.getItem(t, W.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(t, e) {
                return void 0 === e && (e = W.Cache.IMAGE),
                this.getItem(t, e, "getBaseTexture", "base")
            },
            getFrame: function(t, e) {
                return void 0 === e && (e = W.Cache.IMAGE),
                this.getItem(t, e, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(t, e) {
                return void 0 === e && (e = W.Cache.IMAGE),
                this.getItem(t, e, "getFrameData", "frameData")
            },
            hasFrameData: function(t, e) {
                return void 0 === e && (e = W.Cache.IMAGE),
                null !== this.getItem(t, e, "", "frameData")
            },
            updateFrameData: function(t, e, i) {
                void 0 === i && (i = W.Cache.IMAGE),
                this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
            },
            getFrameByIndex: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'),
                null)
            },
            getKeys: function(t) {
                void 0 === t && (t = W.Cache.IMAGE);
                var e = [];
                if (this._cacheMap[t])
                    for (var i in this._cacheMap[t])
                        "__default" !== i && "__missing" !== i && e.push(i);
                return e
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(),
                delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.image[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image)
                    this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t,
                this._urlTemp = this._urlResolver.src,
                this._urlResolver.src = "",
                e && (this._urlMap[this._urlTemp] = e),
                this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e)
                        "__default" !== i && "__missing" !== i && (this.destroyItem(e[i]),
                        delete e[i])
                }
                this._urlMap = null,
                this._urlResolver = null,
                this._urlTemp = null
            },
            destroyItem: function(t) {
                t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(),
                t.data && t.data.destroy && t.data.destroy(),
                t.frameData && t.frameData.destroy && t.frameData.destroy(),
                t.texture && t.texture.destroy && t.texture.destroy(!0))
            }
        },
        W.Cache.prototype.constructor = W.Cache,
        W.Loader = function(t) {
            this.game = t,
            this.cache = t.cache,
            this.resetLocked = !1,
            this.isLoading = !1,
            this.hasLoaded = !1,
            this.preloadSprite = null,
            this.crossOrigin = !1,
            this.baseURL = "",
            this.path = "",
            this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            },
            this.onLoadStart = new W.Signal,
            this.onLoadComplete = new W.Signal,
            this.onPackComplete = new W.Signal,
            this.onFileStart = new W.Signal,
            this.onFileComplete = new W.Signal,
            this.onFileError = new W.Signal,
            this.useXDomainRequest = !1,
            this._warnedAboutXDomainRequest = !1,
            this.enableParallel = !0,
            this.maxParallelDownloads = 4,
            this._withSyncPointDepth = 0,
            this._fileList = [],
            this._flightQueue = [],
            this._processingHead = 0,
            this._fileLoadStarted = !1,
            this._totalPackCount = 0,
            this._totalFileCount = 0,
            this._loadedPackCount = 0,
            this._loadedFileCount = 0
        }
        ,
        W.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0,
        W.Loader.TEXTURE_ATLAS_JSON_HASH = 1,
        W.Loader.TEXTURE_ATLAS_XML_STARLING = 2,
        W.Loader.PHYSICS_LIME_CORONA_JSON = 3,
        W.Loader.PHYSICS_PHASER_JSON = 4,
        W.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5,
        W.Loader.prototype = {
            setPreloadSprite: function(t, e) {
                e = e || 0,
                this.preloadSprite = {
                    sprite: t,
                    direction: e,
                    width: t.width,
                    height: t.height,
                    rect: null
                },
                this.preloadSprite.rect = 0 === e ? new W.Rectangle(0,0,1,t.height) : new W.Rectangle(0,0,t.width,1),
                t.crop(this.preloadSprite.rect),
                t.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return -1 < this.getAssetIndex(t, e)
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, s = 0; s < this._fileList.length; s++) {
                    var n = this._fileList[s];
                    if (n.type === t && n.key === e && (i = s,
                    !n.loaded && !n.loading))
                        break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return -1 < i && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1),
                this.resetLocked || (t && (this.preloadSprite = null),
                this.isLoading = !1,
                this._processingHead = 0,
                this._fileList.length = 0,
                this._flightQueue.length = 0,
                this._fileLoadStarted = !1,
                this._totalFileCount = 0,
                this._totalPackCount = 0,
                this._loadedPackCount = 0,
                this._loadedFileCount = 0,
                e && (this.onLoadStart.removeAll(),
                this.onLoadComplete.removeAll(),
                this.onPackComplete.removeAll(),
                this.onFileStart.removeAll(),
                this.onFileComplete.removeAll(),
                this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, s, n, r) {
                if (void 0 === n && (n = !1),
                void 0 === e || "" === e)
                    return console.warn("Phaser.Loader: Invalid or no key given of type " + t),
                    this;
                if (null == i) {
                    if (!r)
                        return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e),
                        this;
                    i = e + r
                }
                var o = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: 0 < this._withSyncPointDepth,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (s)
                    for (var a in s)
                        o[a] = s[a];
                var h = this.getAssetIndex(t, e);
                if (n && -1 < h) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(o),
                    this._totalFileCount++) : this._fileList[h] = o
                } else
                    -1 === h && (this._fileList.push(o),
                    this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, s) {
                return this.addToFileList(t, e, i, s, !0)
            },
            pack: function(t, e, i, s) {
                if (void 0 === e && (e = null),
                void 0 === i && (i = null),
                void 0 === s && (s = null),
                !e && !i)
                    return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."),
                    this;
                var n = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: s
                };
                i && ("string" == typeof i && (i = JSON.parse(i)),
                n.data = i || {},
                n.loaded = !0);
                for (var r = 0; r < this._fileList.length + 1; r++) {
                    var o = this._fileList[r];
                    if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                        this._fileList.splice(r, 0, n),
                        this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
            },
            imageFromBitmapData: function(t, e, i) {
                return this.image(t, e.canvas.toDataURL("image/png"), i)
            },
            texture: function(t, e, i) {
                if (this.game.renderType === W.WEBGL) {
                    var s, n = this.game.renderer.extensions.compression;
                    for (s in e)
                        if (s.toUpperCase()in n)
                            return this.addToFileList("texture", t, e[s], void 0, i, ".pvr")
                }
                return e.truecolor && this.addToFileList("image", t, e.truecolor, void 0, i, ".png"),
                this
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (var i = 0; i < t.length; i++)
                        this.image(t[i], e[i]);
                else
                    for (i = 0; i < t.length; i++)
                        this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, s) {
                return void 0 === i && (i = !1),
                !1 !== i && void 0 === s && (s = this),
                this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: s
                }, !1, ".js")
            },
            binary: function(t, e, i, s) {
                return void 0 === i && (i = !1),
                !1 !== i && void 0 === s && (s = i),
                this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: s
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, s, n, r, o, a) {
                return void 0 === n && (n = -1),
                void 0 === r && (r = 0),
                void 0 === o && (o = 0),
                void 0 === a && (a = 0),
                this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: s,
                    frameMax: n,
                    margin: r,
                    spacing: o,
                    skipFrames: a
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0),
                "string" == typeof e && (e = [e]),
                this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, s, n) {
                return this.game.sound.noAudio || (void 0 === i && (i = null),
                void 0 === s && (s = null),
                void 0 === n && (n = !0),
                this.audio(t, e, n),
                i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)),
                this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object")),
                this
            },
            audiosprite: function(t, e, i, s, n) {
                return this.audioSprite(t, e, i, s, n)
            },
            video: function(t, e, i, s) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"),
                void 0 === s && (s = !1),
                "string" == typeof e && (e = [e]),
                this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: s,
                    loadEvent: i
                })
            },
            tilemap: function(t, e, i, s) {
                if (void 0 === e && (e = null),
                void 0 === i && (i = null),
                void 0 === s && (s = W.Tilemap.CSV),
                e || i || (e = s === W.Tilemap.CSV ? t + ".csv" : t + ".json"),
                i) {
                    switch (s) {
                    case W.Tilemap.CSV:
                        break;
                    case W.Tilemap.TILED_JSON:
                        "string" == typeof i && (i = JSON.parse(i))
                    }
                    this.cache.addTilemap(t, null, i, s)
                } else
                    this.addToFileList("tilemap", t, e, {
                        format: s
                    });
                return this
            },
            physics: function(t, e, i, s) {
                return void 0 === e && (e = null),
                void 0 === i && (i = null),
                void 0 === s && (s = W.Physics.LIME_CORONA_JSON),
                e || i || (e = t + ".json"),
                i ? ("string" == typeof i && (i = JSON.parse(i)),
                this.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {
                    format: s
                }),
                this
            },
            bitmapFont: function(t, e, i, s, n, r) {
                if (null == e && (e = t + ".png"),
                void 0 === i && (i = null),
                void 0 === s && (s = null),
                null === i && null === s && (i = t + ".xml"),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                i)
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: i,
                        xSpacing: n,
                        ySpacing: r
                    });
                else if ("string" == typeof s) {
                    var o, a;
                    try {
                        o = JSON.parse(s)
                    } catch (t) {
                        a = this.parseXml(s)
                    }
                    if (!a && !o)
                        throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: o || a,
                        atlasType: o ? "json" : "xml",
                        xSpacing: n,
                        ySpacing: r
                    })
                }
                return this
            },
            atlasJSONArray: function(t, e, i, s) {
                return this.atlas(t, e, i, s, W.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(t, e, i, s) {
                return this.atlas(t, e, i, s, W.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(t, e, i, s) {
                return void 0 === i && (i = null),
                void 0 === s && (s = null),
                i || s || (i = t + ".xml"),
                this.atlas(t, e, i, s, W.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(t, e, i, s, n) {
                if (null == e && (e = t + ".png"),
                void 0 === i && (i = null),
                void 0 === s && (s = null),
                void 0 === n && (n = W.Loader.TEXTURE_ATLAS_JSON_ARRAY),
                i || s || (i = n === W.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"),
                i)
                    this.addToFileList("textureatlas", t, e, {
                        atlasURL: i,
                        format: n
                    });
                else {
                    switch (n) {
                    case W.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                        "string" == typeof s && (s = JSON.parse(s));
                        break;
                    case W.Loader.TEXTURE_ATLAS_XML_STARLING:
                        if ("string" == typeof s) {
                            var r = this.parseXml(s);
                            if (!r)
                                throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                            s = r
                        }
                    }
                    this.addToFileList("textureatlas", t, e, {
                        atlasURL: null,
                        atlasData: s,
                        format: n
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0),
                this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0,
                this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1,
                this.isLoading = !0,
                this.updateProgress(),
                this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (!this.isLoading)
                    return console.warn("Phaser.Loader - active loading canceled / reset"),
                    void this.finishedLoading(!0);
                for (var t = 0; t < this._flightQueue.length; t++) {
                    ((s = this._flightQueue[t]).loaded || s.error) && (this._flightQueue.splice(t, 1),
                    t--,
                    s.loading = !1,
                    s.requestUrl = null,
                    s.requestObject = null,
                    s.error && this.onFileError.dispatch(s.key, s),
                    "packfile" !== s.type ? (this._loadedFileCount++,
                    this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++,
                    this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)))
                }
                var e = !1
                  , i = this.enableParallel ? W.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
                for (t = this._processingHead; t < this._fileList.length; t++) {
                    var s;
                    if ("packfile" === (s = this._fileList[t]).type && !s.error && s.loaded && t === this._processingHead && (this.processPack(s),
                    this._loadedPackCount++,
                    this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)),
                    s.loaded || s.error ? t === this._processingHead && (this._processingHead = t + 1) : !s.loading && this._flightQueue.length < i && ("packfile" !== s.type || s.data ? e || (this._fileLoadStarted || (this._fileLoadStarted = !0,
                    this.onLoadStart.dispatch()),
                    this._flightQueue.push(s),
                    s.loading = !0,
                    this.onFileStart.dispatch(this.progress, s.key, s.url),
                    this.loadFile(s)) : (this._flightQueue.push(s),
                    s.loading = !0,
                    this.loadFile(s))),
                    !s.loaded && s.syncPoint && (e = !0),
                    this._flightQueue.length >= i || e && this._loadedPackCount === this._totalPackCount)
                        break
                }
                if (this.updateProgress(),
                this._processingHead >= this._fileList.length)
                    this.finishedLoading();
                else if (!this._flightQueue.length) {
                    console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                    var n = this;
                    setTimeout(function() {
                        n.finishedLoading(!0)
                    }, 2e3)
                }
            },
            finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0,
                this.isLoading = !1,
                t || this._fileLoadStarted || (this._fileLoadStarted = !0,
                this.onLoadStart.dispatch()),
                this.reset(),
                this.onLoadComplete.dispatch(),
                this.game.state.loadComplete())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""),
                t.loaded = !0,
                t.error = !!e,
                e && (t.errorMessage = e,
                console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)),
                this.processLoadQueue()
            },
            processPack: function(t) {
                var e = t.data[t.key];
                if (e)
                    for (var i = 0; i < e.length; i++) {
                        var s = e[i];
                        switch (s.type) {
                        case "image":
                            this.image(s.key, s.url, s.overwrite);
                            break;
                        case "text":
                            this.text(s.key, s.url, s.overwrite);
                            break;
                        case "json":
                            this.json(s.key, s.url, s.overwrite);
                            break;
                        case "xml":
                            this.xml(s.key, s.url, s.overwrite);
                            break;
                        case "script":
                            this.script(s.key, s.url, s.callback, t.callbackContext || this);
                            break;
                        case "binary":
                            this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                            break;
                        case "spritesheet":
                            this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing, s.skipFrames);
                            break;
                        case "video":
                            this.video(s.key, s.urls);
                            break;
                        case "audio":
                            this.audio(s.key, s.urls, s.autoDecode);
                            break;
                        case "audiosprite":
                            this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                            break;
                        case "tilemap":
                            this.tilemap(s.key, s.url, s.data, W.Tilemap[s.format]);
                            break;
                        case "physics":
                            this.physics(s.key, s.url, s.data, W.Loader[s.format]);
                            break;
                        case "bitmapFont":
                            this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                            break;
                        case "atlasJSONArray":
                            this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case "atlasJSONHash":
                            this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case "atlasXML":
                            this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case "atlas":
                            this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, W.Loader[s.format]);
                            break;
                        case "shader":
                            this.shader(s.key, s.url, s.overwrite)
                        }
                    }
                else
                    console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(t) {
                switch (t.type) {
                case "packfile":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                    break;
                case "image":
                case "spritesheet":
                case "textureatlas":
                case "bitmapfont":
                    this.loadImageTag(t);
                    break;
                case "audio":
                    t.url = this.getAudioURL(t.url),
                    t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                    break;
                case "video":
                    t.url = this.getVideoURL(t.url),
                    t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                    break;
                case "json":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                    break;
                case "xml":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                    break;
                case "tilemap":
                    t.format === W.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === W.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                    break;
                case "text":
                case "script":
                case "shader":
                case "physics":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                    break;
                case "texture":
                    "truecolor" === t.key.split("_").pop() ? this.loadImageTag(t) : this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete);
                    break;
                case "binary":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image,
                t.data.name = t.key,
                this.crossOrigin && (t.data.crossOrigin = this.crossOrigin),
                t.data.onload = function() {
                    t.data.onload && (t.data.onload = null,
                    t.data.onerror = null,
                    e.fileComplete(t))
                }
                ,
                t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null,
                    t.data.onerror = null,
                    e.fileError(t))
                }
                ,
                t.data.src = this.transformUrl(t.url, t),
                !this.game.device.firefox && t.data.complete && t.data.width && t.data.height && (t.data.onload = null,
                t.data.onerror = null,
                this.fileComplete(t))
            },
            loadVideoTag: function(t) {
                var e = this;
                t.data = document.createElement("video"),
                t.data.name = t.key,
                t.data.controls = !1,
                t.data.autoplay = !1;
                var i = function() {
                    t.data.removeEventListener(t.loadEvent, i, !1),
                    t.data.onerror = null,
                    t.data.canplay = !0,
                    W.GAMES[e.game.id].load.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener(t.loadEvent, i, !1),
                    t.data.onerror = null,
                    t.data.canplay = !1,
                    e.fileError(t)
                }
                ,
                t.data.addEventListener(t.loadEvent, i, !1),
                t.data.src = this.transformUrl(t.url, t),
                t.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked)
                    t.data = new Audio,
                    t.data.name = t.key,
                    t.data.preload = "auto",
                    t.data.src = this.transformUrl(t.url, t),
                    this.fileComplete(t);
                else {
                    t.data = new Audio,
                    t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1),
                        t.data.onerror = null,
                        e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1),
                        t.data.onerror = null,
                        e.fileError(t)
                    }
                    ,
                    t.data.preload = "auto",
                    t.data.src = this.transformUrl(t.url, t),
                    t.data.addEventListener("canplaythrough", i, !1),
                    t.data.load()
                }
            },
            xhrLoad: function(e, t, i, s, n) {
                if (this.useXDomainRequest && window.XDomainRequest)
                    this.xhrLoadWithXDR(e, t, i, s, n);
                else {
                    var r = new XMLHttpRequest;
                    r.open("GET", t, !0),
                    r.responseType = i,
                    !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith),
                    this.headers[e.type] && r.setRequestHeader("Accept", this.headers[e.type]),
                    n = n || this.fileError;
                    var o = this;
                    r.onload = function() {
                        try {
                            return 4 === r.readyState && 400 <= r.status && r.status <= 599 ? n.call(o, e, r) : s.call(o, e, r)
                        } catch (t) {
                            o.hasLoaded ? window.console && console.error(t) : o.asyncComplete(e, t.message || "Exception")
                        }
                    }
                    ,
                    r.onerror = function() {
                        try {
                            return n.call(o, e, r)
                        } catch (t) {
                            o.hasLoaded ? window.console && console.error(t) : o.asyncComplete(e, t.message || "Exception")
                        }
                    }
                    ,
                    e.requestObject = r,
                    e.requestUrl = t,
                    r.send()
                }
            },
            xhrLoadWithXDR: function(e, t, i, s, n) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(10 <= this.game.device.ieVersion) || (this._warnedAboutXDomainRequest = !0,
                console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
                var r = new window.XDomainRequest;
                r.open("GET", t, !0),
                r.responseType = i,
                r.timeout = 3e3,
                n = n || this.fileError;
                var o = this;
                r.onerror = function() {
                    try {
                        return n.call(o, e, r)
                    } catch (t) {
                        o.asyncComplete(e, t.message || "Exception")
                    }
                }
                ,
                r.ontimeout = function() {
                    try {
                        return n.call(o, e, r)
                    } catch (t) {
                        o.asyncComplete(e, t.message || "Exception")
                    }
                }
                ,
                r.onprogress = function() {}
                ,
                r.onload = function() {
                    try {
                        return 4 === r.readyState && 400 <= r.status && r.status <= 599 ? n.call(o, e, r) : s.call(o, e, r)
                    } catch (t) {
                        o.asyncComplete(e, t.message || "Exception")
                    }
                }
                ,
                e.requestObject = r,
                e.requestUrl = t,
                setTimeout(function() {
                    r.send()
                }, 0)
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type,
                        s = s.uri,
                        this.game.device.canPlayVideo(i))
                            return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:"))
                            return s;
                        if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))),
                        i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(),
                        this.game.device.canPlayVideo(i))
                            return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio)
                    return null;
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type,
                        s = s.uri,
                        this.game.device.canPlayAudio(i))
                            return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:"))
                            return s;
                        if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))),
                        i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(),
                        this.game.device.canPlayAudio(i))
                            return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status),
                i && (s = s + " (" + i + ")"),
                this.asyncComplete(t, s)
            },
            fileComplete: function(e, t) {
                var i = !0;
                switch (e.type) {
                case "packfile":
                    var s = JSON.parse(t.responseText);
                    e.data = s || {};
                    break;
                case "texture":
                    var n = /\.([^.]+)$/.exec(e.url.split("?", 1)[0])[1].toLowerCase();
                    null !== e.data ? this.cache.addCompressedTextureMetaData(e.key, e.url, n, e.data) : this.cache.addCompressedTextureMetaData(e.key, e.url, n, t.response);
                    break;
                case "image":
                    this.cache.addImage(e.key, e.url, e.data);
                    break;
                case "spritesheet":
                    this.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing, e.skipFrames);
                    break;
                case "textureatlas":
                    if (null == e.atlasURL)
                        this.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format);
                    else if (i = !1,
                    e.format === W.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format === W.Loader.TEXTURE_ATLAS_JSON_HASH || e.format === W.Loader.TEXTURE_ATLAS_JSON_PYXEL)
                        this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.jsonLoadComplete);
                    else {
                        if (e.format !== W.Loader.TEXTURE_ATLAS_XML_STARLING)
                            throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                        this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.xmlLoadComplete)
                    }
                    break;
                case "bitmapfont":
                    e.atlasURL ? (i = !1,
                    this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", function(t, e) {
                        var i;
                        try {
                            i = JSON.parse(e.responseText)
                        } catch (t) {}
                        i ? (t.atlasType = "json",
                        this.jsonLoadComplete(t, e)) : (t.atlasType = "xml",
                        this.xmlLoadComplete(t, e))
                    })) : this.cache.addBitmapFont(e.key, e.url, e.data, e.atlasData, e.atlasType, e.xSpacing, e.ySpacing);
                    break;
                case "video":
                    if (e.asBlob)
                        try {
                            e.data = t.response
                        } catch (t) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + e.key)
                        }
                    this.cache.addVideo(e.key, e.url, e.data, e.asBlob);
                    break;
                case "audio":
                    this.game.sound.usingWebAudio ? (e.data = t.response,
                    this.cache.addSound(e.key, e.url, e.data, !0, !1),
                    e.autoDecode && this.game.sound.decode(e.key)) : this.cache.addSound(e.key, e.url, e.data, !1, !0);
                    break;
                case "text":
                    e.data = t.responseText,
                    this.cache.addText(e.key, e.url, e.data);
                    break;
                case "shader":
                    e.data = t.responseText,
                    this.cache.addShader(e.key, e.url, e.data);
                    break;
                case "physics":
                    s = JSON.parse(t.responseText);
                    this.cache.addPhysicsData(e.key, e.url, s, e.format);
                    break;
                case "script":
                    e.data = document.createElement("script"),
                    e.data.language = "javascript",
                    e.data.type = "text/javascript",
                    e.data.defer = !1,
                    e.data.text = t.responseText,
                    document.head.appendChild(e.data),
                    e.callback && (e.data = e.callback.call(e.callbackContext, e.key, t.responseText));
                    break;
                case "binary":
                    e.callback ? e.data = e.callback.call(e.callbackContext, e.key, t.response) : e.data = t.response,
                    this.cache.addBinary(e.key, e.data)
                }
                i && this.asyncComplete(e)
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format),
                this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format),
                this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText
                  , s = this.parseXml(i);
                if (!s) {
                    var n = e.responseType || e.contentType;
                    return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"),
                    void this.asyncComplete(t, "invalid XML")
                }
                "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s),
                this.asyncComplete(t)
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser)
                        e = (new DOMParser).parseFromString(t, "text/xml");
                    else
                        (e = new ActiveXObject("Microsoft.XMLDOM")).async = "false",
                        e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress),
                this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        },
        Object.defineProperty(W.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return W.Math.clamp(t || 0, 0, 100)
            }
        }),
        Object.defineProperty(W.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }),
        W.Loader.prototype.constructor = W.Loader,
        W.LoaderParser = {
            bitmapFont: function(t, e, i, s, n, r) {
                return this.xmlBitmapFont(t, e, i, s, n, r)
            },
            xmlBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var o = {}
                  , a = t.getElementsByTagName("info")[0]
                  , h = t.getElementsByTagName("common")[0];
                o.font = a.getAttribute("face"),
                o.size = parseInt(a.getAttribute("size"), 10),
                o.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s,
                o.chars = {};
                for (var l = t.getElementsByTagName("char"), c = n ? n.x : 0, u = n ? n.y : 0, d = 0; d < l.length; d++) {
                    var p = parseInt(l[d].getAttribute("id"), 10);
                    o.chars[p] = {
                        x: c + parseInt(l[d].getAttribute("x"), 10),
                        y: u + parseInt(l[d].getAttribute("y"), 10),
                        width: parseInt(l[d].getAttribute("width"), 10),
                        height: parseInt(l[d].getAttribute("height"), 10),
                        xOffset: parseInt(l[d].getAttribute("xoffset"), 10) / r,
                        yOffset: parseInt(l[d].getAttribute("yoffset"), 10) / r,
                        xAdvance: (parseInt(l[d].getAttribute("xadvance"), 10) + i) / r,
                        kerning: {}
                    }
                }
                var f = t.getElementsByTagName("kerning");
                for (d = 0; d < f.length; d++) {
                    var g = parseInt(f[d].getAttribute("first"), 10)
                      , m = parseInt(f[d].getAttribute("second"), 10)
                      , y = parseInt(f[d].getAttribute("amount"), 10) / r;
                    o.chars[m].kerning[g] = y
                }
                return this.finalizeBitmapFont(e, o)
            },
            jsonBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var o = {
                    font: t.font.info._face,
                    size: parseInt(t.font.info._size, 10),
                    lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                    chars: {}
                }
                  , a = n ? n.x : 0
                  , h = n ? n.y : 0;
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10);
                    o.chars[e] = {
                        x: a + parseInt(t._x, 10),
                        y: h + parseInt(t._y, 10),
                        width: parseInt(t._width, 10),
                        height: parseInt(t._height, 10),
                        xOffset: parseInt(t._xoffset, 10) / r,
                        yOffset: parseInt(t._yoffset, 10) / r,
                        xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                        kerning: {}
                    }
                }),
                t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r
                }),
                this.finalizeBitmapFont(e, o)
            },
            finalizeBitmapFont: function(i, s) {
                return Object.keys(s.chars).forEach(function(t) {
                    var e = s.chars[t];
                    e.texture = new PIXI.Texture(i,new W.Rectangle(e.x,e.y,e.width,e.height))
                }),
                s
            },
            pvr: function(t) {
                var e, i = new Uint32Array(t.slice(0, 52)), s = new Uint8Array(t), n = null, r = i[3] << 32 | i[2], o = 0;
                if (55727696 === i[0] && 0 <= [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r)) {
                    switch (0 <= r && r <= 3 ? e = "PVRTC" : 7 <= r && r <= 11 ? e = "S3TC" : 6 == r && (e = "ETC1"),
                    r) {
                    case 0:
                        o = 35841;
                        break;
                    case 1:
                        o = 35843;
                        break;
                    case 2:
                        o = 35840;
                        break;
                    case 3:
                        o = 35842;
                        break;
                    case 6:
                        o = 36196;
                        break;
                    case 7:
                        o = 33777;
                        break;
                    case 9:
                        o = 33778;
                        break;
                    case 11:
                        o = 33779;
                        break;
                    default:
                        o = -1
                    }
                    n = {
                        complete: !0,
                        fileFormat: "PVR",
                        compressionAlgorithm: e,
                        flags: i[1],
                        pixelFormat: r,
                        colorSpace: i[4],
                        channelType: i[5],
                        height: i[6],
                        width: i[7],
                        depth: i[8],
                        numberOfSurfaces: i[9],
                        numberOfFaces: i[10],
                        numberOfMipmaps: i[11],
                        metaDataSize: i[12],
                        textureData: s.subarray(52 + i[12], s.byteLength),
                        glExtensionFormat: o
                    }
                }
                return n
            },
            dds: function(t) {
                var e = new Uint8Array(t)
                  , i = new Uint32Array(t)
                  , s = null;
                return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && "DX10" === (s = {
                    complete: !0,
                    fileFormat: "DDS",
                    compressionAlgorithm: "S3TC",
                    size: i[1],
                    flags: i[2],
                    height: i[3],
                    width: i[4],
                    pitch: i[5],
                    depth: i[6],
                    mipmapCount: i[7],
                    formatSize: i[19],
                    formatFlag: i[19],
                    formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                    formatBitCount: i[21],
                    formatRBitMask: i[22],
                    formatGBitMask: i[23],
                    formatBBitMask: i[24],
                    formatABitMask: i[25],
                    caps1: i[26],
                    caps2: i[27],
                    caps3: i[28],
                    caps4: i[29],
                    reserved2: i[30],
                    DXGIFormat: null,
                    resourceDimension: null,
                    miscFlag: null,
                    arraySize: null,
                    textureData: e.subarray(i[1] + 4, e.byteLength)
                }).formatFourCC && (s.DXGIFormat = i[31],
                s.resourceDimension = i[32],
                s.miscFlag = i[33],
                s.arraySize = i[34],
                s.miscFlag = i[35]),
                s
            },
            ktx: function(t) {
                var e = new Uint8Array(t)
                  , i = new Uint32Array(t)
                  , s = null
                  , n = 16 + i[15] / 4 | 0
                  , r = i[n]
                  , o = i[7]
                  , a = 0;
                if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && 0 <= [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(o)) {
                    switch (o) {
                    case 36196:
                        a = "ETC1";
                        break;
                    case 35840:
                    case 35841:
                    case 35842:
                    case 35843:
                        a = "PVRTC";
                        break;
                    case 33776:
                    case 33777:
                    case 33778:
                    case 33779:
                        a = "S3TC"
                    }
                    s = {
                        complete: !0,
                        fileFormat: "KTX",
                        compressionAlgorithm: a,
                        endianness: i[3],
                        glType: i[4],
                        glTypeSize: i[5],
                        glFormat: i[6],
                        glInternalFormat: i[7],
                        glBaseInternalFormat: i[8],
                        width: i[9],
                        height: i[10],
                        pixelDepth: i[11],
                        numberOfArrayElements: i[12],
                        numberOfFaces: i[13],
                        numberOfMipmapLevels: i[14],
                        bytesOfKeyValueData: i[15],
                        keyAndValueByteSize: i[16],
                        imageSize: r,
                        textureData: e.subarray(4 * (1 + n), r + 100)
                    }
                }
                return s
            },
            pkm: function(t) {
                var e = new Uint8Array(t)
                  , i = null;
                return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                    complete: !0,
                    fileFormat: "PKM",
                    compressionAlgorithm: "ETC1",
                    format: 65535 & (e[6] << 8 | e[7]),
                    width: 65535 & (e[8] << 8 | e[9]),
                    height: 65535 & (e[10] << 8 | e[11]),
                    originalWidth: 65535 & (e[12] << 8 | e[13]),
                    originalHeight: 65535 & (e[14] << 8 | e[15]),
                    textureData: e.subarray(16, e.length)
                }),
                i
            }
        },
        W.AudioSprite = function(t, e) {
            for (var i in this.game = t,
            this.key = e,
            this.config = this.game.cache.getJSON(e + "-audioatlas"),
            this.autoplayKey = null,
            this.autoplay = !1,
            this.sounds = {},
            this.config.spritemap) {
                var s = this.config.spritemap[i]
                  , n = this.game.add.sound(this.key);
                n.addMarker(i, s.start, s.end - s.start, null, s.loop),
                this.sounds[i] = n
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay,
            this.play(this.autoplayKey),
            this.autoplay = this.sounds[this.autoplayKey])
        }
        ,
        W.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1),
                this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t)
                    this.sounds[t].stop();
                else
                    for (var e in this.sounds)
                        this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        },
        W.AudioSprite.prototype.constructor = W.AudioSprite,
        W.Sound = function(t, e, i, s, n) {
            void 0 === i && (i = 1),
            void 0 === s && (s = !1),
            void 0 === n && (n = t.sound.connectToMaster),
            this.game = t,
            this.name = e,
            this.key = e,
            this.loop = s,
            this.markers = {},
            this.context = null,
            this.autoplay = !1,
            this.totalDuration = 0,
            this.startTime = 0,
            this.currentTime = 0,
            this.duration = 0,
            this.durationMS = 0,
            this.position = 0,
            this.stopTime = 0,
            this.paused = !1,
            this.pausedPosition = 0,
            this.pausedTime = 0,
            this.isPlaying = !1,
            this.currentMarker = "",
            this.fadeTween = null,
            this.pendingPlayback = !1,
            this.override = !1,
            this.allowMultiple = !1,
            this.usingWebAudio = this.game.sound.usingWebAudio,
            this.usingAudioTag = this.game.sound.usingAudioTag,
            this.externalNode = null,
            this.masterGainNode = null,
            this.gainNode = null,
            this._sound = null,
            this._markedToDelete = !1,
            this._removeFromSoundManager = !1,
            this.usingWebAudio ? (this.context = this.game.sound.context,
            this.masterGainNode = this.game.sound.masterGain,
            void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(),
            this.gainNode.gain.value = i * this.game.sound.volume,
            n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e),
            this.totalDuration = 0,
            this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)),
            this.onDecoded = new W.Signal,
            this.onPlay = new W.Signal,
            this.onPause = new W.Signal,
            this.onResume = new W.Signal,
            this.onLoop = new W.Signal,
            this.onStop = new W.Signal,
            this.onMute = new W.Signal,
            this.onMarkerComplete = new W.Signal,
            this.onFadeComplete = new W.Signal,
            this._volume = i,
            this._buffer = null,
            this._muted = !1,
            this._tempMarker = 0,
            this._tempPosition = 0,
            this._tempVolume = 0,
            this._tempPause = 0,
            this._muteVolume = 0,
            this._tempLoop = 0,
            this._paused = !1,
            this._onDecodedEventDispatched = !1
        }
        ,
        W.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key),
                this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, s, n) {
                null == i && (i = 1),
                null == s && (s = 1),
                void 0 === n && (n = !1),
                this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: s,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: n
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._sound.onended = null,
                this.isPlaying = !1,
                this.currentTime = this.durationMS,
                this.stop(),
                this._markedToDelete && (this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode),
                this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {},
                this.context = null,
                this._buffer = null,
                this.externalNode = null,
                this.onDecoded.dispose(),
                this.onPlay.dispose(),
                this.onPause.dispose(),
                this.onResume.dispose(),
                this.onLoop.dispose(),
                this.onStop.dispose(),
                this.onMute.dispose(),
                this.onMarkerComplete.dispose()))
            },
            update: function() {
                this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this),
                this._onDecodedEventDispatched = !0),
                this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1,
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)),
                this.isPlaying && (this.currentTime = this.game.time.time - this.startTime,
                this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this),
                this.isPlaying = !1,
                "" === this.currentMarker ? (this.currentTime = 0,
                this.startTime = this.game.time.time,
                this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this),
                this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this),
                "" === this.currentMarker && (this.currentTime = 0,
                this.startTime = this.game.time.time),
                this.isPlaying = !1,
                this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, s, n) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""),
                void 0 === n && (n = !0),
                this.isPlaying && !this.allowMultiple && !n && !this.override)
                    return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop)
                            this._sound.noteOff(0);
                        else
                            try {
                                this._sound.stop(0)
                            } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else
                        this.usingAudioTag && (this._sound.pause(),
                        this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                if ("" === t && 0 < Object.keys(this.markers).length)
                    return this;
                if ("" !== t) {
                    if (!this.markers[t])
                        return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"),
                        this;
                    this.currentMarker = t,
                    this.position = this.markers[t].start,
                    this.volume = this.markers[t].volume,
                    this.loop = this.markers[t].loop,
                    this.duration = this.markers[t].duration,
                    this.durationMS = this.markers[t].durationMS,
                    void 0 !== i && (this.volume = i),
                    void 0 !== s && (this.loop = s),
                    this._tempMarker = t,
                    this._tempPosition = this.position,
                    this._tempVolume = this.volume,
                    this._tempLoop = this.loop
                } else
                    e = e || 0,
                    void 0 === i && (i = this._volume),
                    void 0 === s && (s = this.loop),
                    this.position = Math.max(0, e),
                    this.volume = i,
                    this.loop = s,
                    this.duration = 0,
                    this.durationMS = 0,
                    this._tempMarker = t,
                    this._tempPosition = e,
                    this._tempVolume = i,
                    this._tempLoop = s;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(),
                this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
                this._buffer = this.game.cache.getSoundData(this.key),
                this._sound.buffer = this._buffer,
                this.loop && "" === t && (this._sound.loop = !0),
                this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)),
                this.totalDuration = this._sound.buffer.duration,
                0 === this.duration && (this.duration = this.totalDuration,
                this.durationMS = Math.ceil(1e3 * this.totalDuration)),
                void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration),
                this.isPlaying = !0,
                this.startTime = this.game.time.time,
                this.currentTime = 0,
                this.stopTime = this.startTime + this.durationMS,
                this.onPlay.dispatch(this)) : (this.pendingPlayback = !0,
                this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key),
                this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(),
                this.totalDuration = this._sound.duration,
                0 === this.duration && (this.duration = this.totalDuration,
                this.durationMS = 1e3 * this.totalDuration),
                this._sound.currentTime = this.position,
                this._sound.muted = this._muted,
                this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume,
                this.isPlaying = !0,
                this.startTime = this.game.time.time,
                this.currentTime = 0,
                this.stopTime = this.startTime + this.durationMS,
                this.onPlay.dispatch(this)) : this.pendingPlayback = !0,
                this
            },
            restart: function(t, e, i, s) {
                t = t || "",
                e = e || 0,
                i = i || 1,
                void 0 === s && (s = !1),
                this.play(t, e, i, s, !0)
            },
            pause: function() {
                this.isPlaying && this._sound && (this.paused = !0,
                this.pausedPosition = this.currentTime,
                this.pausedTime = this.game.time.time,
                this._tempPause = this._sound.currentTime,
                this.onPause.dispatch(this),
                this.stop())
            },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(),
                        this._sound.buffer = this._buffer,
                        this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
                        this.loop && (this._sound.loop = !0),
                        this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var e = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                    } else
                        this._sound.currentTime = this._tempPause,
                        this._sound.play();
                    this.isPlaying = !0,
                    this.paused = !1,
                    this.startTime += this.game.time.time - this.pausedTime,
                    this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop)
                            this._sound.noteOff(0);
                        else
                            try {
                                this._sound.stop(0)
                            } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else
                        this.usingAudioTag && (this._sound.pause(),
                        this._sound.currentTime = 0);
                if (this.pendingPlayback = !1,
                this.isPlaying = !1,
                !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this),
                    this.currentMarker = "",
                    null !== this.fadeTween && this.fadeTween.stop(),
                    this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !1),
                void 0 === i && (i = this.currentMarker),
                this.paused || (this.play(i, 0, 0, e),
                this.fadeTo(t, 1))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(t, e) {
                this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3),
                void 0 !== e ? (this.fadeTween = this.game.add.tween(this).to({
                    volume: e
                }, t, W.Easing.Linear.None, !0),
                this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume),
                0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0),
                this._markedToDelete = !0,
                this._removeFromSoundManager = t,
                this.stop(),
                t ? this.game.sound.remove(this) : (this.markers = {},
                this.context = null,
                this._buffer = null,
                this.externalNode = null,
                this.onDecoded.dispose(),
                this.onPlay.dispose(),
                this.onPause.dispose(),
                this.onResume.dispose(),
                this.onLoop.dispose(),
                this.onStop.dispose(),
                this.onMute.dispose(),
                this.onMarkerComplete.dispose())
            }
        },
        W.Sound.prototype.constructor = W.Sound,
        Object.defineProperty(W.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }),
        Object.defineProperty(W.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }),
        Object.defineProperty(W.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0,
                this._muteVolume = this._tempVolume,
                this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1,
                this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)),
                this.onMute.dispatch(this))
            }
        }),
        Object.defineProperty(W.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)),
                this._muted ? this._muteVolume = t : (this._tempVolume = t,
                this._volume = t,
                this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t))
            }
        }),
        W.SoundManager = function(t) {
            this.game = t,
            this.onSoundDecode = new W.Signal,
            this.onVolumeChange = new W.Signal,
            this.onMute = new W.Signal,
            this.onUnMute = new W.Signal,
            this.context = null,
            this.usingWebAudio = !1,
            this.usingAudioTag = !1,
            this.noAudio = !1,
            this.connectToMaster = !0,
            this.touchLocked = !1,
            this.channels = 32,
            this.muteOnPause = !0,
            this._codeMuted = !1,
            this._muted = !1,
            this._unlockSource = null,
            this._volume = 1,
            this._sounds = [],
            this._watchList = new W.ArraySet,
            this._watching = !1,
            this._watchCallback = null,
            this._watchContext = null
        }
        ,
        W.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1),
                window.PhaserGlobal) {
                    if (!0 === window.PhaserGlobal.disableAudio)
                        return this.noAudio = !0,
                        void (this.touchLocked = !1);
                    if (!0 === window.PhaserGlobal.disableWebAudio)
                        return this.usingAudioTag = !0,
                        void (this.touchLocked = !1)
                }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext)
                    this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext)
                    try {
                        this.context = new window.AudioContext
                    } catch (t) {
                        this.context = null,
                        this.usingWebAudio = !1,
                        this.touchLocked = !1
                    }
                else if (window.webkitAudioContext)
                    try {
                        this.context = new window.webkitAudioContext
                    } catch (t) {
                        this.context = null,
                        this.usingWebAudio = !1,
                        this.touchLocked = !1
                    }
                if (null === this.context) {
                    if (void 0 === window.Audio)
                        return void (this.noAudio = !0);
                    this.usingAudioTag = !0
                } else
                    this.usingWebAudio = !0,
                    void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(),
                    this.masterGain.gain.value = 1,
                    this.masterGain.connect(this.context.destination);
                this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (8 < this.game.device.iOSVersion ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this),
                this.touchLocked = !0)
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource)
                    return !0;
                if (this.usingAudioTag)
                    this.touchLocked = !1,
                    this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(),
                    this._unlockSource.buffer = t,
                    this._unlockSource.connect(this.context.destination),
                    void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(e, i) {
                i = i || null;
                var t = this.game.cache.getSoundData(e);
                if (t && !1 === this.game.cache.isSoundDecoded(e)) {
                    this.game.cache.updateSound(e, "isDecoding", !0);
                    var s = this;
                    try {
                        this.context.decodeAudioData(t, function(t) {
                            t && (s.game.cache.decodedSound(e, t),
                            s.onSoundDecode.dispatch(e, i))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(t, e, i) {
                "string" == typeof t && (t = [t]),
                this._watchList.reset();
                for (var s = 0; s < t.length; s++)
                    t[s]instanceof W.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                0 === this._watchList.total ? (this._watching = !1,
                e.call(i)) : (this._watching = !0,
                this._watchCallback = e,
                this._watchContext = i)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1,
                    this._unlockSource = null);
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e; )
                            this.game.cache.isSoundDecoded(e) && this._watchList.remove(e),
                            e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1,
                        this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(t, e, i, s) {
                void 0 === e && (e = 1),
                void 0 === i && (i = !1),
                void 0 === s && (s = this.connectToMaster);
                var n = new W.Sound(this.game,t,e,i,s);
                return this._sounds.push(n),
                n
            },
            addSprite: function(t) {
                return new W.AudioSprite(this.game,t)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--; )
                    if (this._sounds[e] === t)
                        return this._sounds[e].destroy(!1),
                        this._sounds.splice(e, 1),
                        !0;
                return !1
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--; )
                    this._sounds[e].key === t && (this._sounds[e].destroy(!1),
                    this._sounds.splice(e, 1),
                    i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var s = this.add(t, e, i);
                    return s.play(),
                    s
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0,
                    this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value,
                    this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1,
                    this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++)
                        this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++)
                    this._sounds[t] && this._sounds[t].destroy();
                this._sounds = [],
                this.onSoundDecode.dispose(),
                this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        },
        W.SoundManager.prototype.constructor = W.SoundManager,
        Object.defineProperty(W.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted)
                        return;
                    this._codeMuted = !0,
                    this.setMute()
                } else {
                    if (!this._muted)
                        return;
                    this._codeMuted = !1,
                    this.unsetMute()
                }
            }
        }),
        Object.defineProperty(W.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : 1 < t && (t = 1),
                this._volume !== t) {
                    if (this._volume = t,
                    this.usingWebAudio)
                        this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++)
                            this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }),
        W.ScaleManager = function(t, e, i) {
            this.game = t,
            this.dom = W.DOM,
            this.grid = null,
            this.width = 0,
            this.height = 0,
            this.minWidth = null,
            this.maxWidth = null,
            this.minHeight = null,
            this.maxHeight = null,
            this.offset = new W.Point,
            this.forceLandscape = !1,
            this.forcePortrait = !1,
            this.incorrectOrientation = !1,
            this._pageAlignHorizontally = !1,
            this._pageAlignVertically = !1,
            this.onOrientationChange = new W.Signal,
            this.enterIncorrectOrientation = new W.Signal,
            this.leaveIncorrectOrientation = new W.Signal,
            this.hasPhaserSetFullScreen = !1,
            this.fullScreenTarget = null,
            this._createdFullScreenTarget = null,
            this.onFullScreenInit = new W.Signal,
            this.onFullScreenChange = new W.Signal,
            this.onFullScreenError = new W.Signal,
            this.screenOrientation = this.dom.getScreenOrientation(),
            this.scaleFactor = new W.Point(1,1),
            this.scaleFactorInversed = new W.Point(1,1),
            this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            },
            this.bounds = new W.Rectangle,
            this.aspectRatio = 0,
            this.sourceAspectRatio = 0,
            this.event = null,
            this.windowConstraints = {
                right: "layout",
                bottom: ""
            },
            this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            },
            this._scaleMode = W.ScaleManager.NO_SCALE,
            this._fullScreenScaleMode = W.ScaleManager.NO_SCALE,
            this.parentIsWindow = !1,
            this.parentNode = null,
            this.parentScaleFactor = new W.Point(1,1),
            this.trackParentInterval = 2e3,
            this.onSizeChange = new W.Signal,
            this.onResize = null,
            this.onResizeContext = null,
            this._pendingScaleMode = null,
            this._fullScreenRestore = null,
            this._gameSize = new W.Rectangle,
            this._userScaleFactor = new W.Point(1,1),
            this._userScaleTrim = new W.Point(0,0),
            this._lastUpdate = 0,
            this._updateThrottle = 0,
            this._updateThrottleReset = 100,
            this._parentBounds = new W.Rectangle,
            this._tempBounds = new W.Rectangle,
            this._lastReportedCanvasSize = new W.Rectangle,
            this._lastReportedGameSize = new W.Rectangle,
            this._booted = !1,
            t.config && this.parseConfig(t.config),
            this.setupScale(e, i)
        }
        ,
        W.ScaleManager.EXACT_FIT = 0,
        W.ScaleManager.NO_SCALE = 1,
        W.ScaleManager.SHOW_ALL = 2,
        W.ScaleManager.RESIZE = 3,
        W.ScaleManager.USER_SCALE = 4,
        W.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS,
                this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new W.Point(0,1) : t.scrollTo = new W.Point(0,0)),
                this.game.device.desktop ? (t.orientationFallback = "screen",
                t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "",
                t.clickTrampoline = "");
                var e = this;
                this._orientationChange = function(t) {
                    return e.orientationChange(t)
                }
                ,
                this._windowResize = function(t) {
                    return e.windowResize(t)
                }
                ,
                window.addEventListener("orientationchange", this._orientationChange, !1),
                window.addEventListener("resize", this._windowResize, !1),
                this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return e.fullScreenChange(t)
                }
                ,
                this._fullScreenError = function(t) {
                    return e.fullScreenError(t)
                }
                ,
                document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
                document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1),
                document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1),
                document.addEventListener("fullscreenchange", this._fullScreenChange, !1),
                document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1),
                document.addEventListener("mozfullscreenerror", this._fullScreenError, !1),
                document.addEventListener("MSFullscreenError", this._fullScreenError, !1),
                document.addEventListener("fullscreenerror", this._fullScreenError, !1)),
                this.game.onResume.add(this._gameResumed, this),
                this.dom.getOffset(this.game.canvas, this.offset),
                this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
                this.setGameSize(this.game.width, this.game.height),
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
                W.FlexGrid && (this.grid = new W.FlexGrid(this,this.width,this.height)),
                this._booted = !0,
                null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode,
                this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode),
                void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode),
                t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
            },
            setupScale: function(t, e) {
                var i, s = new W.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? i = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (i = this.game.parent)),
                i ? (this.parentNode = i,
                this.parentIsWindow = !1,
                this.getParentBounds(this._parentBounds),
                s.width = this._parentBounds.width,
                s.height = this._parentBounds.height,
                this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null,
                this.parentIsWindow = !0,
                s.width = this.dom.visualBounds.width,
                s.height = this.dom.visualBounds.height,
                this.offset.set(0, 0));
                var n = 0
                  , r = 0;
                n = "number" == typeof t ? t : (this.parentScaleFactor.x = parseInt(t, 10) / 100,
                s.width * this.parentScaleFactor.x),
                r = "number" == typeof e ? e : (this.parentScaleFactor.y = parseInt(e, 10) / 100,
                s.height * this.parentScaleFactor.y),
                n = Math.floor(n),
                r = Math.floor(r),
                this._gameSize.setTo(0, 0, n, r),
                this.updateDimensions(n, r, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(t, e) {
                this._gameSize.setTo(0, 0, t, e),
                this.currentScaleMode !== W.ScaleManager.RESIZE && this.updateDimensions(t, e, !0),
                this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, s) {
                this._userScaleFactor.setTo(t, e),
                this._userScaleTrim.setTo(0 | i, 0 | s),
                this.queueUpdate(!0)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t,
                this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!W.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !W.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width
                      , e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e),
                    this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height),
                    this.grid && this.grid.onResize(t, e),
                    this.onSizeChange.dispatch(this, t, e),
                    this.currentScaleMode === W.ScaleManager.RESIZE && (this.game.state.resize(t, e),
                    this.game.load.resize(t, e))
                }
            },
            setMinMax: function(t, e, i, s) {
                this.minWidth = t,
                this.minHeight = e,
                void 0 !== i && (this.maxWidth = i),
                void 0 !== s && (this.maxHeight = s)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = 400 <= t ? 0 : 100,
                    this.dom.getOffset(this.game.canvas, this.offset);
                    var e = this._parentBounds.width
                      , i = this._parentBounds.height
                      , s = this.getParentBounds(this._parentBounds)
                      , n = s.width !== e || s.height !== i
                      , r = this.updateOrientationState();
                    (n || r) && (this.onResize && this.onResize.call(this.onResizeContext, this, s),
                    this.updateLayout(),
                    this.signalSizeChange());
                    var o = 2 * this._updateThrottle;
                    this._updateThrottle < t && (o = Math.min(t, this._updateThrottleReset)),
                    this._updateThrottle = W.Math.clamp(o, 25, this.trackParentInterval),
                    this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(),
                this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x,
                this.height = e * this.parentScaleFactor.y,
                this.game.width = this.width,
                this.game.height = this.height,
                this.sourceAspectRatio = this.width / this.height,
                this.updateScalingAndBounds(),
                i && (this.game.renderer.resize(this.width, this.height),
                this.game.camera.setSize(this.width, this.height),
                this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width,
                this.scaleFactor.y = this.game.height / this.height,
                this.scaleFactorInversed.x = this.width / this.game.width,
                this.scaleFactorInversed.y = this.height / this.game.height,
                this.aspectRatio = this.width / this.height,
                this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset),
                this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
                this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1),
                this.forceLandscape = t,
                this.forcePortrait = e,
                this.queueUpdate(!0)
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation
                  , e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
                this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation
                  , s = e !== this.incorrectOrientation;
                return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()),
                (i || s) && this.onOrientationChange.dispatch(this, t, e),
                i || s
            },
            orientationChange: function(t) {
                this.event = t,
                this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t,
                this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(),
                this.queueUpdate(!0)
            },
            updateLayout: function() {
                var t = this.currentScaleMode;
                if (t !== W.ScaleManager.RESIZE) {
                    if (this.scrollTop(),
                    this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"),
                    this.incorrectOrientation ? this.setMaximum() : t === W.ScaleManager.EXACT_FIT ? this.setExactFit() : t === W.ScaleManager.SHOW_ALL ? (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent && (this.setShowAll(!0),
                    this.resetCanvas()),
                    this.setShowAll()) : t === W.ScaleManager.NO_SCALE ? (this.width = this.game.width,
                    this.height = this.game.height) : t === W.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x,
                    this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y),
                    !this.compatibility.canExpandParent && (t === W.ScaleManager.SHOW_ALL || t === W.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width),
                        this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width,
                    this.height = 0 | this.height,
                    this.reflowCanvas()
                } else
                    this.reflowGame()
            },
            getParentBounds: function(t) {
                var e = t || new W.Rectangle
                  , i = this.boundingParent
                  , s = this.dom.visualBounds
                  , n = this.dom.layoutBounds;
                if (i) {
                    var r = i.getBoundingClientRect()
                      , o = i.offsetParent ? i.offsetParent.getBoundingClientRect() : i.getBoundingClientRect();
                    e.setTo(r.left - o.left, r.top - o.top, r.width, r.height);
                    var a = this.windowConstraints;
                    if (a.right) {
                        var h = "layout" === a.right ? n : s;
                        e.right = Math.min(e.right, h.width)
                    }
                    if (a.bottom) {
                        h = "layout" === a.bottom ? n : s;
                        e.bottom = Math.min(e.bottom, h.height)
                    }
                } else
                    e.setTo(0, 0, s.width, s.height);
                return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)),
                e
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds)
                  , s = this.game.canvas
                  , n = this.margin;
                if (t) {
                    n.left = n.right = 0;
                    var r = s.getBoundingClientRect();
                    if (this.width < i.width && !this.incorrectOrientation) {
                        var o = r.left - i.x
                          , a = i.width / 2 - this.width / 2
                          , h = (a = Math.max(a, 0)) - o;
                        n.left = Math.round(h)
                    }
                    s.style.marginLeft = n.left + "px",
                    0 !== n.left && (n.right = -(i.width - r.width - n.left),
                    s.style.marginRight = n.right + "px")
                }
                if (e) {
                    n.top = n.bottom = 0;
                    r = s.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        o = r.top - i.y,
                        a = i.height / 2 - this.height / 2,
                        h = (a = Math.max(a, 0)) - o;
                        n.top = Math.round(h)
                    }
                    s.style.marginTop = n.top + "px",
                    0 !== n.top && (n.bottom = -(i.height - r.height - n.top),
                    s.style.marginBottom = n.bottom + "px")
                }
                n.x = n.left,
                n.y = n.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = W.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width),
                this.height = W.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)),
                this.resetCanvas(),
                this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)),
                this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"),
                void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "",
                i.style.marginTop = "",
                i.style.marginRight = "",
                i.style.marginBottom = ""),
                i.style.width = t,
                i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0,
                this._parentBounds.height = 0),
                this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width,
                this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds), s = i.width, n = i.height;
                e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width),
                this.width = Math.round(this.game.width * e),
                this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width,
                this.height = t.height,
                this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)),
                this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0",
                t.style.padding = "0",
                t.style.background = "#000",
                t
            },
            startFullScreen: function(t, e) {
                if (this.isFullScreen)
                    return !1;
                if (this.compatibility.supportsFullScreen) {
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var i = this.game.input;
                        if (i.activePointer && i.activePointer !== i.mousePointer && (e || !1 !== e))
                            return void i.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                    }
                    void 0 !== t && this.game.renderType === W.CANVAS && (this.game.stage.smoothed = t);
                    var s = this.fullScreenTarget;
                    s || (this.cleanupCreatedTarget(),
                    this._createdFullScreenTarget = this.createFullScreenTarget(),
                    s = this._createdFullScreenTarget);
                    var n = {
                        targetElement: s
                    };
                    if (this.hasPhaserSetFullScreen = !0,
                    this.onFullScreenInit.dispatch(this, n),
                    this._createdFullScreenTarget) {
                        var r = this.game.canvas;
                        r.parentNode.insertBefore(s, r),
                        s.appendChild(r)
                    }
                    return this.game.device.fullscreenKeyboard ? s[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : s[this.game.device.requestFullscreen](),
                    !0
                }
                var o = this;
                setTimeout(function() {
                    o.fullScreenError()
                }, 10)
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1,
                document[this.game.device.cancelFullscreen](),
                !0)
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t),
                    e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(t) {
                var e = !!this._createdFullScreenTarget
                  , i = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? !e && this.fullScreenScaleMode !== W.ScaleManager.EXACT_FIT || i === this.game.canvas || (this._fullScreenRestore = {
                    targetWidth: i.style.width,
                    targetHeight: i.style.height
                },
                i.style.width = "100%",
                i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth,
                i.style.height = this._fullScreenRestore.targetHeight,
                this._fullScreenRestore = null),
                this.updateDimensions(this._gameSize.width, this._gameSize.height, !0),
                this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t,
                this.isFullScreen ? this.prepScreenMode(!0) : (this.prepScreenMode(!1),
                this.cleanupCreatedTarget()),
                this.updateLayout(),
                this.queueUpdate(!0),
                this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t,
                this.cleanupCreatedTarget(),
                console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"),
                this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, s) {
                if (void 0 === e && (e = this.width),
                void 0 === i && (i = this.height),
                void 0 === s && (s = !1),
                !t || !t.scale)
                    return t;
                if (t.scale.x = 1,
                t.scale.y = 1,
                t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0)
                    return t;
                var n = e
                  , r = t.height * e / t.width
                  , o = t.width * i / t.height
                  , a = i
                  , h = e < o;
                return (h = h ? s : !s) ? (t.width = Math.floor(n),
                t.height = Math.floor(r)) : (t.width = Math.floor(o),
                t.height = Math.floor(a)),
                t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this),
                window.removeEventListener("orientationchange", this._orientationChange, !1),
                window.removeEventListener("resize", this._windowResize, !1),
                this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
                document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1),
                document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1),
                document.removeEventListener("fullscreenchange", this._fullScreenChange, !1),
                document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1),
                document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1),
                document.removeEventListener("MSFullscreenError", this._fullScreenError, !1),
                document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        },
        W.ScaleManager.prototype.constructor = W.ScaleManager,
        Object.defineProperty(W.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0),
                this.queueUpdate(!0)),
                this._scaleMode = t),
                this._scaleMode
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1),
                this._fullScreenScaleMode = t,
                this.prepScreenMode(!0),
                this.queueUpdate(!0)) : this._fullScreenScaleMode = t),
                this._fullScreenScaleMode
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t,
                this.queueUpdate(!0))
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t,
                this.queueUpdate(!0))
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }),
        Object.defineProperty(W.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }),
        W.Utils.Debug = function(t) {
            this.game = t,
            this.sprite = null,
            this.bmd = null,
            this.canvas = null,
            this.context = null,
            this.font = "14px Courier",
            this.columnWidth = 100,
            this.lineHeight = 16,
            this.renderShadow = !0,
            this.currentX = 0,
            this.currentY = 0,
            this.currentAlpha = 1,
            this.dirty = !1
        }
        ,
        W.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === W.CANVAS ? this.context = this.game.context : (this.bmd = new W.BitmapData(this.game,"__DEBUG",this.game.width,this.game.height,!0),
                this.sprite = this.game.make.image(0, 0, this.bmd),
                this.game.stage.addChild(this.sprite),
                this.game.scale.onSizeChange.add(this.resize, this),
                this.canvas = W.CanvasPool.create(this, this.game.width, this.game.height),
                this.context = this.canvas.getContext("2d"))
            },
            resize: function(t, e, i) {
                this.bmd.resize(e, i),
                this.canvas.width = e,
                this.canvas.height = i
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(),
                this.bmd.draw(this.canvas, 0, 0),
                this.context.clearRect(0, 0, this.game.width, this.game.height),
                this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height),
                this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, s) {
                "number" != typeof t && (t = 0),
                "number" != typeof e && (e = 0),
                i = i || "rgb(255,255,255)",
                void 0 === s && (s = 0),
                this.currentX = t,
                this.currentY = e,
                this.currentColor = i,
                this.columnWidth = s,
                this.dirty = !0,
                this.context.save(),
                this.context.setTransform(1, 0, 0, 1, 0, 0),
                this.context.strokeStyle = i,
                this.context.fillStyle = i,
                this.context.font = this.font,
                this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++)
                    this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)",
                    this.context.fillText(arguments[e], t + 1, this.currentY + 1),
                    this.context.fillStyle = this.currentColor),
                    this.context.fillText(arguments[e], t, this.currentY),
                    t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(t, e, i, s) {
                this.start(e, i, s),
                this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked),
                this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback),
                this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding),
                this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying),
                this.line("Time: " + t.currentTime),
                this.line("Volume: " + t.volume + " Muted: " + t.mute),
                this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag),
                "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"),
                this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop),
                this.line("Position: " + t.position)),
                this.stop()
            },
            cameraInfo: function(t, e, i, s) {
                this.start(e, i, s),
                this.line("Camera (" + t.width + " x " + t.height + ")"),
                this.line("X: " + t.x + " Y: " + t.y),
                t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height),
                this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height),
                this.line("Total in view: " + t.totalInView),
                this.stop()
            },
            timer: function(t, e, i, s) {
                this.start(e, i, s),
                this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"),
                this.line("Next Tick: " + t.next + " Duration: " + t.duration),
                this.line("Paused: " + t.paused + " Length: " + t.length),
                this.stop()
            },
            pointer: function(t, e, i, s, n) {
                null != t && (void 0 === e && (e = !1),
                i = i || "rgba(0,255,0,0.5)",
                s = s || "rgba(255,0,0,0.5)",
                !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n),
                this.context.beginPath(),
                this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI),
                t.active ? this.context.fillStyle = i : this.context.fillStyle = s,
                this.context.fill(),
                this.context.closePath(),
                this.context.beginPath(),
                this.context.moveTo(t.positionDown.x, t.positionDown.y),
                this.context.lineTo(t.position.x, t.position.y),
                this.context.lineWidth = 2,
                this.context.stroke(),
                this.context.closePath(),
                this.line("ID: " + t.id + " Active: " + t.active),
                this.line("World X: " + t.worldX + " World Y: " + t.worldY),
                this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame),
                this.line("Duration: " + t.duration + " ms"),
                this.line("is Down: " + t.isDown + " is Up: " + t.isUp),
                this.stop()))
            },
            spriteInputInfo: function(t, e, i, s) {
                this.start(e, i, s),
                this.line("Sprite Input: (" + t.width + " x " + t.height + ")"),
                this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)),
                this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)),
                this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)),
                this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()),
                this.stop()
            },
            key: function(t, e, i, s) {
                this.start(e, i, s, 150),
                this.line("Key:", t.keyCode, "isDown:", t.isDown),
                this.line("justDown:", t.justDown, "justUp:", t.justUp),
                this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)),
                this.stop()
            },
            inputInfo: function(t, e, i) {
                this.start(t, e, i),
                this.line("Input"),
                this.line("X: " + this.game.input.x + " Y: " + this.game.input.y),
                this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY),
                this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)),
                this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY),
                this.stop()
            },
            spriteBounds: function(t, e, i) {
                var s = t.getBounds();
                s.x += this.game.camera.x,
                s.y += this.game.camera.y,
                this.rectangle(s, e, i)
            },
            ropeSegments: function(t, e, i) {
                var s = t.segments
                  , n = this;
                s.forEach(function(t) {
                    n.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, s) {
                this.start(e, i, s),
                this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y),
                this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)),
                this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)),
                this.line("visible: " + t.visible + " in camera: " + t.inCamera),
                this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)),
                this.stop()
            },
            spriteCoords: function(t, e, i, s) {
                this.start(e, i, s, 100),
                t.name && this.line(t.name),
                this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)),
                this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)),
                this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)),
                this.stop()
            },
            lineInfo: function(t, e, i, s) {
                this.start(e, i, s, 80),
                this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)),
                this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)),
                this.line("length:", t.length.toFixed(2), "angle:", t.angle),
                this.stop()
            },
            pixel: function(t, e, i, s) {
                s = s || 2,
                this.start(),
                this.context.fillStyle = i,
                this.context.fillRect(t, e, s, s),
                this.stop()
            },
            geom: function(t, e, i, s) {
                void 0 === i && (i = !0),
                void 0 === s && (s = 0),
                e = e || "rgba(0,255,0,0.4)",
                this.start(),
                this.context.fillStyle = e,
                this.context.strokeStyle = e,
                t instanceof W.Rectangle || 1 === s ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof W.Circle || 2 === s ? (this.context.beginPath(),
                this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1),
                this.context.closePath(),
                i ? this.context.fill() : this.context.stroke()) : t instanceof W.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof W.Line || 4 === s) && (this.context.lineWidth = 1,
                this.context.beginPath(),
                this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y),
                this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y),
                this.context.closePath(),
                this.context.stroke()),
                this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0),
                e = e || "rgba(0, 255, 0, 0.4)",
                this.start(),
                i ? (this.context.fillStyle = e,
                this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e,
                this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)),
                this.stop()
            },
            text: function(t, e, i, s, n) {
                s = s || "rgb(255,255,255)",
                n = n || "16px Courier",
                this.start(),
                this.context.font = n,
                this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)",
                this.context.fillText(t, e + 1, i + 1)),
                this.context.fillStyle = s,
                this.context.fillText(t, e, i),
                this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)",
                this.start();
                var i = t.bounds;
                if (0 === t.nodes.length) {
                    this.context.strokeStyle = e,
                    this.context.strokeRect(i.x, i.y, i.width, i.height),
                    this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"),
                    this.context.strokeStyle = "rgb(0,255,0)";
                    for (var s = 0; s < t.objects.length; s++)
                        this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                } else
                    for (s = 0; s < t.nodes.length; s++)
                        this.quadTree(t.nodes[s]);
                this.stop()
            },
            body: function(t, e, i) {
                t.body && (this.start(),
                t.body.type === W.Physics.ARCADE ? W.Physics.Arcade.Body.render(this.context, t.body, e, i) : t.body.type === W.Physics.NINJA ? W.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === W.Physics.BOX2D && W.Physics.Box2D.renderBody(this.context, t.body, e),
                this.stop())
            },
            bodyInfo: function(t, e, i, s) {
                t.body && (this.start(e, i, s, 210),
                t.body.type === W.Physics.ARCADE ? W.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === W.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body),
                this.stop())
            },
            box2dWorld: function() {
                this.start(),
                this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0),
                this.game.physics.box2d.renderDebugDraw(this.context),
                this.stop()
            },
            box2dBody: function(t, e) {
                this.start(),
                W.Physics.Box2D.renderBody(this.context, t, e),
                this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world),
                t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t),
                t.children && 0 < t.children.length)
                    for (var e = 0; e < t.children.length; e++)
                        this.game.debug.displayList(t.children[e])
            },
            destroy: function() {
                W.CanvasPool.remove(this)
            }
        },
        W.Utils.Debug.prototype.constructor = W.Utils.Debug,
        W.DOM = {
            getOffset: function(t, e) {
                e = e || new W.Point;
                var i = t.getBoundingClientRect()
                  , s = W.DOM.scrollY
                  , n = W.DOM.scrollX
                  , r = document.documentElement.clientTop
                  , o = document.documentElement.clientLeft;
                return e.x = i.left + n - o,
                e.y = i.top + s - r,
                e
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0),
                !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e),
                i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e),
                i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width
                  , i = t.height;
                return "function" == typeof e && (e = e.call(t)),
                "function" == typeof i && (i = i.call(t)),
                e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && 0 <= i.bottom && 0 <= i.right && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen
                  , i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type)
                    return i.type;
                if ("string" == typeof i)
                    return i;
                var s = "portrait-primary"
                  , n = "landscape-primary";
                if ("screen" === t)
                    return e.height > e.width ? s : n;
                if ("viewport" === t)
                    return this.visualBounds.height > this.visualBounds.width ? s : n;
                if ("window.orientation" === t && "number" == typeof window.orientation)
                    return 0 === window.orientation || 180 === window.orientation ? s : n;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches)
                        return s;
                    if (window.matchMedia("(orientation: landscape)").matches)
                        return n
                }
                return this.visualBounds.height > this.visualBounds.width ? s : n
            },
            visualBounds: new W.Rectangle,
            layoutBounds: new W.Rectangle,
            documentBounds: new W.Rectangle
        },
        W.Device.whenReady(function(t) {
            var e = window && "pageXOffset"in window ? function() {
                return window.pageXOffset
            }
            : function() {
                return document.documentElement.scrollLeft
            }
              , i = window && "pageYOffset"in window ? function() {
                return window.pageYOffset
            }
            : function() {
                return document.documentElement.scrollTop
            }
            ;
            if (Object.defineProperty(W.DOM, "scrollX", {
                get: e
            }),
            Object.defineProperty(W.DOM, "scrollY", {
                get: i
            }),
            Object.defineProperty(W.DOM.visualBounds, "x", {
                get: e
            }),
            Object.defineProperty(W.DOM.visualBounds, "y", {
                get: i
            }),
            Object.defineProperty(W.DOM.layoutBounds, "x", {
                value: 0
            }),
            Object.defineProperty(W.DOM.layoutBounds, "y", {
                value: 0
            }),
            t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                function s() {
                    return Math.max(window.innerWidth, document.documentElement.clientWidth)
                }
                function n() {
                    return Math.max(window.innerHeight, document.documentElement.clientHeight)
                }
                Object.defineProperty(W.DOM.visualBounds, "width", {
                    get: s
                }),
                Object.defineProperty(W.DOM.visualBounds, "height", {
                    get: n
                }),
                Object.defineProperty(W.DOM.layoutBounds, "width", {
                    get: s
                }),
                Object.defineProperty(W.DOM.layoutBounds, "height", {
                    get: n
                })
            } else
                Object.defineProperty(W.DOM.visualBounds, "width", {
                    get: function() {
                        return window.innerWidth
                    }
                }),
                Object.defineProperty(W.DOM.visualBounds, "height", {
                    get: function() {
                        return window.innerHeight
                    }
                }),
                Object.defineProperty(W.DOM.layoutBounds, "width", {
                    get: function() {
                        var t = document.documentElement.clientWidth
                          , e = window.innerWidth;
                        return t < e ? e : t
                    }
                }),
                Object.defineProperty(W.DOM.layoutBounds, "height", {
                    get: function() {
                        var t = document.documentElement.clientHeight
                          , e = window.innerHeight;
                        return t < e ? e : t
                    }
                });
            Object.defineProperty(W.DOM.documentBounds, "x", {
                value: 0
            }),
            Object.defineProperty(W.DOM.documentBounds, "y", {
                value: 0
            }),
            Object.defineProperty(W.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }),
            Object.defineProperty(W.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0),
        W.ArraySet = function(t) {
            this.position = 0,
            this.list = t || []
        }
        ,
        W.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t),
                t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--; )
                    if (this.list[i][t] === e)
                        return this.list[i];
                return null
            },
            exists: function(t) {
                return -1 < this.list.indexOf(t)
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (-1 < e)
                    return this.list.splice(e, 1),
                    t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--; )
                    this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--; )
                    this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--; )
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0,
                this.list = []
            }
        },
        Object.defineProperty(W.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }),
        Object.defineProperty(W.ArraySet.prototype, "first", {
            get: function() {
                return (this.position = 0) < this.list.length ? this.list[0] : null
            }
        }),
        Object.defineProperty(W.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++,
                this.list[this.position]) : null
            }
        }),
        W.ArraySet.prototype.constructor = W.ArraySet,
        W.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t)
                    return null;
                void 0 === e && (e = 0),
                void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                return void 0 === t[s] ? null : t[s]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t)
                    return null;
                void 0 === e && (e = 0),
                void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                if (s < t.length) {
                    var n = t.splice(s, 1);
                    return void 0 === n[0] ? null : n[0]
                }
                return null
            },
            shuffle: function(t) {
                for (var e = t.length - 1; 0 < e; e--) {
                    var i = Math.floor(Math.random() * (e + 1))
                      , s = t[e];
                    t[e] = t[i],
                    t[i] = s
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                    s[n] = new Array(e);
                    for (var r = e - 1; -1 < r; r--)
                        s[n][r] = t[r][n]
                }
                return s
            },
            rotateMatrix: function(t, e) {
                if ("string" != typeof e && (e = (e % 360 + 360) % 360),
                90 === e || -270 === e || "rotateLeft" === e)
                    t = (t = W.ArrayUtils.transposeMatrix(t)).reverse();
                else if (-90 === e || 270 === e || "rotateRight" === e)
                    t = t.reverse(),
                    t = W.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(e) || "rotate180" === e) {
                    for (var i = 0; i < t.length; i++)
                        t[i].reverse();
                    t = t.reverse()
                }
                return t
            },
            findClosest: function(t, e) {
                if (!e.length)
                    return NaN;
                if (1 === e.length || t < e[0])
                    return e[0];
                for (var i = 1; e[i] < t; )
                    i++;
                var s = e[i - 1]
                  , n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return n - t <= t - s ? n : s
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e),
                e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e),
                e
            },
            rotate: function(t) {
                var e = t.shift();
                return t.push(e),
                e
            },
            numberArray: function(t, e) {
                for (var i = [], s = t; s <= e; s++)
                    i.push(s);
                return i
            },
            numberArrayStep: function(t, e, i) {
                null == t && (t = 0),
                null == e && (e = t,
                t = 0),
                void 0 === i && (i = 1);
                for (var s = [], n = Math.max(W.Math.roundAwayFromZero((e - t) / (i || 1)), 0), r = 0; r < n; r++)
                    s.push(t),
                    t += i;
                return s
            }
        },
        W.LinkedList = function() {
            this.next = null,
            this.prev = null,
            this.first = null,
            this.last = null,
            this.total = 0
        }
        ,
        W.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t,
                this.last = t,
                ((this.next = t).prev = this).total++) : ((this.last.next = t).prev = this.last,
                this.last = t,
                this.total++),
                t
            },
            reset: function() {
                this.first = null,
                this.last = null,
                this.next = null,
                this.prev = null,
                this.total = 0
            },
            remove: function(t) {
                if (1 === this.total)
                    return this.reset(),
                    void (t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev),
                t.prev && (t.prev.next = t.next),
                t.next && (t.next.prev = t.prev),
                t.next = t.prev = null,
                null === this.first && (this.last = null),
                this.total--
            },
            callAll: function(t) {
                if (this.first && this.last)
                    for (var e = this.first; e && e[t] && e[t].call(e),
                    (e = e.next) !== this.last.next; )
                        ;
            }
        },
        W.LinkedList.prototype.constructor = W.LinkedList,
        W.Create = function(t) {
            this.game = t,
            this.bmd = null,
            this.canvas = null,
            this.ctx = null,
            this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }
        ,
        W.Create.PALETTE_ARNE = 0,
        W.Create.PALETTE_JMP = 1,
        W.Create.PALETTE_CGA = 2,
        W.Create.PALETTE_C64 = 3,
        W.Create.PALETTE_JAPANESE_MACHINE = 4,
        W.Create.prototype = {
            texture: function(t, e, i, s, n) {
                void 0 === i && (i = 8),
                void 0 === s && (s = i),
                void 0 === n && (n = 0);
                var r = e[0].length * i
                  , o = e.length * s;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(),
                this.canvas = this.bmd.canvas,
                this.ctx = this.bmd.context),
                this.bmd.resize(r, o),
                this.bmd.clear();
                for (var a = 0; a < e.length; a++)
                    for (var h = e[a], l = 0; l < h.length; l++) {
                        var c = h[l];
                        "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[n][c],
                        this.ctx.fillRect(l * i, a * s, i, s))
                    }
                return this.bmd.generateTexture(t)
            },
            grid: function(t, e, i, s, n, r) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(),
                this.canvas = this.bmd.canvas,
                this.ctx = this.bmd.context),
                this.bmd.resize(e, i),
                this.ctx.fillStyle = r;
                for (var o = 0; o < i; o += n)
                    this.ctx.fillRect(0, o, e, 1);
                for (var a = 0; a < e; a += s)
                    this.ctx.fillRect(a, 0, 1, i);
                return this.bmd.generateTexture(t)
            }
        },
        W.Create.prototype.constructor = W.Create,
        W.FlexGrid = function(t, e, i) {
            this.game = t.game,
            this.manager = t,
            this.width = e,
            this.height = i,
            this.boundsCustom = new W.Rectangle(0,0,e,i),
            this.boundsFluid = new W.Rectangle(0,0,e,i),
            this.boundsFull = new W.Rectangle(0,0,e,i),
            this.boundsNone = new W.Rectangle(0,0,e,i),
            this.positionCustom = new W.Point(0,0),
            this.positionFluid = new W.Point(0,0),
            this.positionFull = new W.Point(0,0),
            this.positionNone = new W.Point(0,0),
            this.scaleCustom = new W.Point(1,1),
            this.scaleFluid = new W.Point(1,1),
            this.scaleFluidInversed = new W.Point(1,1),
            this.scaleFull = new W.Point(1,1),
            this.scaleNone = new W.Point(1,1),
            this.customWidth = 0,
            this.customHeight = 0,
            this.customOffsetX = 0,
            this.customOffsetY = 0,
            this.ratioH = e / i,
            this.ratioV = i / e,
            this.multiplier = 0,
            this.layers = []
        }
        ,
        W.FlexGrid.prototype = {
            setSize: function(t, e) {
                this.width = t,
                this.height = e,
                this.ratioH = t / e,
                this.ratioV = e / t,
                this.scaleNone = new W.Point(1,1),
                this.boundsNone.width = this.width,
                this.boundsNone.height = this.height,
                this.refresh()
            },
            createCustomLayer: function(t, e, i, s) {
                void 0 === s && (s = !0),
                this.customWidth = t,
                this.customHeight = e,
                this.boundsCustom.width = t,
                this.boundsCustom.height = e;
                var n = new W.FlexLayer(this,this.positionCustom,this.boundsCustom,this.scaleCustom);
                return s && this.game.world.add(n),
                this.layers.push(n),
                void 0 !== i && null !== typeof i && n.addMultiple(i),
                n
            },
            createFluidLayer: function(t, e) {
                void 0 === e && (e = !0);
                var i = new W.FlexLayer(this,this.positionFluid,this.boundsFluid,this.scaleFluid);
                return e && this.game.world.add(i),
                this.layers.push(i),
                void 0 !== t && null !== typeof t && i.addMultiple(t),
                i
            },
            createFullLayer: function(t) {
                var e = new W.FlexLayer(this,this.positionFull,this.boundsFull,this.scaleFluid);
                return this.game.world.add(e),
                this.layers.push(e),
                void 0 !== t && e.addMultiple(t),
                e
            },
            createFixedLayer: function(t) {
                var e = new W.FlexLayer(this,this.positionNone,this.boundsNone,this.scaleNone);
                return this.game.world.add(e),
                this.layers.push(e),
                void 0 !== t && e.addMultiple(t),
                e
            },
            reset: function() {
                for (var t = this.layers.length; t--; )
                    this.layers[t].persist || (this.layers[t].position = null,
                    this.layers[t].scale = null,
                    this.layers.slice(t, 1))
            },
            onResize: function(t, e) {
                this.ratioH = t / e,
                this.ratioV = e / t,
                this.refresh(t, e)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width),
                this.boundsFluid.width = Math.round(this.width * this.multiplier),
                this.boundsFluid.height = Math.round(this.height * this.multiplier),
                this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height),
                this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height),
                this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height),
                this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x),
                this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y),
                this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
                this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
                this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y),
                this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(t) {
                this.manager.scaleSprite(t),
                t.x = this.manager.bounds.centerX,
                t.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16),
                this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        },
        W.FlexGrid.prototype.constructor = W.FlexGrid,
        W.FlexLayer = function(t, e, i, s) {
            W.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1),
            this.manager = t.manager,
            this.grid = t,
            this.persist = !1,
            this.position = e,
            this.bounds = i,
            this.scale = s,
            this.topLeft = i.topLeft,
            this.topMiddle = new W.Point(i.halfWidth,0),
            this.topRight = i.topRight,
            this.bottomLeft = i.bottomLeft,
            this.bottomMiddle = new W.Point(i.halfWidth,i.bottom),
            this.bottomRight = i.bottomRight
        }
        ,
        W.FlexLayer.prototype = Object.create(W.Group.prototype),
        W.FlexLayer.prototype.constructor = W.FlexLayer,
        W.FlexLayer.prototype.resize = function() {}
        ,
        W.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16),
            this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1),
            this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"),
            this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"),
            this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }
        ,
        W.Color = {
            packPixel: function(t, e, i, s) {
                return W.Device.LITTLE_ENDIAN ? (s << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | s) >>> 0
            },
            unpackPixel: function(t, e, i, s) {
                return null == e && (e = W.Color.createColor()),
                null == i && (i = !1),
                null == s && (s = !1),
                W.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24,
                e.b = (16711680 & t) >>> 16,
                e.g = (65280 & t) >>> 8,
                e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24,
                e.g = (16711680 & t) >>> 16,
                e.b = (65280 & t) >>> 8,
                e.a = 255 & t),
                e.color = t,
                e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")",
                i && W.Color.RGBtoHSL(e.r, e.g, e.b, e),
                s && W.Color.RGBtoHSV(e.r, e.g, e.b, e),
                e
            },
            fromRGBA: function(t, e) {
                return (e = e || W.Color.createColor()).r = (4278190080 & t) >>> 24,
                e.g = (16711680 & t) >>> 16,
                e.b = (65280 & t) >>> 8,
                e.a = 255 & t,
                e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")",
                e
            },
            toRGBA: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            toABGR: function(t, e, i, s) {
                return (s << 24 | i << 16 | e << 8 | t) >>> 0
            },
            hexToRGBArray: function(t) {
                return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
            },
            RGBArrayToHex: function(t) {
                return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
            },
            RGBtoHSL: function(t, e, i, s) {
                s = s || W.Color.createColor(t, e, i, 1),
                t /= 255,
                e /= 255,
                i /= 255;
                var n = Math.min(t, e, i)
                  , r = Math.max(t, e, i);
                if (s.h = 0,
                s.s = 0,
                s.l = (r + n) / 2,
                r !== n) {
                    var o = r - n;
                    s.s = .5 < s.l ? o / (2 - r - n) : o / (r + n),
                    r === t ? s.h = (e - i) / o + (e < i ? 6 : 0) : r === e ? s.h = (i - t) / o + 2 : r === i && (s.h = (t - e) / o + 4),
                    s.h /= 6
                }
                return s
            },
            HSLtoRGB: function(t, e, i, s) {
                if (s ? (s.r = i,
                s.g = i,
                s.b = i) : s = W.Color.createColor(i, i, i),
                0 !== e) {
                    var n = i < .5 ? i * (1 + e) : i + e - i * e
                      , r = 2 * i - n;
                    s.r = W.Color.hueToColor(r, n, t + 1 / 3),
                    s.g = W.Color.hueToColor(r, n, t),
                    s.b = W.Color.hueToColor(r, n, t - 1 / 3)
                }
                return s.r = Math.floor(255 * s.r | 0),
                s.g = Math.floor(255 * s.g | 0),
                s.b = Math.floor(255 * s.b | 0),
                W.Color.updateColor(s),
                s
            },
            RGBtoHSV: function(t, e, i, s) {
                s = s || W.Color.createColor(t, e, i, 255),
                t /= 255,
                e /= 255,
                i /= 255;
                var n = Math.min(t, e, i)
                  , r = Math.max(t, e, i)
                  , o = r - n;
                return s.h = 0,
                s.s = 0 === r ? 0 : o / r,
                (s.v = r) !== n && (r === t ? s.h = (e - i) / o + (e < i ? 6 : 0) : r === e ? s.h = (i - t) / o + 2 : r === i && (s.h = (t - e) / o + 4),
                s.h /= 6),
                s
            },
            HSVtoRGB: function(t, e, i, s) {
                var n, r, o;
                void 0 === s && (s = W.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                var a = Math.floor(6 * t)
                  , h = 6 * t - a
                  , l = i * (1 - e)
                  , c = i * (1 - h * e)
                  , u = i * (1 - (1 - h) * e);
                switch (a % 6) {
                case 0:
                    n = i,
                    r = u,
                    o = l;
                    break;
                case 1:
                    n = c,
                    r = i,
                    o = l;
                    break;
                case 2:
                    n = l,
                    r = i,
                    o = u;
                    break;
                case 3:
                    n = l,
                    r = c,
                    o = i;
                    break;
                case 4:
                    n = u,
                    r = l,
                    o = i;
                    break;
                case 5:
                    n = i,
                    r = l,
                    o = c
                }
                return s.r = Math.floor(255 * n),
                s.g = Math.floor(255 * r),
                s.b = Math.floor(255 * o),
                W.Color.updateColor(s),
                s
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1),
                1 < i && (i -= 1),
                i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(t, e, i, s, n, r, o, a) {
                var h = {
                    r: t || 0,
                    g: e || 0,
                    b: i || 0,
                    a: s || 1,
                    h: n || 0,
                    s: r || 0,
                    l: o || 0,
                    v: a || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return W.Color.updateColor(h)
            },
            updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")",
                t.color = W.Color.getColor(t.r, t.g, t.b),
                t.color32 = W.Color.getColor32(255 * t.a, t.r, t.g, t.b),
                t
            },
            getColor32: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(t, e, i, s, n) {
                return void 0 === s && (s = 255),
                void 0 === n && (n = "#"),
                "#" === n ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + W.Color.componentToHex(s) + W.Color.componentToHex(t) + W.Color.componentToHex(e) + W.Color.componentToHex(i)
            },
            hexToRGB: function(t) {
                var e = W.Color.hexToColor(t);
                if (e)
                    return W.Color.getColor32(e.a, e.r, e.g, e.b)
            },
            hexToColor: function(t, e) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                    return e + e + i + i + s + s
                });
                var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if (i) {
                    var s = parseInt(i[1], 16)
                      , n = parseInt(i[2], 16)
                      , r = parseInt(i[3], 16);
                    e ? (e.r = s,
                    e.g = n,
                    e.b = r) : e = W.Color.createColor(s, n, r)
                }
                return e
            },
            webToColor: function(t, e) {
                e = e || W.Color.createColor();
                var i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return i && (e.r = parseInt(i[1], 10),
                e.g = parseInt(i[2], 10),
                e.b = parseInt(i[3], 10),
                e.a = void 0 !== i[4] ? parseFloat(i[4]) : 1,
                W.Color.updateColor(e)),
                e
            },
            valueToColor: function(t, e) {
                if (e = e || W.Color.createColor(),
                "string" == typeof t)
                    return 0 === t.indexOf("rgb") ? W.Color.webToColor(t, e) : (e.a = 1,
                    W.Color.hexToColor(t, e));
                if ("number" != typeof t)
                    return e;
                var i = W.Color.getRGB(t);
                return e.r = i.r,
                e.g = i.g,
                e.b = i.b,
                e.a = i.a / 255,
                e
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(t, e) {
                void 0 === t && (t = 1),
                void 0 === e && (e = 1);
                for (var i = [], s = 0; s <= 359; s++)
                    i.push(W.Color.HSVtoRGB(s / 359, t, e));
                return i
            },
            HSLColorWheel: function(t, e) {
                void 0 === t && (t = .5),
                void 0 === e && (e = .5);
                for (var i = [], s = 0; s <= 359; s++)
                    i.push(W.Color.HSLtoRGB(s / 359, t, e));
                return i
            },
            interpolateColor: function(t, e, i, s, n) {
                void 0 === n && (n = 255);
                var r = W.Color.getRGB(t)
                  , o = W.Color.getRGB(e)
                  , a = (o.red - r.red) * s / i + r.red
                  , h = (o.green - r.green) * s / i + r.green
                  , l = (o.blue - r.blue) * s / i + r.blue;
                return W.Color.getColor32(n, a, h, l)
            },
            interpolateColorWithRGB: function(t, e, i, s, n, r) {
                var o = W.Color.getRGB(t)
                  , a = (e - o.red) * r / n + o.red
                  , h = (i - o.green) * r / n + o.green
                  , l = (s - o.blue) * r / n + o.blue;
                return W.Color.getColor(a, h, l)
            },
            interpolateRGB: function(t, e, i, s, n, r, o, a) {
                var h = (s - t) * a / o + t
                  , l = (n - e) * a / o + e
                  , c = (r - i) * a / o + i;
                return W.Color.getColor(h, l, c)
            },
            getRandomColor: function(t, e, i) {
                if (void 0 === t && (t = 0),
                void 0 === e && (e = 255),
                void 0 === i && (i = 255),
                255 < e || e < t)
                    return W.Color.getColor(255, 255, 255);
                var s = t + Math.round(Math.random() * (e - t))
                  , n = t + Math.round(Math.random() * (e - t))
                  , r = t + Math.round(Math.random() * (e - t));
                return W.Color.getColor32(i, s, n, r)
            },
            getRGB: function(t) {
                return 16777215 < t ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(t) {
                if ("object" == typeof t)
                    return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var e = W.Color.getRGB(t);
                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return t < e ? e : t
            },
            blendDarken: function(t, e) {
                return t < e ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(t, e) {
                return W.Color.blendOverlay(e, t)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(t, e) {
                return W.Color.blendAdd(t, e)
            },
            blendLinearBurn: function(t, e) {
                return W.Color.blendSubtract(t, e)
            },
            blendLinearLight: function(t, e) {
                return e < 128 ? W.Color.blendLinearBurn(t, 2 * e) : W.Color.blendLinearDodge(t, 2 * (e - 128))
            },
            blendVividLight: function(t, e) {
                return e < 128 ? W.Color.blendColorBurn(t, 2 * e) : W.Color.blendColorDodge(t, 2 * (e - 128))
            },
            blendPinLight: function(t, e) {
                return e < 128 ? W.Color.blendDarken(t, 2 * e) : W.Color.blendLighten(t, 2 * (e - 128))
            },
            blendHardMix: function(t, e) {
                return W.Color.blendVividLight(t, e) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(t, e) {
                return W.Color.blendReflect(e, t)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        },
        W.Physics = function(t, e) {
            e = e || {},
            this.game = t,
            this.config = e,
            this.arcade = null,
            this.p2 = null,
            this.ninja = null,
            this.box2d = null,
            this.chipmunk = null,
            this.matter = null,
            this.parseConfig()
        }
        ,
        W.Physics.ARCADE = 0,
        W.Physics.P2JS = 1,
        W.Physics.NINJA = 2,
        W.Physics.BOX2D = 3,
        W.Physics.CHIPMUNK = 4,
        W.Physics.MATTERJS = 5,
        W.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !W.Physics.hasOwnProperty("Arcade") || (this.arcade = new W.Physics.Arcade(this.game)),
                this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && W.Physics.hasOwnProperty("Ninja") && (this.ninja = new W.Physics.Ninja(this.game)),
                this.config.hasOwnProperty("p2") && !0 === this.config.p2 && W.Physics.hasOwnProperty("P2") && (this.p2 = new W.Physics.P2(this.game,this.config)),
                this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && W.Physics.hasOwnProperty("BOX2D") && (this.box2d = new W.Physics.BOX2D(this.game,this.config)),
                this.config.hasOwnProperty("matter") && !0 === this.config.matter && W.Physics.hasOwnProperty("Matter") && (this.matter = new W.Physics.Matter(this.game,this.config))
            },
            startSystem: function(t) {
                t === W.Physics.ARCADE ? this.arcade = new W.Physics.Arcade(this.game) : t === W.Physics.P2JS ? null === this.p2 ? this.p2 = new W.Physics.P2(this.game,this.config) : this.p2.reset() : t === W.Physics.NINJA ? this.ninja = new W.Physics.Ninja(this.game) : t === W.Physics.BOX2D ? null === this.box2d ? this.box2d = new W.Physics.Box2D(this.game,this.config) : this.box2d.reset() : t === W.Physics.MATTERJS && (null === this.matter ? this.matter = new W.Physics.Matter(this.game,this.config) : this.matter.reset())
            },
            enable: function(t, e, i) {
                void 0 === e && (e = W.Physics.ARCADE),
                void 0 === i && (i = !1),
                e === W.Physics.ARCADE ? this.arcade.enable(t) : e === W.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === W.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === W.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === W.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(),
                this.box2d && this.box2d.preUpdate(),
                this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(),
                this.box2d && this.box2d.update(),
                this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(),
                this.ninja && this.ninja.setBoundsToWorld(),
                this.p2 && this.p2.setBoundsToWorld(),
                this.box2d && this.box2d.setBoundsToWorld(),
                this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(),
                this.box2d && this.box2d.clear(),
                this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(),
                this.box2d && this.box2d.reset(),
                this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(),
                this.box2d && this.box2d.destroy(),
                this.matter && this.matter.destroy(),
                this.arcade = null,
                this.ninja = null,
                this.p2 = null,
                this.box2d = null,
                this.matter = null
            }
        },
        W.Physics.prototype.constructor = W.Physics,
        W.Physics.Arcade = function(t) {
            this.game = t,
            this.gravity = new W.Point,
            this.bounds = new W.Rectangle(0,0,t.world.width,t.world.height),
            this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            },
            this.maxObjects = 10,
            this.maxLevels = 4,
            this.OVERLAP_BIAS = 4,
            this.forceX = !1,
            this.sortDirection = W.Physics.Arcade.LEFT_RIGHT,
            this.skipQuadTree = !0,
            this.isPaused = !1,
            this.quadTree = new W.QuadTree(this.game.world.bounds.x,this.game.world.bounds.y,this.game.world.bounds.width,this.game.world.bounds.height,this.maxObjects,this.maxLevels),
            this._total = 0,
            this.setBoundsToWorld()
        }
        ,
        W.Physics.Arcade.prototype.constructor = W.Physics.Arcade,
        W.Physics.Arcade.SORT_NONE = 0,
        W.Physics.Arcade.LEFT_RIGHT = 1,
        W.Physics.Arcade.RIGHT_LEFT = 2,
        W.Physics.Arcade.TOP_BOTTOM = 3,
        W.Physics.Arcade.BOTTOM_TOP = 4,
        W.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, s) {
                this.bounds.setTo(t, e, i, s)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(t, e) {
                void 0 === e && (e = !0);
                var i = 1;
                if (Array.isArray(t))
                    for (i = t.length; i--; )
                        t[i]instanceof W.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]),
                        e && t[i].hasOwnProperty("children") && 0 < t[i].children.length && this.enable(t[i], !0));
                else
                    t instanceof W.Group ? this.enable(t.children, e) : (this.enableBody(t),
                    e && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, !0))
            },
            enableBody: function(t) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new W.Physics.Arcade.Body(t),
                t.parent && t.parent instanceof W.Group && t.parent.addToHash(t))
            },
            updateMotion: function(t) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e,
                t.rotation += t.angularVelocity * this.game.time.physicsElapsed,
                t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x),
                t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            },
            computeVelocity: function(t, e, i, s, n, r) {
                return void 0 === r && (r = 1e4),
                1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed),
                s ? i += s * this.game.time.physicsElapsed : n && (0 < i - (n *= this.game.time.physicsElapsed) ? i -= n : i + n < 0 ? i += n : i = 0),
                r < i ? i = r : i < -r && (i = -r),
                i
            },
            overlap: function(t, e, i, s, n) {
                if (i = i || null,
                s = s || null,
                n = n || i,
                this._total = 0,
                !Array.isArray(t) && Array.isArray(e))
                    for (var r = 0; r < e.length; r++)
                        this.collideHandler(t, e[r], i, s, n, !0);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        this.collideHandler(t[r], e, i, s, n, !0);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        for (var o = 0; o < e.length; o++)
                            this.collideHandler(t[r], e[o], i, s, n, !0);
                else
                    this.collideHandler(t, e, i, s, n, !0);
                return 0 < this._total
            },
            collide: function(t, e, i, s, n) {
                if (i = i || null,
                s = s || null,
                n = n || i,
                this._total = 0,
                !Array.isArray(t) && Array.isArray(e))
                    for (var r = 0; r < e.length; r++)
                        this.collideHandler(t, e[r], i, s, n, !1);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        this.collideHandler(t[r], e, i, s, n, !1);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        for (var o = 0; o < e.length; o++)
                            this.collideHandler(t[r], e[o], i, s, n, !1);
                else
                    this.collideHandler(t, e, i, s, n, !1);
                return 0 < this._total
            },
            sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            },
            sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            },
            sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            },
            sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            },
            sort: function(t, e) {
                null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection),
                e === W.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === W.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === W.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === W.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
            },
            collideHandler: function(t, e, i, s, n, r) {
                if (void 0 === e && t.physicsType === W.GROUP)
                    return this.sort(t),
                    void this.collideGroupVsSelf(t, i, s, n, r);
                t && e && t.exists && e.exists && (this.sortDirection !== W.Physics.Arcade.SORT_NONE && (t.physicsType === W.GROUP && this.sort(t),
                e.physicsType === W.GROUP && this.sort(e)),
                t.physicsType === W.SPRITE ? e.physicsType === W.SPRITE ? this.collideSpriteVsSprite(t, e, i, s, n, r) : e.physicsType === W.GROUP ? this.collideSpriteVsGroup(t, e, i, s, n, r) : e.physicsType === W.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, s, n, r) : t.physicsType === W.GROUP ? e.physicsType === W.SPRITE ? this.collideSpriteVsGroup(e, t, i, s, n, r) : e.physicsType === W.GROUP ? this.collideGroupVsGroup(t, e, i, s, n, r) : e.physicsType === W.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, n, r) : t.physicsType === W.TILEMAPLAYER && (e.physicsType === W.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, s, n, r) : e.physicsType === W.GROUP && this.collideGroupVsTilemapLayer(e, t, i, s, n, r)))
            },
            collideSpriteVsSprite: function(t, e, i, s, n, r) {
                return !(!t.body || !e.body) && (this.separate(t.body, e.body, s, n, r) && (i && i.call(n, t, e),
                this._total++),
                !0)
            },
            collideSpriteVsGroup: function(t, e, i, s, n, r) {
                if (0 !== e.length && t.body)
                    if (this.skipQuadTree || t.body.skipQuadTree)
                        for (var o = {}, a = 0; a < e.hash.length; a++) {
                            var h = e.hash[a];
                            if (h && h.exists && h.body) {
                                if (o = h.body.getBounds(o),
                                this.sortDirection === W.Physics.Arcade.LEFT_RIGHT) {
                                    if (t.body.right < o.x)
                                        break;
                                    if (o.right < t.body.x)
                                        continue
                                } else if (this.sortDirection === W.Physics.Arcade.RIGHT_LEFT) {
                                    if (t.body.x > o.right)
                                        break;
                                    if (o.x > t.body.right)
                                        continue
                                } else if (this.sortDirection === W.Physics.Arcade.TOP_BOTTOM) {
                                    if (t.body.bottom < o.y)
                                        break;
                                    if (o.bottom < t.body.y)
                                        continue
                                } else if (this.sortDirection === W.Physics.Arcade.BOTTOM_TOP) {
                                    if (t.body.y > o.bottom)
                                        break;
                                    if (o.y > t.body.bottom)
                                        continue
                                }
                                this.collideSpriteVsSprite(t, h, i, s, n, r)
                            }
                        }
                    else {
                        this.quadTree.clear(),
                        this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
                        this.quadTree.populate(e);
                        var l = this.quadTree.retrieve(t);
                        for (a = 0; a < l.length; a++)
                            this.separate(t.body, l[a], s, n, r) && (i && i.call(n, t, l[a].sprite),
                            this._total++)
                    }
            },
            collideGroupVsSelf: function(t, e, i, s, n) {
                if (0 !== t.length)
                    for (var r = 0; r < t.hash.length; r++) {
                        var o = {}
                          , a = t.hash[r];
                        if (a && a.exists && a.body) {
                            o = a.body.getBounds(o);
                            for (var h = r + 1; h < t.hash.length; h++) {
                                var l = {}
                                  , c = t.hash[h];
                                if (c && c.exists && c.body) {
                                    if (l = c.body.getBounds(l),
                                    this.sortDirection === W.Physics.Arcade.LEFT_RIGHT) {
                                        if (o.right < l.x)
                                            break;
                                        if (l.right < o.x)
                                            continue
                                    } else if (this.sortDirection === W.Physics.Arcade.RIGHT_LEFT) {
                                        if (o.x > l.right)
                                            continue;
                                        if (l.x > o.right)
                                            break
                                    } else if (this.sortDirection === W.Physics.Arcade.TOP_BOTTOM) {
                                        if (o.bottom < l.y)
                                            continue;
                                        if (l.bottom < o.y)
                                            break
                                    } else if (this.sortDirection === W.Physics.Arcade.BOTTOM_TOP) {
                                        if (o.y > l.bottom)
                                            continue;
                                        if (l.y > a.body.bottom)
                                            break
                                    }
                                    this.collideSpriteVsSprite(a, c, e, i, s, n)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(t, e, i, s, n, r) {
                if (0 !== t.length && 0 !== e.length)
                    for (var o = 0; o < t.children.length; o++)
                        t.children[o].exists && (t.children[o].physicsType === W.GROUP ? this.collideGroupVsGroup(t.children[o], e, i, s, n, r) : this.collideSpriteVsGroup(t.children[o], e, i, s, n, r))
            },
            separate: function(t, e, i, s, n) {
                if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e))
                    return !1;
                if (i && !1 === i.call(s, t.sprite, e.sprite))
                    return !1;
                if (t.isCircle && e.isCircle)
                    return this.separateCircle(t, e, n);
                if (t.isCircle !== e.isCircle) {
                    var r = t.isCircle ? e : t
                      , o = t.isCircle ? t : e
                      , a = r.x
                      , h = r.y
                      , l = r.right
                      , c = r.bottom
                      , u = o.x + o.radius
                      , d = o.y + o.radius;
                    if ((d < h || c < d) && (u < a || l < u))
                        return this.separateCircle(t, e, n)
                }
                var p = !1
                  , f = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (p = this.separateX(t, e, n),
                this.intersects(t, e) && (f = this.separateY(t, e, n))) : (f = this.separateY(t, e, n),
                this.intersects(t, e) && (p = this.separateX(t, e, n)));
                var g = p || f;
                return g && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite),
                e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite),
                e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))),
                g
            },
            intersects: function(t, e) {
                return t !== e && (t.isCircle ? e.isCircle ? W.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
            },
            circleBodyIntersects: function(t, e) {
                var i = W.Math.clamp(t.center.x, e.left, e.right)
                  , s = W.Math.clamp(t.center.y, e.top, e.bottom);
                return (t.center.x - i) * (t.center.x - i) + (t.center.y - s) * (t.center.y - s) <= t.radius * t.radius
            },
            separateCircle: function(t, e, i) {
                this.getOverlapX(t, e),
                this.getOverlapY(t, e);
                var s = e.center.x - t.center.x
                  , n = e.center.y - t.center.y
                  , r = Math.atan2(n, s)
                  , o = 0;
                if (t.isCircle !== e.isCircle) {
                    var a = {
                        x: e.isCircle ? t.position.x : e.position.x,
                        y: e.isCircle ? t.position.y : e.position.y,
                        right: e.isCircle ? t.right : e.right,
                        bottom: e.isCircle ? t.bottom : e.bottom
                    }
                      , h = {
                        x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                        y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                        radius: t.isCircle ? t.radius : e.radius
                    };
                    h.y < a.y ? h.x < a.x ? o = W.Math.distance(h.x, h.y, a.x, a.y) - h.radius : a.right < h.x && (o = W.Math.distance(h.x, h.y, a.right, a.y) - h.radius) : a.bottom < h.y && (h.x < a.x ? o = W.Math.distance(h.x, h.y, a.x, a.bottom) - h.radius : a.right < h.x && (o = W.Math.distance(h.x, h.y, a.right, a.bottom) - h.radius)),
                    o *= -1
                } else
                    o = t.radius + e.radius - W.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                if (i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX)
                    return 0 !== o && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite),
                    e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)),
                    0 !== o;
                var l = t.velocity.x * Math.cos(r) + t.velocity.y * Math.sin(r)
                  , c = t.velocity.x * Math.sin(r) - t.velocity.y * Math.cos(r)
                  , u = e.velocity.x * Math.cos(r) + e.velocity.y * Math.sin(r)
                  , d = e.velocity.x * Math.sin(r) - e.velocity.y * Math.cos(r)
                  , p = ((t.mass - e.mass) * l + 2 * e.mass * u) / (t.mass + e.mass)
                  , f = (2 * t.mass * l + (e.mass - t.mass) * u) / (t.mass + e.mass);
                return t.immovable || (t.velocity.x = (p * Math.cos(r) - c * Math.sin(r)) * t.bounce.x,
                t.velocity.y = (c * Math.cos(r) + p * Math.sin(r)) * t.bounce.y),
                e.immovable || (e.velocity.x = (f * Math.cos(r) - d * Math.sin(r)) * e.bounce.x,
                e.velocity.y = (d * Math.cos(r) + f * Math.sin(r)) * e.bounce.y),
                Math.abs(r) < Math.PI / 2 ? 0 < t.velocity.x && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : 0 < t.velocity.y && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(r) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : 0 < e.velocity.x && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : 0 < e.velocity.y && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)),
                t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - o * Math.cos(r),
                t.y += t.velocity.y * this.game.time.physicsElapsed - o * Math.sin(r)),
                e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + o * Math.cos(r),
                e.y += e.velocity.y * this.game.time.physicsElapsed + o * Math.sin(r)),
                t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite),
                e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite),
                !0
            },
            getOverlapX: function(t, e, i) {
                var s = 0
                  , n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0,
                e.embedded = !0) : t.deltaX() > e.deltaX() ? n < (s = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1,
                t.touching.right = !0,
                e.touching.none = !1,
                e.touching.left = !0) : t.deltaX() < e.deltaX() && (n < -(s = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1,
                t.touching.left = !0,
                e.touching.none = !1,
                e.touching.right = !0)),
                t.overlapX = s,
                e.overlapX = s
            },
            getOverlapY: function(t, e, i) {
                var s = 0
                  , n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0,
                e.embedded = !0) : t.deltaY() > e.deltaY() ? n < (s = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1,
                t.touching.down = !0,
                e.touching.none = !1,
                e.touching.up = !0) : t.deltaY() < e.deltaY() && (n < -(s = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1,
                t.touching.up = !0,
                e.touching.none = !1,
                e.touching.down = !0)),
                t.overlapY = s,
                e.overlapY = s
            },
            separateX: function(t, e, i) {
                var s = this.getOverlapX(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX)
                    return 0 !== s || t.embedded && e.embedded;
                var n = t.velocity.x
                  , r = e.velocity.x;
                if (t.immovable || e.immovable)
                    t.immovable ? (e.x += s,
                    e.velocity.x = n - r * e.bounce.x,
                    t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s,
                    t.velocity.x = r - n * t.bounce.x,
                    e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else {
                    s *= .5,
                    t.x -= s,
                    e.x += s;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (0 < r ? 1 : -1)
                      , a = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1)
                      , h = .5 * (o + a);
                    o -= h,
                    a -= h,
                    t.velocity.x = h + o * t.bounce.x,
                    e.velocity.x = h + a * e.bounce.x
                }
                return !0
            },
            separateY: function(t, e, i) {
                var s = this.getOverlapY(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY)
                    return 0 !== s || t.embedded && e.embedded;
                var n = t.velocity.y
                  , r = e.velocity.y;
                if (t.immovable || e.immovable)
                    t.immovable ? (e.y += s,
                    e.velocity.y = n - r * e.bounce.y,
                    t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s,
                    t.velocity.y = r - n * t.bounce.y,
                    e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else {
                    s *= .5,
                    t.y -= s,
                    e.y += s;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (0 < r ? 1 : -1)
                      , a = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1)
                      , h = .5 * (o + a);
                    o -= h,
                    a -= h,
                    t.velocity.y = h + o * t.bounce.y,
                    e.velocity.y = h + a * e.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(t, e, i, s) {
                if (0 !== e.length && t.exists)
                    return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
            },
            getObjectsAtLocation: function(t, e, i, s, n, r) {
                this.quadTree.clear(),
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
                this.quadTree.populate(i);
                for (var o = new W.Rectangle(t,e,1,1), a = [], h = this.quadTree.retrieve(o), l = 0; l < h.length; l++)
                    h[l].hitTest(t, e) && (s && s.call(n, r, h[l].sprite),
                    a.push(h[l].sprite));
                return a
            },
            moveToObject: function(t, e, i, s) {
                void 0 === i && (i = 60),
                void 0 === s && (s = 0);
                var n = Math.atan2(e.y - t.y, e.x - t.x);
                return 0 < s && (i = this.distanceBetween(t, e) / (s / 1e3)),
                t.body.velocity.x = Math.cos(n) * i,
                t.body.velocity.y = Math.sin(n) * i,
                n
            },
            moveToPointer: function(t, e, i, s) {
                void 0 === e && (e = 60),
                i = i || this.game.input.activePointer,
                void 0 === s && (s = 0);
                var n = this.angleToPointer(t, i);
                return 0 < s && (e = this.distanceToPointer(t, i) / (s / 1e3)),
                t.body.velocity.x = Math.cos(n) * e,
                t.body.velocity.y = Math.sin(n) * e,
                n
            },
            moveToXY: function(t, e, i, s, n) {
                void 0 === s && (s = 60),
                void 0 === n && (n = 0);
                var r = Math.atan2(i - t.y, e - t.x);
                return 0 < n && (s = this.distanceToXY(t, e, i) / (n / 1e3)),
                t.body.velocity.x = Math.cos(r) * s,
                t.body.velocity.y = Math.sin(r) * s,
                r
            },
            velocityFromAngle: function(t, e, i) {
                return void 0 === e && (e = 60),
                (i = i || new W.Point).setTo(Math.cos(W.Math.degToRad(t)) * e, Math.sin(W.Math.degToRad(t)) * e)
            },
            velocityFromRotation: function(t, e, i) {
                return void 0 === e && (e = 60),
                (i = i || new W.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerationFromRotation: function(t, e, i) {
                return void 0 === e && (e = 60),
                (i = i || new W.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerateToObject: function(t, e, i, s, n) {
                void 0 === i && (i = 60),
                void 0 === s && (s = 1e3),
                void 0 === n && (n = 1e3);
                var r = this.angleBetween(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i),
                t.body.maxVelocity.setTo(s, n),
                r
            },
            accelerateToPointer: function(t, e, i, s, n) {
                void 0 === i && (i = 60),
                void 0 === e && (e = this.game.input.activePointer),
                void 0 === s && (s = 1e3),
                void 0 === n && (n = 1e3);
                var r = this.angleToPointer(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i),
                t.body.maxVelocity.setTo(s, n),
                r
            },
            accelerateToXY: function(t, e, i, s, n, r) {
                void 0 === s && (s = 60),
                void 0 === n && (n = 1e3),
                void 0 === r && (r = 1e3);
                var o = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(Math.cos(o) * s, Math.sin(o) * s),
                t.body.maxVelocity.setTo(n, r),
                o
            },
            distanceBetween: function(t, e, i) {
                void 0 === i && (i = !1);
                var s = i ? t.world.x - e.world.x : t.x - e.x
                  , n = i ? t.world.y - e.world.y : t.y - e.y;
                return Math.sqrt(s * s + n * n)
            },
            distanceToXY: function(t, e, i, s) {
                void 0 === s && (s = !1);
                var n = s ? t.world.x - e : t.x - e
                  , r = s ? t.world.y - i : t.y - i;
                return Math.sqrt(n * n + r * r)
            },
            distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer),
                void 0 === i && (i = !1);
                var s = i ? t.world.x - e.worldX : t.x - e.worldX
                  , n = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(s * s + n * n)
            },
            angleBetween: function(t, e, i) {
                return void 0 === i && (i = !1),
                i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX
                  , s = e.centerY - t.centerY;
                return Math.atan2(s, i)
            },
            angleToXY: function(t, e, i, s) {
                return void 0 === s && (s = !1),
                s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            },
            angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer),
                void 0 === i && (i = !1),
                i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            },
            worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        },
        W.Physics.Arcade.Body = function(t) {
            this.sprite = t,
            this.game = t.game,
            this.type = W.Physics.ARCADE,
            this.enable = !0,
            this.isCircle = !1,
            this.radius = 0,
            this.offset = new W.Point,
            this.position = new W.Point(t.x,t.y),
            this.prev = new W.Point(this.position.x,this.position.y),
            this.allowRotation = !0,
            this.rotation = t.angle,
            this.preRotation = t.angle,
            this.width = t.width,
            this.height = t.height,
            this.sourceWidth = t.width,
            this.sourceHeight = t.height,
            t.texture && (this.sourceWidth = t.texture.frame.width,
            this.sourceHeight = t.texture.frame.height),
            this.halfWidth = Math.abs(t.width / 2),
            this.halfHeight = Math.abs(t.height / 2),
            this.center = new W.Point(t.x + this.halfWidth,t.y + this.halfHeight),
            this.velocity = new W.Point,
            this.newVelocity = new W.Point,
            this.deltaMax = new W.Point,
            this.acceleration = new W.Point,
            this.drag = new W.Point,
            this.allowGravity = !0,
            this.gravity = new W.Point,
            this.bounce = new W.Point,
            this.worldBounce = null,
            this.onWorldBounds = null,
            this.onCollide = null,
            this.onOverlap = null,
            this.maxVelocity = new W.Point(1e4,1e4),
            this.friction = new W.Point(1,0),
            this.angularVelocity = 0,
            this.angularAcceleration = 0,
            this.angularDrag = 0,
            this.maxAngular = 1e3,
            this.mass = 1,
            this.angle = 0,
            this.speed = 0,
            this.facing = W.NONE,
            this.immovable = !1,
            this.moves = !0,
            this.customSeparateX = !1,
            this.customSeparateY = !1,
            this.overlapX = 0,
            this.overlapY = 0,
            this.overlapR = 0,
            this.embedded = !1,
            this.collideWorldBounds = !1,
            this.checkCollision = {
                none: !1,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            },
            this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            },
            this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            },
            this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            },
            this.tilePadding = new W.Point,
            this.dirty = !1,
            this.skipQuadTree = !1,
            this.syncBounds = !1,
            this.isMoving = !1,
            this.stopVelocityOnCollide = !0,
            this.moveTimer = 0,
            this.moveDistance = 0,
            this.moveDuration = 0,
            this.moveTarget = null,
            this.moveEnd = null,
            this.onMoveComplete = new W.Signal,
            this.movementCallback = null,
            this.movementCallbackContext = null,
            this._reset = !0,
            this._sx = t.scale.x,
            this._sy = t.scale.y,
            this._dx = 0,
            this._dy = 0
        }
        ,
        W.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(),
                    t.width === this.width && t.height === this.height || (this.width = t.width,
                    this.height = t.height,
                    this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x)
                      , i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e,
                    this.height = this.sourceHeight * i,
                    this._sx = e,
                    this._sy = i,
                    this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2),
                this.halfHeight = Math.floor(this.height / 2),
                this.updateCenter())
            },
            updateCenter: function() {
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0,
                this.wasTouching.none = this.touching.none,
                this.wasTouching.up = this.touching.up,
                this.wasTouching.down = this.touching.down,
                this.wasTouching.left = this.touching.left,
                this.wasTouching.right = this.touching.right,
                this.touching.none = !0,
                this.touching.up = !1,
                this.touching.down = !1,
                this.touching.left = !1,
                this.touching.right = !1,
                this.blocked.up = !1,
                this.blocked.down = !1,
                this.blocked.left = !1,
                this.blocked.right = !1,
                this.overlapR = 0,
                this.overlapX = 0,
                this.overlapY = 0,
                this.embedded = !1,
                this.updateBounds(),
                this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x,
                this.position.x -= this.sprite.scale.x < 0 ? this.width : 0,
                this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y,
                this.position.y -= this.sprite.scale.y < 0 ? this.height : 0,
                this.rotation = this.sprite.angle,
                this.preRotation = this.rotation,
                (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x,
                this.prev.y = this.position.y),
                this.moves && (this.game.physics.arcade.updateMotion(this),
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed),
                this.position.x += this.newVelocity.x,
                this.position.y += this.newVelocity.y,
                this.updateCenter(),
                this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)),
                this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y),
                this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)),
                this._dx = this.deltaX(),
                this._dy = this.deltaY(),
                this._reset = !1)
            },
            updateMovement: function() {
                var t = 0
                  , e = 0 !== this.overlapX || 0 !== this.overlapY;
                if (t = 0 < this.moveDuration ? (this.moveTimer += this.game.time.elapsedMS,
                this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y),
                this.moveTarget.length / this.moveDistance),
                this.movementCallback)
                    var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || 1 <= t || void 0 !== i && !0 !== i) || (this.stopMovement(1 <= t || this.stopVelocityOnCollide && e),
                !1)
            },
            stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1,
                t && this.velocity.set(0),
                this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(),
                this.dirty = !1,
                this.deltaX() < 0 ? this.facing = W.LEFT : 0 < this.deltaX() && (this.facing = W.RIGHT),
                this.deltaY() < 0 ? this.facing = W.UP : 0 < this.deltaY() && (this.facing = W.DOWN),
                this.moves && (this._dx = this.deltaX(),
                this._dy = this.deltaY(),
                0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : 0 < this._dx && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)),
                0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : 0 < this._dy && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)),
                this.sprite.position.x += this._dx,
                this.sprite.position.y += this._dy,
                this._reset = !0),
                this.updateCenter(),
                this.allowRotation && (this.sprite.angle += this.deltaZ()),
                this.prev.x = this.position.x,
                this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var t = this.position
                  , e = this.game.physics.arcade.bounds
                  , i = this.game.physics.arcade.checkCollision
                  , s = this.worldBounce ? -this.worldBounce.x : -this.bounce.x
                  , n = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var r = this.center.x - this.radius
                      , o = this.center.y - this.radius
                      , a = this.center.x + this.radius
                      , h = this.center.y + this.radius;
                    r < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius,
                    this.velocity.x *= s,
                    this.blocked.left = !0) : a > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius,
                    this.velocity.x *= s,
                    this.blocked.right = !0),
                    o < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius,
                    this.velocity.y *= n,
                    this.blocked.up = !0) : h > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius,
                    this.velocity.y *= n,
                    this.blocked.down = !0)
                } else
                    t.x < e.x && i.left ? (t.x = e.x,
                    this.velocity.x *= s,
                    this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width,
                    this.velocity.x *= s,
                    this.blocked.right = !0),
                    t.y < e.y && i.up ? (t.y = e.y,
                    this.velocity.y *= n,
                    this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height,
                    this.velocity.y *= n,
                    this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(t, e, i) {
                return void 0 === e && (e = this.speed),
                0 !== e && (void 0 === i ? (s = this.angle,
                i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i),
                this.moveTimer = 0,
                this.moveDuration = t,
                0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.set(Math.cos(s) * e, Math.sin(s) * e),
                this.isMoving = !0);
                var s
            },
            moveTo: function(t, e, i) {
                var s, n = e / (t / 1e3);
                return 0 != n && (void 0 === i ? (s = this.angle,
                i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i),
                e = Math.abs(e),
                this.moveDuration = 0,
                this.moveDistance = e,
                null === this.moveTarget && (this.moveTarget = new W.Line,
                this.moveEnd = new W.Point),
                this.moveTarget.fromAngle(this.x, this.y, s, e),
                this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y),
                this.moveTarget.setTo(this.x, this.y, this.x, this.y),
                0 === i || 180 === i ? this.velocity.set(Math.cos(s) * n, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * n) : this.velocity.set(Math.cos(s) * n, Math.sin(s) * n),
                this.isMoving = !0)
            },
            setSize: function(t, e, i, s) {
                void 0 === i && (i = this.offset.x),
                void 0 === s && (s = this.offset.y),
                this.sourceWidth = t,
                this.sourceHeight = e,
                this.width = this.sourceWidth * this._sx,
                this.height = this.sourceHeight * this._sy,
                this.halfWidth = Math.floor(this.width / 2),
                this.halfHeight = Math.floor(this.height / 2),
                this.offset.setTo(i, s),
                this.updateCenter(),
                this.isCircle = !1,
                this.radius = 0
            },
            setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x),
                void 0 === i && (i = this.offset.y),
                0 < t ? (this.isCircle = !0,
                this.radius = t,
                this.sourceWidth = 2 * t,
                this.sourceHeight = 2 * t,
                this.width = this.sourceWidth * this._sx,
                this.height = this.sourceHeight * this._sy,
                this.halfWidth = Math.floor(this.width / 2),
                this.halfHeight = Math.floor(this.height / 2),
                this.offset.setTo(e, i),
                this.updateCenter()) : this.isCircle = !1
            },
            reset: function(t, e) {
                this.velocity.set(0),
                this.acceleration.set(0),
                this.speed = 0,
                this.angularVelocity = 0,
                this.angularAcceleration = 0,
                this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x,
                this.position.x -= this.sprite.scale.x < 0 ? this.width : 0,
                this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y,
                this.position.y -= this.sprite.scale.y < 0 ? this.height : 0,
                this.prev.x = this.position.x,
                this.prev.y = this.position.y,
                this.rotation = this.sprite.angle,
                this.preRotation = this.rotation,
                this.updateBounds(),
                this.updateCenter()
            },
            getBounds: function(t) {
                return this.isCircle ? (t.x = this.center.x - this.radius,
                t.y = this.center.y - this.radius,
                t.right = this.center.x + this.radius,
                t.bottom = this.center.y + this.radius) : (t.x = this.x,
                t.y = this.y,
                t.right = this.right,
                t.bottom = this.bottom),
                t
            },
            hitTest: function(t, e) {
                return this.isCircle ? W.Circle.contains(this, t, e) : W.Rectangle.contains(this, t, e)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof W.Group && this.sprite.parent.removeFromHash(this.sprite),
                this.sprite.body = null,
                this.sprite = null
            }
        },
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }),
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }),
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }),
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }),
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        }),
        Object.defineProperty(W.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }),
        W.Physics.Arcade.Body.render = function(t, e, i, s) {
            void 0 === s && (s = !0),
            i = i || "rgba(0,255,0,0.4)",
            t.fillStyle = i,
            t.strokeStyle = i,
            e.isCircle ? (t.beginPath(),
            t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI),
            s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }
        ,
        W.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height),
            t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)),
            t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)),
            t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)),
            t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down),
            t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }
        ,
        W.Physics.Arcade.Body.prototype.constructor = W.Physics.Arcade.Body,
        W.Physics.Arcade.TilemapCollision = function() {}
        ,
        W.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(t, e, i, s, n, r) {
                if (t.body) {
                    var o = e.getTiles(t.body.position.x - t.body.tilePadding.x - e.getTileOffsetX(), t.body.position.y - t.body.tilePadding.y - e.getTileOffsetY(), t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if (0 !== o.length)
                        for (var a = 0; a < o.length; a++)
                            s ? s.call(n, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++,
                            i && i.call(n, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++,
                            i && i.call(n, t, o[a]))
                }
            },
            collideGroupVsTilemapLayer: function(t, e, i, s, n, r) {
                if (0 !== t.length)
                    for (var o = 0; o < t.children.length; o++)
                        t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, r)
            },
            separateTile: function(t, e, i, s, n) {
                if (!e.enable)
                    return !1;
                var r = s.getTileOffsetX()
                  , o = s.getTileOffsetY();
                if (!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o))
                    return !1;
                if (n)
                    return !0;
                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i))
                    return !1;
                if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i))
                    return !1;
                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom))
                    return !1;
                var a = 0
                  , h = 0
                  , l = 0
                  , c = 1;
                if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1),
                0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)),
                c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))),
                l < c) {
                    if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o))
                        return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
                } else {
                    if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o))
                        return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, s))
                }
                return 0 !== a || 0 !== h
            },
            tileCheckX: function(t, e, i) {
                var s = 0
                  , n = i.getTileOffsetX();
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (s = t.x - n - e.right) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaX() && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (s = t.right - n - e.left) > this.TILE_BIAS && (s = 0),
                0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)),
                s
            },
            tileCheckY: function(t, e, i) {
                var s = 0
                  , n = i.getTileOffsetY();
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (s = t.y - n - e.bottom) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaY() && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (s = t.bottom - n - e.top) > this.TILE_BIAS && (s = 0),
                0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)),
                s
            },
            processTileSeparationX: function(t, e) {
                e < 0 ? t.blocked.left = !0 : 0 < e && (t.blocked.right = !0),
                t.position.x -= e,
                0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            },
            processTileSeparationY: function(t, e) {
                e < 0 ? t.blocked.up = !0 : 0 < e && (t.blocked.down = !0),
                t.position.y -= e,
                0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        },
        W.Utils.mixinPrototype(W.Physics.Arcade.prototype, W.Physics.Arcade.TilemapCollision.prototype),
        p2.Body.prototype.parent = null,
        p2.Spring.prototype.parent = null,
        W.Physics.P2 = function(t, e) {
            this.game = t,
            void 0 === e ? e = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]),
            e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)),
            this.config = e,
            this.world = new p2.World(this.config),
            this.frameRate = 1 / 60,
            this.useElapsedTime = !1,
            this.paused = !1,
            this.materials = [],
            this.gravity = new W.Physics.P2.InversePointProxy(this,this.world.gravity),
            this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            },
            this.onBodyAdded = new W.Signal,
            this.onBodyRemoved = new W.Signal,
            this.onSpringAdded = new W.Signal,
            this.onSpringRemoved = new W.Signal,
            this.onConstraintAdded = new W.Signal,
            this.onConstraintRemoved = new W.Signal,
            this.onContactMaterialAdded = new W.Signal,
            this.onContactMaterialRemoved = new W.Signal,
            this.postBroadphaseCallback = null,
            this.callbackContext = null,
            this.onBeginContact = new W.Signal,
            this.onEndContact = new W.Signal,
            e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx,
            this.mpxi = e.mpxi,
            this.pxm = e.pxm,
            this.pxmi = e.pxmi),
            this.world.on("beginContact", this.beginContactHandler, this),
            this.world.on("endContact", this.endContactHandler, this),
            this.collisionGroups = [],
            this.nothingCollisionGroup = new W.Physics.P2.CollisionGroup(1),
            this.boundsCollisionGroup = new W.Physics.P2.CollisionGroup(2),
            this.everythingCollisionGroup = new W.Physics.P2.CollisionGroup(2147483648),
            this.boundsCollidesWith = [],
            this._toRemove = [],
            this._collisionGroupID = 2,
            this._boundsLeft = !0,
            this._boundsRight = !0,
            this._boundsTop = !0,
            this._boundsBottom = !0,
            this._boundsOwnGroup = !1,
            this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }
        ,
        W.Physics.P2.prototype = {
            removeBodyNextStep: function(t) {
                this._toRemove.push(t)
            },
            preUpdate: function() {
                for (var t = this._toRemove.length; t--; )
                    this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0
            },
            enable: function(t, e, i) {
                void 0 === e && (e = !1),
                void 0 === i && (i = !0);
                var s = 1;
                if (Array.isArray(t))
                    for (s = t.length; s--; )
                        t[s]instanceof W.Group ? this.enable(t[s].children, e, i) : (this.enableBody(t[s], e),
                        i && t[s].hasOwnProperty("children") && 0 < t[s].children.length && this.enable(t[s], e, !0));
                else
                    t instanceof W.Group ? this.enable(t.children, e, i) : (this.enableBody(t, e),
                    i && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, e, !0))
            },
            enableBody: function(t, e) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new W.Physics.P2.Body(this.game,t,t.x,t.y,1),
                t.body.debug = e,
                void 0 !== t.anchor && t.anchor.set(.5))
            },
            setImpactEvents: function(t) {
                t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(t, e) {
                this.postBroadphaseCallback = t,
                this.callbackContext = e,
                null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(t) {
                if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; 0 <= e; e -= 2)
                        t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
            },
            impactHandler: function(t) {
                if (t.bodyA.parent && t.bodyB.parent) {
                    var e = t.bodyA.parent
                      , i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB),
                    i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA),
                    e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB),
                    i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                }
            },
            beginContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations),
                t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations),
                t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
            },
            endContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB),
                t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB),
                t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
            },
            setBoundsToWorld: function(t, e, i, s, n) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
            },
            setWorldMaterial: function(t, e, i, s, n) {
                void 0 === e && (e = !0),
                void 0 === i && (i = !0),
                void 0 === s && (s = !0),
                void 0 === n && (n = !0),
                e && this.walls.left && (this.walls.left.shapes[0].material = t),
                i && this.walls.right && (this.walls.right.shapes[0].material = t),
                s && this.walls.top && (this.walls.top.shapes[0].material = t),
                n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
            },
            updateBoundsCollisionGroup: function(t) {
                void 0 === t && (t = !0);
                var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e),
                this.walls.right && (this.walls.right.shapes[0].collisionGroup = e),
                this.walls.top && (this.walls.top.shapes[0].collisionGroup = e),
                this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e),
                this._boundsOwnGroup = t
            },
            setBounds: function(t, e, i, s, n, r, o, a, h) {
                void 0 === n && (n = this._boundsLeft),
                void 0 === r && (r = this._boundsRight),
                void 0 === o && (o = this._boundsTop),
                void 0 === a && (a = this._boundsBottom),
                void 0 === h && (h = this._boundsOwnGroup),
                this.setupWall(n, "left", t, e, 1.5707963267948966, h),
                this.setupWall(r, "right", t + i, e, -1.5707963267948966, h),
                this.setupWall(o, "top", t, e, -3.141592653589793, h),
                this.setupWall(a, "bottom", t, e + s, 0, h),
                this._boundsLeft = n,
                this._boundsRight = r,
                this._boundsTop = o,
                this._boundsBottom = a,
                this._boundsOwnGroup = h
            },
            setupWall: function(t, e, i, s, n, r) {
                t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(i), this.pxmi(s)],
                    angle: n
                }),
                this.walls[e].addShape(new p2.Plane),
                this.world.addBody(this.walls[e])),
                r && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]),
                this.walls[e] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this),
                this.world.on("endContact", this.endContactHandler, this),
                this.nothingCollisionGroup = new W.Physics.P2.CollisionGroup(1),
                this.boundsCollisionGroup = new W.Physics.P2.CollisionGroup(2),
                this.everythingCollisionGroup = new W.Physics.P2.CollisionGroup(2147483648),
                this._collisionGroupID = 2,
                this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0,
                this.world.fixedStepTime = 0,
                this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var t = this.world.constraints, e = t.length - 1; 0 <= e; e--)
                    this.world.removeConstraint(t[e]);
                var i = this.world.bodies;
                for (e = i.length - 1; 0 <= e; e--)
                    this.world.removeBody(i[e]);
                var s = this.world.springs;
                for (e = s.length - 1; 0 <= e; e--)
                    this.world.removeSpring(s[e]);
                var n = this.world.contactMaterials;
                for (e = n.length - 1; 0 <= e; e--)
                    this.world.removeContactMaterial(n[e]);
                this.world.off("beginContact", this.beginContactHandler, this),
                this.world.off("endContact", this.endContactHandler, this),
                this.postBroadphaseCallback = null,
                this.callbackContext = null,
                this.impactCallback = null,
                this.collisionGroups = [],
                this._toRemove = [],
                this.boundsCollidesWith = [],
                this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(),
                this.game = null
            },
            addBody: function(t) {
                return !t.data.world && (this.world.addBody(t.data),
                this.onBodyAdded.dispatch(t),
                !0)
            },
            removeBody: function(t) {
                return t.data.world === this.world && (this.world.removeBody(t.data),
                this.onBodyRemoved.dispatch(t)),
                t
            },
            addSpring: function(t) {
                return t instanceof W.Physics.P2.Spring || t instanceof W.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t),
                this.onSpringAdded.dispatch(t),
                t
            },
            removeSpring: function(t) {
                return t instanceof W.Physics.P2.Spring || t instanceof W.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t),
                this.onSpringRemoved.dispatch(t),
                t
            },
            createDistanceConstraint: function(t, e, i, s, n, r) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addConstraint(new W.Physics.P2.DistanceConstraint(this,t,e,i,s,n,r));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createGearConstraint: function(t, e, i, s) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addConstraint(new W.Physics.P2.GearConstraint(this,t,e,i,s));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createRevoluteConstraint: function(t, e, i, s, n, r) {
                if (t = this.getBody(t),
                i = this.getBody(i),
                t && i)
                    return this.addConstraint(new W.Physics.P2.RevoluteConstraint(this,t,e,i,s,n,r));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createLockConstraint: function(t, e, i, s, n) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addConstraint(new W.Physics.P2.LockConstraint(this,t,e,i,s,n));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createPrismaticConstraint: function(t, e, i, s, n, r, o) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addConstraint(new W.Physics.P2.PrismaticConstraint(this,t,e,i,s,n,r,o));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            addConstraint: function(t) {
                return this.world.addConstraint(t),
                this.onConstraintAdded.dispatch(t),
                t
            },
            removeConstraint: function(t) {
                return this.world.removeConstraint(t),
                this.onConstraintRemoved.dispatch(t),
                t
            },
            addContactMaterial: function(t) {
                return this.world.addContactMaterial(t),
                this.onContactMaterialAdded.dispatch(t),
                t
            },
            removeContactMaterial: function(t) {
                return this.world.removeContactMaterial(t),
                this.onContactMaterialRemoved.dispatch(t),
                t
            },
            getContactMaterial: function(t, e) {
                return this.world.getContactMaterial(t, e)
            },
            setMaterial: function(t, e) {
                for (var i = e.length; i--; )
                    e[i].setMaterial(t)
            },
            createMaterial: function(t, e) {
                t = t || "";
                var i = new W.Physics.P2.Material(t);
                return this.materials.push(i),
                void 0 !== e && e.setMaterial(i),
                i
            },
            createContactMaterial: function(t, e, i) {
                void 0 === t && (t = this.createMaterial()),
                void 0 === e && (e = this.createMaterial());
                var s = new W.Physics.P2.ContactMaterial(t,e,i);
                return this.addContactMaterial(s)
            },
            getBodies: function() {
                for (var t = [], e = this.world.bodies.length; e--; )
                    t.push(this.world.bodies[e].parent);
                return t
            },
            getBody: function(t) {
                return t instanceof p2.Body ? t : t instanceof W.Physics.P2.Body ? t.data : t.body && t.body.type === W.Physics.P2JS ? t.body.data : null
            },
            getSprings: function() {
                for (var t = [], e = this.world.springs.length; e--; )
                    t.push(this.world.springs[e].parent);
                return t
            },
            getConstraints: function() {
                for (var t = [], e = this.world.constraints.length; e--; )
                    t.push(this.world.constraints[e]);
                return t
            },
            hitTest: function(t, e, i, s) {
                void 0 === e && (e = this.world.bodies),
                void 0 === i && (i = 5),
                void 0 === s && (s = !1);
                for (var n = [this.pxmi(t.x), this.pxmi(t.y)], r = [], o = e.length; o--; )
                    e[o]instanceof W.Physics.P2.Body && (!s || e[o].data.type !== p2.Body.STATIC) ? r.push(e[o].data) : e[o]instanceof p2.Body && e[o].parent && (!s || e[o].type !== p2.Body.STATIC) ? r.push(e[o]) : e[o]instanceof W.Sprite && e[o].hasOwnProperty("body") && (!s || e[o].body.data.type !== p2.Body.STATIC) && r.push(e[o].body.data);
                return this.world.hitTest(n, r, i)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(t) {
                var e = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e),
                this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e),
                this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e),
                this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e),
                this._collisionGroupID++;
                var i = new W.Physics.P2.CollisionGroup(e);
                return this.collisionGroups.push(i),
                t && this.setCollisionGroup(t, i),
                i
            },
            setCollisionGroup: function(t, e) {
                if (t instanceof W.Group)
                    for (var i = 0; i < t.total; i++)
                        t.children[i].body && t.children[i].body.type === W.Physics.P2JS && t.children[i].body.setCollisionGroup(e);
                else
                    t.body.setCollisionGroup(e)
            },
            createSpring: function(t, e, i, s, n, r, o, a, h) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addSpring(new W.Physics.P2.Spring(this,t,e,i,s,n,r,o,a,h));
                console.warn("Cannot create Spring, invalid body objects given")
            },
            createRotationalSpring: function(t, e, i, s, n) {
                if (t = this.getBody(t),
                e = this.getBody(e),
                t && e)
                    return this.addSpring(new W.Physics.P2.RotationalSpring(this,t,e,i,s,n));
                console.warn("Cannot create Rotational Spring, invalid body objects given")
            },
            createBody: function(t, e, i, s, n, r) {
                void 0 === s && (s = !1);
                var o = new W.Physics.P2.Body(this.game,null,t,e,i);
                if (r && !o.addPolygon(n, r))
                    return !1;
                return s && this.world.addBody(o.data),
                o
            },
            createParticle: function(t, e, i, s, n, r) {
                void 0 === s && (s = !1);
                var o = new W.Physics.P2.Body(this.game,null,t,e,i);
                if (r && !o.addPolygon(n, r))
                    return !1;
                return s && this.world.addBody(o.data),
                o
            },
            convertCollisionObjects: function(t, e, i) {
                void 0 === i && (i = !0);
                for (var s = [], n = 0, r = t.collision[e].length; n < r; n++) {
                    var o = t.collision[e][n]
                      , a = this.createBody(o.x, o.y, 0, i, {}, o.polyline);
                    a && s.push(a)
                }
                return s
            },
            clearTilemapLayerBodies: function(t, e) {
                e = t.getLayer(e);
                for (var i = t.layers[e].bodies.length; i--; )
                    t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0
            },
            convertTilemap: function(t, e, i, s) {
                e = t.getLayer(e),
                void 0 === i && (i = !0),
                void 0 === s && (s = !0),
                this.clearTilemapLayerBodies(t, e);
                for (var n = 0, r = 0, o = 0, a = 0, h = t.layers[e].height; a < h; a++)
                    for (var l = n = 0, c = t.layers[e].width; l < c; l++) {
                        var u = t.layers[e].data[a][l];
                        if (u && -1 < u.index && u.collides)
                            if (s) {
                                var d = t.getTileRight(e, l, a);
                                if (0 === n && (r = u.x * u.width,
                                o = u.y * u.height,
                                n = u.width),
                                d && d.collides)
                                    n += u.width;
                                else
                                    (p = this.createBody(r, o, 0, !1)).addRectangle(n, u.height, n / 2, u.height / 2, 0),
                                    i && this.addBody(p),
                                    t.layers[e].bodies.push(p),
                                    n = 0
                            } else {
                                var p;
                                (p = this.createBody(u.x * u.width, u.y * u.height, 0, !1)).addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0),
                                i && this.addBody(p),
                                t.layers[e].bodies.push(p)
                            }
                    }
                return t.layers[e].bodies
            },
            mpx: function(t) {
                return 20 * t
            },
            pxm: function(t) {
                return .05 * t
            },
            mpxi: function(t) {
                return -20 * t
            },
            pxmi: function(t) {
                return -.05 * t
            }
        },
        Object.defineProperty(W.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(t) {
                this.world.defaultContactMaterial.friction = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(t) {
                this.world.defaultContactMaterial.restitution = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(t) {
                this.world.defaultContactMaterial = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(t) {
                this.world.applySpringForces = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(t) {
                this.world.applyDamping = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(t) {
                this.world.applyGravity = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(t) {
                this.world.solveConstraints = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(t) {
                this.world.emitImpactEvent = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(t) {
                this.world.sleepMode = t
            }
        }),
        Object.defineProperty(W.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }),
        W.Physics.P2.FixtureList = function(t) {
            Array.isArray(t) || (t = [t]),
            this.rawList = t,
            this.init(),
            this.parse(this.rawList)
        }
        ,
        W.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {},
                this.groupedFixtures = [],
                this.allFixtures = []
            },
            setCategory: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.collisionGroup = e
                })
            },
            setMask: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.collisionMask = e
                })
            },
            setSensor: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.sensor = e
                })
            },
            setMaterial: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.material = e
                })
            },
            getFixtures: function(t) {
                var e = [];
                if (t) {
                    t instanceof Array || (t = [t]);
                    var i = this;
                    return t.forEach(function(t) {
                        i.namedFixtures[t] && e.push(i.namedFixtures[t])
                    }),
                    this.flatten(e)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(t) {
                return this.namedFixtures[t]
            },
            getGroup: function(t) {
                return this.groupedFixtures[t]
            },
            parse: function() {
                var t, e, i, s;
                for (t in s = [],
                i = this.rawList)
                    e = i[t],
                    isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [],
                    this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)),
                    s.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(t) {
                var e, i;
                return e = [],
                i = arguments.callee,
                t.forEach(function(t) {
                    return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                }),
                e
            }
        },
        W.Physics.P2.PointProxy = function(t, e) {
            this.world = t,
            this.destination = e
        }
        ,
        W.Physics.P2.PointProxy.prototype.constructor = W.Physics.P2.PointProxy,
        Object.defineProperty(W.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxm(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxm(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = t
            }
        }),
        Object.defineProperty(W.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = t
            }
        }),
        W.Physics.P2.InversePointProxy = function(t, e) {
            this.world = t,
            this.destination = e
        }
        ,
        W.Physics.P2.InversePointProxy.prototype.constructor = W.Physics.P2.InversePointProxy,
        Object.defineProperty(W.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxmi(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxmi(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = -t
            }
        }),
        Object.defineProperty(W.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = -t
            }
        }),
        W.Physics.P2.Body = function(t, e, i, s, n) {
            e = e || null,
            i = i || 0,
            s = s || 0,
            void 0 === n && (n = 1),
            this.game = t,
            this.world = t.physics.p2,
            this.sprite = e,
            this.type = W.Physics.P2JS,
            this.offset = new W.Point,
            this.data = new p2.Body({
                position: [this.world.pxmi(i), this.world.pxmi(s)],
                mass: n
            }),
            (this.data.parent = this).velocity = new W.Physics.P2.InversePointProxy(this.world,this.data.velocity),
            this.force = new W.Physics.P2.InversePointProxy(this.world,this.data.force),
            this.gravity = new W.Point,
            this.onBeginContact = new W.Signal,
            this.onEndContact = new W.Signal,
            this.collidesWith = [],
            this.removeNextStep = !1,
            this.debugBody = null,
            this.dirty = !1,
            this._collideWorldBounds = !0,
            this._bodyCallbacks = {},
            this._bodyCallbackContext = {},
            this._groupCallbacks = {},
            this._groupCallbackContext = {},
            this._reset = !1,
            e && (this.setRectangleFromSprite(e),
            e.exists && this.game.physics.p2.addBody(this))
        }
        ,
        W.Physics.P2.Body.prototype = {
            createBodyCallback: function(t, e, i) {
                var s = -1;
                t.id ? s = t.id : t.body && (s = t.body.id),
                -1 < s && (null === e ? (delete this._bodyCallbacks[s],
                delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e,
                this._bodyCallbackContext[s] = i))
            },
            createGroupCallback: function(t, e, i) {
                null === e ? (delete this._groupCallbacks[t.mask],
                delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e,
                this._groupCallbackContext[t.mask] = i)
            },
            getCollisionMask: function() {
                var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var e = 0; e < this.collidesWith.length; e++)
                    t |= this.collidesWith[e].mask;
                return t
            },
            updateCollisionMask: function(t) {
                var e = this.getCollisionMask();
                if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; 0 <= i; i--)
                        this.data.shapes[i].collisionMask = e;
                else
                    t.collisionMask = e
            },
            setCollisionGroup: function(t, e) {
                var i = this.getCollisionMask();
                if (void 0 === e)
                    for (var s = this.data.shapes.length - 1; 0 <= s; s--)
                        this.data.shapes[s].collisionGroup = t.mask,
                        this.data.shapes[s].collisionMask = i;
                else
                    e.collisionGroup = t.mask,
                    e.collisionMask = i
            },
            clearCollision: function(t, e, i) {
                if (void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === i)
                    for (var s = this.data.shapes.length - 1; 0 <= s; s--)
                        t && (this.data.shapes[s].collisionGroup = null),
                        e && (this.data.shapes[s].collisionMask = null);
                else
                    t && (i.collisionGroup = null),
                    e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(t, e, i) {
                var s;
                if (void 0 === e && (e = !0),
                Array.isArray(t))
                    for (var n = 0; n < t.length; n++)
                        -1 < (s = this.collidesWith.indexOf(t[n])) && (this.collidesWith.splice(s, 1),
                        e && (delete this._groupCallbacks[t.mask],
                        delete this._groupCallbackContext[t.mask]));
                else
                    -1 < (s = this.collidesWith.indexOf(t)) && (this.collidesWith.splice(s, 1),
                    e && (delete this._groupCallbacks[t.mask],
                    delete this._groupCallbackContext[t.mask]));
                var r = this.getCollisionMask();
                if (void 0 === i)
                    for (n = this.data.shapes.length - 1; 0 <= n; n--)
                        this.data.shapes[n].collisionMask = r;
                else
                    i.collisionMask = r
            },
            collides: function(t, e, i, s) {
                if (Array.isArray(t))
                    for (var n = 0; n < t.length; n++)
                        -1 === this.collidesWith.indexOf(t[n]) && (this.collidesWith.push(t[n]),
                        e && this.createGroupCallback(t[n], e, i));
                else
                    -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t),
                    e && this.createGroupCallback(t, e, i));
                var r = this.getCollisionMask();
                if (void 0 === s)
                    for (n = this.data.shapes.length - 1; 0 <= n; n--)
                        this.data.shapes[n].collisionMask = r;
                else
                    s.collisionMask = r
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(),
                this.shapeChanged()
            },
            getVelocityAtPoint: function(t, e) {
                return this.data.getVelocityAtPoint(t, e)
            },
            applyDamping: function(t) {
                this.data.applyDamping(t)
            },
            applyImpulse: function(t, e, i) {
                this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyImpulseLocal: function(t, e, i) {
                this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyForce: function(t, e, i) {
                this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0,
                this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0,
                this.data.angularDamping = 0
            },
            toLocalFrame: function(t, e) {
                return this.data.toLocalFrame(t, e)
            },
            toWorldFrame: function(t, e) {
                return this.data.toWorldFrame(t, e)
            },
            rotateLeft: function(t) {
                this.data.angularVelocity = this.world.pxm(-t)
            },
            rotateRight: function(t) {
                this.data.angularVelocity = this.world.pxm(t)
            },
            moveForward: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i),
                this.data.velocity[1] = e * Math.sin(i)
            },
            moveBackward: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i),
                this.data.velocity[1] = -e * Math.sin(i)
            },
            thrust: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i),
                this.data.force[1] += e * Math.sin(i)
            },
            thrustLeft: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle;
                this.data.force[0] += e * Math.cos(i),
                this.data.force[1] += e * Math.sin(i)
            },
            thrustRight: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i),
                this.data.force[1] -= e * Math.sin(i)
            },
            reverse: function(t) {
                var e = this.world.pxmi(-t)
                  , i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i),
                this.data.force[1] -= e * Math.sin(i)
            },
            moveLeft: function(t) {
                this.data.velocity[0] = this.world.pxmi(-t)
            },
            moveRight: function(t) {
                this.data.velocity[0] = this.world.pxmi(t)
            },
            moveUp: function(t) {
                this.data.velocity[1] = this.world.pxmi(-t)
            },
            moveDown: function(t) {
                this.data.velocity[1] = this.world.pxmi(t)
            },
            preUpdate: function() {
                this.dirty = !0,
                this.removeNextStep && (this.removeFromWorld(),
                this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x,
                this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y,
                this.fixedRotation || (this.sprite.rotation = this.data.angle),
                this.debugBody && this.debugBody.updateSpriteTransform(),
                this.dirty = !1
            },
            reset: function(t, e, i, s) {
                void 0 === i && (i = !1),
                void 0 === s && (s = !1),
                this.setZeroForce(),
                this.setZeroVelocity(),
                this.setZeroRotation(),
                i && this.setZeroDamping(),
                s && (this.mass = 1),
                this.x = t,
                this.y = e
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++)
                        this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(),
                this.clearShapes(),
                this._bodyCallbacks = {},
                this._bodyCallbackContext = {},
                this._groupCallbacks = {},
                this._groupCallbackContext = {},
                this.debugBody && this.debugBody.destroy(!0, !0),
                this.debugBody = null,
                this.sprite && (this.sprite.body = null,
                this.sprite = null)
            },
            clearShapes: function() {
                for (var t = this.data.shapes.length; t--; )
                    this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged()
            },
            addShape: function(t, e, i, s) {
                return void 0 === e && (e = 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s),
                this.shapeChanged(),
                t
            },
            addCircle: function(t, e, i, s) {
                var n = new p2.Circle({
                    radius: this.world.pxm(t)
                });
                return this.addShape(n, e, i, s)
            },
            addRectangle: function(t, e, i, s, n) {
                var r = new p2.Box({
                    width: this.world.pxm(t),
                    height: this.world.pxm(e)
                });
                return this.addShape(r, i, s, n)
            },
            addPlane: function(t, e, i) {
                var s = new p2.Plane;
                return this.addShape(s, t, e, i)
            },
            addParticle: function(t, e, i) {
                var s = new p2.Particle;
                return this.addShape(s, t, e, i)
            },
            addLine: function(t, e, i, s) {
                var n = new p2.Line({
                    length: this.world.pxm(t)
                });
                return this.addShape(n, e, i, s)
            },
            addCapsule: function(t, e, i, s, n) {
                var r = new p2.Capsule({
                    length: this.world.pxm(t),
                    radius: this.world.pxm(e)
                });
                return this.addShape(r, i, s, n)
            },
            addPolygon: function(t, e) {
                t = t || {},
                Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                var i = [];
                if (1 === e.length && Array.isArray(e[0]))
                    i = e[0].slice(0);
                else if (Array.isArray(e[0]))
                    i = e.slice();
                else if ("number" == typeof e[0])
                    for (var s = 0, n = e.length; s < n; s += 2)
                        i.push([e[s], e[s + 1]]);
                var r = i.length - 1;
                i[r][0] === i[0][0] && i[r][1] === i[0][1] && i.pop();
                for (var o = 0; o < i.length; o++)
                    i[o][0] = this.world.pxmi(i[o][0]),
                    i[o][1] = this.world.pxmi(i[o][1]);
                var a = this.data.fromPolygon(i, t);
                return this.shapeChanged(),
                a
            },
            removeShape: function(t) {
                var e = this.data.removeShape(t);
                return this.shapeChanged(),
                e
            },
            setCircle: function(t, e, i, s) {
                return this.clearShapes(),
                this.addCircle(t, e, i, s)
            },
            setRectangle: function(t, e, i, s, n) {
                return void 0 === t && (t = 16),
                void 0 === e && (e = 16),
                this.clearShapes(),
                this.addRectangle(t, e, i, s, n)
            },
            setRectangleFromSprite: function(t) {
                return void 0 === t && (t = this.sprite),
                this.clearShapes(),
                this.addRectangle(t.width, t.height, 0, 0, t.rotation)
            },
            setMaterial: function(t, e) {
                if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; 0 <= i; i--)
                        this.data.shapes[i].material = t;
                else
                    e.material = t
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(t, e) {
                for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                    var r = i[n]
                      , o = this.addFixture(r);
                    s[r.filter.group] = s[r.filter.group] || [],
                    s[r.filter.group] = s[r.filter.group].concat(o),
                    r.fixtureKey && (s[r.fixtureKey] = o)
                }
                return this.data.aabbNeedsUpdate = !0,
                this.shapeChanged(),
                s
            },
            addFixture: function(t) {
                var e = [];
                if (t.circle) {
                    (l = new p2.Circle({
                        radius: this.world.pxm(t.circle.radius)
                    })).collisionGroup = t.filter.categoryBits,
                    l.collisionMask = t.filter.maskBits,
                    l.sensor = t.isSensor;
                    var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2),
                    i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2),
                    this.data.addShape(l, i),
                    e.push(l)
                } else
                    for (var s = t.polygons, n = p2.vec2.create(), r = 0; r < s.length; r++) {
                        for (var o = s[r], a = [], h = 0; h < o.length; h += 2)
                            a.push([this.world.pxmi(o[h]), this.world.pxmi(o[h + 1])]);
                        for (var l = new p2.Convex({
                            vertices: a
                        }), c = 0; c !== l.vertices.length; c++) {
                            var u = l.vertices[c];
                            p2.vec2.sub(u, u, l.centerOfMass)
                        }
                        p2.vec2.scale(n, l.centerOfMass, 1),
                        n[0] -= this.world.pxmi(this.sprite.width / 2),
                        n[1] -= this.world.pxmi(this.sprite.height / 2),
                        l.updateTriangles(),
                        l.updateCenterOfMass(),
                        l.updateBoundingRadius(),
                        l.collisionGroup = t.filter.categoryBits,
                        l.collisionMask = t.filter.maskBits,
                        l.sensor = t.isSensor,
                        this.data.addShape(l, n),
                        e.push(l)
                    }
                return e
            },
            loadPolygon: function(t, e, i) {
                if (null === t)
                    var s = e;
                else
                    s = this.game.cache.getPhysicsData(t, e);
                "number" != typeof i && (i = 1);
                for (var n = p2.vec2.create(), r = 0; r < s.length; r++) {
                    for (var o = [], a = 0; a < s[r].shape.length; a += 2)
                        o.push([this.world.pxmi(s[r].shape[a] * i), this.world.pxmi(s[r].shape[a + 1] * i)]);
                    for (var h = new p2.Convex({
                        vertices: o
                    }), l = 0; l !== h.vertices.length; l++) {
                        var c = h.vertices[l];
                        p2.vec2.sub(c, c, h.centerOfMass)
                    }
                    p2.vec2.scale(n, h.centerOfMass, 1),
                    n[0] -= this.world.pxmi(this.sprite.width / 2),
                    n[1] -= this.world.pxmi(this.sprite.height / 2),
                    h.updateTriangles(),
                    h.updateCenterOfMass(),
                    h.updateBoundingRadius(),
                    this.data.addShape(h, n)
                }
                return this.data.aabbNeedsUpdate = !0,
                this.shapeChanged(),
                !0
            }
        },
        W.Physics.P2.Body.prototype.constructor = W.Physics.P2.Body,
        W.Physics.P2.Body.DYNAMIC = 1,
        W.Physics.P2.Body.STATIC = 2,
        W.Physics.P2.Body.KINEMATIC = 4,
        Object.defineProperty(W.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === W.Physics.P2.Body.STATIC
            },
            set: function(t) {
                t && this.data.type !== W.Physics.P2.Body.STATIC ? (this.data.type = W.Physics.P2.Body.STATIC,
                this.mass = 0) : t || this.data.type !== W.Physics.P2.Body.STATIC || (this.data.type = W.Physics.P2.Body.DYNAMIC,
                this.mass = 1)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === W.Physics.P2.Body.DYNAMIC
            },
            set: function(t) {
                t && this.data.type !== W.Physics.P2.Body.DYNAMIC ? (this.data.type = W.Physics.P2.Body.DYNAMIC,
                this.mass = 1) : t || this.data.type !== W.Physics.P2.Body.DYNAMIC || (this.data.type = W.Physics.P2.Body.STATIC,
                this.mass = 0)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === W.Physics.P2.Body.KINEMATIC
            },
            set: function(t) {
                t && this.data.type !== W.Physics.P2.Body.KINEMATIC ? (this.data.type = W.Physics.P2.Body.KINEMATIC,
                this.mass = 4) : t || this.data.type !== W.Physics.P2.Body.KINEMATIC || (this.data.type = W.Physics.P2.Body.STATIC,
                this.mass = 0)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(t) {
                t !== this.data.allowSleep && (this.data.allowSleep = t)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return W.Math.wrapAngle(W.Math.radToDeg(this.data.angle))
            },
            set: function(t) {
                this.data.angle = W.Math.degToRad(W.Math.wrapAngle(t))
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(t) {
                this.data.angularDamping = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(t) {
                this.data.angularForce = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(t) {
                this.data.angularVelocity = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(t) {
                this.data.damping = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(t) {
                t !== this.data.fixedRotation && (this.data.fixedRotation = t)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(t) {
                this.data.inertia = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(t) {
                t !== this.data.mass && (this.data.mass = t,
                this.data.updateMassProperties())
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(t) {
                t !== this.data.type && (this.data.type = t)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(t) {
                this.data.angle = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(t) {
                this.data.sleepSpeedLimit = t
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(t) {
                this.data.position[0] = this.world.pxmi(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(t) {
                this.data.position[1] = this.world.pxmi(t)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(t) {
                t && !this.debugBody ? this.debugBody = new W.Physics.P2.BodyDebug(this.game,this.data) : !t && this.debugBody && (this.debugBody.destroy(),
                this.debugBody = null)
            }
        }),
        Object.defineProperty(W.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(t) {
                t && !this._collideWorldBounds ? (this._collideWorldBounds = !0,
                this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1,
                this.updateCollisionMask())
            }
        }),
        W.Physics.P2.BodyDebug = function(t, e, i) {
            W.Group.call(this, t);
            var s = {
                pixelsPerLengthUnit: t.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = W.Utils.extend(s, i),
            this.ppu = this.settings.pixelsPerLengthUnit,
            this.ppu = -1 * this.ppu,
            this.body = e,
            this.canvas = new W.Graphics(t),
            this.canvas.alpha = this.settings.alpha,
            this.add(this.canvas),
            this.draw(),
            this.updateSpriteTransform()
        }
        ,
        W.Physics.P2.BodyDebug.prototype = Object.create(W.Group.prototype),
        W.Physics.P2.BodyDebug.prototype.constructor = W.Physics.P2.BodyDebug,
        W.Utils.extend(W.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu,
                this.position.y = this.body.position[1] * this.ppu,
                this.rotation = this.body.angle
            },
            draw: function() {
                var t, e, i, s, n, r, o, a, h, l, c, u, d, p, f;
                if (a = this.body,
                (l = this.canvas).clear(),
                i = parseInt(this.randomPastelHex(), 16),
                r = 16711680,
                o = this.lineWidth,
                a instanceof p2.Body && a.shapes.length) {
                    var g = a.shapes.length;
                    for (s = 0; s !== g; ) {
                        if (h = (e = a.shapes[s]).position || 0,
                        t = e.angle || 0,
                        e instanceof p2.Circle)
                            this.drawCircle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.radius * this.ppu, i, o);
                        else if (e instanceof p2.Capsule)
                            this.drawCapsule(l, h[0] * this.ppu, h[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, r, i, o);
                        else if (e instanceof p2.Plane)
                            this.drawPlane(l, h[0] * this.ppu, -h[1] * this.ppu, i, r, 5 * o, 10 * o, 10 * o, 100 * this.ppu, t);
                        else if (e instanceof p2.Line)
                            this.drawLine(l, e.length * this.ppu, r, o);
                        else if (e instanceof p2.Box)
                            this.drawRectangle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, r, i, o);
                        else if (e instanceof p2.Convex) {
                            for (u = [],
                            d = p2.vec2.create(),
                            n = p = 0,
                            f = e.vertices.length; 0 <= f ? p < f : f < p; n = 0 <= f ? ++p : --p)
                                c = e.vertices[n],
                                p2.vec2.rotate(d, c, t),
                                u.push([(d[0] + h[0]) * this.ppu, -(d[1] + h[1]) * this.ppu]);
                            this.drawConvex(l, u, e.triangles, r, i, o, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                        }
                        s++
                    }
                }
            },
            drawRectangle: function(t, e, i, s, n, r, o, a, h) {
                void 0 === h && (h = 1),
                void 0 === o && (o = 0),
                t.lineStyle(h, o, 1),
                t.beginFill(a),
                t.drawRect(e - n / 2, i - r / 2, n, r)
            },
            drawCircle: function(t, e, i, s, n, r, o) {
                void 0 === o && (o = 1),
                void 0 === r && (r = 16777215),
                t.lineStyle(o, 0, 1),
                t.beginFill(r, 1),
                t.drawCircle(e, i, 2 * -n),
                t.endFill(),
                t.moveTo(e, i),
                t.lineTo(e + n * Math.cos(-s), i + n * Math.sin(-s))
            },
            drawLine: function(t, e, i, s) {
                void 0 === s && (s = 1),
                void 0 === i && (i = 0),
                t.lineStyle(5 * s, i, 1),
                t.moveTo(-e / 2, 0),
                t.lineTo(e / 2, 0)
            },
            drawConvex: function(t, e, i, s, n, r, o, a) {
                var h, l, c, u, d, p, f, g, m, y, v;
                if (void 0 === r && (r = 1),
                void 0 === s && (s = 0),
                o) {
                    for (h = [16711680, 65280, 255],
                    l = 0; l !== e.length + 1; )
                        u = e[l % e.length],
                        d = e[(l + 1) % e.length],
                        f = u[0],
                        y = u[1],
                        g = d[0],
                        v = d[1],
                        t.lineStyle(r, h[l % h.length], 1),
                        t.moveTo(f, -y),
                        t.lineTo(g, -v),
                        t.drawCircle(f, -y, 2 * r),
                        l++;
                    return t.lineStyle(r, 0, 1),
                    t.drawCircle(a[0], a[1], 2 * r)
                }
                for (t.lineStyle(r, s, 1),
                t.beginFill(n),
                l = 0; l !== e.length; )
                    p = (c = e[l])[0],
                    m = c[1],
                    0 === l ? t.moveTo(p, -m) : t.lineTo(p, -m),
                    l++;
                if (t.endFill(),
                2 < e.length)
                    return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]),
                    t.lineTo(e[0][0], -e[0][1])
            },
            drawPath: function(t, e, i, s, n) {
                var r, o, a, h, l, c, u, d, p, f, g;
                for (void 0 === n && (n = 1),
                void 0 === i && (i = 0),
                t.lineStyle(n, i, 1),
                "number" == typeof s && t.beginFill(s),
                a = o = null,
                r = 0; r < e.length; )
                    f = (p = e[r])[0],
                    g = p[1],
                    f === o && g === a || (0 === r ? t.moveTo(f, g) : (h = o,
                    l = a,
                    c = f,
                    u = g,
                    d = e[(r + 1) % e.length][0],
                    0 != (c - h) * (e[(r + 1) % e.length][1] - l) - (d - h) * (u - l) && t.lineTo(f, g)),
                    o = f,
                    a = g),
                    r++;
                "number" == typeof s && t.endFill(),
                2 < e.length && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]),
                t.lineTo(e[0][0], e[0][1]))
            },
            drawPlane: function(t, e, i, s, n, r, o, a, h, l) {
                var c, u;
                void 0 === r && (r = 1),
                void 0 === s && (s = 16777215),
                t.lineStyle(r, n, 11),
                t.beginFill(s),
                t.moveTo(e, -i),
                c = e + Math.cos(l) * this.game.width,
                u = i + Math.sin(l) * this.game.height,
                t.lineTo(c, -u),
                t.moveTo(e, -i),
                c = e + Math.cos(l) * -this.game.width,
                u = i + Math.sin(l) * -this.game.height,
                t.lineTo(c, -u)
            },
            drawCapsule: function(t, e, i, s, n, r, o, a, h) {
                void 0 === h && (h = 1),
                void 0 === o && (o = 0),
                t.lineStyle(h, o, 1);
                var l = Math.cos(s)
                  , c = Math.sin(s);
                t.beginFill(a, 1),
                t.drawCircle(-n / 2 * l + e, -n / 2 * c + i, 2 * -r),
                t.drawCircle(n / 2 * l + e, n / 2 * c + i, 2 * -r),
                t.endFill(),
                t.lineStyle(h, o, 0),
                t.beginFill(a, 1),
                t.moveTo(-n / 2 * l + r * c + e, -n / 2 * c + r * l + i),
                t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i),
                t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i),
                t.lineTo(-n / 2 * l - r * c + e, -n / 2 * c - r * l + i),
                t.endFill(),
                t.lineStyle(h, o, 1),
                t.moveTo(-n / 2 * l + r * c + e, -n / 2 * c + r * l + i),
                t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i),
                t.moveTo(-n / 2 * l - r * c + e, -n / 2 * c - r * l + i),
                t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i)
            },
            randomPastelHex: function() {
                var t, e, i, s;
                return i = [255, 255, 255],
                s = Math.floor(256 * Math.random()),
                e = Math.floor(256 * Math.random()),
                t = Math.floor(256 * Math.random()),
                s = Math.floor((s + 3 * i[0]) / 4),
                e = Math.floor((e + 3 * i[1]) / 4),
                t = Math.floor((t + 3 * i[2]) / 4),
                this.rgbToHex(s, e, t)
            },
            rgbToHex: function(t, e, i) {
                return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
            },
            componentToHex: function(t) {
                var e;
                return 2 === (e = t.toString(16)).length ? e : e + "0"
            }
        }),
        W.Physics.P2.Spring = function(t, e, i, s, n, r, o, a, h, l) {
            this.game = t.game,
            void 0 === s && (s = 1),
            void 0 === n && (n = 100),
            void 0 === r && (r = 1);
            var c = {
                restLength: s = (this.world = t).pxm(s),
                stiffness: n,
                damping: r
            };
            null != o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]),
            null != a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]),
            null != h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]),
            null != l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]),
            this.data = new p2.LinearSpring(e,i,c),
            this.data.parent = this
        }
        ,
        W.Physics.P2.Spring.prototype.constructor = W.Physics.P2.Spring,
        W.Physics.P2.RotationalSpring = function(t, e, i, s, n, r) {
            this.game = t.game,
            this.world = t,
            void 0 === s && (s = null),
            void 0 === n && (n = 100),
            void 0 === r && (r = 1);
            var o = {
                restAngle: s = s && t.pxm(s),
                stiffness: n,
                damping: r
            };
            this.data = new p2.RotationalSpring(e,i,o),
            this.data.parent = this
        }
        ,
        W.Physics.P2.Spring.prototype.constructor = W.Physics.P2.Spring,
        W.Physics.P2.Material = function(t) {
            this.name = t,
            p2.Material.call(this)
        }
        ,
        W.Physics.P2.Material.prototype = Object.create(p2.Material.prototype),
        W.Physics.P2.Material.prototype.constructor = W.Physics.P2.Material,
        W.Physics.P2.ContactMaterial = function(t, e, i) {
            p2.ContactMaterial.call(this, t, e, i)
        }
        ,
        W.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype),
        W.Physics.P2.ContactMaterial.prototype.constructor = W.Physics.P2.ContactMaterial,
        W.Physics.P2.CollisionGroup = function(t) {
            this.mask = t
        }
        ,
        W.Physics.P2.DistanceConstraint = function(t, e, i, s, n, r, o) {
            void 0 === s && (s = 100),
            void 0 === n && (n = [0, 0]),
            void 0 === r && (r = [0, 0]),
            void 0 === o && (o = Number.MAX_VALUE),
            this.game = t.game;
            var a = {
                distance: s = (this.world = t).pxm(s),
                localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                maxForce: o
            };
            p2.DistanceConstraint.call(this, e, i, a)
        }
        ,
        W.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype),
        W.Physics.P2.DistanceConstraint.prototype.constructor = W.Physics.P2.DistanceConstraint,
        W.Physics.P2.GearConstraint = function(t, e, i, s, n) {
            void 0 === s && (s = 0),
            void 0 === n && (n = 1),
            this.game = t.game,
            this.world = t;
            var r = {
                angle: s,
                ratio: n
            };
            p2.GearConstraint.call(this, e, i, r)
        }
        ,
        W.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype),
        W.Physics.P2.GearConstraint.prototype.constructor = W.Physics.P2.GearConstraint,
        W.Physics.P2.LockConstraint = function(t, e, i, s, n, r) {
            void 0 === s && (s = [0, 0]),
            void 0 === n && (n = 0),
            void 0 === r && (r = Number.MAX_VALUE),
            this.game = t.game;
            var o = {
                localOffsetB: s = [(this.world = t).pxm(s[0]), t.pxm(s[1])],
                localAngleB: n,
                maxForce: r
            };
            p2.LockConstraint.call(this, e, i, o)
        }
        ,
        W.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype),
        W.Physics.P2.LockConstraint.prototype.constructor = W.Physics.P2.LockConstraint,
        W.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, r, o, a) {
            void 0 === s && (s = !0),
            void 0 === n && (n = [0, 0]),
            void 0 === r && (r = [0, 0]),
            void 0 === o && (o = [0, 0]),
            void 0 === a && (a = Number.MAX_VALUE),
            this.game = t.game;
            var h = {
                localAnchorA: n = [(this.world = t).pxmi(n[0]), t.pxmi(n[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                localAxisA: o,
                maxForce: a,
                disableRotationalLock: !s
            };
            p2.PrismaticConstraint.call(this, e, i, h)
        }
        ,
        W.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype),
        W.Physics.P2.PrismaticConstraint.prototype.constructor = W.Physics.P2.PrismaticConstraint,
        W.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, r, o) {
            void 0 === r && (r = Number.MAX_VALUE),
            void 0 === o && (o = null),
            this.game = t.game,
            i = [(this.world = t).pxmi(i[0]), t.pxmi(i[1])],
            n = [t.pxmi(n[0]), t.pxmi(n[1])];
            var a = {
                worldPivot: o = o && [t.pxmi(o[0]), t.pxmi(o[1])],
                localPivotA: i,
                localPivotB: n,
                maxForce: r
            };
            p2.RevoluteConstraint.call(this, e, s, a)
        }
        ,
        W.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype),
        W.Physics.P2.RevoluteConstraint.prototype.constructor = W.Physics.P2.RevoluteConstraint,
        W.ImageCollection = function(t, e, i, s, n, r, o) {
            (void 0 === i || i <= 0) && (i = 32),
            (void 0 === s || s <= 0) && (s = 32),
            void 0 === n && (n = 0),
            void 0 === r && (r = 0),
            this.name = t,
            this.firstgid = 0 | e,
            this.imageWidth = 0 | i,
            this.imageHeight = 0 | s,
            this.imageMargin = 0 | n,
            this.imageSpacing = 0 | r,
            this.properties = o || {},
            this.images = [],
            this.total = 0
        }
        ,
        W.ImageCollection.prototype = {
            containsImageIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            addImage: function(t, e) {
                this.images.push({
                    gid: t,
                    image: e
                }),
                this.total++
            }
        },
        W.ImageCollection.prototype.constructor = W.ImageCollection,
        W.Tile = function(t, e, i, s, n, r) {
            this.layer = t,
            this.index = e,
            this.x = i,
            this.y = s,
            this.rotation = 0,
            this.flipped = !1,
            this.worldX = i * n,
            this.worldY = s * r,
            this.width = n,
            this.height = r,
            this.centerX = Math.abs(n / 2),
            this.centerY = Math.abs(r / 2),
            this.alpha = 1,
            this.properties = {},
            this.scanned = !1,
            this.faceTop = !1,
            this.faceBottom = !1,
            this.faceLeft = !1,
            this.faceRight = !1,
            this.collideLeft = !1,
            this.collideRight = !1,
            this.collideUp = !1,
            this.collideDown = !1,
            this.collisionCallback = null,
            this.collisionCallbackContext = this
        }
        ,
        W.Tile.prototype = {
            containsPoint: function(t, e) {
                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
            },
            intersects: function(t, e, i, s) {
                return !(i <= this.worldX) && (!(s <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
            },
            setCollisionCallback: function(t, e) {
                this.collisionCallback = t,
                this.collisionCallbackContext = e
            },
            destroy: function() {
                this.collisionCallback = null,
                this.collisionCallbackContext = null,
                this.properties = null
            },
            setCollision: function(t, e, i, s) {
                this.collideLeft = t,
                this.collideRight = e,
                this.collideUp = i,
                this.collideDown = s,
                this.faceLeft = t,
                this.faceRight = e,
                this.faceTop = i,
                this.faceBottom = s
            },
            resetCollision: function() {
                this.collideLeft = !1,
                this.collideRight = !1,
                this.collideUp = !1,
                this.collideDown = !1,
                this.faceTop = !1,
                this.faceBottom = !1,
                this.faceLeft = !1,
                this.faceRight = !1
            },
            isInteresting: function(t, e) {
                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(t) {
                this.index = t.index,
                this.alpha = t.alpha,
                this.properties = t.properties,
                this.collideUp = t.collideUp,
                this.collideDown = t.collideDown,
                this.collideLeft = t.collideLeft,
                this.collideRight = t.collideRight,
                this.collisionCallback = t.collisionCallback,
                this.collisionCallbackContext = t.collisionCallbackContext
            }
        },
        W.Tile.prototype.constructor = W.Tile,
        Object.defineProperty(W.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }),
        Object.defineProperty(W.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }),
        Object.defineProperty(W.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }),
        Object.defineProperty(W.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }),
        Object.defineProperty(W.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }),
        Object.defineProperty(W.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }),
        W.Tilemap = function(t, e, i, s, n, r) {
            this.game = t,
            this.key = e;
            var o = W.TilemapParser.parse(this.game, e, i, s, n, r);
            null !== o && (this.width = o.width,
            this.height = o.height,
            this.tileWidth = o.tileWidth,
            this.tileHeight = o.tileHeight,
            this.orientation = o.orientation,
            this.format = o.format,
            this.version = o.version,
            this.properties = o.properties,
            this.widthInPixels = o.widthInPixels,
            this.heightInPixels = o.heightInPixels,
            this.layers = o.layers,
            this.tilesets = o.tilesets,
            this.imagecollections = o.imagecollections,
            this.tiles = o.tiles,
            this.objects = o.objects,
            this.collideIndexes = [],
            this.collision = o.collision,
            this.images = o.images,
            this.enableDebug = !1,
            this.currentLayer = 0,
            this.debugMap = [],
            this._results = [],
            this._tempA = 0,
            this._tempB = 0)
        }
        ,
        W.Tilemap.CSV = 0,
        W.Tilemap.TILED_JSON = 1,
        W.Tilemap.NORTH = 0,
        W.Tilemap.EAST = 1,
        W.Tilemap.SOUTH = 2,
        W.Tilemap.WEST = 3,
        W.Tilemap.prototype = {
            create: function(t, e, i, s, n, r) {
                return void 0 === r && (r = this.game.world),
                this.width = e,
                this.height = i,
                this.setTileSize(s, n),
                this.layers.length = 0,
                this.createBlankLayer(t, e, i, s, n, r)
            },
            setTileSize: function(t, e) {
                this.tileWidth = t,
                this.tileHeight = e,
                this.widthInPixels = this.width * t,
                this.heightInPixels = this.height * e
            },
            addTilesetImage: function(t, e, i, s, n, r, o) {
                if (void 0 === t)
                    return null;
                void 0 === i && (i = this.tileWidth),
                void 0 === s && (s = this.tileHeight),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                void 0 === o && (o = 0),
                0 === i && (i = 32),
                0 === s && (s = 32);
                var a = null;
                if (null == e && (e = t),
                e instanceof W.BitmapData)
                    a = e.canvas;
                else {
                    if (!this.game.cache.checkImageKey(e))
                        return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + e + '"'),
                        null;
                    a = this.game.cache.getImage(e)
                }
                var h = this.getTilesetIndex(t);
                if (null === h && this.format === W.Tilemap.TILED_JSON)
                    return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + t + '"'),
                    null;
                if (this.tilesets[h])
                    return this.tilesets[h].setImage(a),
                    this.tilesets[h];
                var l = new W.Tileset(t,o,i,s,n,r,{});
                l.setImage(a),
                this.tilesets.push(l);
                for (var c = this.tilesets.length - 1, u = n, d = n, p = 0, f = 0, g = 0, m = o; m < o + l.total && (this.tiles[m] = [u, d, c],
                u += i + r,
                ++p !== l.total) && (++f !== l.columns || (u = n,
                d += s + r,
                f = 0,
                ++g !== l.rows)); m++)
                    ;
                return l
            },
            createFromObjects: function(t, e, i, s, n, r, o, a, h) {
                if (void 0 === n && (n = !0),
                void 0 === r && (r = !1),
                void 0 === o && (o = this.game.world),
                void 0 === a && (a = W.Sprite),
                void 0 === h && (h = !0),
                this.objects[t])
                    for (var l = 0; l < this.objects[t].length; l++) {
                        var c = !1
                          , u = this.objects[t][l];
                        if (void 0 !== u.gid && "number" == typeof e && u.gid === e ? c = !0 : void 0 !== u.id && "number" == typeof e && u.id === e ? c = !0 : void 0 !== u.name && "string" == typeof e && u.name === e && (c = !0),
                        c) {
                            var d = new a(this.game,parseFloat(u.x, 10),parseFloat(u.y, 10),i,s);
                            for (var p in d.name = u.name,
                            d.visible = u.visible,
                            d.autoCull = r,
                            d.exists = n,
                            u.width && (d.width = u.width),
                            u.height && (d.height = u.height),
                            u.rotation && (d.angle = u.rotation),
                            h && (d.y -= d.height),
                            o.add(d),
                            u.properties)
                                o.set(d, p, u.properties[p], !1, !1, 0, !0)
                        }
                    }
                else
                    console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + t)
            },
            createFromTiles: function(t, e, i, s, n, r) {
                "number" == typeof t && (t = [t]),
                null == e ? e = [] : "number" == typeof e && (e = [e]),
                s = this.getLayer(s),
                void 0 === n && (n = this.game.world),
                void 0 === r && (r = {}),
                void 0 === r.customClass && (r.customClass = W.Sprite),
                void 0 === r.adjustY && (r.adjustY = !0);
                var o = this.layers[s].width
                  , a = this.layers[s].height;
                if (this.copy(0, 0, o, a, s),
                this._results.length < 2)
                    return 0;
                for (var h, l = 0, c = 1, u = this._results.length; c < u; c++)
                    if (-1 !== t.indexOf(this._results[c].index)) {
                        for (var d in h = new r.customClass(this.game,this._results[c].worldX,this._results[c].worldY,i),
                        r)
                            h[d] = r[d];
                        n.add(h),
                        l++
                    }
                if (1 === e.length)
                    for (c = 0; c < t.length; c++)
                        this.replace(t[c], e[0], 0, 0, o, a, s);
                else if (1 < e.length)
                    for (c = 0; c < t.length; c++)
                        this.replace(t[c], e[c], 0, 0, o, a, s);
                return l
            },
            createLayer: function(t, e, i, s) {
                void 0 === e && (e = this.game.width),
                void 0 === i && (i = this.game.height),
                void 0 === s && (s = this.game.world);
                var n = t;
                if ("string" == typeof t && (n = this.getLayerIndex(t)),
                !(null === n || n > this.layers.length)) {
                    void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width),
                    void 0 === i || i <= 0 ? i = Math.min(this.game.height, this.layers[n].heightInPixels) : i > this.game.height && (i = this.game.height),
                    this.enableDebug && (console.group("Tilemap.createLayer"),
                    console.log("Name:", this.layers[n].name),
                    console.log("Size:", e, "x", i),
                    console.log("Tileset:", this.tilesets[0].name, "index:", n));
                    var r = s.add(new W.TilemapLayer(this.game,this,n,e,i));
                    return this.enableDebug && console.groupEnd(),
                    r
                }
                console.warn("Tilemap.createLayer: Invalid layer ID given: " + n)
            },
            createBlankLayer: function(t, e, i, s, n, r) {
                if (void 0 === r && (r = this.game.world),
                null === this.getLayerIndex(t)) {
                    for (var o, a = {
                        name: t,
                        x: 0,
                        y: 0,
                        width: e,
                        height: i,
                        widthInPixels: e * s,
                        heightInPixels: i * n,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: null
                    }, h = [], l = 0; l < i; l++) {
                        o = [];
                        for (var c = 0; c < e; c++)
                            o.push(new W.Tile(a,-1,c,l,s,n));
                        h.push(o)
                    }
                    a.data = h,
                    this.layers.push(a),
                    this.currentLayer = this.layers.length - 1;
                    var u = a.widthInPixels
                      , d = a.heightInPixels;
                    return u > this.game.width && (u = this.game.width),
                    d > this.game.height && (d = this.game.height),
                    (h = new W.TilemapLayer(this.game,this,this.layers.length - 1,u,d)).name = t,
                    r.add(h)
                }
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + t)
            },
            getIndex: function(t, e) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].name === e)
                        return i;
                return null
            },
            getLayerIndex: function(t) {
                return this.getIndex(this.layers, t)
            },
            getTilesetIndex: function(t) {
                return this.getIndex(this.tilesets, t)
            },
            getImageIndex: function(t) {
                return this.getIndex(this.images, t)
            },
            setTileIndexCallback: function(t, e, i, s) {
                if (s = this.getLayer(s),
                "number" == typeof t)
                    this.layers[s].callbacks[t] = {
                        callback: e,
                        callbackContext: i
                    };
                else
                    for (var n = 0, r = t.length; n < r; n++)
                        this.layers[s].callbacks[t[n]] = {
                            callback: e,
                            callbackContext: i
                        }
            },
            setTileLocationCallback: function(t, e, i, s, n, r, o) {
                if (o = this.getLayer(o),
                this.copy(t, e, i, s, o),
                !(this._results.length < 2))
                    for (var a = 1; a < this._results.length; a++)
                        this._results[a].setCollisionCallback(n, r)
            },
            setCollision: function(t, e, i, s) {
                if (void 0 === e && (e = !0),
                void 0 === s && (s = !0),
                i = this.getLayer(i),
                "number" == typeof t)
                    return this.setCollisionByIndex(t, e, i, !0);
                if (Array.isArray(t)) {
                    for (var n = 0; n < t.length; n++)
                        this.setCollisionByIndex(t[n], e, i, !1);
                    s && this.calculateFaces(i)
                }
            },
            setCollisionBetween: function(t, e, i, s, n) {
                if (void 0 === i && (i = !0),
                void 0 === n && (n = !0),
                s = this.getLayer(s),
                !(e < t)) {
                    for (var r = t; r <= e; r++)
                        this.setCollisionByIndex(r, i, s, !1);
                    n && this.calculateFaces(s)
                }
            },
            setCollisionByExclusion: function(t, e, i, s) {
                void 0 === e && (e = !0),
                void 0 === s && (s = !0),
                i = this.getLayer(i);
                for (var n = 0, r = this.tiles.length; n < r; n++)
                    -1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                s && this.calculateFaces(i)
            },
            setCollisionByIndex: function(t, e, i, s) {
                if (void 0 === e && (e = !0),
                void 0 === i && (i = this.currentLayer),
                void 0 === s && (s = !0),
                e)
                    this.collideIndexes.push(t);
                else {
                    var n = this.collideIndexes.indexOf(t);
                    -1 < n && this.collideIndexes.splice(n, 1)
                }
                for (var r = 0; r < this.layers[i].height; r++)
                    for (var o = 0; o < this.layers[i].width; o++) {
                        var a = this.layers[i].data[r][o];
                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(),
                        a.faceTop = e,
                        a.faceBottom = e,
                        a.faceLeft = e,
                        a.faceRight = e)
                    }
                return s && this.calculateFaces(i),
                i
            },
            getLayer: function(t) {
                return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof W.TilemapLayer && (t = t.index),
                t
            },
            setPreventRecalculate: function(t) {
                if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0,
                this.needToRecalculate = {}),
                !1 === t && !0 === this.preventingRecalculate) {
                    for (var e in this.preventingRecalculate = !1,
                    this.needToRecalculate)
                        this.calculateFaces(e);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(t) {
                if (this.preventingRecalculate)
                    this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, s = null, n = null, r = 0, o = this.layers[t].height; r < o; r++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) {
                            var l = this.layers[t].data[r][a];
                            l && (e = this.getTileAbove(t, a, r),
                            i = this.getTileBelow(t, a, r),
                            s = this.getTileLeft(t, a, r),
                            n = this.getTileRight(t, a, r),
                            l.collides && (l.faceTop = !0,
                            l.faceBottom = !0,
                            l.faceLeft = !0,
                            l.faceRight = !0),
                            e && e.collides && (l.faceTop = !1),
                            i && i.collides && (l.faceBottom = !1),
                            s && s.collides && (l.faceLeft = !1),
                            n && n.collides && (l.faceRight = !1))
                        }
            },
            getTileAbove: function(t, e, i) {
                return 0 < i ? this.layers[t].data[i - 1][e] : null
            },
            getTileBelow: function(t, e, i) {
                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
            },
            getTileLeft: function(t, e, i) {
                return 0 < e ? this.layers[t].data[i][e - 1] : null
            },
            getTileRight: function(t, e, i) {
                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
            },
            setLayer: function(t) {
                t = this.getLayer(t),
                this.layers[t] && (this.currentLayer = t)
            },
            hasTile: function(t, e, i) {
                return i = this.getLayer(i),
                void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && -1 < this.layers[i].data[e][t].index
            },
            removeTile: function(t, e, i) {
                if (i = this.getLayer(i),
                0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height && this.hasTile(t, e, i)) {
                    var s = this.layers[i].data[e][t];
                    return this.layers[i].data[e][t] = new W.Tile(this.layers[i],-1,t,e,this.tileWidth,this.tileHeight),
                    this.layers[i].dirty = !0,
                    this.calculateFaces(i),
                    s
                }
            },
            removeTileWorldXY: function(t, e, i, s, n) {
                return n = this.getLayer(n),
                t = this.game.math.snapToFloor(t, i) / i,
                e = this.game.math.snapToFloor(e, s) / s,
                this.removeTile(t, e, n)
            },
            putTile: function(t, e, i, s) {
                return null === t ? this.removeTile(e, i, s) : (s = this.getLayer(s),
                0 <= e && e < this.layers[s].width && 0 <= i && i < this.layers[s].height ? (t instanceof W.Tile ? (n = t.index,
                this.hasTile(e, i, s) ? this.layers[s].data[i][e].copy(t) : this.layers[s].data[i][e] = new W.Tile(s,n,e,i,t.width,t.height)) : (n = t,
                this.hasTile(e, i, s) ? this.layers[s].data[i][e].index = n : this.layers[s].data[i][e] = new W.Tile(this.layers[s],n,e,i,this.tileWidth,this.tileHeight)),
                -1 < this.collideIndexes.indexOf(n) ? this.layers[s].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[i][e].resetCollision(),
                this.layers[s].dirty = !0,
                this.calculateFaces(s),
                this.layers[s].data[i][e]) : null);
                var n
            },
            putTileWorldXY: function(t, e, i, s, n, r) {
                return r = this.getLayer(r),
                e = this.game.math.snapToFloor(e, s) / s,
                i = this.game.math.snapToFloor(i, n) / n,
                this.putTile(t, e, i, r)
            },
            searchTileIndex: function(t, e, i, s) {
                void 0 === e && (e = 0),
                void 0 === i && (i = !1),
                s = this.getLayer(s);
                var n = 0;
                if (i) {
                    for (var r = this.layers[s].height - 1; 0 <= r; r--)
                        for (var o = this.layers[s].width - 1; 0 <= o; o--)
                            if (this.layers[s].data[r][o].index === t) {
                                if (n === e)
                                    return this.layers[s].data[r][o];
                                n++
                            }
                } else
                    for (r = 0; r < this.layers[s].height; r++)
                        for (o = 0; o < this.layers[s].width; o++)
                            if (this.layers[s].data[r][o].index === t) {
                                if (n === e)
                                    return this.layers[s].data[r][o];
                                n++
                            }
                return null
            },
            getTile: function(t, e, i, s) {
                return void 0 === s && (s = !1),
                i = this.getLayer(i),
                0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
            },
            getTileWorldXY: function(t, e, i, s, n, r) {
                return void 0 === i && (i = this.tileWidth),
                void 0 === s && (s = this.tileHeight),
                n = this.getLayer(n),
                t = this.game.math.snapToFloor(t, i) / i,
                e = this.game.math.snapToFloor(e, s) / s,
                this.getTile(t, e, n, r)
            },
            copy: function(t, e, i, s, n) {
                if (n = this.getLayer(n),
                this.layers[n]) {
                    void 0 === t && (t = 0),
                    void 0 === e && (e = 0),
                    void 0 === i && (i = this.layers[n].width),
                    void 0 === s && (s = this.layers[n].height),
                    t < 0 && (t = 0),
                    e < 0 && (e = 0),
                    i > this.layers[n].width && (i = this.layers[n].width),
                    s > this.layers[n].height && (s = this.layers[n].height),
                    this._results.length = 0,
                    this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: s,
                        layer: n
                    });
                    for (var r = e; r < e + s; r++)
                        for (var o = t; o < t + i; o++)
                            this._results.push(this.layers[n].data[r][o]);
                    return this._results
                }
                this._results.length = 0
            },
            paste: function(t, e, i, s) {
                if (void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                s = this.getLayer(s),
                i && !(i.length < 2)) {
                    for (var n = t - i[1].x, r = e - i[1].y, o = 1; o < i.length; o++)
                        this.layers[s].data[r + i[o].y][n + i[o].x].copy(i[o]);
                    this.layers[s].dirty = !0,
                    this.calculateFaces(s)
                }
            },
            swap: function(t, e, i, s, n, r, o) {
                o = this.getLayer(o),
                this.copy(i, s, n, r, o),
                this._results.length < 2 || (this._tempA = t,
                this._tempB = e,
                this._results.forEach(this.swapHandler, this),
                this.paste(i, s, this._results, o))
            },
            swapHandler: function(t) {
                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
            },
            forEach: function(t, e, i, s, n, r, o) {
                o = this.getLayer(o),
                this.copy(i, s, n, r, o),
                this._results.length < 2 || (this._results.forEach(t, e),
                this.paste(i, s, this._results, o))
            },
            replace: function(t, e, i, s, n, r, o) {
                if (o = this.getLayer(o),
                this.copy(i, s, n, r, o),
                !(this._results.length < 2)) {
                    for (var a = 1; a < this._results.length; a++)
                        this._results[a].index === t && (this._results[a].index = e);
                    this.paste(i, s, this._results, o)
                }
            },
            random: function(t, e, i, s, n) {
                if (n = this.getLayer(n),
                this.copy(t, e, i, s, n),
                !(this._results.length < 2)) {
                    for (var r = [], o = 1; o < this._results.length; o++)
                        if (this._results[o].index) {
                            var a = this._results[o].index;
                            -1 === r.indexOf(a) && r.push(a)
                        }
                    for (var h = 1; h < this._results.length; h++)
                        this._results[h].index = this.game.rnd.pick(r);
                    this.paste(t, e, this._results, n)
                }
            },
            shuffle: function(t, e, i, s, n) {
                if (n = this.getLayer(n),
                this.copy(t, e, i, s, n),
                !(this._results.length < 2)) {
                    for (var r = [], o = 1; o < this._results.length; o++)
                        this._results[o].index && r.push(this._results[o].index);
                    W.ArrayUtils.shuffle(r);
                    for (var a = 1; a < this._results.length; a++)
                        this._results[a].index = r[a - 1];
                    this.paste(t, e, this._results, n)
                }
            },
            fill: function(t, e, i, s, n, r) {
                if (r = this.getLayer(r),
                this.copy(e, i, s, n, r),
                !(this._results.length < 2)) {
                    for (var o = 1; o < this._results.length; o++)
                        this._results[o].index = t;
                    this.paste(e, i, this._results, r)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0,
                this.currentLayer = 0
            },
            dump: function() {
                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                    for (var s = 0; s < this.layers[this.currentLayer].width; s++)
                        t += "%c  ",
                        1 < this.layers[this.currentLayer].data[i][s] ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n"
                }
                e[0] = t,
                console.log.apply(console, e)
            },
            destroy: function() {
                this.removeAllLayers(),
                this.data = [],
                this.game = null
            }
        },
        W.Tilemap.prototype.constructor = W.Tilemap,
        Object.defineProperty(W.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(t) {
                t !== this.currentLayer && this.setLayer(t)
            }
        }),
        W.TilemapLayer = function(t, e, i, s, n) {
            s |= 0,
            n |= 0,
            W.Sprite.call(this, t, 0, 0),
            this.map = e,
            this.index = i,
            this.layer = e.layers[i],
            this.canvas = W.CanvasPool.create(this, s, n),
            this.context = this.canvas.getContext("2d"),
            this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas,null,this.game.resolution))),
            this.type = W.TILEMAPLAYER,
            this.physicsType = W.TILEMAPLAYER,
            this.renderSettings = {
                enableScrollDelta: !0,
                overdrawRatio: .2,
                copyCanvas: null
            },
            this.debug = !1,
            this.exists = !0,
            this.debugSettings = {
                missingImageFill: "rgb(255,255,255)",
                debuggedTileOverfill: "rgba(0,255,0,0.4)",
                forceFullRedraw: !0,
                debugAlpha: .5,
                facingEdgeStroke: "rgba(0,255,0,1)",
                collidingTileOverfill: "rgba(0,255,0,0.2)"
            },
            this.scrollFactorX = 1,
            this.scrollFactorY = 1,
            this.dirty = !0,
            this.rayStepRate = 4,
            this._wrap = !1,
            this._mc = {
                scrollX: 0,
                scrollY: 0,
                renderWidth: 0,
                renderHeight: 0,
                tileWidth: e.tileWidth,
                tileHeight: e.tileHeight,
                cw: e.tileWidth,
                ch: e.tileHeight,
                tilesets: []
            },
            this._scrollX = 0,
            this._scrollY = 0,
            this.tileOffset = new W.Point(this.layer.offsetX || 0,this.layer.offsetY || 0),
            this._results = [],
            t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = W.TilemapLayer.ensureSharedCopyCanvas()),
            this.fixedToCamera = !0
        }
        ,
        W.TilemapLayer.prototype = Object.create(W.Sprite.prototype),
        W.TilemapLayer.prototype.constructor = W.TilemapLayer,
        W.TilemapLayer.prototype.preUpdateCore = W.Component.Core.preUpdate,
        W.TilemapLayer.sharedCopyCanvas = null,
        W.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = W.CanvasPool.create(this, 2, 2)),
            this.sharedCopyCanvas
        }
        ,
        W.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }
        ,
        W.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
            this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
            this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y
        }
        ,
        W.TilemapLayer.prototype._renderCanvas = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
            this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
            this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y,
            this.render(),
            PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }
        ,
        W.TilemapLayer.prototype._renderWebGL = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
            this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
            this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y,
            this.render(),
            PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }
        ,
        W.TilemapLayer.prototype.destroy = function() {
            W.CanvasPool.remove(this),
            W.Component.Destroy.prototype.destroy.call(this)
        }
        ,
        W.TilemapLayer.prototype.resize = function(t, e) {
            this.canvas.width = t,
            this.canvas.height = e,
            this.texture.frame.resize(t, e),
            this.texture.width = t,
            this.texture.height = e,
            this.texture.crop.width = t,
            this.texture.crop.height = e,
            this.texture.baseTexture.width = t,
            this.texture.baseTexture.height = e,
            this.texture.baseTexture.dirty(),
            this.texture.requiresUpdate = !0,
            this.texture._updateUvs(),
            this.dirty = !0
        }
        ,
        W.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }
        ,
        W.TilemapLayer.prototype.getTileOffsetX = function() {
            return this.tileOffset.x || (this.fixedToCamera ? 0 : this.position.x)
        }
        ,
        W.TilemapLayer.prototype.getTileOffsetY = function() {
            return this.tileOffset.y || (this.fixedToCamera ? 0 : this.position.y)
        }
        ,
        W.TilemapLayer.prototype._fixX = function(t) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
        }
        ,
        W.TilemapLayer.prototype._unfixX = function(t) {
            return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
        }
        ,
        W.TilemapLayer.prototype._fixY = function(t) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
        }
        ,
        W.TilemapLayer.prototype._unfixY = function(t) {
            return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
        }
        ,
        W.TilemapLayer.prototype.getTileX = function(t) {
            return Math.floor(this._fixX(t) / this._mc.tileWidth)
        }
        ,
        W.TilemapLayer.prototype.getTileY = function(t) {
            return Math.floor(this._fixY(t) / this._mc.tileHeight)
        }
        ,
        W.TilemapLayer.prototype.getTileXY = function(t, e, i) {
            return i.x = this.getTileX(t),
            i.y = this.getTileY(e),
            i
        }
        ,
        W.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
            e = e || this.rayStepRate,
            void 0 === i && (i = !1),
            void 0 === s && (s = !1);
            var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
            if (0 === n.length)
                return [];
            for (var r = t.coordinatesOnLine(e), o = [], a = 0; a < n.length; a++)
                for (var h = 0; h < r.length; h++) {
                    var l = n[a]
                      , c = r[h];
                    if (l.containsPoint(c[0], c[1])) {
                        o.push(l);
                        break
                    }
                }
            return o
        }
        ,
        W.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, r) {
            void 0 === n && (n = !1),
            void 0 === r && (r = !1);
            var o = !(n || r);
            t = this._fixX(t),
            e = this._fixY(e);
            for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length; )
                this._results.pop();
            for (var u = h; u < h + c; u++)
                for (var d = a; d < a + l; d++) {
                    var p = this.layer.data[u];
                    p && p[d] && (o || p[d].isInteresting(n, r)) && this._results.push(p[d])
                }
            return this._results.slice()
        }
        ,
        W.TilemapLayer.prototype.resolveTileset = function(t) {
            var e = this._mc.tilesets;
            if (t < 2e3)
                for (; e.length < t; )
                    e.push(void 0);
            var i = this.map.tiles[t] && this.map.tiles[t][2];
            if (null !== i) {
                var s = this.map.tilesets[i];
                if (s && s.containsTileIndex(t))
                    return e[t] = s
            }
            return e[t] = null
        }
        ,
        W.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var t = this._mc.tilesets; t.length; )
                t.pop()
        }
        ,
        W.TilemapLayer.prototype.setScale = function(t, e) {
            t = t || 1,
            e = e || t;
            for (var i = 0; i < this.layer.data.length; i++)
                for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
                    var r = s[n];
                    r.width = this.map.tileWidth * t,
                    r.height = this.map.tileHeight * e,
                    r.worldX = r.x * r.width,
                    r.worldY = r.y * r.height
                }
            this.scale.setTo(t, e)
        }
        ,
        W.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
            var s = t.canvas
              , n = s.width - Math.abs(e)
              , r = s.height - Math.abs(i)
              , o = 0
              , a = 0
              , h = e
              , l = i;
            e < 0 && (o = -e,
            h = 0),
            i < 0 && (a = -i,
            l = 0);
            var c = this.renderSettings.copyCanvas;
            if (c) {
                (c.width < n || c.height < r) && (c.width = n,
                c.height = r);
                var u = c.getContext("2d");
                u.clearRect(0, 0, n, r),
                u.drawImage(s, o, a, n, r, 0, 0, n, r),
                t.clearRect(h, l, n, r),
                t.drawImage(c, 0, 0, n, r, h, l, n, r)
            } else
                t.save(),
                t.globalCompositeOperation = "copy",
                t.drawImage(s, o, a, n, r, h, l, n, r),
                t.restore()
        }
        ,
        W.TilemapLayer.prototype.renderRegion = function(t, e, i, s, n, r) {
            var o = this.context
              , a = this.layer.width
              , h = this.layer.height
              , l = this._mc.tileWidth
              , c = this._mc.tileHeight
              , u = this._mc.tilesets
              , d = NaN;
            this._wrap || (i <= n && (i = Math.max(0, i),
            n = Math.min(a - 1, n)),
            s <= r && (s = Math.max(0, s),
            r = Math.min(h - 1, r)));
            var p, f, g, m, y, v, x = i * l - t, b = (i + (1 << 20) * a) % a;
            for (m = (s + (1 << 20) * h) % h,
            v = r - s,
            f = s * c - e; 0 <= v; m++,
            v--,
            f += c) {
                h <= m && (m -= h);
                var _ = this.layer.data[m];
                for (g = b,
                y = n - i,
                p = x; 0 <= y; g++,
                y--,
                p += l) {
                    a <= g && (g -= a);
                    var w = _[g];
                    if (w && !(w.index < 0)) {
                        var T = w.index
                          , P = u[T];
                        void 0 === P && (P = this.resolveTileset(T)),
                        w.alpha === d || this.debug || (o.globalAlpha = w.alpha,
                        d = w.alpha),
                        P ? w.rotation || w.flipped ? (o.save(),
                        o.translate(p + w.centerX, f + w.centerY),
                        o.rotate(w.rotation),
                        w.flipped && o.scale(-1, 1),
                        P.draw(o, -w.centerX, -w.centerY, T),
                        o.restore()) : P.draw(o, p, f, T) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill,
                        o.fillRect(p, f, l, c)),
                        w.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill,
                        o.fillRect(p, f, l, c))
                    }
                }
            }
        }
        ,
        W.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
            var i = this._mc.scrollX
              , s = this._mc.scrollY
              , n = this.canvas.width
              , r = this.canvas.height
              , o = this._mc.tileWidth
              , a = this._mc.tileHeight
              , h = 0
              , l = -o
              , c = 0
              , u = -a;
            if (t < 0 ? (h = n + t,
            l = n - 1) : 0 < t && (l = t),
            e < 0 ? (c = r + e,
            u = r - 1) : 0 < e && (u = e),
            this.shiftCanvas(this.context, t, e),
            h = Math.floor((h + i) / o),
            l = Math.floor((l + i) / o),
            c = Math.floor((c + s) / a),
            u = Math.floor((u + s) / a),
            h <= l) {
                this.context.clearRect(h * o - i, 0, (l - h + 1) * o, r);
                var d = Math.floor((0 + s) / a)
                  , p = Math.floor((r - 1 + s) / a);
                this.renderRegion(i, s, h, d, l, p)
            }
            if (c <= u) {
                this.context.clearRect(0, c * a - s, n, (u - c + 1) * a);
                var f = Math.floor((0 + i) / o)
                  , g = Math.floor((n - 1 + i) / o);
                this.renderRegion(i, s, f, c, g, u)
            }
        }
        ,
        W.TilemapLayer.prototype.renderFull = function() {
            var t = this._mc.scrollX
              , e = this._mc.scrollY
              , i = this.canvas.width
              , s = this.canvas.height
              , n = this._mc.tileWidth
              , r = this._mc.tileHeight
              , o = Math.floor(t / n)
              , a = Math.floor((i - 1 + t) / n)
              , h = Math.floor(e / r)
              , l = Math.floor((s - 1 + e) / r);
            this.context.clearRect(0, 0, i, s),
            this.renderRegion(t, e, o, h, a, l)
        }
        ,
        W.TilemapLayer.prototype.render = function() {
            var t = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (t = !(this.layer.dirty = !1));
                var e = this.canvas.width
                  , i = this.canvas.height
                  , s = 0 | this._scrollX
                  , n = 0 | this._scrollY
                  , r = this._mc
                  , o = r.scrollX - s
                  , a = r.scrollY - n;
                if (t || 0 != o || 0 != a || r.renderWidth !== e || r.renderHeight !== i)
                    return this.context.save(),
                    r.scrollX = s,
                    r.scrollY = n,
                    r.renderWidth === e && r.renderHeight === i || (r.renderWidth = e,
                    r.renderHeight = i),
                    this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha,
                    this.debugSettings.forceFullRedraw && (t = !0)),
                    !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(o, a) : this.renderFull(),
                    this.debug && (this.context.globalAlpha = 1,
                    this.renderDebug()),
                    this.texture.baseTexture.dirty(),
                    this.dirty = !1,
                    this.context.restore(),
                    !0
            }
        }
        ,
        W.TilemapLayer.prototype.renderDebug = function() {
            var t, e, i, s, n, r, o = this._mc.scrollX, a = this._mc.scrollY, h = this.context, l = this.canvas.width, c = this.canvas.height, u = this.layer.width, d = this.layer.height, p = this._mc.tileWidth, f = this._mc.tileHeight, g = Math.floor(o / p), m = Math.floor((l - 1 + o) / p), y = Math.floor(a / f), v = Math.floor((c - 1 + a) / f), x = g * p - o, b = y * f - a, _ = (g + (1 << 20) * u) % u, w = (y + (1 << 20) * d) % d;
            for (h.strokeStyle = this.debugSettings.facingEdgeStroke,
            s = w,
            r = v - y,
            e = b; 0 <= r; s++,
            r--,
            e += f) {
                d <= s && (s -= d);
                var T = this.layer.data[s];
                for (i = _,
                n = m - g,
                t = x; 0 <= n; i++,
                n--,
                t += p) {
                    u <= i && (i -= u);
                    var P = T[i];
                    !P || P.index < 0 || !P.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill,
                    h.fillRect(t, e, this._mc.cw, this._mc.ch)),
                    this.debugSettings.facingEdgeStroke && (h.beginPath(),
                    P.faceTop && (h.moveTo(t, e),
                    h.lineTo(t + this._mc.cw, e)),
                    P.faceBottom && (h.moveTo(t, e + this._mc.ch),
                    h.lineTo(t + this._mc.cw, e + this._mc.ch)),
                    P.faceLeft && (h.moveTo(t, e),
                    h.lineTo(t, e + this._mc.ch)),
                    P.faceRight && (h.moveTo(t + this._mc.cw, e),
                    h.lineTo(t + this._mc.cw, e + this._mc.ch)),
                    h.closePath(),
                    h.stroke()))
                }
            }
        }
        ,
        Object.defineProperty(W.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(t) {
                this._wrap = t,
                this.dirty = !0
            }
        }),
        Object.defineProperty(W.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(t) {
                this._scrollX = t
            }
        }),
        Object.defineProperty(W.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(t) {
                this._scrollY = t
            }
        }),
        Object.defineProperty(W.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(t) {
                this._mc.cw = 0 | t,
                this.dirty = !0
            }
        }),
        Object.defineProperty(W.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(t) {
                this._mc.ch = 0 | t,
                this.dirty = !0
            }
        }),
        W.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(t, e, i, s, n, r) {
                if (void 0 === i && (i = 32),
                void 0 === s && (s = 32),
                void 0 === n && (n = 10),
                void 0 === r && (r = 10),
                void 0 === e)
                    return this.getEmptyData();
                if (null === e)
                    return this.getEmptyData(i, s, n, r);
                var o = t.cache.getTilemapData(e);
                if (o) {
                    if (o.format === W.Tilemap.CSV)
                        return this.parseCSV(e, o.data, i, s);
                    if (!o.format || o.format === W.Tilemap.TILED_JSON)
                        return this.parseTiledJSON(o.data)
                } else
                    console.warn("Phaser.TilemapParser.parse - No map data found for key " + e)
            },
            parseCSV: function(t, e, i, s) {
                for (var n = this.getEmptyData(), r = [], o = (e = e.trim()).split("\n"), a = o.length, h = 0, l = 0; l < o.length; l++) {
                    r[l] = [];
                    for (var c = o[l].split(","), u = 0; u < c.length; u++)
                        r[l][u] = new W.Tile(n.layers[0],parseInt(c[u], 10),u,l,i,s);
                    0 === h && (h = c.length)
                }
                return n.format = W.Tilemap.CSV,
                n.name = t,
                n.width = h,
                n.height = a,
                n.tileWidth = i,
                n.tileHeight = s,
                n.widthInPixels = h * i,
                n.heightInPixels = a * s,
                n.layers[0].width = h,
                n.layers[0].height = a,
                n.layers[0].widthInPixels = n.widthInPixels,
                n.layers[0].heightInPixels = n.heightInPixels,
                n.layers[0].data = r,
                n
            },
            getEmptyData: function(t, e, i, s) {
                return {
                    width: null != i ? i : 0,
                    height: null != s ? s : 0,
                    tileWidth: null != t ? t : 0,
                    tileHeight: null != e ? e : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            parseTiledJSON: function(t) {
                if ("orthogonal" !== t.orientation)
                    return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"),
                    null;
                for (var e = {
                    width: t.width,
                    height: t.height,
                    tileWidth: t.tilewidth,
                    tileHeight: t.tileheight,
                    orientation: t.orientation,
                    format: W.Tilemap.TILED_JSON,
                    version: t.version,
                    properties: t.properties,
                    widthInPixels: t.width * t.tilewidth,
                    heightInPixels: t.height * t.tileheight
                }, i = [], s = 0; s < t.layers.length; s++)
                    if ("tilelayer" === t.layers[s].type) {
                        var n = t.layers[s];
                        if (!n.compression && n.encoding && "base64" === n.encoding) {
                            for (var r = window.atob(n.data), o = r.length, a = new Array(o), h = 0; h < o; h += 4)
                                a[h / 4] = (r.charCodeAt(h) | r.charCodeAt(h + 1) << 8 | r.charCodeAt(h + 2) << 16 | r.charCodeAt(h + 3) << 24) >>> 0;
                            n.data = a,
                            delete n.encoding
                        } else if (n.compression) {
                            console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + n.name + "'");
                            continue
                        }
                        var l = {
                            name: n.name,
                            x: n.x,
                            y: n.y,
                            width: n.width,
                            height: n.height,
                            widthInPixels: n.width * t.tilewidth,
                            heightInPixels: n.height * t.tileheight,
                            alpha: n.opacity,
                            offsetX: n.offsetx,
                            offsetY: n.offsety,
                            visible: n.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        };
                        n.properties && (l.properties = n.properties);
                        var c, u, d, p = 0, f = [], g = [], m = 0;
                        for (o = n.data.length; m < o; m++) {
                            if (u = !1,
                            d = c = 0,
                            536870912 < (S = n.data[m]))
                                switch (2147483648 < S && (S -= 2147483648,
                                d += 4),
                                1073741824 < S && (S -= 1073741824,
                                d += 2),
                                536870912 < S && (S -= 536870912,
                                d += 1),
                                d) {
                                case 5:
                                    c = Math.PI / 2;
                                    break;
                                case 6:
                                    c = Math.PI;
                                    break;
                                case 3:
                                    c = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    u = !(c = 0);
                                    break;
                                case 7:
                                    c = Math.PI / 2,
                                    u = !0;
                                    break;
                                case 2:
                                    c = Math.PI,
                                    u = !0;
                                    break;
                                case 1:
                                    c = 3 * Math.PI / 2,
                                    u = !0
                                }
                            if (0 < S)
                                (A = new W.Tile(l,S,p,g.length,t.tilewidth,t.tileheight)).rotation = c,
                                A.flipped = u,
                                0 !== d && (A.flippedVal = d),
                                f.push(A);
                            else
                                W.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new W.Tile(l,-1,p,g.length,t.tilewidth,t.tileheight));
                            ++p === n.width && (g.push(f),
                            p = 0,
                            f = [])
                        }
                        l.data = g,
                        i.push(l)
                    }
                e.layers = i;
                var y = [];
                for (s = 0; s < t.layers.length; s++)
                    if ("imagelayer" === t.layers[s].type) {
                        var v = t.layers[s]
                          , x = {
                            name: v.name,
                            image: v.image,
                            x: v.x,
                            y: v.y,
                            alpha: v.opacity,
                            visible: v.visible,
                            properties: {}
                        };
                        v.properties && (x.properties = v.properties),
                        y.push(x)
                    }
                e.images = y;
                var b = []
                  , _ = []
                  , w = null;
                for (s = 0; s < t.tilesets.length; s++) {
                    if ((F = t.tilesets[s]).image) {
                        var T = new W.Tileset(F.name,F.firstgid,F.tilewidth,F.tileheight,F.margin,F.spacing,F.properties);
                        F.tileproperties && (T.tileProperties = F.tileproperties),
                        T.updateTileData(F.imagewidth, F.imageheight),
                        b.push(T)
                    } else {
                        var P = new W.ImageCollection(F.name,F.firstgid,F.tilewidth,F.tileheight,F.margin,F.spacing,F.properties);
                        for (var C in F.tiles) {
                            x = F.tiles[C].image;
                            var S = F.firstgid + parseInt(C, 10);
                            P.addImage(S, x)
                        }
                        _.push(P)
                    }
                    w && (w.lastgid = F.firstgid - 1),
                    w = F
                }
                e.tilesets = b,
                e.imagecollections = _;
                var A, E, M = {}, R = {};
                function L(t, e) {
                    var i = {};
                    for (var s in e) {
                        var n = e[s];
                        void 0 !== t[n] && (i[n] = t[n])
                    }
                    return i
                }
                for (s = 0; s < t.layers.length; s++)
                    if ("objectgroup" === t.layers[s].type) {
                        var B = t.layers[s];
                        M[B.name] = [],
                        R[B.name] = [];
                        var I = 0;
                        for (o = B.objects.length; I < o; I++)
                            if (B.objects[I].gid) {
                                var O = {
                                    gid: B.objects[I].gid,
                                    name: B.objects[I].name,
                                    type: B.objects[I].hasOwnProperty("type") ? B.objects[I].type : "",
                                    x: B.objects[I].x,
                                    y: B.objects[I].y,
                                    visible: B.objects[I].visible,
                                    properties: B.objects[I].properties
                                };
                                B.objects[I].rotation && (O.rotation = B.objects[I].rotation),
                                M[B.name].push(O)
                            } else if (B.objects[I].polyline) {
                                O = {
                                    name: B.objects[I].name,
                                    type: B.objects[I].type,
                                    x: B.objects[I].x,
                                    y: B.objects[I].y,
                                    width: B.objects[I].width,
                                    height: B.objects[I].height,
                                    visible: B.objects[I].visible,
                                    properties: B.objects[I].properties
                                };
                                B.objects[I].rotation && (O.rotation = B.objects[I].rotation),
                                O.polyline = [];
                                for (var k = 0; k < B.objects[I].polyline.length; k++)
                                    O.polyline.push([B.objects[I].polyline[k].x, B.objects[I].polyline[k].y]);
                                R[B.name].push(O),
                                M[B.name].push(O)
                            } else if (B.objects[I].polygon) {
                                (O = L(B.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                                for (k = 0; k < B.objects[I].polygon.length; k++)
                                    O.polygon.push([B.objects[I].polygon[k].x, B.objects[I].polygon[k].y]);
                                M[B.name].push(O)
                            } else if (B.objects[I].ellipse) {
                                O = L(B.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                                M[B.name].push(O)
                            } else {
                                (O = L(B.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0,
                                M[B.name].push(O)
                            }
                    }
                e.objects = M,
                e.collision = R,
                e.tiles = [];
                for (s = 0; s < e.tilesets.length; s++) {
                    p = (F = e.tilesets[s]).tileMargin;
                    var F, D = F.tileMargin, U = 0, G = 0, N = 0;
                    for (m = F.firstgid; m < F.firstgid + F.total && (e.tiles[m] = [p, D, s],
                    p += F.tileWidth + F.tileSpacing,
                    ++U !== F.total) && (++G !== F.columns || (p = F.tileMargin,
                    D += F.tileHeight + F.tileSpacing,
                    G = 0,
                    ++N !== F.rows)); m++)
                        ;
                }
                for (s = 0; s < e.layers.length; s++) {
                    l = e.layers[s],
                    F = null;
                    for (h = 0; h < l.data.length; h++) {
                        f = l.data[h];
                        for (var X = 0; X < f.length; X++)
                            null === (A = f[X]) || A.index < 0 || (E = e.tiles[A.index][2],
                            (F = e.tilesets[E]).tileProperties && F.tileProperties[A.index - F.firstgid] && (A.properties = W.Utils.mixin(F.tileProperties[A.index - F.firstgid], A.properties)))
                    }
                }
                return e
            }
        },
        W.Tileset = function(t, e, i, s, n, r, o) {
            (void 0 === i || i <= 0) && (i = 32),
            (void 0 === s || s <= 0) && (s = 32),
            void 0 === n && (n = 0),
            void 0 === r && (r = 0),
            this.name = t,
            this.firstgid = 0 | e,
            this.tileWidth = 0 | i,
            this.tileHeight = 0 | s,
            this.tileMargin = 0 | n,
            this.tileSpacing = 0 | r,
            this.properties = o || {},
            this.image = null,
            this.rows = 0,
            this.columns = 0,
            this.total = 0,
            this.drawCoords = []
        }
        ,
        W.Tileset.prototype = {
            draw: function(t, e, i, s) {
                var n = s - this.firstgid << 1;
                0 <= n && 1 + n < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[1 + n], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            setImage: function(t) {
                this.image = t,
                this.updateTileData(t.width, t.height)
            },
            setSpacing: function(t, e) {
                this.tileMargin = 0 | t,
                this.tileSpacing = 0 | e,
                this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(t, e) {
                var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing)
                  , s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i % 1 == 0 && s % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"),
                i = Math.floor(i),
                s = Math.floor(s),
                (this.rows && this.rows !== i || this.columns && this.columns !== s) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"),
                this.rows = i,
                this.columns = s,
                this.total = i * s,
                this.drawCoords.length = 0;
                for (var n = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) {
                    for (var a = 0; a < this.columns; a++)
                        this.drawCoords.push(n),
                        this.drawCoords.push(r),
                        n += this.tileWidth + this.tileSpacing;
                    n = this.tileMargin,
                    r += this.tileHeight + this.tileSpacing
                }
            }
        },
        W.Tileset.prototype.constructor = W.Tileset,
        W.Particle = function(t, e, i, s, n) {
            W.Sprite.call(this, t, e, i, s, n),
            this.autoScale = !1,
            this.scaleData = null,
            this._s = 0,
            this.autoAlpha = !1,
            this.alphaData = null,
            this._a = 0
        }
        ,
        W.Particle.prototype = Object.create(W.Sprite.prototype),
        W.Particle.prototype.constructor = W.Particle,
        W.Particle.prototype.update = function() {
            this.autoScale && (this._s--,
            this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1),
            this.autoAlpha && (this._a--,
            this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }
        ,
        W.Particle.prototype.onEmit = function() {}
        ,
        W.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t,
            this._a = t.length - 1,
            this.alpha = this.alphaData[this._a].v,
            this.autoAlpha = !0
        }
        ,
        W.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t,
            this._s = t.length - 1,
            this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y),
            this.autoScale = !0
        }
        ,
        W.Particle.prototype.reset = function(t, e, i) {
            return W.Component.Reset.prototype.reset.call(this, t, e, i),
            this.alpha = 1,
            this.scale.set(1),
            this.autoScale = !1,
            this.autoAlpha = !1,
            this
        }
        ,
        W.Particles = function(t) {
            this.game = t,
            this.emitters = {},
            this.ID = 0
        }
        ,
        W.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.id] = t
            },
            remove: function(t) {
                delete this.emitters[t.id]
            },
            update: function() {
                for (var t in this.emitters)
                    this.emitters[t].exists && this.emitters[t].update()
            }
        },
        W.Particles.prototype.constructor = W.Particles,
        W.Particles.Arcade = {},
        W.Particles.Arcade.Emitter = function(t, e, i, s) {
            this.maxParticles = s || 50,
            W.Group.call(this, t),
            this._id = this.game.particles.ID++,
            this.name = "emitter" + this.id,
            this.type = W.EMITTER,
            this.physicsType = W.GROUP,
            this.area = new W.Rectangle(e,i,1,1),
            this.minParticleSpeed = new W.Point(-100,-100),
            this.maxParticleSpeed = new W.Point(100,100),
            this.minParticleScale = 1,
            this.maxParticleScale = 1,
            this.scaleData = null,
            this.minRotation = -360,
            this.maxRotation = 360,
            this.minParticleAlpha = 1,
            this.maxParticleAlpha = 1,
            this.alphaData = null,
            this.gravity = new W.Point(0,100),
            this.particleClass = W.Particle,
            this.particleDrag = new W.Point,
            this.angularDrag = 0,
            this.frequency = 100,
            this.lifespan = 2e3,
            this.bounce = new W.Point,
            this.on = !1,
            this.particleAnchor = new W.Point(.5,.5),
            this.blendMode = W.blendModes.NORMAL,
            this.emitX = e,
            this.emitY = i,
            this.autoScale = !1,
            this.autoAlpha = !1,
            this.particleBringToTop = !1,
            this.particleSendToBack = !1,
            this._minParticleScale = new W.Point(1,1),
            this._maxParticleScale = new W.Point(1,1),
            this._quantity = 0,
            this._timer = 0,
            this._counter = 0,
            this._flowQuantity = 0,
            this._flowTotal = 0,
            this._explode = !0,
            this._frames = null
        }
        ,
        W.Particles.Arcade.Emitter.prototype = Object.create(W.Group.prototype),
        W.Particles.Arcade.Emitter.prototype.constructor = W.Particles.Arcade.Emitter,
        W.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion,
                0 !== this._flowTotal)
                    if (0 < this._flowQuantity) {
                        for (var t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++,
                            -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else
                        this.emitParticle() && (this._counter++,
                        -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
                else
                    this.emitParticle() && (this._counter++,
                    0 < this._quantity && this._counter >= this._quantity && (this.on = !1));
            for (t = this.children.length; t--; )
                this.children[t].exists && this.children[t].update()
        }
        ,
        W.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n, r) {
            var o;
            void 0 === e && (e = 0),
            void 0 === i && (i = this.maxParticles),
            void 0 === s && (s = !1),
            void 0 === n && (n = !1),
            void 0 === r && (r = null);
            var a = 0
              , h = t
              , l = e;
            for (this._frames = e,
            i > this.maxParticles && (this.maxParticles = i); a < i; )
                Array.isArray(t) && (h = this.game.rnd.pick(t)),
                Array.isArray(e) && (l = this.game.rnd.pick(e)),
                o = new this.particleClass(this.game,0,0,h,l,r),
                this.game.physics.arcade.enable(o, !1),
                o.body.checkCollision.none = !s,
                o.body.collideWorldBounds = n,
                o.body.skipQuadTree = !0,
                o.exists = !1,
                o.visible = !1,
                o.anchor.copyFrom(this.particleAnchor),
                this.add(o),
                a++;
            return this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1,
            this.alive = !1,
            this.exists = !1,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0,
            this.exists = !0,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return void 0 === e && (e = this.maxParticles),
            this._flowTotal = 0,
            this.start(!0, t, 0, e, !1),
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, n) {
            return null == e && (e = 250),
            void 0 !== i && 0 !== i || (i = 1),
            void 0 === s && (s = -1),
            void 0 === n && (n = !0),
            i > this.maxParticles && (i = this.maxParticles),
            this._counter = 0,
            this._flowQuantity = i,
            this._flowTotal = s,
            n ? (this.start(!0, t, e, i),
            this._counter += i,
            this.on = !0,
            this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i),
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
            if (void 0 === t && (t = !0),
            void 0 === e && (e = 0),
            null == i && (i = 250),
            void 0 === s && (s = 0),
            void 0 === n && (n = !1),
            s > this.maxParticles && (s = this.maxParticles),
            this.revive(),
            this.visible = !0,
            this.lifespan = e,
            this.frequency = i,
            t || n)
                for (var r = 0; r < s; r++)
                    this.emitParticle();
            else
                this.on = !0,
                this._quantity = s,
                this._counter = 0,
                this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
            void 0 === t && (t = null),
            void 0 === e && (e = null);
            var n = this.getFirstExists(!1);
            if (null === n)
                return !1;
            var r = this.game.rnd;
            void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && n.loadTexture(i);
            var o = this.emitX
              , a = this.emitY;
            null !== t ? o = t : 1 < this.width && (o = r.between(this.left, this.right)),
            null !== e ? a = e : 1 < this.height && (a = r.between(this.top, this.bottom)),
            n.reset(o, a),
            n.angle = 0,
            n.lifespan = this.lifespan,
            this.particleBringToTop ? this.bringToTop(n) : this.particleSendToBack && this.sendToBack(n),
            this.autoScale ? n.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? n.scale.set(r.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || n.scale.set(r.realInRange(this._minParticleScale.x, this._maxParticleScale.x), r.realInRange(this._minParticleScale.y, this._maxParticleScale.y)),
            void 0 === s && (Array.isArray(this._frames) ? n.frame = this.game.rnd.pick(this._frames) : n.frame = this._frames),
            this.autoAlpha ? n.setAlphaData(this.alphaData) : n.alpha = r.realInRange(this.minParticleAlpha, this.maxParticleAlpha),
            n.blendMode = this.blendMode;
            var h = n.body;
            return h.updateBounds(),
            h.bounce.copyFrom(this.bounce),
            h.drag.copyFrom(this.particleDrag),
            h.velocity.x = r.between(this.minParticleSpeed.x, this.maxParticleSpeed.x),
            h.velocity.y = r.between(this.minParticleSpeed.y, this.maxParticleSpeed.y),
            h.angularVelocity = r.between(this.minRotation, this.maxRotation),
            h.gravity = this.gravity,
            h.angularDrag = this.angularDrag,
            n.onEmit(),
            !0
        }
        ,
        W.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this),
            W.Group.prototype.destroy.call(this, !0, !1)
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t,
            this.area.height = e,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0,
            e = e || 0,
            this.minParticleSpeed.x = t,
            this.maxParticleSpeed.x = e,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0,
            e = e || 0,
            this.minParticleSpeed.y = t,
            this.maxParticleSpeed.y = e,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0,
            e = e || 0,
            this.minRotation = t,
            this.maxRotation = e,
            this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, i, s, n) {
            if (void 0 === t && (t = 1),
            void 0 === e && (e = 1),
            void 0 === i && (i = 0),
            void 0 === s && (s = W.Easing.Linear.None),
            void 0 === n && (n = !1),
            this.minParticleAlpha = t,
            this.maxParticleAlpha = e,
            this.autoAlpha = !1,
            0 < i && t !== e) {
                var r = {
                    v: t
                }
                  , o = this.game.make.tween(r).to({
                    v: e
                }, i, s);
                o.yoyo(n),
                this.alphaData = o.generateData(60),
                this.alphaData.reverse(),
                this.autoAlpha = !0
            }
            return this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.setScale = function(t, e, i, s, n, r, o) {
            if (void 0 === t && (t = 1),
            void 0 === e && (e = 1),
            void 0 === i && (i = 1),
            void 0 === s && (s = 1),
            void 0 === n && (n = 0),
            void 0 === r && (r = W.Easing.Linear.None),
            void 0 === o && (o = !1),
            this.minParticleScale = 1,
            this.maxParticleScale = 1,
            this._minParticleScale.set(t, i),
            this._maxParticleScale.set(e, s),
            this.autoScale = !1,
            0 < n && (t !== e || i !== s)) {
                var a = {
                    x: t,
                    y: i
                }
                  , h = this.game.make.tween(a).to({
                    x: e,
                    y: s
                }, n, r);
                h.yoyo(o),
                this.scaleData = h.generateData(60),
                this.scaleData.reverse(),
                this.autoScale = !0
            }
            return this
        }
        ,
        W.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x,
            this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width,
            this.emitY = t.world.y + t.anchor.y * t.height),
            this
        }
        ,
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "id", {
            get: function() {
                return this._id
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(t) {
                this.area.width = t
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(t) {
                this.area.height = t
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(t) {
                this.emitX = t
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(t) {
                this.emitY = t
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }),
        Object.defineProperty(W.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }),
        W.Weapon = function(t, e) {
            W.Plugin.call(this, t, e),
            this.bullets = null,
            this.autoExpandBulletsGroup = !1,
            this.autofire = !1,
            this.shots = 0,
            this.fireLimit = 0,
            this.fireRate = 100,
            this.fireRateVariance = 0,
            this.fireFrom = new W.Rectangle(0,0,1,1),
            this.fireAngle = W.ANGLE_UP,
            this.bulletInheritSpriteSpeed = !1,
            this.bulletAnimation = "",
            this.bulletFrameRandom = !1,
            this.bulletFrameCycle = !1,
            this.bulletWorldWrap = !1,
            this.bulletWorldWrapPadding = 0,
            this.bulletAngleOffset = 0,
            this.bulletAngleVariance = 0,
            this.bulletSpeed = 200,
            this.bulletSpeedVariance = 0,
            this.bulletLifespan = 0,
            this.bulletKillDistance = 0,
            this.bulletGravity = new W.Point(0,0),
            this.bulletRotateToVelocity = !1,
            this.bulletKey = "",
            this.bulletFrame = "",
            this._bulletClass = W.Bullet,
            this._bulletCollideWorldBounds = !1,
            this._bulletKillType = W.Weapon.KILL_WORLD_BOUNDS,
            this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            },
            this.bounds = new W.Rectangle,
            this.bulletBounds = t.world.bounds,
            this.bulletFrames = [],
            this.bulletFrameIndex = 0,
            this.anims = {},
            this.onFire = new W.Signal,
            this.onKill = new W.Signal,
            this.onFireLimit = new W.Signal,
            this.trackedSprite = null,
            this.trackedPointer = null,
            this.multiFire = !1,
            this._hasFired = !1,
            this.trackRotation = !1,
            this.trackOffset = new W.Point,
            this._nextFire = 0,
            this._tempNextFire = 0,
            this._rotatedPoint = new W.Point
        }
        ,
        W.Weapon.prototype = Object.create(W.Plugin.prototype),
        W.Weapon.prototype.constructor = W.Weapon,
        W.Weapon.KILL_NEVER = 0,
        W.Weapon.KILL_LIFESPAN = 1,
        W.Weapon.KILL_DISTANCE = 2,
        W.Weapon.KILL_WEAPON_BOUNDS = 3,
        W.Weapon.KILL_CAMERA_BOUNDS = 4,
        W.Weapon.KILL_WORLD_BOUNDS = 5,
        W.Weapon.KILL_STATIC_BOUNDS = 6,
        W.Weapon.prototype.createBullets = function(t, e, i, s) {
            return void 0 === t && (t = 1),
            void 0 === s && (s = this.game.world),
            this.bullets || (this.bullets = this.game.add.physicsGroup(W.Physics.ARCADE, s),
            this.bullets.classType = this._bulletClass),
            0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0,
            t = 1),
            this.bullets.createMultiple(t, e, i),
            this.bullets.setAll("data.bulletManager", this),
            this.bulletKey = e,
            this.bulletFrame = i),
            this
        }
        ,
        W.Weapon.prototype.forEach = function(t, e) {
            return this.bullets.forEachExists(t, e, arguments),
            this
        }
        ,
        W.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1),
            this
        }
        ,
        W.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0),
            this
        }
        ,
        W.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0),
            this.bullets.setAll("body.enable", !0),
            this
        }
        ,
        W.Weapon.prototype.resetShots = function(t) {
            return void (this.shots = 0) !== t && (this.fireLimit = t),
            this
        }
        ,
        W.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1),
            this.bullets.destroy(),
            this.game = null,
            this.parent = null,
            this.active = !1,
            this.visible = !1
        }
        ,
        W.Weapon.prototype.update = function() {
            this._bulletKillType === W.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(),
            this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)),
            this.autofire && this.fire()
        }
        ,
        W.Weapon.prototype.postRender = function() {
            this.multiFire && this._hasFired && (this._hasFired = !1,
            this._nextFire = this._tempNextFire)
        }
        ,
        W.Weapon.prototype.trackSprite = function(t, e, i, s) {
            return void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = !1),
            this.trackedPointer = null,
            this.trackedSprite = t,
            this.trackRotation = s,
            this.trackOffset.set(e, i),
            this
        }
        ,
        W.Weapon.prototype.trackPointer = function(t, e, i) {
            return void 0 === t && (t = this.game.input.activePointer),
            void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            this.trackedPointer = t,
            this.trackedSprite = null,
            this.trackRotation = !1,
            this.trackOffset.set(e, i),
            this
        }
        ,
        W.Weapon.prototype.fireMany = function(t, e) {
            this.multiFire = !0;
            var i = []
              , s = this;
            return e || this.trackedSprite || this.trackedPointer ? t.forEach(function(t) {
                i.push(s.fire(e, null, null, t.x, t.y))
            }) : t.forEach(function(t) {
                i.push(s.fire(t))
            }),
            i
        }
        ,
        W.Weapon.prototype.fireOffset = function(t, e) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            this.fire(null, null, null, t, e)
        }
        ,
        W.Weapon.prototype.fire = function(t, e, i, s, n) {
            if (void 0 === e && (e = null),
            void 0 === i && (i = null),
            this.game.time.now < this._nextFire || 0 < this.fireLimit && this.shots === this.fireLimit)
                return null;
            var r = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (r += W.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)),
            t ? 1 < this.fireFrom.width ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x,
            this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y),
            this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.worldRotation),
            1 < this.fireFrom.width ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x,
            this.fireFrom.y = this._rotatedPoint.y)) : 1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x,
            this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y),
            this.bulletInheritSpriteSpeed && (r += this.trackedSprite.body.speed)) : this.trackedPointer && (1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x,
            this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)),
            void 0 !== s && (this.fireFrom.x += s),
            void 0 !== n && (this.fireFrom.y += n);
            var o = 1 < this.fireFrom.width ? this.fireFrom.randomX : this.fireFrom.x
              , a = 1 < this.fireFrom.height ? this.fireFrom.randomY : this.fireFrom.y
              , h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            null !== e && null !== i && (h = this.game.math.radToDeg(Math.atan2(i - a, e - o))),
            0 !== this.bulletAngleVariance && (h += W.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var l = 0
              , c = 0;
            0 === h || 180 === h ? l = Math.cos(this.game.math.degToRad(h)) * r : c = (90 === h || 270 === h || (l = Math.cos(this.game.math.degToRad(h)) * r),
            Math.sin(this.game.math.degToRad(h)) * r);
            var u = null;
            if (this.autoExpandBulletsGroup ? (u = this.bullets.getFirstExists(!1, !0, o, a, this.bulletKey, this.bulletFrame)).data.bulletManager = this : u = this.bullets.getFirstExists(!1),
            u) {
                if (u.reset(o, a),
                u.data.fromX = o,
                u.data.fromY = a,
                u.data.killType = this.bulletKillType,
                u.data.killDistance = this.bulletKillDistance,
                u.data.rotateToVelocity = this.bulletRotateToVelocity,
                this.bulletKillType === W.Weapon.KILL_LIFESPAN && (u.lifespan = this.bulletLifespan),
                u.angle = h + this.bulletAngleOffset,
                "" !== this.bulletAnimation) {
                    if (null === u.animations.getAnimation(this.bulletAnimation)) {
                        var d = this.anims[this.bulletAnimation];
                        u.animations.add(d.name, d.frames, d.frameRate, d.loop, d.useNumericIndex)
                    }
                    u.animations.play(this.bulletAnimation)
                } else
                    this.bulletFrameCycle ? (u.frame = this.bulletFrames[this.bulletFrameIndex],
                    this.bulletFrameIndex++,
                    this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (u.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                u.data.bodyDirty && (this._data.customBody && u.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY),
                u.body.collideWorldBounds = this.bulletCollideWorldBounds,
                u.data.bodyDirty = !1),
                u.body.velocity.set(l, c),
                u.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y);
                var p = 0;
                if (0 !== this.bulletSpeedVariance) {
                    var f = this.fireRate;
                    (f += W.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (f = 0),
                    p = this.game.time.now + f
                } else
                    p = this.game.time.now + this.fireRate;
                this.multiFire ? this._hasFired || (this._hasFired = !0,
                this._tempNextFire = p,
                this.shots++) : (this._nextFire = p,
                this.shots++),
                this.onFire.dispatch(u, this, r),
                0 < this.fireLimit && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return u
        }
        ,
        W.Weapon.prototype.fireAtPointer = function(t) {
            return void 0 === t && (t = this.game.input.activePointer),
            this.fire(null, t.worldX, t.worldY)
        }
        ,
        W.Weapon.prototype.fireAtSprite = function(t) {
            return this.fire(null, t.world.x, t.world.y)
        }
        ,
        W.Weapon.prototype.fireAtXY = function(t, e) {
            return this.fire(null, t, e)
        }
        ,
        W.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
            return void 0 === i && (i = 0),
            void 0 === s && (s = 0),
            this._data.customBody = !0,
            this._data.width = t,
            this._data.height = e,
            this._data.offsetX = i,
            this._data.offsetY = s,
            this.bullets.callAll("body.setSize", "body", t, e, i, s),
            this.bullets.setAll("data.bodyDirty", !1),
            this
        }
        ,
        W.Weapon.prototype.setBulletFrames = function(t, e, i, s) {
            return void 0 === i && (i = !0),
            void 0 === s && (s = !1),
            this.bulletFrames = W.ArrayUtils.numberArray(t, e),
            this.bulletFrameIndex = 0,
            this.bulletFrameCycle = i,
            this.bulletFrameRandom = s,
            this
        }
        ,
        W.Weapon.prototype.addBulletAnimation = function(t, e, i, s, n) {
            return this.anims[t] = {
                name: t,
                frames: e,
                frameRate: i,
                loop: s,
                useNumericIndex: n
            },
            this.bullets.callAll("animations.add", "animations", t, e, i, s, n),
            this.bulletAnimation = t,
            this
        }
        ,
        W.Weapon.prototype.debug = function(t, e, i) {
            void 0 === t && (t = 16),
            void 0 === e && (e = 32),
            void 0 === i && (i = !1),
            this.game.debug.text("Weapon Plugin", t, e),
            this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24),
            i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }
        ,
        Object.defineProperty(W.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(t) {
                this._bulletClass = t,
                this.bullets && (this.bullets.classType = this._bulletClass)
            }
        }),
        Object.defineProperty(W.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(t) {
                switch (t) {
                case W.Weapon.KILL_STATIC_BOUNDS:
                case W.Weapon.KILL_WEAPON_BOUNDS:
                    this.bulletBounds = this.bounds;
                    break;
                case W.Weapon.KILL_CAMERA_BOUNDS:
                    this.bulletBounds = this.game.camera.view;
                    break;
                case W.Weapon.KILL_WORLD_BOUNDS:
                    this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = t
            }
        }),
        Object.defineProperty(W.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(t) {
                this._bulletCollideWorldBounds = t,
                this.bullets.setAll("body.collideWorldBounds", t),
                this.bullets.setAll("data.bodyDirty", !1)
            }
        }),
        Object.defineProperty(W.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(t) {
                this.fireFrom.x = t
            }
        }),
        Object.defineProperty(W.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(t) {
                this.fireFrom.y = t
            }
        }),
        W.Bullet = function(t, e, i, s, n) {
            W.Sprite.call(this, t, e, i, s, n),
            this.anchor.set(.5),
            this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }
        ,
        W.Bullet.prototype = Object.create(W.Sprite.prototype),
        W.Bullet.prototype.constructor = W.Bullet,
        W.Bullet.prototype.kill = function() {
            return this.alive = !1,
            this.exists = !1,
            this.visible = !1,
            this.data.bulletManager.onKill.dispatch(this),
            this
        }
        ,
        W.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > W.Weapon.KILL_LIFESPAN && (this.data.killType === W.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()),
            this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)),
            this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }
        ,
        W.Video = function(t, e, i) {
            if (void 0 === e && (e = null),
            void 0 === i && (i = null),
            this.game = t,
            this.key = e,
            this.width = 0,
            this.height = 0,
            this.type = W.VIDEO,
            this.disableTextureUpload = !1,
            this.touchLocked = !1,
            this.onPlay = new W.Signal,
            this.onChangeSource = new W.Signal,
            this.onComplete = new W.Signal,
            this.onAccess = new W.Signal,
            this.onError = new W.Signal,
            this.onTimeout = new W.Signal,
            this.timeout = 15e3,
            this._timeOutID = null,
            this.video = null,
            this.videoStream = null,
            this.isStreaming = !1,
            this.retryLimit = 20,
            this.retry = 0,
            this.retryInterval = 500,
            this._retryID = null,
            this._codeMuted = !1,
            this._muted = !1,
            this._codePaused = !1,
            this._paused = !1,
            this._pending = !1,
            this._pendingChangeSource = !1,
            this._autoplay = !1,
            this._endCallback = null,
            this._playCallback = null,
            e && this.game.cache.checkVideoKey(e)) {
                var s = this.game.cache.getVideo(e);
                s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data,
                this.width = this.video.videoWidth,
                this.height = this.video.videoHeight
            } else
                i && this.createVideoFromURL(i, !1);
            this.video && !i ? this.baseTexture = new PIXI.BaseTexture(this.video,null,this.game.resolution) : this.baseTexture = new PIXI.BaseTexture(W.Cache.DEFAULT.baseTexture.source,null,this.game.resolution),
            this.baseTexture.forceLoaded(this.width, this.height),
            this.texture = new PIXI.Texture(this.baseTexture),
            this.textureFrame = new W.Frame(0,0,0,this.width,this.height,"video"),
            this.texture.setFrame(this.textureFrame),
            this.texture.valid = !1,
            null !== e && this.video && (this.texture.valid = this.video.canplay),
            this.snapshot = null,
            W.BitmapData && (this.snapshot = new W.BitmapData(this.game,"",this.width,this.height)),
            !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
        }
        ,
        W.Video.prototype = {
            connectToMediaStream: function(t, e) {
                return t && e && (this.video = t,
                this.videoStream = e,
                this.isStreaming = !0,
                this.baseTexture.source = this.video,
                this.updateTexture(null, this.video.videoWidth, this.video.videoHeight),
                this.onAccess.dispatch(this)),
                this
            },
            startMediaStream: function(t, e, i) {
                if (void 0 === t && (t = !1),
                void 0 === e && (e = null),
                void 0 === i && (i = null),
                !this.game.device.getUserMedia)
                    return this.onError.dispatch(this, "No getUserMedia"),
                    !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()),
                this.removeVideoElement(),
                this.video = document.createElement("video"),
                this.video.setAttribute("autoplay", "autoplay"),
                null !== e && (this.video.width = e),
                null !== i && (this.video.height = i),
                this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: t,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (t) {
                    this.getUserMediaError(t)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID),
                this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(t) {
                clearTimeout(this._timeOutID),
                this.onError.dispatch(this, t)
            },
            getUserMediaSuccess: function(t) {
                clearTimeout(this._timeOutID),
                this.videoStream = t,
                void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                var n = this;
                this.video.onloadeddata = function() {
                    var s = 10;
                    !function t() {
                        if (0 < s)
                            if (0 < n.video.videoWidth) {
                                var e = n.video.videoWidth
                                  , i = n.video.videoHeight;
                                isNaN(n.video.videoHeight) && (i = e / (4 / 3)),
                                n.video.play(),
                                n.isStreaming = !0,
                                n.baseTexture.source = n.video,
                                n.updateTexture(null, e, i),
                                n.onAccess.dispatch(n)
                            } else
                                window.setTimeout(t, 500);
                        else
                            console.warn("Unable to connect to video stream. Webcam error?");
                        s--
                    }()
                }
            },
            createVideoFromBlob: function(t) {
                var e = this;
                return this.video = document.createElement("video"),
                this.video.controls = !1,
                this.video.setAttribute("autoplay", "autoplay"),
                this.video.addEventListener("loadeddata", function(t) {
                    e.updateTexture(t)
                }, !0),
                this.video.src = window.URL.createObjectURL(t),
                this.video.canplay = !0,
                this
            },
            createVideoFromURL: function(t, e) {
                return void 0 === e && (e = !1),
                this.texture && (this.texture.valid = !1),
                this.video = document.createElement("video"),
                this.video.controls = !1,
                e && this.video.setAttribute("autoplay", "autoplay"),
                this.video.src = t,
                this.video.canplay = !0,
                this.video.load(),
                this.retry = this.retryLimit,
                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
                this.key = t,
                this
            },
            updateTexture: function(t, e, i) {
                var s = !1;
                null == e && (e = this.video.videoWidth,
                s = !0),
                null == i && (i = this.video.videoHeight),
                this.width = e,
                this.height = i,
                this.baseTexture.source !== this.video && (this.baseTexture.source = this.video),
                this.baseTexture.forceLoaded(e, i),
                this.texture.frame.resize(e, i),
                this.texture.width = e,
                this.texture.height = i,
                this.texture.valid = !0,
                this.snapshot && this.snapshot.resize(e, i),
                s && null !== this.key && (this.onChangeSource.dispatch(this, e, i),
                this._autoplay && (this.video.play(),
                this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(t, e) {
                return this._pendingChangeSource || (void 0 === t && (t = !1),
                void 0 === e && (e = 1),
                this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this),
                this.game.sound.onUnMute.add(this.unsetMute, this),
                this.game.sound.mute && this.setMute()),
                this.game.onPause.add(this.setPause, this),
                this.game.onResume.add(this.setResume, this),
                this._endCallback = this.complete.bind(this),
                this.video.addEventListener("ended", this._endCallback, !0),
                this.video.addEventListener("webkitendfullscreen", this._endCallback, !0),
                this.video.loop = t ? "loop" : "",
                this.video.playbackRate = e,
                this.touchLocked ? this._pending = !0 : (this._pending = !1,
                null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit,
                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this),
                this.video.addEventListener("playing", this._playCallback, !0))),
                this.video.play(),
                this.onPlay.dispatch(this, t, e))),
                this
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0),
                this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this),
                this.game.sound.onUnMute.remove(this.unsetMute, this)),
                this.game.onPause.remove(this.setPause, this),
                this.game.onResume.remove(this.setResume, this),
                this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(),
                this.video.src = null) : (this.video.src = "",
                this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                    t.stop()
                }) : this.videoStream.stop()),
                this.videoStream = null,
                this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0),
                this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0),
                this.video.removeEventListener("playing", this._playCallback, !0),
                this.touchLocked ? this._pending = !1 : this.video.pause()),
                this
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++)
                        t[e].loadTexture && t[e].loadTexture(this);
                else
                    t.loadTexture(this);
                return this
            },
            addToWorld: function(t, e, i, s, n, r) {
                n = n || 1,
                r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, s),
                o.scale.set(n, r),
                o
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0,
                this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1,
                this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0,
                this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1,
                this.video.ended || this.video.play())
            },
            changeSource: function(t, e) {
                return void 0 === e && (e = !0),
                this.texture.valid = !1,
                this.video.pause(),
                this._pendingChangeSource = !0,
                this.retry = this.retryLimit,
                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
                this.video.src = t,
                this.video.load(),
                (this._autoplay = e) || (this.paused = !0),
                this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? (this._pendingChangeSource = !1,
                this.updateTexture()) : (this.retry--,
                0 < this.retry ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming))
            },
            setTouchLock: function() {
                this.game.input.touch.addTouchLockCallback(this.unlock, this),
                this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1,
                this.video.play(),
                this.onPlay.dispatch(this, this.loop, this.playbackRate),
                this.key) {
                    var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1)
                }
                return !0
            },
            grab: function(t, e, i) {
                if (void 0 === t && (t = !1),
                void 0 === e && (e = 1),
                void 0 === i && (i = null),
                null !== this.snapshot)
                    return t && this.snapshot.cls(),
                    this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i),
                    this.snapshot;
                console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable")
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes(); )
                        this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"),
                    this.video.removeAttribute("src"),
                    this.video = null
                }
            },
            destroy: function() {
                this.stop(),
                this.removeVideoElement(),
                this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this),
                this._retryID && window.clearTimeout(this._retryID)
            }
        },
        Object.defineProperty(W.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(t) {
                this.video.currentTime = t
            }
        }),
        Object.defineProperty(W.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }),
        Object.defineProperty(W.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }),
        Object.defineProperty(W.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || null) {
                    if (this._muted)
                        return;
                    this._codeMuted = !0,
                    this.setMute()
                } else {
                    if (!this._muted)
                        return;
                    this._codeMuted = !1,
                    this.unsetMute()
                }
            }
        }),
        Object.defineProperty(W.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                if (t = t || null,
                !this.touchLocked)
                    if (t) {
                        if (this._paused)
                            return;
                        this._codePaused = !0,
                        this.setPause()
                    } else {
                        if (!this._paused)
                            return;
                        this._codePaused = !1,
                        this.setResume()
                    }
            }
        }),
        Object.defineProperty(W.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(t) {
                t < 0 ? t = 0 : 1 < t && (t = 1),
                this.video && (this.video.volume = t)
            }
        }),
        Object.defineProperty(W.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(t) {
                this.video && (this.video.playbackRate = t)
            }
        }),
        Object.defineProperty(W.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(t) {
                t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }),
        Object.defineProperty(W.Video.prototype, "playing", {
            get: function() {
                return !!this.video && !(this.video.paused && this.video.ended)
            }
        }),
        W.Video.prototype.constructor = W.Video,
        void 0 === PIXI.blendModes && (PIXI.blendModes = W.blendModes),
        void 0 === PIXI.scaleModes && (PIXI.scaleModes = W.scaleModes),
        void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)),
        void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix),
        PIXI.TextureSilentFail = !0,
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = W),
        exports.Phaser = W) : "undefined" != typeof define && define.amd ? define("Phaser", t.Phaser = W) : t.Phaser = W,
        W
    }
    .call(this);
    !function(t) {
        "use strict";
        var e = {};
        "undefined" == typeof exports ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (e.exports = {},
        define(function() {
            return e.exports
        })) : e.exports = "undefined" != typeof window ? window : t : e.exports = exports,
        function(t) {
            if (!q)
                var q = 1e-6;
            if (!i)
                var i = "undefined" != typeof Float32Array ? Float32Array : Array;
            if (!s)
                var s = Math.random;
            var e = {
                setMatrixArrayType: function(t) {
                    i = t
                }
            };
            void 0 !== t && (t.glMatrix = e);
            var r = Math.PI / 180;
            e.toRadian = function(t) {
                return t * r
            }
            ;
            var c, n = {};
            n.create = function() {
                var t = new i(2);
                return t[0] = 0,
                t[1] = 0,
                t
            }
            ,
            n.clone = function(t) {
                var e = new i(2);
                return e[0] = t[0],
                e[1] = t[1],
                e
            }
            ,
            n.fromValues = function(t, e) {
                var r = new i(2);
                return r[0] = t,
                r[1] = e,
                r
            }
            ,
            n.copy = function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t
            }
            ,
            n.set = function(t, e, r) {
                return t[0] = e,
                t[1] = r,
                t
            }
            ,
            n.add = function(t, e, r) {
                return t[0] = e[0] + r[0],
                t[1] = e[1] + r[1],
                t
            }
            ,
            n.subtract = function(t, e, r) {
                return t[0] = e[0] - r[0],
                t[1] = e[1] - r[1],
                t
            }
            ,
            n.sub = n.subtract,
            n.multiply = function(t, e, r) {
                return t[0] = e[0] * r[0],
                t[1] = e[1] * r[1],
                t
            }
            ,
            n.mul = n.multiply,
            n.divide = function(t, e, r) {
                return t[0] = e[0] / r[0],
                t[1] = e[1] / r[1],
                t
            }
            ,
            n.div = n.divide,
            n.min = function(t, e, r) {
                return t[0] = Math.min(e[0], r[0]),
                t[1] = Math.min(e[1], r[1]),
                t
            }
            ,
            n.max = function(t, e, r) {
                return t[0] = Math.max(e[0], r[0]),
                t[1] = Math.max(e[1], r[1]),
                t
            }
            ,
            n.scale = function(t, e, r) {
                return t[0] = e[0] * r,
                t[1] = e[1] * r,
                t
            }
            ,
            n.scaleAndAdd = function(t, e, r, n) {
                return t[0] = e[0] + r[0] * n,
                t[1] = e[1] + r[1] * n,
                t
            }
            ,
            n.distance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1];
                return Math.sqrt(r * r + n * n)
            }
            ,
            n.dist = n.distance,
            n.squaredDistance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1];
                return r * r + n * n
            }
            ,
            n.sqrDist = n.squaredDistance,
            n.length = function(t) {
                var e = t[0]
                  , r = t[1];
                return Math.sqrt(e * e + r * r)
            }
            ,
            n.len = n.length,
            n.squaredLength = function(t) {
                var e = t[0]
                  , r = t[1];
                return e * e + r * r
            }
            ,
            n.sqrLen = n.squaredLength,
            n.negate = function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t
            }
            ,
            n.inverse = function(t, e) {
                return t[0] = 1 / e[0],
                t[1] = 1 / e[1],
                t
            }
            ,
            n.normalize = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = r * r + n * n;
                return 0 < a && (a = 1 / Math.sqrt(a),
                t[0] = e[0] * a,
                t[1] = e[1] * a),
                t
            }
            ,
            n.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }
            ,
            n.cross = function(t, e, r) {
                var n = e[0] * r[1] - e[1] * r[0];
                return t[0] = t[1] = 0,
                t[2] = n,
                t
            }
            ,
            n.lerp = function(t, e, r, n) {
                var a = e[0]
                  , i = e[1];
                return t[0] = a + n * (r[0] - a),
                t[1] = i + n * (r[1] - i),
                t
            }
            ,
            n.random = function(t, e) {
                e = e || 1;
                var r = 2 * s() * Math.PI;
                return t[0] = Math.cos(r) * e,
                t[1] = Math.sin(r) * e,
                t
            }
            ,
            n.transformMat2 = function(t, e, r) {
                var n = e[0]
                  , a = e[1];
                return t[0] = r[0] * n + r[2] * a,
                t[1] = r[1] * n + r[3] * a,
                t
            }
            ,
            n.transformMat2d = function(t, e, r) {
                var n = e[0]
                  , a = e[1];
                return t[0] = r[0] * n + r[2] * a + r[4],
                t[1] = r[1] * n + r[3] * a + r[5],
                t
            }
            ,
            n.transformMat3 = function(t, e, r) {
                var n = e[0]
                  , a = e[1];
                return t[0] = r[0] * n + r[3] * a + r[6],
                t[1] = r[1] * n + r[4] * a + r[7],
                t
            }
            ,
            n.transformMat4 = function(t, e, r) {
                var n = e[0]
                  , a = e[1];
                return t[0] = r[0] * n + r[4] * a + r[12],
                t[1] = r[1] * n + r[5] * a + r[13],
                t
            }
            ,
            n.forEach = (c = n.create(),
            function(t, e, r, n, a, i) {
                var s, o;
                for (e = e || 2,
                r = r || 0,
                o = n ? Math.min(n * e + r, t.length) : t.length,
                s = r; s < o; s += e)
                    c[0] = t[s],
                    c[1] = t[s + 1],
                    a(c, c, i),
                    t[s] = c[0],
                    t[s + 1] = c[1];
                return t
            }
            ),
            n.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }
            ,
            void 0 !== t && (t.vec2 = n);
            var h, a = {};
            a.create = function() {
                var t = new i(3);
                return t[0] = 0,
                t[1] = 0,
                t[2] = 0,
                t
            }
            ,
            a.clone = function(t) {
                var e = new i(3);
                return e[0] = t[0],
                e[1] = t[1],
                e[2] = t[2],
                e
            }
            ,
            a.fromValues = function(t, e, r) {
                var n = new i(3);
                return n[0] = t,
                n[1] = e,
                n[2] = r,
                n
            }
            ,
            a.copy = function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t[2] = e[2],
                t
            }
            ,
            a.set = function(t, e, r, n) {
                return t[0] = e,
                t[1] = r,
                t[2] = n,
                t
            }
            ,
            a.add = function(t, e, r) {
                return t[0] = e[0] + r[0],
                t[1] = e[1] + r[1],
                t[2] = e[2] + r[2],
                t
            }
            ,
            a.subtract = function(t, e, r) {
                return t[0] = e[0] - r[0],
                t[1] = e[1] - r[1],
                t[2] = e[2] - r[2],
                t
            }
            ,
            a.sub = a.subtract,
            a.multiply = function(t, e, r) {
                return t[0] = e[0] * r[0],
                t[1] = e[1] * r[1],
                t[2] = e[2] * r[2],
                t
            }
            ,
            a.mul = a.multiply,
            a.divide = function(t, e, r) {
                return t[0] = e[0] / r[0],
                t[1] = e[1] / r[1],
                t[2] = e[2] / r[2],
                t
            }
            ,
            a.div = a.divide,
            a.min = function(t, e, r) {
                return t[0] = Math.min(e[0], r[0]),
                t[1] = Math.min(e[1], r[1]),
                t[2] = Math.min(e[2], r[2]),
                t
            }
            ,
            a.max = function(t, e, r) {
                return t[0] = Math.max(e[0], r[0]),
                t[1] = Math.max(e[1], r[1]),
                t[2] = Math.max(e[2], r[2]),
                t
            }
            ,
            a.scale = function(t, e, r) {
                return t[0] = e[0] * r,
                t[1] = e[1] * r,
                t[2] = e[2] * r,
                t
            }
            ,
            a.scaleAndAdd = function(t, e, r, n) {
                return t[0] = e[0] + r[0] * n,
                t[1] = e[1] + r[1] * n,
                t[2] = e[2] + r[2] * n,
                t
            }
            ,
            a.distance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1]
                  , a = e[2] - t[2];
                return Math.sqrt(r * r + n * n + a * a)
            }
            ,
            a.dist = a.distance,
            a.squaredDistance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1]
                  , a = e[2] - t[2];
                return r * r + n * n + a * a
            }
            ,
            a.sqrDist = a.squaredDistance,
            a.length = function(t) {
                var e = t[0]
                  , r = t[1]
                  , n = t[2];
                return Math.sqrt(e * e + r * r + n * n)
            }
            ,
            a.len = a.length,
            a.squaredLength = function(t) {
                var e = t[0]
                  , r = t[1]
                  , n = t[2];
                return e * e + r * r + n * n
            }
            ,
            a.sqrLen = a.squaredLength,
            a.negate = function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t[2] = -e[2],
                t
            }
            ,
            a.inverse = function(t, e) {
                return t[0] = 1 / e[0],
                t[1] = 1 / e[1],
                t[2] = 1 / e[2],
                t
            }
            ,
            a.normalize = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = r * r + n * n + a * a;
                return 0 < i && (i = 1 / Math.sqrt(i),
                t[0] = e[0] * i,
                t[1] = e[1] * i,
                t[2] = e[2] * i),
                t
            }
            ,
            a.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
            }
            ,
            a.cross = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = r[0]
                  , o = r[1]
                  , c = r[2];
                return t[0] = a * c - i * o,
                t[1] = i * s - n * c,
                t[2] = n * o - a * s,
                t
            }
            ,
            a.lerp = function(t, e, r, n) {
                var a = e[0]
                  , i = e[1]
                  , s = e[2];
                return t[0] = a + n * (r[0] - a),
                t[1] = i + n * (r[1] - i),
                t[2] = s + n * (r[2] - s),
                t
            }
            ,
            a.random = function(t, e) {
                e = e || 1;
                var r = 2 * s() * Math.PI
                  , n = 2 * s() - 1
                  , a = Math.sqrt(1 - n * n) * e;
                return t[0] = Math.cos(r) * a,
                t[1] = Math.sin(r) * a,
                t[2] = n * e,
                t
            }
            ,
            a.transformMat4 = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = r[3] * n + r[7] * a + r[11] * i + r[15];
                return s = s || 1,
                t[0] = (r[0] * n + r[4] * a + r[8] * i + r[12]) / s,
                t[1] = (r[1] * n + r[5] * a + r[9] * i + r[13]) / s,
                t[2] = (r[2] * n + r[6] * a + r[10] * i + r[14]) / s,
                t
            }
            ,
            a.transformMat3 = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2];
                return t[0] = n * r[0] + a * r[3] + i * r[6],
                t[1] = n * r[1] + a * r[4] + i * r[7],
                t[2] = n * r[2] + a * r[5] + i * r[8],
                t
            }
            ,
            a.transformQuat = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = r[0]
                  , o = r[1]
                  , c = r[2]
                  , h = r[3]
                  , u = h * n + o * i - c * a
                  , l = h * a + c * n - s * i
                  , _ = h * i + s * a - o * n
                  , p = -s * n - o * a - c * i;
                return t[0] = u * h + p * -s + l * -c - _ * -o,
                t[1] = l * h + p * -o + _ * -s - u * -c,
                t[2] = _ * h + p * -c + u * -o - l * -s,
                t
            }
            ,
            a.rotateX = function(t, e, r, n) {
                var a = []
                  , i = [];
                return a[0] = e[0] - r[0],
                a[1] = e[1] - r[1],
                a[2] = e[2] - r[2],
                i[0] = a[0],
                i[1] = a[1] * Math.cos(n) - a[2] * Math.sin(n),
                i[2] = a[1] * Math.sin(n) + a[2] * Math.cos(n),
                t[0] = i[0] + r[0],
                t[1] = i[1] + r[1],
                t[2] = i[2] + r[2],
                t
            }
            ,
            a.rotateY = function(t, e, r, n) {
                var a = []
                  , i = [];
                return a[0] = e[0] - r[0],
                a[1] = e[1] - r[1],
                a[2] = e[2] - r[2],
                i[0] = a[2] * Math.sin(n) + a[0] * Math.cos(n),
                i[1] = a[1],
                i[2] = a[2] * Math.cos(n) - a[0] * Math.sin(n),
                t[0] = i[0] + r[0],
                t[1] = i[1] + r[1],
                t[2] = i[2] + r[2],
                t
            }
            ,
            a.rotateZ = function(t, e, r, n) {
                var a = []
                  , i = [];
                return a[0] = e[0] - r[0],
                a[1] = e[1] - r[1],
                a[2] = e[2] - r[2],
                i[0] = a[0] * Math.cos(n) - a[1] * Math.sin(n),
                i[1] = a[0] * Math.sin(n) + a[1] * Math.cos(n),
                i[2] = a[2],
                t[0] = i[0] + r[0],
                t[1] = i[1] + r[1],
                t[2] = i[2] + r[2],
                t
            }
            ,
            a.forEach = (h = a.create(),
            function(t, e, r, n, a, i) {
                var s, o;
                for (e = e || 3,
                r = r || 0,
                o = n ? Math.min(n * e + r, t.length) : t.length,
                s = r; s < o; s += e)
                    h[0] = t[s],
                    h[1] = t[s + 1],
                    h[2] = t[s + 2],
                    a(h, h, i),
                    t[s] = h[0],
                    t[s + 1] = h[1],
                    t[s + 2] = h[2];
                return t
            }
            ),
            a.str = function(t) {
                return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
            }
            ,
            void 0 !== t && (t.vec3 = a);
            var u, o = {};
            o.create = function() {
                var t = new i(4);
                return t[0] = 0,
                t[1] = 0,
                t[2] = 0,
                t[3] = 0,
                t
            }
            ,
            o.clone = function(t) {
                var e = new i(4);
                return e[0] = t[0],
                e[1] = t[1],
                e[2] = t[2],
                e[3] = t[3],
                e
            }
            ,
            o.fromValues = function(t, e, r, n) {
                var a = new i(4);
                return a[0] = t,
                a[1] = e,
                a[2] = r,
                a[3] = n,
                a
            }
            ,
            o.copy = function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t[2] = e[2],
                t[3] = e[3],
                t
            }
            ,
            o.set = function(t, e, r, n, a) {
                return t[0] = e,
                t[1] = r,
                t[2] = n,
                t[3] = a,
                t
            }
            ,
            o.add = function(t, e, r) {
                return t[0] = e[0] + r[0],
                t[1] = e[1] + r[1],
                t[2] = e[2] + r[2],
                t[3] = e[3] + r[3],
                t
            }
            ,
            o.subtract = function(t, e, r) {
                return t[0] = e[0] - r[0],
                t[1] = e[1] - r[1],
                t[2] = e[2] - r[2],
                t[3] = e[3] - r[3],
                t
            }
            ,
            o.sub = o.subtract,
            o.multiply = function(t, e, r) {
                return t[0] = e[0] * r[0],
                t[1] = e[1] * r[1],
                t[2] = e[2] * r[2],
                t[3] = e[3] * r[3],
                t
            }
            ,
            o.mul = o.multiply,
            o.divide = function(t, e, r) {
                return t[0] = e[0] / r[0],
                t[1] = e[1] / r[1],
                t[2] = e[2] / r[2],
                t[3] = e[3] / r[3],
                t
            }
            ,
            o.div = o.divide,
            o.min = function(t, e, r) {
                return t[0] = Math.min(e[0], r[0]),
                t[1] = Math.min(e[1], r[1]),
                t[2] = Math.min(e[2], r[2]),
                t[3] = Math.min(e[3], r[3]),
                t
            }
            ,
            o.max = function(t, e, r) {
                return t[0] = Math.max(e[0], r[0]),
                t[1] = Math.max(e[1], r[1]),
                t[2] = Math.max(e[2], r[2]),
                t[3] = Math.max(e[3], r[3]),
                t
            }
            ,
            o.scale = function(t, e, r) {
                return t[0] = e[0] * r,
                t[1] = e[1] * r,
                t[2] = e[2] * r,
                t[3] = e[3] * r,
                t
            }
            ,
            o.scaleAndAdd = function(t, e, r, n) {
                return t[0] = e[0] + r[0] * n,
                t[1] = e[1] + r[1] * n,
                t[2] = e[2] + r[2] * n,
                t[3] = e[3] + r[3] * n,
                t
            }
            ,
            o.distance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1]
                  , a = e[2] - t[2]
                  , i = e[3] - t[3];
                return Math.sqrt(r * r + n * n + a * a + i * i)
            }
            ,
            o.dist = o.distance,
            o.squaredDistance = function(t, e) {
                var r = e[0] - t[0]
                  , n = e[1] - t[1]
                  , a = e[2] - t[2]
                  , i = e[3] - t[3];
                return r * r + n * n + a * a + i * i
            }
            ,
            o.sqrDist = o.squaredDistance,
            o.length = function(t) {
                var e = t[0]
                  , r = t[1]
                  , n = t[2]
                  , a = t[3];
                return Math.sqrt(e * e + r * r + n * n + a * a)
            }
            ,
            o.len = o.length,
            o.squaredLength = function(t) {
                var e = t[0]
                  , r = t[1]
                  , n = t[2]
                  , a = t[3];
                return e * e + r * r + n * n + a * a
            }
            ,
            o.sqrLen = o.squaredLength,
            o.negate = function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t[2] = -e[2],
                t[3] = -e[3],
                t
            }
            ,
            o.inverse = function(t, e) {
                return t[0] = 1 / e[0],
                t[1] = 1 / e[1],
                t[2] = 1 / e[2],
                t[3] = 1 / e[3],
                t
            }
            ,
            o.normalize = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = e[3]
                  , s = r * r + n * n + a * a + i * i;
                return 0 < s && (s = 1 / Math.sqrt(s),
                t[0] = e[0] * s,
                t[1] = e[1] * s,
                t[2] = e[2] * s,
                t[3] = e[3] * s),
                t
            }
            ,
            o.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
            }
            ,
            o.lerp = function(t, e, r, n) {
                var a = e[0]
                  , i = e[1]
                  , s = e[2]
                  , o = e[3];
                return t[0] = a + n * (r[0] - a),
                t[1] = i + n * (r[1] - i),
                t[2] = s + n * (r[2] - s),
                t[3] = o + n * (r[3] - o),
                t
            }
            ,
            o.random = function(t, e) {
                return e = e || 1,
                t[0] = s(),
                t[1] = s(),
                t[2] = s(),
                t[3] = s(),
                o.normalize(t, t),
                o.scale(t, t, e),
                t
            }
            ,
            o.transformMat4 = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3];
                return t[0] = r[0] * n + r[4] * a + r[8] * i + r[12] * s,
                t[1] = r[1] * n + r[5] * a + r[9] * i + r[13] * s,
                t[2] = r[2] * n + r[6] * a + r[10] * i + r[14] * s,
                t[3] = r[3] * n + r[7] * a + r[11] * i + r[15] * s,
                t
            }
            ,
            o.transformQuat = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = r[0]
                  , o = r[1]
                  , c = r[2]
                  , h = r[3]
                  , u = h * n + o * i - c * a
                  , l = h * a + c * n - s * i
                  , _ = h * i + s * a - o * n
                  , p = -s * n - o * a - c * i;
                return t[0] = u * h + p * -s + l * -c - _ * -o,
                t[1] = l * h + p * -o + _ * -s - u * -c,
                t[2] = _ * h + p * -c + u * -o - l * -s,
                t
            }
            ,
            o.forEach = (u = o.create(),
            function(t, e, r, n, a, i) {
                var s, o;
                for (e = e || 4,
                r = r || 0,
                o = n ? Math.min(n * e + r, t.length) : t.length,
                s = r; s < o; s += e)
                    u[0] = t[s],
                    u[1] = t[s + 1],
                    u[2] = t[s + 2],
                    u[3] = t[s + 3],
                    a(u, u, i),
                    t[s] = u[0],
                    t[s + 1] = u[1],
                    t[s + 2] = u[2],
                    t[s + 3] = u[3];
                return t
            }
            ),
            o.str = function(t) {
                return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            }
            ,
            void 0 !== t && (t.vec4 = o);
            var l = {
                create: function() {
                    var t = new i(4);
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t
                },
                clone: function(t) {
                    var e = new i(4);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e[3] = t[3],
                    e
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t
                },
                identity: function(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t
                },
                transpose: function(t, e) {
                    if (t === e) {
                        var r = e[1];
                        t[1] = e[2],
                        t[2] = r
                    } else
                        t[0] = e[0],
                        t[1] = e[2],
                        t[2] = e[1],
                        t[3] = e[3];
                    return t
                },
                invert: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = r * i - a * n;
                    return s ? (s = 1 / s,
                    t[0] = i * s,
                    t[1] = -n * s,
                    t[2] = -a * s,
                    t[3] = r * s,
                    t) : null
                },
                adjoint: function(t, e) {
                    var r = e[0];
                    return t[0] = e[3],
                    t[1] = -e[1],
                    t[2] = -e[2],
                    t[3] = r,
                    t
                },
                determinant: function(t) {
                    return t[0] * t[3] - t[2] * t[1]
                },
                multiply: function(t, e, r) {
                    var n = e[0]
                      , a = e[1]
                      , i = e[2]
                      , s = e[3]
                      , o = r[0]
                      , c = r[1]
                      , h = r[2]
                      , u = r[3];
                    return t[0] = n * o + i * c,
                    t[1] = a * o + s * c,
                    t[2] = n * h + i * u,
                    t[3] = a * h + s * u,
                    t
                }
            };
            l.mul = l.multiply,
            l.rotate = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = Math.sin(r)
                  , c = Math.cos(r);
                return t[0] = n * c + i * o,
                t[1] = a * c + s * o,
                t[2] = n * -o + i * c,
                t[3] = a * -o + s * c,
                t
            }
            ,
            l.scale = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = r[0]
                  , c = r[1];
                return t[0] = n * o,
                t[1] = a * o,
                t[2] = i * c,
                t[3] = s * c,
                t
            }
            ,
            l.str = function(t) {
                return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            }
            ,
            l.frob = function(t) {
                return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2))
            }
            ,
            l.LDU = function(t, e, r, n) {
                return t[2] = n[2] / n[0],
                r[0] = n[0],
                r[1] = n[1],
                r[3] = n[3] - t[2] * r[1],
                [t, e, r]
            }
            ,
            void 0 !== t && (t.mat2 = l);
            var _ = {
                create: function() {
                    var t = new i(6);
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t[4] = 0,
                    t[5] = 0,
                    t
                },
                clone: function(t) {
                    var e = new i(6);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e[3] = t[3],
                    e[4] = t[4],
                    e[5] = t[5],
                    e
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[4] = e[4],
                    t[5] = e[5],
                    t
                },
                identity: function(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t[4] = 0,
                    t[5] = 0,
                    t
                },
                invert: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = e[4]
                      , o = e[5]
                      , c = r * i - n * a;
                    return c ? (c = 1 / c,
                    t[0] = i * c,
                    t[1] = -n * c,
                    t[2] = -a * c,
                    t[3] = r * c,
                    t[4] = (a * o - i * s) * c,
                    t[5] = (n * s - r * o) * c,
                    t) : null
                },
                determinant: function(t) {
                    return t[0] * t[3] - t[1] * t[2]
                },
                multiply: function(t, e, r) {
                    var n = e[0]
                      , a = e[1]
                      , i = e[2]
                      , s = e[3]
                      , o = e[4]
                      , c = e[5]
                      , h = r[0]
                      , u = r[1]
                      , l = r[2]
                      , _ = r[3]
                      , p = r[4]
                      , d = r[5];
                    return t[0] = n * h + i * u,
                    t[1] = a * h + s * u,
                    t[2] = n * l + i * _,
                    t[3] = a * l + s * _,
                    t[4] = n * p + i * d + o,
                    t[5] = a * p + s * d + c,
                    t
                }
            };
            _.mul = _.multiply,
            _.rotate = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = e[4]
                  , c = e[5]
                  , h = Math.sin(r)
                  , u = Math.cos(r);
                return t[0] = n * u + i * h,
                t[1] = a * u + s * h,
                t[2] = n * -h + i * u,
                t[3] = a * -h + s * u,
                t[4] = o,
                t[5] = c,
                t
            }
            ,
            _.scale = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = e[4]
                  , c = e[5]
                  , h = r[0]
                  , u = r[1];
                return t[0] = n * h,
                t[1] = a * h,
                t[2] = i * u,
                t[3] = s * u,
                t[4] = o,
                t[5] = c,
                t
            }
            ,
            _.translate = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = e[4]
                  , c = e[5]
                  , h = r[0]
                  , u = r[1];
                return t[0] = n,
                t[1] = a,
                t[2] = i,
                t[3] = s,
                t[4] = n * h + i * u + o,
                t[5] = a * h + s * u + c,
                t
            }
            ,
            _.str = function(t) {
                return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
            }
            ,
            _.frob = function(t) {
                return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1)
            }
            ,
            void 0 !== t && (t.mat2d = _);
            var p = {
                create: function() {
                    var t = new i(9);
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 1,
                    t[5] = 0,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 1,
                    t
                },
                fromMat4: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[4],
                    t[4] = e[5],
                    t[5] = e[6],
                    t[6] = e[8],
                    t[7] = e[9],
                    t[8] = e[10],
                    t
                },
                clone: function(t) {
                    var e = new i(9);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e[3] = t[3],
                    e[4] = t[4],
                    e[5] = t[5],
                    e[6] = t[6],
                    e[7] = t[7],
                    e[8] = t[8],
                    e
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[4] = e[4],
                    t[5] = e[5],
                    t[6] = e[6],
                    t[7] = e[7],
                    t[8] = e[8],
                    t
                },
                identity: function(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 1,
                    t[5] = 0,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 1,
                    t
                },
                transpose: function(t, e) {
                    if (t === e) {
                        var r = e[1]
                          , n = e[2]
                          , a = e[5];
                        t[1] = e[3],
                        t[2] = e[6],
                        t[3] = r,
                        t[5] = e[7],
                        t[6] = n,
                        t[7] = a
                    } else
                        t[0] = e[0],
                        t[1] = e[3],
                        t[2] = e[6],
                        t[3] = e[1],
                        t[4] = e[4],
                        t[5] = e[7],
                        t[6] = e[2],
                        t[7] = e[5],
                        t[8] = e[8];
                    return t
                },
                invert: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = e[4]
                      , o = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8]
                      , l = u * s - o * h
                      , _ = -u * i + o * c
                      , p = h * i - s * c
                      , d = r * l + n * _ + a * p;
                    return d ? (d = 1 / d,
                    t[0] = l * d,
                    t[1] = (-u * n + a * h) * d,
                    t[2] = (o * n - a * s) * d,
                    t[3] = _ * d,
                    t[4] = (u * r - a * c) * d,
                    t[5] = (-o * r + a * i) * d,
                    t[6] = p * d,
                    t[7] = (-h * r + n * c) * d,
                    t[8] = (s * r - n * i) * d,
                    t) : null
                },
                adjoint: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = e[4]
                      , o = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8];
                    return t[0] = s * u - o * h,
                    t[1] = a * h - n * u,
                    t[2] = n * o - a * s,
                    t[3] = o * c - i * u,
                    t[4] = r * u - a * c,
                    t[5] = a * i - r * o,
                    t[6] = i * h - s * c,
                    t[7] = n * c - r * h,
                    t[8] = r * s - n * i,
                    t
                },
                determinant: function(t) {
                    var e = t[0]
                      , r = t[1]
                      , n = t[2]
                      , a = t[3]
                      , i = t[4]
                      , s = t[5]
                      , o = t[6]
                      , c = t[7]
                      , h = t[8];
                    return e * (h * i - s * c) + r * (-h * a + s * o) + n * (c * a - i * o)
                },
                multiply: function(t, e, r) {
                    var n = e[0]
                      , a = e[1]
                      , i = e[2]
                      , s = e[3]
                      , o = e[4]
                      , c = e[5]
                      , h = e[6]
                      , u = e[7]
                      , l = e[8]
                      , _ = r[0]
                      , p = r[1]
                      , d = r[2]
                      , m = r[3]
                      , f = r[4]
                      , v = r[5]
                      , g = r[6]
                      , M = r[7]
                      , y = r[8];
                    return t[0] = _ * n + p * s + d * h,
                    t[1] = _ * a + p * o + d * u,
                    t[2] = _ * i + p * c + d * l,
                    t[3] = m * n + f * s + v * h,
                    t[4] = m * a + f * o + v * u,
                    t[5] = m * i + f * c + v * l,
                    t[6] = g * n + M * s + y * h,
                    t[7] = g * a + M * o + y * u,
                    t[8] = g * i + M * c + y * l,
                    t
                }
            };
            p.mul = p.multiply,
            p.translate = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = e[4]
                  , c = e[5]
                  , h = e[6]
                  , u = e[7]
                  , l = e[8]
                  , _ = r[0]
                  , p = r[1];
                return t[0] = n,
                t[1] = a,
                t[2] = i,
                t[3] = s,
                t[4] = o,
                t[5] = c,
                t[6] = _ * n + p * s + h,
                t[7] = _ * a + p * o + u,
                t[8] = _ * i + p * c + l,
                t
            }
            ,
            p.rotate = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = e[4]
                  , c = e[5]
                  , h = e[6]
                  , u = e[7]
                  , l = e[8]
                  , _ = Math.sin(r)
                  , p = Math.cos(r);
                return t[0] = p * n + _ * s,
                t[1] = p * a + _ * o,
                t[2] = p * i + _ * c,
                t[3] = p * s - _ * n,
                t[4] = p * o - _ * a,
                t[5] = p * c - _ * i,
                t[6] = h,
                t[7] = u,
                t[8] = l,
                t
            }
            ,
            p.scale = function(t, e, r) {
                var n = r[0]
                  , a = r[1];
                return t[0] = n * e[0],
                t[1] = n * e[1],
                t[2] = n * e[2],
                t[3] = a * e[3],
                t[4] = a * e[4],
                t[5] = a * e[5],
                t[6] = e[6],
                t[7] = e[7],
                t[8] = e[8],
                t
            }
            ,
            p.fromMat2d = function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t[2] = 0,
                t[3] = e[2],
                t[4] = e[3],
                t[5] = 0,
                t[6] = e[4],
                t[7] = e[5],
                t[8] = 1,
                t
            }
            ,
            p.fromQuat = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = e[3]
                  , s = r + r
                  , o = n + n
                  , c = a + a
                  , h = r * s
                  , u = n * s
                  , l = n * o
                  , _ = a * s
                  , p = a * o
                  , d = a * c
                  , m = i * s
                  , f = i * o
                  , v = i * c;
                return t[0] = 1 - l - d,
                t[3] = u - v,
                t[6] = _ + f,
                t[1] = u + v,
                t[4] = 1 - h - d,
                t[7] = p - m,
                t[2] = _ - f,
                t[5] = p + m,
                t[8] = 1 - h - l,
                t
            }
            ,
            p.normalFromMat4 = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = e[3]
                  , s = e[4]
                  , o = e[5]
                  , c = e[6]
                  , h = e[7]
                  , u = e[8]
                  , l = e[9]
                  , _ = e[10]
                  , p = e[11]
                  , d = e[12]
                  , m = e[13]
                  , f = e[14]
                  , v = e[15]
                  , g = r * o - n * s
                  , M = r * c - a * s
                  , y = r * h - i * s
                  , R = n * c - a * o
                  , C = n * h - i * o
                  , b = a * h - i * c
                  , w = u * m - l * d
                  , Q = u * f - _ * d
                  , U = u * v - p * d
                  , B = l * f - _ * m
                  , W = l * v - p * m
                  , P = _ * v - p * f
                  , V = g * P - M * W + y * B + R * U - C * Q + b * w;
                return V ? (V = 1 / V,
                t[0] = (o * P - c * W + h * B) * V,
                t[1] = (c * U - s * P - h * Q) * V,
                t[2] = (s * W - o * U + h * w) * V,
                t[3] = (a * W - n * P - i * B) * V,
                t[4] = (r * P - a * U + i * Q) * V,
                t[5] = (n * U - r * W - i * w) * V,
                t[6] = (m * b - f * C + v * R) * V,
                t[7] = (f * y - d * b - v * M) * V,
                t[8] = (d * C - m * y + v * g) * V,
                t) : null
            }
            ,
            p.str = function(t) {
                return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
            }
            ,
            p.frob = function(t) {
                return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2))
            }
            ,
            void 0 !== t && (t.mat3 = p);
            var b = {
                create: function() {
                    var t = new i(16);
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = 1,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[10] = 1,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t
                },
                clone: function(t) {
                    var e = new i(16);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e[3] = t[3],
                    e[4] = t[4],
                    e[5] = t[5],
                    e[6] = t[6],
                    e[7] = t[7],
                    e[8] = t[8],
                    e[9] = t[9],
                    e[10] = t[10],
                    e[11] = t[11],
                    e[12] = t[12],
                    e[13] = t[13],
                    e[14] = t[14],
                    e[15] = t[15],
                    e
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[4] = e[4],
                    t[5] = e[5],
                    t[6] = e[6],
                    t[7] = e[7],
                    t[8] = e[8],
                    t[9] = e[9],
                    t[10] = e[10],
                    t[11] = e[11],
                    t[12] = e[12],
                    t[13] = e[13],
                    t[14] = e[14],
                    t[15] = e[15],
                    t
                },
                identity: function(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = 1,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[10] = 1,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t
                },
                transpose: function(t, e) {
                    if (t === e) {
                        var r = e[1]
                          , n = e[2]
                          , a = e[3]
                          , i = e[6]
                          , s = e[7]
                          , o = e[11];
                        t[1] = e[4],
                        t[2] = e[8],
                        t[3] = e[12],
                        t[4] = r,
                        t[6] = e[9],
                        t[7] = e[13],
                        t[8] = n,
                        t[9] = i,
                        t[11] = e[14],
                        t[12] = a,
                        t[13] = s,
                        t[14] = o
                    } else
                        t[0] = e[0],
                        t[1] = e[4],
                        t[2] = e[8],
                        t[3] = e[12],
                        t[4] = e[1],
                        t[5] = e[5],
                        t[6] = e[9],
                        t[7] = e[13],
                        t[8] = e[2],
                        t[9] = e[6],
                        t[10] = e[10],
                        t[11] = e[14],
                        t[12] = e[3],
                        t[13] = e[7],
                        t[14] = e[11],
                        t[15] = e[15];
                    return t
                },
                invert: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = e[4]
                      , o = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8]
                      , l = e[9]
                      , _ = e[10]
                      , p = e[11]
                      , d = e[12]
                      , m = e[13]
                      , f = e[14]
                      , v = e[15]
                      , g = r * o - n * s
                      , M = r * c - a * s
                      , y = r * h - i * s
                      , R = n * c - a * o
                      , C = n * h - i * o
                      , b = a * h - i * c
                      , w = u * m - l * d
                      , Q = u * f - _ * d
                      , U = u * v - p * d
                      , B = l * f - _ * m
                      , W = l * v - p * m
                      , P = _ * v - p * f
                      , V = g * P - M * W + y * B + R * U - C * Q + b * w;
                    return V ? (V = 1 / V,
                    t[0] = (o * P - c * W + h * B) * V,
                    t[1] = (a * W - n * P - i * B) * V,
                    t[2] = (m * b - f * C + v * R) * V,
                    t[3] = (_ * C - l * b - p * R) * V,
                    t[4] = (c * U - s * P - h * Q) * V,
                    t[5] = (r * P - a * U + i * Q) * V,
                    t[6] = (f * y - d * b - v * M) * V,
                    t[7] = (u * b - _ * y + p * M) * V,
                    t[8] = (s * W - o * U + h * w) * V,
                    t[9] = (n * U - r * W - i * w) * V,
                    t[10] = (d * C - m * y + v * g) * V,
                    t[11] = (l * y - u * C - p * g) * V,
                    t[12] = (o * Q - s * B - c * w) * V,
                    t[13] = (r * B - n * Q + a * w) * V,
                    t[14] = (m * M - d * R - f * g) * V,
                    t[15] = (u * R - l * M + _ * g) * V,
                    t) : null
                },
                adjoint: function(t, e) {
                    var r = e[0]
                      , n = e[1]
                      , a = e[2]
                      , i = e[3]
                      , s = e[4]
                      , o = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8]
                      , l = e[9]
                      , _ = e[10]
                      , p = e[11]
                      , d = e[12]
                      , m = e[13]
                      , f = e[14]
                      , v = e[15];
                    return t[0] = o * (_ * v - p * f) - l * (c * v - h * f) + m * (c * p - h * _),
                    t[1] = -(n * (_ * v - p * f) - l * (a * v - i * f) + m * (a * p - i * _)),
                    t[2] = n * (c * v - h * f) - o * (a * v - i * f) + m * (a * h - i * c),
                    t[3] = -(n * (c * p - h * _) - o * (a * p - i * _) + l * (a * h - i * c)),
                    t[4] = -(s * (_ * v - p * f) - u * (c * v - h * f) + d * (c * p - h * _)),
                    t[5] = r * (_ * v - p * f) - u * (a * v - i * f) + d * (a * p - i * _),
                    t[6] = -(r * (c * v - h * f) - s * (a * v - i * f) + d * (a * h - i * c)),
                    t[7] = r * (c * p - h * _) - s * (a * p - i * _) + u * (a * h - i * c),
                    t[8] = s * (l * v - p * m) - u * (o * v - h * m) + d * (o * p - h * l),
                    t[9] = -(r * (l * v - p * m) - u * (n * v - i * m) + d * (n * p - i * l)),
                    t[10] = r * (o * v - h * m) - s * (n * v - i * m) + d * (n * h - i * o),
                    t[11] = -(r * (o * p - h * l) - s * (n * p - i * l) + u * (n * h - i * o)),
                    t[12] = -(s * (l * f - _ * m) - u * (o * f - c * m) + d * (o * _ - c * l)),
                    t[13] = r * (l * f - _ * m) - u * (n * f - a * m) + d * (n * _ - a * l),
                    t[14] = -(r * (o * f - c * m) - s * (n * f - a * m) + d * (n * c - a * o)),
                    t[15] = r * (o * _ - c * l) - s * (n * _ - a * l) + u * (n * c - a * o),
                    t
                },
                determinant: function(t) {
                    var e = t[0]
                      , r = t[1]
                      , n = t[2]
                      , a = t[3]
                      , i = t[4]
                      , s = t[5]
                      , o = t[6]
                      , c = t[7]
                      , h = t[8]
                      , u = t[9]
                      , l = t[10]
                      , _ = t[11]
                      , p = t[12]
                      , d = t[13]
                      , m = t[14]
                      , f = t[15];
                    return (e * s - r * i) * (l * f - _ * m) - (e * o - n * i) * (u * f - _ * d) + (e * c - a * i) * (u * m - l * d) + (r * o - n * s) * (h * f - _ * p) - (r * c - a * s) * (h * m - l * p) + (n * c - a * o) * (h * d - u * p)
                },
                multiply: function(t, e, r) {
                    var n = e[0]
                      , a = e[1]
                      , i = e[2]
                      , s = e[3]
                      , o = e[4]
                      , c = e[5]
                      , h = e[6]
                      , u = e[7]
                      , l = e[8]
                      , _ = e[9]
                      , p = e[10]
                      , d = e[11]
                      , m = e[12]
                      , f = e[13]
                      , v = e[14]
                      , g = e[15]
                      , M = r[0]
                      , y = r[1]
                      , R = r[2]
                      , C = r[3];
                    return t[0] = M * n + y * o + R * l + C * m,
                    t[1] = M * a + y * c + R * _ + C * f,
                    t[2] = M * i + y * h + R * p + C * v,
                    t[3] = M * s + y * u + R * d + C * g,
                    M = r[4],
                    y = r[5],
                    R = r[6],
                    C = r[7],
                    t[4] = M * n + y * o + R * l + C * m,
                    t[5] = M * a + y * c + R * _ + C * f,
                    t[6] = M * i + y * h + R * p + C * v,
                    t[7] = M * s + y * u + R * d + C * g,
                    M = r[8],
                    y = r[9],
                    R = r[10],
                    C = r[11],
                    t[8] = M * n + y * o + R * l + C * m,
                    t[9] = M * a + y * c + R * _ + C * f,
                    t[10] = M * i + y * h + R * p + C * v,
                    t[11] = M * s + y * u + R * d + C * g,
                    M = r[12],
                    y = r[13],
                    R = r[14],
                    C = r[15],
                    t[12] = M * n + y * o + R * l + C * m,
                    t[13] = M * a + y * c + R * _ + C * f,
                    t[14] = M * i + y * h + R * p + C * v,
                    t[15] = M * s + y * u + R * d + C * g,
                    t
                }
            };
            b.mul = b.multiply,
            b.translate = function(t, e, r) {
                var n, a, i, s, o, c, h, u, l, _, p, d, m = r[0], f = r[1], v = r[2];
                return e === t ? (t[12] = e[0] * m + e[4] * f + e[8] * v + e[12],
                t[13] = e[1] * m + e[5] * f + e[9] * v + e[13],
                t[14] = e[2] * m + e[6] * f + e[10] * v + e[14],
                t[15] = e[3] * m + e[7] * f + e[11] * v + e[15]) : (n = e[0],
                a = e[1],
                i = e[2],
                s = e[3],
                o = e[4],
                c = e[5],
                h = e[6],
                u = e[7],
                l = e[8],
                _ = e[9],
                p = e[10],
                d = e[11],
                t[0] = n,
                t[1] = a,
                t[2] = i,
                t[3] = s,
                t[4] = o,
                t[5] = c,
                t[6] = h,
                t[7] = u,
                t[8] = l,
                t[9] = _,
                t[10] = p,
                t[11] = d,
                t[12] = n * m + o * f + l * v + e[12],
                t[13] = a * m + c * f + _ * v + e[13],
                t[14] = i * m + h * f + p * v + e[14],
                t[15] = s * m + u * f + d * v + e[15]),
                t
            }
            ,
            b.scale = function(t, e, r) {
                var n = r[0]
                  , a = r[1]
                  , i = r[2];
                return t[0] = e[0] * n,
                t[1] = e[1] * n,
                t[2] = e[2] * n,
                t[3] = e[3] * n,
                t[4] = e[4] * a,
                t[5] = e[5] * a,
                t[6] = e[6] * a,
                t[7] = e[7] * a,
                t[8] = e[8] * i,
                t[9] = e[9] * i,
                t[10] = e[10] * i,
                t[11] = e[11] * i,
                t[12] = e[12],
                t[13] = e[13],
                t[14] = e[14],
                t[15] = e[15],
                t
            }
            ,
            b.rotate = function(t, e, r, n) {
                var a, i, s, o, c, h, u, l, _, p, d, m, f, v, g, M, y, R, C, b, w, Q, U, B, W = n[0], P = n[1], V = n[2], x = Math.sqrt(W * W + P * P + V * V);
                return Math.abs(x) < q ? null : (W *= x = 1 / x,
                P *= x,
                V *= x,
                a = Math.sin(r),
                s = 1 - (i = Math.cos(r)),
                o = e[0],
                c = e[1],
                h = e[2],
                u = e[3],
                l = e[4],
                _ = e[5],
                p = e[6],
                d = e[7],
                m = e[8],
                f = e[9],
                v = e[10],
                g = e[11],
                M = W * W * s + i,
                y = P * W * s + V * a,
                R = V * W * s - P * a,
                C = W * P * s - V * a,
                b = P * P * s + i,
                w = V * P * s + W * a,
                Q = W * V * s + P * a,
                U = P * V * s - W * a,
                B = V * V * s + i,
                t[0] = o * M + l * y + m * R,
                t[1] = c * M + _ * y + f * R,
                t[2] = h * M + p * y + v * R,
                t[3] = u * M + d * y + g * R,
                t[4] = o * C + l * b + m * w,
                t[5] = c * C + _ * b + f * w,
                t[6] = h * C + p * b + v * w,
                t[7] = u * C + d * b + g * w,
                t[8] = o * Q + l * U + m * B,
                t[9] = c * Q + _ * U + f * B,
                t[10] = h * Q + p * U + v * B,
                t[11] = u * Q + d * U + g * B,
                e !== t && (t[12] = e[12],
                t[13] = e[13],
                t[14] = e[14],
                t[15] = e[15]),
                t)
            }
            ,
            b.rotateX = function(t, e, r) {
                var n = Math.sin(r)
                  , a = Math.cos(r)
                  , i = e[4]
                  , s = e[5]
                  , o = e[6]
                  , c = e[7]
                  , h = e[8]
                  , u = e[9]
                  , l = e[10]
                  , _ = e[11];
                return e !== t && (t[0] = e[0],
                t[1] = e[1],
                t[2] = e[2],
                t[3] = e[3],
                t[12] = e[12],
                t[13] = e[13],
                t[14] = e[14],
                t[15] = e[15]),
                t[4] = i * a + h * n,
                t[5] = s * a + u * n,
                t[6] = o * a + l * n,
                t[7] = c * a + _ * n,
                t[8] = h * a - i * n,
                t[9] = u * a - s * n,
                t[10] = l * a - o * n,
                t[11] = _ * a - c * n,
                t
            }
            ,
            b.rotateY = function(t, e, r) {
                var n = Math.sin(r)
                  , a = Math.cos(r)
                  , i = e[0]
                  , s = e[1]
                  , o = e[2]
                  , c = e[3]
                  , h = e[8]
                  , u = e[9]
                  , l = e[10]
                  , _ = e[11];
                return e !== t && (t[4] = e[4],
                t[5] = e[5],
                t[6] = e[6],
                t[7] = e[7],
                t[12] = e[12],
                t[13] = e[13],
                t[14] = e[14],
                t[15] = e[15]),
                t[0] = i * a - h * n,
                t[1] = s * a - u * n,
                t[2] = o * a - l * n,
                t[3] = c * a - _ * n,
                t[8] = i * n + h * a,
                t[9] = s * n + u * a,
                t[10] = o * n + l * a,
                t[11] = c * n + _ * a,
                t
            }
            ,
            b.rotateZ = function(t, e, r) {
                var n = Math.sin(r)
                  , a = Math.cos(r)
                  , i = e[0]
                  , s = e[1]
                  , o = e[2]
                  , c = e[3]
                  , h = e[4]
                  , u = e[5]
                  , l = e[6]
                  , _ = e[7];
                return e !== t && (t[8] = e[8],
                t[9] = e[9],
                t[10] = e[10],
                t[11] = e[11],
                t[12] = e[12],
                t[13] = e[13],
                t[14] = e[14],
                t[15] = e[15]),
                t[0] = i * a + h * n,
                t[1] = s * a + u * n,
                t[2] = o * a + l * n,
                t[3] = c * a + _ * n,
                t[4] = h * a - i * n,
                t[5] = u * a - s * n,
                t[6] = l * a - o * n,
                t[7] = _ * a - c * n,
                t
            }
            ,
            b.fromRotationTranslation = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = n + n
                  , c = a + a
                  , h = i + i
                  , u = n * o
                  , l = n * c
                  , _ = n * h
                  , p = a * c
                  , d = a * h
                  , m = i * h
                  , f = s * o
                  , v = s * c
                  , g = s * h;
                return t[0] = 1 - (p + m),
                t[1] = l + g,
                t[2] = _ - v,
                t[3] = 0,
                t[4] = l - g,
                t[5] = 1 - (u + m),
                t[6] = d + f,
                t[7] = 0,
                t[8] = _ + v,
                t[9] = d - f,
                t[10] = 1 - (u + p),
                t[11] = 0,
                t[12] = r[0],
                t[13] = r[1],
                t[14] = r[2],
                t[15] = 1,
                t
            }
            ,
            b.fromQuat = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = e[3]
                  , s = r + r
                  , o = n + n
                  , c = a + a
                  , h = r * s
                  , u = n * s
                  , l = n * o
                  , _ = a * s
                  , p = a * o
                  , d = a * c
                  , m = i * s
                  , f = i * o
                  , v = i * c;
                return t[0] = 1 - l - d,
                t[1] = u + v,
                t[2] = _ - f,
                t[3] = 0,
                t[4] = u - v,
                t[5] = 1 - h - d,
                t[6] = p + m,
                t[7] = 0,
                t[8] = _ + f,
                t[9] = p - m,
                t[10] = 1 - h - l,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                t
            }
            ,
            b.frustum = function(t, e, r, n, a, i, s) {
                var o = 1 / (r - e)
                  , c = 1 / (a - n)
                  , h = 1 / (i - s);
                return t[0] = 2 * i * o,
                t[1] = 0,
                t[2] = 0,
                t[3] = 0,
                t[4] = 0,
                t[5] = 2 * i * c,
                t[6] = 0,
                t[7] = 0,
                t[8] = (r + e) * o,
                t[9] = (a + n) * c,
                t[10] = (s + i) * h,
                t[11] = -1,
                t[12] = 0,
                t[13] = 0,
                t[14] = s * i * 2 * h,
                t[15] = 0,
                t
            }
            ,
            b.perspective = function(t, e, r, n, a) {
                var i = 1 / Math.tan(e / 2)
                  , s = 1 / (n - a);
                return t[0] = i / r,
                t[1] = 0,
                t[2] = 0,
                t[3] = 0,
                t[4] = 0,
                t[5] = i,
                t[6] = 0,
                t[7] = 0,
                t[8] = 0,
                t[9] = 0,
                t[10] = (a + n) * s,
                t[11] = -1,
                t[12] = 0,
                t[13] = 0,
                t[14] = 2 * a * n * s,
                t[15] = 0,
                t
            }
            ,
            b.ortho = function(t, e, r, n, a, i, s) {
                var o = 1 / (e - r)
                  , c = 1 / (n - a)
                  , h = 1 / (i - s);
                return t[0] = -2 * o,
                t[1] = 0,
                t[2] = 0,
                t[3] = 0,
                t[4] = 0,
                t[5] = -2 * c,
                t[6] = 0,
                t[7] = 0,
                t[8] = 0,
                t[9] = 0,
                t[10] = 2 * h,
                t[11] = 0,
                t[12] = (e + r) * o,
                t[13] = (a + n) * c,
                t[14] = (s + i) * h,
                t[15] = 1,
                t
            }
            ,
            b.lookAt = function(t, e, r, n) {
                var a, i, s, o, c, h, u, l, _, p, d = e[0], m = e[1], f = e[2], v = n[0], g = n[1], M = n[2], y = r[0], R = r[1], C = r[2];
                return Math.abs(d - y) < q && Math.abs(m - R) < q && Math.abs(f - C) < q ? b.identity(t) : (u = d - y,
                l = m - R,
                _ = f - C,
                a = g * (_ *= p = 1 / Math.sqrt(u * u + l * l + _ * _)) - M * (l *= p),
                i = M * (u *= p) - v * _,
                s = v * l - g * u,
                (p = Math.sqrt(a * a + i * i + s * s)) ? (a *= p = 1 / p,
                i *= p,
                s *= p) : s = i = a = 0,
                o = l * s - _ * i,
                c = _ * a - u * s,
                h = u * i - l * a,
                (p = Math.sqrt(o * o + c * c + h * h)) ? (o *= p = 1 / p,
                c *= p,
                h *= p) : h = c = o = 0,
                t[0] = a,
                t[1] = o,
                t[2] = u,
                t[3] = 0,
                t[4] = i,
                t[5] = c,
                t[6] = l,
                t[7] = 0,
                t[8] = s,
                t[9] = h,
                t[10] = _,
                t[11] = 0,
                t[12] = -(a * d + i * m + s * f),
                t[13] = -(o * d + c * m + h * f),
                t[14] = -(u * d + l * m + _ * f),
                t[15] = 1,
                t)
            }
            ,
            b.str = function(t) {
                return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
            }
            ,
            b.frob = function(t) {
                return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2))
            }
            ,
            void 0 !== t && (t.mat4 = b);
            var d, m, f, v, g = {};
            g.create = function() {
                var t = new i(4);
                return t[0] = 0,
                t[1] = 0,
                t[2] = 0,
                t[3] = 1,
                t
            }
            ,
            g.rotationTo = (d = a.create(),
            m = a.fromValues(1, 0, 0),
            f = a.fromValues(0, 1, 0),
            function(t, e, r) {
                var n = a.dot(e, r);
                return n < -.999999 ? (a.cross(d, m, e),
                a.length(d) < 1e-6 && a.cross(d, f, e),
                a.normalize(d, d),
                g.setAxisAngle(t, d, Math.PI),
                t) : .999999 < n ? (t[0] = 0,
                t[1] = 0,
                t[2] = 0,
                t[3] = 1,
                t) : (a.cross(d, e, r),
                t[0] = d[0],
                t[1] = d[1],
                t[2] = d[2],
                t[3] = 1 + n,
                g.normalize(t, t))
            }
            ),
            g.setAxes = (v = p.create(),
            function(t, e, r, n) {
                return v[0] = r[0],
                v[3] = r[1],
                v[6] = r[2],
                v[1] = n[0],
                v[4] = n[1],
                v[7] = n[2],
                v[2] = -e[0],
                v[5] = -e[1],
                v[8] = -e[2],
                g.normalize(t, g.fromMat3(t, v))
            }
            ),
            g.clone = o.clone,
            g.fromValues = o.fromValues,
            g.copy = o.copy,
            g.set = o.set,
            g.identity = function(t) {
                return t[0] = 0,
                t[1] = 0,
                t[2] = 0,
                t[3] = 1,
                t
            }
            ,
            g.setAxisAngle = function(t, e, r) {
                r *= .5;
                var n = Math.sin(r);
                return t[0] = n * e[0],
                t[1] = n * e[1],
                t[2] = n * e[2],
                t[3] = Math.cos(r),
                t
            }
            ,
            g.add = o.add,
            g.multiply = function(t, e, r) {
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = r[0]
                  , c = r[1]
                  , h = r[2]
                  , u = r[3];
                return t[0] = n * u + s * o + a * h - i * c,
                t[1] = a * u + s * c + i * o - n * h,
                t[2] = i * u + s * h + n * c - a * o,
                t[3] = s * u - n * o - a * c - i * h,
                t
            }
            ,
            g.mul = g.multiply,
            g.scale = o.scale,
            g.rotateX = function(t, e, r) {
                r *= .5;
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = Math.sin(r)
                  , c = Math.cos(r);
                return t[0] = n * c + s * o,
                t[1] = a * c + i * o,
                t[2] = i * c - a * o,
                t[3] = s * c - n * o,
                t
            }
            ,
            g.rotateY = function(t, e, r) {
                r *= .5;
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = Math.sin(r)
                  , c = Math.cos(r);
                return t[0] = n * c - i * o,
                t[1] = a * c + s * o,
                t[2] = i * c + n * o,
                t[3] = s * c - a * o,
                t
            }
            ,
            g.rotateZ = function(t, e, r) {
                r *= .5;
                var n = e[0]
                  , a = e[1]
                  , i = e[2]
                  , s = e[3]
                  , o = Math.sin(r)
                  , c = Math.cos(r);
                return t[0] = n * c + a * o,
                t[1] = a * c - n * o,
                t[2] = i * c + s * o,
                t[3] = s * c - i * o,
                t
            }
            ,
            g.calculateW = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2];
                return t[0] = r,
                t[1] = n,
                t[2] = a,
                t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - a * a)),
                t
            }
            ,
            g.dot = o.dot,
            g.lerp = o.lerp,
            g.slerp = function(t, e, r, n) {
                var a, i, s, o, c, h = e[0], u = e[1], l = e[2], _ = e[3], p = r[0], d = r[1], m = r[2], f = r[3];
                return (i = h * p + u * d + l * m + _ * f) < 0 && (i = -i,
                p = -p,
                d = -d,
                m = -m,
                f = -f),
                c = 1e-6 < 1 - i ? (a = Math.acos(i),
                s = Math.sin(a),
                o = Math.sin((1 - n) * a) / s,
                Math.sin(n * a) / s) : (o = 1 - n,
                n),
                t[0] = o * h + c * p,
                t[1] = o * u + c * d,
                t[2] = o * l + c * m,
                t[3] = o * _ + c * f,
                t
            }
            ,
            g.invert = function(t, e) {
                var r = e[0]
                  , n = e[1]
                  , a = e[2]
                  , i = e[3]
                  , s = r * r + n * n + a * a + i * i
                  , o = s ? 1 / s : 0;
                return t[0] = -r * o,
                t[1] = -n * o,
                t[2] = -a * o,
                t[3] = i * o,
                t
            }
            ,
            g.conjugate = function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t[2] = -e[2],
                t[3] = e[3],
                t
            }
            ,
            g.length = o.length,
            g.len = g.length,
            g.squaredLength = o.squaredLength,
            g.sqrLen = g.squaredLength,
            g.normalize = o.normalize,
            g.fromMat3 = function(t, e) {
                var r, n = e[0] + e[4] + e[8];
                if (0 < n)
                    r = Math.sqrt(n + 1),
                    t[3] = .5 * r,
                    r = .5 / r,
                    t[0] = (e[5] - e[7]) * r,
                    t[1] = (e[6] - e[2]) * r,
                    t[2] = (e[1] - e[3]) * r;
                else {
                    var a = 0;
                    e[4] > e[0] && (a = 1),
                    e[8] > e[3 * a + a] && (a = 2);
                    var i = (a + 1) % 3
                      , s = (a + 2) % 3;
                    r = Math.sqrt(e[3 * a + a] - e[3 * i + i] - e[3 * s + s] + 1),
                    t[a] = .5 * r,
                    r = .5 / r,
                    t[3] = (e[3 * i + s] - e[3 * s + i]) * r,
                    t[i] = (e[3 * i + a] + e[3 * a + i]) * r,
                    t[s] = (e[3 * s + a] + e[3 * a + s]) * r
                }
                return t
            }
            ,
            g.str = function(t) {
                return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            }
            ,
            void 0 !== t && (t.quat = g)
        }(e.exports)
    }(this);
    var Q_X = 0
      , Q_Y = 1
      , Q_Z = 2
      , Q_W = 3;
    function dualQuat() {
        this.real = quat.create(),
        this.real[Q_W] = 0,
        this.imaginary = quat.create(),
        this.imaginary[Q_W] = 0,
        this.tmpQ1 = quat.create()
    }
    dualQuat.prototype.reset = function() {
        quat.identity(this.real),
        this.real[Q_W] = 0,
        quat.identity(this.imaginary),
        this.imaginary[Q_W] = 0,
        quat.identity(this.tmpQ1)
    }
    ,
    dualQuat.prototype.createFromData = function(t, e) {
        this.real = t,
        this.imaginary = quat.create(),
        this.imaginary[Q_W] = -.5 * (e[Q_X] * t[Q_X] + e[Q_Y] * t[Q_Y] + e[Q_Z] * t[Q_Z]),
        this.imaginary[Q_X] = .5 * (e[Q_X] * t[Q_W] + e[Q_Y] * t[Q_Z] - e[Q_Z] * t[Q_Y]),
        this.imaginary[Q_Y] = .5 * (-e[Q_X] * t[Q_Z] + e[Q_Y] * t[Q_W] + e[Q_Z] * t[Q_X]),
        this.imaginary[Q_Z] = .5 * (e[Q_X] * t[Q_Y] - e[Q_Y] * t[Q_X] + e[Q_Z] * t[Q_W])
    }
    ,
    dualQuat.prototype.add = function(t, e, r) {
        quat.copy(this.tmpQ1, t.real),
        quat.scale(this.tmpQ1, this.tmpQ1, e),
        quat.add(this.real, this.tmpQ1, this.real),
        quat.copy(this.tmpQ1, t.imaginary),
        quat.scale(this.tmpQ1, this.tmpQ1, r),
        quat.add(this.imaginary, this.tmpQ1, this.imaginary)
    }
    ,
    dualQuat.prototype.normalize = function() {
        var t = quat.length(this.real);
        this.real = quat.scale(this.real, this.real, 1 / t),
        this.imaginary = quat.scale(this.imaginary, this.imaginary, 1 / t)
    }
    ;
    var v0 = vec3.create()
      , ve = vec3.create()
      , trans = vec3.create()
      , tmpVec1 = vec3.create()
      , tmpVec2 = vec3.create()
      , tmpVec0 = vec3.create()
      , aVec = vec3.create()
      , rot = vec3.create();
    dualQuat.prototype.transform = function(t) {
        return v0[Q_X] = this.real[Q_X],
        v0[Q_Y] = this.real[Q_Y],
        v0[Q_Z] = this.real[Q_Z],
        ve[Q_X] = this.imaginary[Q_X],
        ve[Q_Y] = this.imaginary[Q_Y],
        ve[Q_Z] = this.imaginary[Q_Z],
        tmpVec1 = vec3.scale(tmpVec1, v0, this.imaginary[Q_W]),
        tmpVec2 = vec3.cross(tmpVec2, v0, ve),
        tmpVec0 = vec3.scale(tmpVec0, ve, this.real[Q_W]),
        aVec = vec3.subtract(aVec, tmpVec0, tmpVec1),
        trans = vec3.add(trans, aVec, tmpVec2),
        trans = vec3.scale(trans, trans, 2),
        rot = vec3.transformQuat(rot, t, this.real),
        rot = vec3.add(rot, rot, trans)
    }
    ;
    var Utils = {
        setAxisMatrix: function(t, e, r) {
            var n = mat4.create();
            return n[0] = t[Q_X],
            n[4] = t[Q_Y],
            n[8] = t[Q_Z],
            n[1] = e[Q_X],
            n[5] = e[Q_Y],
            n[9] = e[Q_Z],
            n[2] = r[Q_X],
            n[6] = r[Q_Y],
            n[10] = r[Q_Z],
            n[12] = 0,
            n[13] = 0,
            n[14] = 0,
            n[3] = 0,
            n[7] = 0,
            n[11] = 0,
            n[15] = 1,
            n = mat4.transpose(n, n)
        },
        matrixToQuat: function(t) {
            var e, r = quat.create(), n = t, a = n[0], i = n[4], s = n[8], o = n[1], c = n[5], h = n[9], u = n[2], l = n[6], _ = n[10], p = a + c + _;
            return 0 < p ? (e = .5 / Math.sqrt(p + 1),
            r[Q_W] = .25 / e,
            r[Q_X] = (l - h) * e,
            r[Q_Y] = (s - u) * e,
            r[Q_Z] = (o - i) * e) : c < a && _ < a ? (e = 2 * Math.sqrt(1 + a - c - _),
            r[Q_W] = (l - h) / e,
            r[Q_X] = .25 * e,
            r[Q_Y] = (i + o) / e,
            r[Q_Z] = (s + u) / e) : _ < c ? (e = 2 * Math.sqrt(1 + c - a - _),
            r[Q_W] = (s - u) / e,
            r[Q_X] = (i + o) / e,
            r[Q_Y] = .25 * e,
            r[Q_Z] = (h + l) / e) : (e = 2 * Math.sqrt(1 + _ - a - c),
            r[Q_W] = (o - i) / e,
            r[Q_X] = (s + u) / e,
            r[Q_Y] = (h + l) / e,
            r[Q_Z] = .25 * e),
            r
        },
        rotateVec_90: function(t) {
            return vec3.fromValues(-t[Q_Y], t[Q_X], t[Q_Z])
        },
        calcRotateMat: function(t) {
            var e = vec3.clone(t);
            e = vec3.normalize(e, e);
            var r = Utils.rotateVec_90(e)
              , n = vec3.fromValues(e[Q_X], e[Q_Y], 0)
              , a = vec3.fromValues(r[Q_X], r[Q_Y], 0)
              , i = vec3.fromValues(0, 0, 1);
            mat4.create();
            return Utils.setAxisMatrix(n, a, i)
        },
        getMatTranslate: function(t) {
            var e = vec3.create();
            return e[Q_X] = t[12],
            e[Q_Y] = t[13],
            e[Q_Z] = t[14],
            e
        },
        addMat: function(t, e) {
            for (var r = mat4.create(), n = 0; n < 16; n++)
                r[n] = t[n] + e[n];
            return r
        },
        mulMat: function(t, e) {
            for (var r = mat4.create(), n = 0; n < 16; n++)
                r[n] = t[n] * e;
            return r
        },
        clamp: function(t, e, r) {
            return t < e ? e : r < t ? r : t
        }
    }
      , newVec1 = vec3.create()
      , newVec2 = vec3.create();
    function MeshBone(t, e, r, n) {
        this.key = t,
        this.world_rest_angle = 0,
        this.rest_parent_mat = mat4.create(),
        this.rest_parent_inv_mat = mat4.create(),
        this.rest_world_mat = mat4.create(),
        this.rest_world_inv_mat = mat4.create(),
        this.bind_world_mat = mat4.create(),
        this.bind_world_inv_mat = mat4.create(),
        this.parent_world_mat = mat4.create(),
        this.parent_world_inv_mat = mat4.create(),
        this.local_rest_start_pt = null,
        this.local_rest_end_pt = null,
        this.setRestParentMat(n, null),
        this.setLocalRestStartPt(e),
        this.setLocalRestEndPt(r),
        this.setParentWorldInvMat(mat4.create()),
        this.setParentWorldMat(mat4.create()),
        this.local_binormal_dir = vec3.fromValues(0, 0, 1),
        this.tag_id = 0,
        this.children = []
    }
    function MeshRenderRegion(t, e, r, n, a, i, s) {
        this.store_indices = t,
        this.store_rest_pts = e,
        this.store_uvs = r,
        this.use_local_displacements = !1,
        this.use_post_displacements = !1,
        this.use_uv_warp = !1,
        this.uv_warp_local_offset = vec2.fromValues(0, 0),
        this.uv_warp_global_offset = vec2.fromValues(0, 0),
        this.uv_warp_scale = vec2.fromValues(1, 1),
        this.start_pt_index = n,
        this.end_pt_index = a,
        this.start_index = i,
        this.end_index = s,
        this.main_bone = null,
        this.local_displacements = [],
        this.post_displacements = [],
        this.uv_warp_ref_uvs = [],
        this.normal_weight_map = {},
        this.fast_normal_weight_map = [],
        this.fast_bones_map = [],
        this.relevant_bones_indices = [],
        this.use_dq = !0,
        this.tag_id = -1,
        this.initUvWarp()
    }
    Utils.vecInterp = function(t, e, r) {
        newVec1 = vec3.scale(newVec1, t, 1 - r),
        newVec2 = vec3.scale(newVec2, e, r);
        var n = vec3.create();
        return n = vec3.add(n, newVec1, newVec2)
    }
    ,
    Utils.vec2Interp = function(t, e, r) {
        var n = vec2.create()
          , a = vec2.create();
        n = vec2.scale(n, t, 1 - r),
        a = vec2.scale(a, e, r);
        var i = vec2.create();
        return i = vec2.add(i, n, a)
    }
    ,
    MeshBone.prototype.setRestParentMat = function(t, e) {
        this.rest_parent_mat = t,
        null == e ? (this.rest_parent_inv_mat = mat4.clone(this.rest_parent_mat),
        mat4.invert(this.rest_parent_inv_mat, this.rest_parent_inv_mat)) : this.rest_parent_inv_mat = mat4.clone(e)
    }
    ,
    MeshBone.prototype.setParentWorldMat = function(t) {
        this.parent_world_mat = t
    }
    ,
    MeshBone.prototype.setParentWorldInvMat = function(t) {
        this.parent_world_inv_mat = t
    }
    ,
    MeshBone.prototype.getLocalRestStartPt = function() {
        return this.local_rest_start_pt
    }
    ,
    MeshBone.prototype.getLocalRestEndPt = function() {
        return this.local_rest_end_pt
    }
    ,
    MeshBone.prototype.setLocalRestStartPt = function(t) {
        this.local_rest_start_pt = vec3.create(),
        this.local_rest_start_pt = vec3.transformMat4(this.local_rest_start_pt, t, this.rest_parent_inv_mat),
        this.calcRestData()
    }
    ,
    MeshBone.prototype.setLocalRestEndPt = function(t) {
        this.local_rest_end_pt = vec3.create(),
        this.local_rest_end_pt = vec3.transformMat4(this.local_rest_end_pt, t, this.rest_parent_inv_mat),
        this.calcRestData()
    }
    ,
    MeshBone.prototype.calcRestData = function() {
        if (null != this.local_rest_start_pt && null != this.local_rest_end_pt) {
            var t = this.computeDirs(this.local_rest_start_pt, this.local_rest_end_pt);
            this.local_rest_dir = t.first,
            this.local_rest_normal_dir = t.second,
            this.computeRestLength()
        }
    }
    ,
    MeshBone.prototype.setWorldStartPt = function(t) {
        this.world_start_pt = t
    }
    ,
    MeshBone.prototype.setWorldEndPt = function(t) {
        this.world_end_pt = t
    }
    ,
    MeshBone.prototype.fixDQs = function(t) {
        quat.dot(this.world_dq.real, t.real) < 0 && (this.world_dq.real = quat.scale(this.world_dq.real, this.world_dq.real, -1),
        this.world_dq.imaginary = quat.scale(this.world_dq.imaginary, this.world_dq.imaginary, -1));
        for (var e = 0; e < this.children.length; e++) {
            this.children[e].fixDQs(this.world_dq)
        }
    }
    ,
    MeshBone.prototype.initWorldPts = function() {
        this.setWorldStartPt(this.getWorldRestStartPt()),
        this.setWorldEndPt(this.getWorldRestEndPt());
        for (var t = 0; t < this.children.length; t++)
            this.children[t].initWorldPts()
    }
    ,
    MeshBone.prototype.getWorldRestStartPt = function() {
        var t = this.rest_parent_mat
          , e = vec3.create();
        return e = vec3.transformMat4(e, this.local_rest_start_pt, t)
    }
    ,
    MeshBone.prototype.getWorldRestEndPt = function() {
        var t = this.rest_parent_mat
          , e = vec3.create();
        return e = vec3.transformMat4(e, this.local_rest_end_pt, t)
    }
    ,
    MeshBone.prototype.getWorldRestAngle = function() {
        return this.world_rest_angle
    }
    ,
    MeshBone.prototype.getWorldRestPos = function() {
        return this.world_rest_pos
    }
    ,
    MeshBone.prototype.getWorldStartPt = function() {
        return this.world_start_pt
    }
    ,
    MeshBone.prototype.getWorldEndPt = function() {
        return this.world_end_pt
    }
    ,
    MeshBone.prototype.getRestParentMat = function() {
        return this.rest_parent_mat
    }
    ,
    MeshBone.prototype.getRestWorldMat = function() {
        return this.rest_world_mat
    }
    ,
    MeshBone.prototype.getWorldDeltaMat = function() {
        return this.world_delta_mat
    }
    ,
    MeshBone.prototype.getParentWorldMat = function() {
        return this.parent_world_mat
    }
    ,
    MeshBone.prototype.getParentWorldInvMat = function() {
        return this.parent_world_inv_mat
    }
    ,
    MeshBone.prototype.getWorldDq = function() {
        return this.world_dq
    }
    ,
    MeshBone.prototype.computeRestParentTransforms = function() {
        var t = vec3.fromValues(this.local_rest_dir[Q_X], this.local_rest_dir[Q_Y], 0)
          , e = vec3.fromValues(this.local_binormal_dir[Q_X], this.local_binormal_dir[Q_Y], this.local_binormal_dir[Q_Z])
          , r = vec3.fromValues(this.local_rest_normal_dir[Q_X], this.local_rest_normal_dir[Q_Y], 0)
          , n = mat4.create();
        mat4.translate(n, n, this.local_rest_end_pt);
        var a = mat4.create();
        a = Utils.setAxisMatrix(t, r, e);
        var i = mat4.create();
        i = mat4.multiply(i, n, a),
        this.rest_world_mat = mat4.create(),
        this.rest_world_mat = mat4.multiply(this.rest_world_mat, this.rest_parent_mat, i),
        this.rest_world_inv_mat = mat4.clone(this.rest_world_mat),
        this.rest_world_inv_mat = mat4.invert(this.rest_world_inv_mat, this.rest_world_inv_mat);
        var s = vec3.clone(this.getWorldRestEndPt());
        s = vec3.subtract(s, s, this.getWorldRestStartPt()),
        s = vec3.normalize(s, s),
        this.world_rest_pos = this.getWorldRestStartPt();
        var o = mat4.create();
        o = mat4.translate(o, o, this.getWorldRestStartPt());
        var c = vec3.create();
        c = vec3.sub(c, this.getWorldRestEndPt(), this.getWorldRestStartPt());
        var h = Utils.calcRotateMat(c)
          , u = mat4.create();
        u = mat4.multiply(u, o, h),
        this.bind_world_mat = mat4.clone(u),
        this.bind_world_inv_mat = mat4.clone(this.bind_world_mat),
        this.bind_world_inv_mat = mat4.invert(this.bind_world_inv_mat, this.bind_world_inv_mat);
        for (var l = 0; l < this.children.length; l++) {
            var _ = this.children[l];
            _.setRestParentMat(this.rest_world_mat, this.rest_world_inv_mat),
            _.computeRestParentTransforms()
        }
    }
    ,
    MeshBone.prototype.computeParentTransforms = function() {
        var t = mat4.create();
        t = mat4.translate(t, t, this.getWorldEndPt());
        var e = vec3.create();
        e = vec3.subtract(e, this.getWorldEndpt(), this.getWorldStartPt());
        var r = Utils.calcRotateMat(e)
          , n = mat4.create();
        n = mat4.multiply(n, t, r);
        var a = mat4.clone(n);
        a = mat4.invert(a, a);
        for (var i = 0; i < children.length; i++) {
            var s = children[i];
            s.setParentWorldMat(n),
            s.setParentWorldInvMat(a),
            s.computeParentTransforms()
        }
    }
    ,
    MeshBone.prototype.computeWorldDeltaTransforms = function() {
        var t = this.computeDirs(this.world_start_pt, this.world_end_pt)
          , e = vec3.fromValues(t.first[Q_X], t.first[Q_Y], 0)
          , r = vec3.fromValues(t.second[Q_X], t.second[Q_Y], 0)
          , n = vec3.fromValues(this.local_binormal_dir[Q_X], this.local_binormal_dir[Q_Y], this.local_binormal_dir[Q_Z])
          , a = mat4.create();
        a = Utils.setAxisMatrix(e, r, n);
        var i = mat4.create();
        i = mat4.translate(i, i, this.world_start_pt),
        this.world_delta_mat = mat4.create(),
        this.world_delta_mat = mat4.multiply(this.world_delta_mat, i, a),
        this.world_delta_mat = mat4.multiply(this.world_delta_mat, this.world_delta_mat, this.bind_world_inv_mat);
        var s = Utils.matrixToQuat(this.world_delta_mat)
          , o = Utils.getMatTranslate(this.world_delta_mat);
        this.world_dq = new dualQuat,
        this.world_dq.createFromData(s, o);
        for (var c = 0; c < this.children.length; c++) {
            this.children[c].computeWorldDeltaTransforms()
        }
    }
    ,
    MeshBone.prototype.addChild = function(t) {
        t.setRestParentMat(this.rest_world_mat, this.rest_world_inv_mat),
        this.children.push(t)
    }
    ,
    MeshBone.prototype.getChildren = function() {
        return this.children
    }
    ,
    MeshBone.prototype.hasBone = function(t) {
        for (var e = 0; e < this.children.length; e++) {
            if (this.children[e] == t)
                return !0
        }
        return !1
    }
    ,
    MeshBone.prototype.getChildByKey = function(t) {
        if (this.key === t)
            return this;
        for (var e = null, r = 0; r < this.children.length; r++) {
            var n = this.children[r].getChildByKey(t);
            if (null != n) {
                e = n;
                break
            }
        }
        return e
    }
    ,
    MeshBone.prototype.getKey = function() {
        return this.key
    }
    ,
    MeshBone.prototype.getAllBoneKeys = function() {
        var t = [];
        t.push(this.getKey());
        for (var e = 0; e < this.children.length; e++) {
            var r = this.children[e].getAllBoneKeys();
            t = t.concat(r)
        }
        return t
    }
    ,
    MeshBone.prototype.getAllChildren = function() {
        var t = [];
        t.push(this);
        for (var e = 0; e < this.children.length; e++) {
            var r = this.children[e].getAllChildren();
            t = t.concat(r)
        }
        return t
    }
    ,
    MeshBone.prototype.getBoneDepth = function(t, e) {
        if (t == this)
            return e;
        for (var r = 0; r < this.children.length; r++) {
            var n = this.children[r].getBoneDepth(t, e + 1);
            if (-1 != n)
                return n
        }
        return -1
    }
    ,
    MeshBone.prototype.isLeaf = function() {
        return 0 == this.children.length
    }
    ,
    MeshBone.prototype.deleteChildren = function() {
        for (var t = 0; t < this.children.length; t++) {
            this.children[t].deleteChildren()
        }
        this.children = []
    }
    ,
    MeshBone.prototype.setTagId = function(t) {
        this.tag_id = t
    }
    ,
    MeshBone.prototype.getTagId = function() {
        return this.tag_id
    }
    ,
    MeshBone.prototype.computeDirs = function(t, e) {
        var r = vec3.create();
        r = vec3.subtract(r, e, t),
        r = vec3.normalize(r, r);
        var n = Utils.rotateVec_90(r)
          , a = {};
        return a.first = r,
        a.second = n,
        a
    }
    ,
    MeshBone.prototype.computeRestLength = function() {
        var t = vec3.create();
        t = vec3.subtract(t, this.local_rest_end_pt, this.local_rest_start_pt),
        this.rest_length = vec3.length(t)
    }
    ,
    MeshRenderRegion.prototype.getIndicesIndex = function() {
        return this.start_index
    }
    ,
    MeshRenderRegion.prototype.getRestPtsIndex = function() {
        return 3 * this.start_pt_index
    }
    ,
    MeshRenderRegion.prototype.getUVsIndex = function() {
        return 2 * this.start_pt_index
    }
    ,
    MeshRenderRegion.prototype.getNumPts = function() {
        return this.end_pt_index - this.start_pt_index + 1
    }
    ,
    MeshRenderRegion.prototype.getStartPtIndex = function() {
        return this.start_pt_index
    }
    ,
    MeshRenderRegion.prototype.getEndPtIndex = function() {
        return this.end_pt_index
    }
    ,
    MeshRenderRegion.prototype.getNumIndices = function() {
        return this.end_index - this.start_index + 1
    }
    ,
    MeshRenderRegion.prototype.getStartIndex = function() {
        return this.start_index
    }
    ,
    MeshRenderRegion.prototype.getEndIndex = function() {
        return this.end_index
    }
    ;
    var accum_dq = new dualQuat
      , accum_mat = mat4.create()
      , final_pt = vec3.create()
      , tmp1 = vec3.create()
      , tmp2 = vec3.create();
    function MeshRenderBoneComposition() {
        this.root_bone = null,
        this.bones_map = {},
        this.regions = [],
        this.regions_map = {}
    }
    function MeshBoneCache(t) {
        this.key = t
    }
    function MeshDisplacementCache(t) {
        this.key = t,
        this.local_displacements = [],
        this.post_displacements = []
    }
    function MeshUVWarpCache(t) {
        this.uv_warp_global_offset = vec2.create(),
        this.uv_warp_local_offset = vec2.create(),
        this.uv_warp_scale = vec2.fromValues(-1, -1),
        this.key = t,
        this.enabled = !1
    }
    function MeshBoneCacheManager() {
        this.is_ready = !1,
        this.bone_cache_table = null,
        this.bone_cache_data_ready = null,
        this.bone_cache_table = [],
        this.bone_cache_data_ready = []
    }
    function MeshDisplacementCacheManager() {
        this.is_ready = !1,
        this.displacement_cache_table = null,
        this.displacement_cache_data_ready = null,
        this.displacement_cache_table = [],
        this.displacement_cache_data_ready = []
    }
    function MeshUVWarpCacheManager() {
        this.is_ready = !1,
        this.uv_cache_table = null,
        this.uv_cache_data_ready = null,
        this.uv_cache_table = [],
        this.uv_cache_data_ready = []
    }
    MeshRenderRegion.prototype.poseFinalPts = function(t, e, r) {
        for (var n = this.getRestPtsIndex(), a = e, i = 0; i < 16; i++)
            accum_mat[i] = 0;
        Object.keys(r).length,
        i = 0;
        for (var s = this.getNumPts(); i < s; i++) {
            var o = vec3.set(tmp1, this.store_rest_pts[0 + n], this.store_rest_pts[1 + n], this.store_rest_pts[2 + n]);
            1 == this.use_local_displacements && (o[Q_X] += this.local_displacements[i][Q_X],
            o[Q_Y] += this.local_displacements[i][Q_Y]);
            for (var c = 0; c < 16; c++)
                accum_mat[c] = 0;
            accum_dq.reset();
            var h = this.relevant_bones_indices[i]
              , u = h.length;
            for (c = 0; c < u; c++) {
                var l = h[c]
                  , _ = this.fast_bones_map[l]
                  , p = this.fast_normal_weight_map[l][i]
                  , d = p
                  , m = _.getWorldDq();
                accum_dq.add(m, p, d)
            }
            accum_dq.normalize();
            var f = vec3.set(tmp2, o[Q_X], o[Q_Y], o[Q_Z]);
            final_pt = accum_dq.transform(f),
            1 == this.use_post_displacements && (final_pt[Q_X] += this.post_displacements[i][Q_X],
            final_pt[Q_Y] += this.post_displacements[i][Q_Y]),
            t[0 + a] = final_pt[Q_X],
            t[1 + a] = final_pt[Q_Y],
            t[2 + a] = final_pt[Q_Z],
            n += 3,
            a += 3
        }
        1 == this.use_uv_warp && this.runUvWarp()
    }
    ,
    MeshRenderRegion.prototype.setMainBoneKey = function(t) {
        this.main_bone_key = t
    }
    ,
    MeshRenderRegion.prototype.determineMainBone = function(t) {
        this.main_bone = t.getChildByKey(this.main_bone_key)
    }
    ,
    MeshRenderRegion.prototype.setUseDq = function(t) {
        this.use_dq = t
    }
    ,
    MeshRenderRegion.prototype.setName = function(t) {
        this.name = t
    }
    ,
    MeshRenderRegion.prototype.getName = function() {
        return this.name
    }
    ,
    MeshRenderRegion.prototype.setUseLocalDisplacements = function(t) {
        if (this.use_local_displacements = t,
        this.local_displacements.length != this.getNumPts() && this.use_local_displacements) {
            this.local_displacements = [];
            for (var e = 0; e < this.getNumPts(); e++)
                this.local_displacements.push(vec2.create())
        }
    }
    ,
    MeshRenderRegion.prototype.getUseLocalDisplacements = function() {
        return this.use_local_displacements
    }
    ,
    MeshRenderRegion.prototype.setUsePostDisplacements = function(t) {
        if (this.use_post_displacements = t,
        this.post_displacements.length != this.getNumPts() && this.use_post_displacements) {
            this.post_displacements = [];
            for (var e = 0; e < this.getNumPts(); e++)
                this.post_displacements.push(vec2.create())
        }
    }
    ,
    MeshRenderRegion.prototype.getUsePostDisplacements = function() {
        return this.use_post_displacements
    }
    ,
    MeshRenderRegion.prototype.getRestLocalPt = function(t) {
        var e = this.getRestPtsIndex() + 3 * t;
        return vec2.fromValues(this.store_rest_pts[0 + e], this.store_rest_pts[1 + e])
    }
    ,
    MeshRenderRegion.prototype.getLocalIndex = function(t) {
        var e = this.getIndicesIndex() + t;
        return this.store_indices[e]
    }
    ,
    MeshRenderRegion.prototype.clearLocalDisplacements = function() {
        for (var t = 0; t < this.local_displacements.length; t++)
            this.local_displacements[t] = vec2.create()
    }
    ,
    MeshRenderRegion.prototype.clearPostDisplacements = function() {
        for (var t = 0; t < this.post_displacements.length; t++)
            this.post_displacements[t] = vec2.create()
    }
    ,
    MeshRenderRegion.prototype.setUseUvWarp = function(t) {
        this.use_uv_warp = t,
        0 == this.use_uv_warp && this.restoreRefUv()
    }
    ,
    MeshRenderRegion.prototype.getUseUvWarp = function() {
        return this.use_uv_warp
    }
    ,
    MeshRenderRegion.prototype.setUvWarpLocalOffset = function(t) {
        this.uv_warp_local_offset = t
    }
    ,
    MeshRenderRegion.prototype.setUvWarpGlobalOffset = function(t) {
        this.uv_warp_global_offset = t
    }
    ,
    MeshRenderRegion.prototype.setUvWarpScale = function(t) {
        this.uv_warp_scale = t
    }
    ,
    MeshRenderRegion.prototype.getUvWarpLocalOffset = function() {
        return this.uv_warp_local_offset
    }
    ,
    MeshRenderRegion.prototype.getUvWarpGlobalOffset = function() {
        return this.uv_warp_global_offset
    }
    ,
    MeshRenderRegion.prototype.getUvWarpScale = function() {
        return this.uv_warp_scale
    }
    ,
    MeshRenderRegion.prototype.runUvWarp = function() {
        for (var t = this.getUVsIndex(), e = 0; e < this.uv_warp_ref_uvs.length; e++) {
            var r = vec2.clone(this.uv_warp_ref_uvs[e]);
            (r = vec2.subtract(r, r, this.uv_warp_local_offset))[Q_X] *= this.uv_warp_scale[Q_X],
            r[Q_Y] *= this.uv_warp_scale[Q_Y],
            r = vec2.add(r, r, this.uv_warp_global_offset),
            this.store_uvs[0 + t] = r[Q_X],
            this.store_uvs[1 + t] = r[Q_Y],
            t += 2
        }
    }
    ,
    MeshRenderRegion.prototype.restoreRefUv = function() {
        for (var t = this.getUVsIndex(), e = 0; e < this.uv_warp_ref_uvs.length; e++) {
            var r = this.uv_warp_ref_uvs[e];
            this.store_uvs[0 + t] = r[Q_X],
            this.store_uvs[1 + t] = r[Q_Y],
            t += 2
        }
    }
    ,
    MeshRenderRegion.prototype.getTagId = function() {
        return this.tag_id
    }
    ,
    MeshRenderRegion.prototype.setTagId = function(t) {
        this.tag_id = t
    }
    ,
    MeshRenderRegion.prototype.initFastNormalWeightMap = function(t) {
        for (var e in this.relevant_bones_indices = [],
        t) {
            var r = this.normal_weight_map[e];
            this.fast_normal_weight_map.push(r)
        }
        for (var n = 0; n < this.getNumPts(); n++) {
            for (var a = [], i = 0; i < this.fast_normal_weight_map.length; i++) {
                .05 < this.fast_normal_weight_map[i][n] && a.push(i)
            }
            this.relevant_bones_indices.push(a)
        }
        for (var e in t) {
            var s = t[e];
            this.fast_bones_map.push(s)
        }
    }
    ,
    MeshRenderRegion.prototype.initUvWarp = function() {
        var t = this.getUVsIndex();
        this.uv_warp_ref_uvs = [];
        for (var e = 0; e < this.getNumPts(); e++)
            this.uv_warp_ref_uvs.push(vec2.create()),
            this.uv_warp_ref_uvs[e] = vec2.fromValues(this.store_uvs[t], this.store_uvs[t + 1]),
            t += 2
    }
    ,
    MeshRenderBoneComposition.prototype.addRegion = function(t) {
        this.regions.push(t)
    }
    ,
    MeshRenderBoneComposition.prototype.setRootBone = function(t) {
        this.root_bone = t
    }
    ,
    MeshRenderBoneComposition.prototype.getRootBone = function() {
        return this.root_bone
    }
    ,
    MeshRenderBoneComposition.prototype.initBoneMap = function() {
        this.bones_map = MeshRenderBoneComposition.genBoneMap(this.root_bone)
    }
    ,
    MeshRenderBoneComposition.prototype.initRegionsMap = function() {
        this.regions_map = {};
        for (var t = 0; t < this.regions.length; t++)
            cur_key = this.regions[t].getName(),
            this.regions_map[cur_key] = this.regions[t]
    }
    ,
    MeshRenderBoneComposition.genBoneMap = function(t) {
        for (var e = {}, r = t.getAllBoneKeys(), n = 0; n < r.length; n++) {
            var a = r[n];
            e[a] = t.getChildByKey(a)
        }
        return e
    }
    ,
    MeshRenderBoneComposition.prototype.getBonesMap = function() {
        return this.bones_map
    }
    ,
    MeshRenderBoneComposition.prototype.getRegionsMap = function() {
        return this.regions_map
    }
    ,
    MeshRenderBoneComposition.prototype.getRegions = function() {
        return this.regions
    }
    ,
    MeshRenderBoneComposition.prototype.getRegionWithId = function(t) {
        for (var e = 0; e < this.regions.length; e++) {
            var r = this.regions[e];
            if (r.getTagId() == t)
                return r
        }
        return null
    }
    ,
    MeshRenderBoneComposition.prototype.resetToWorldRestPts = function() {
        this.getRootBone().initWorldPts()
    }
    ,
    MeshRenderBoneComposition.prototype.updateAllTransforms = function(t) {
        t && this.getRootBone().computeParentTransforms(),
        this.getRootBone().computeWorldDeltaTransforms(),
        this.getRootBone().fixDQs(this.getRootBone().getWorldDq())
    }
    ,
    MeshBoneCache.prototype.setWorldStartPt = function(t) {
        this.world_start_pt = t
    }
    ,
    MeshBoneCache.prototype.setWorldEndPt = function(t) {
        this.world_end_pt = t
    }
    ,
    MeshBoneCache.prototype.getWorldStartPt = function() {
        return this.world_start_pt
    }
    ,
    MeshBoneCache.prototype.getWorldEndPt = function() {
        return this.world_end_pt
    }
    ,
    MeshBoneCache.prototype.getKey = function() {
        return this.key
    }
    ,
    MeshDisplacementCache.prototype.setLocalDisplacements = function(t) {
        this.local_displacements = t
    }
    ,
    MeshDisplacementCache.prototype.setPostDisplacements = function(t) {
        this.post_displacements = t
    }
    ,
    MeshDisplacementCache.prototype.getKey = function() {
        return this.key
    }
    ,
    MeshDisplacementCache.prototype.getLocalDisplacements = function() {
        return this.local_displacements
    }
    ,
    MeshDisplacementCache.prototype.getPostDisplacements = function() {
        return this.post_displacements
    }
    ,
    MeshUVWarpCache.prototype.setUvWarpLocalOffset = function(t) {
        this.uv_warp_local_offset = t
    }
    ,
    MeshUVWarpCache.prototype.setUvWarpGlobalOffset = function(t) {
        this.uv_warp_global_offset = t
    }
    ,
    MeshUVWarpCache.prototype.setUvWarpScale = function(t) {
        this.uv_warp_scale = t
    }
    ,
    MeshUVWarpCache.prototype.getUvWarpLocalOffset = function() {
        return this.uv_warp_local_offset
    }
    ,
    MeshUVWarpCache.prototype.getUvWarpGlobalOffset = function() {
        return this.uv_warp_global_offset
    }
    ,
    MeshUVWarpCache.prototype.getUvWarpScale = function() {
        return this.uv_warp_scale
    }
    ,
    MeshUVWarpCache.prototype.getKey = function() {
        return this.key
    }
    ,
    MeshUVWarpCache.prototype.setEnabled = function(t) {
        this.enabled = t
    }
    ,
    MeshUVWarpCache.prototype.getEnabled = function() {
        return this.enabled
    }
    ,
    MeshBoneCacheManager.prototype.init = function(t, e) {
        this.start_time = t,
        this.end_time = e;
        var r = this.end_time - this.start_time + 1;
        this.bone_cache_table = [],
        this.bone_cache_data_ready = [];
        for (var n = 0; n < r; n++)
            this.bone_cache_table.push([]),
            this.bone_cache_data_ready.push(!1);
        this.is_ready = !1
    }
    ,
    MeshBoneCacheManager.prototype.getStartTime = function() {
        return this.start_time
    }
    ,
    MeshBoneCacheManager.prototype.getEndime = function() {
        return this.end_time
    }
    ,
    MeshBoneCacheManager.prototype.getIndexByTime = function(t) {
        var e = t - this.start_time;
        return e = Utils.clamp(e, 0, this.bone_cache_table.length - 1)
    }
    ,
    MeshBoneCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
        var r = this.getIndexByTime(Math.floor(t))
          , n = this.getIndexByTime(Math.ceil(t))
          , a = t - Math.floor(t);
        if (0 != this.bone_cache_data_ready.length && 0 != this.bone_cache_data_ready[r] && 0 != this.bone_cache_data_ready[n])
            for (var i = this.bone_cache_table[r], s = this.bone_cache_table[n], o = 0, c = i.length; o < c; o++) {
                var h = i[o]
                  , u = s[o]
                  , l = h.getKey()
                  , _ = Utils.vecInterp(h.getWorldStartPt(), u.getWorldStartPt(), a)
                  , p = Utils.vecInterp(h.getWorldEndPt(), u.getWorldEndPt(), a);
                e[l].setWorldStartPt(_),
                e[l].setWorldEndPt(p)
            }
    }
    ,
    MeshBoneCacheManager.prototype.allReady = function() {
        if (this.is_ready)
            return !0;
        for (var t = this.end_time - this.start_time + 1, e = 0, r = 0; r < this.bone_cache_data_ready.size(); r++)
            this.bone_cache_data_ready[r] && e++;
        return e == t && (this.is_ready = !0),
        this.is_ready
    }
    ,
    MeshBoneCacheManager.prototype.makeAllReady = function() {
        for (var t = 0; t < this.bone_cache_data_ready.length; t++)
            this.bone_cache_data_ready[t] = !0
    }
    ,
    MeshDisplacementCacheManager.prototype.init = function(t, e) {
        this.start_time = t,
        this.end_time = e;
        var r = this.end_time - this.start_time + 1;
        this.displacement_cache_table = [],
        this.displacement_cache_data_ready = [];
        for (var n = 0; n < r; n++)
            this.displacement_cache_table.push([]),
            this.displacement_cache_data_ready.push(!1);
        this.is_ready = !1
    }
    ,
    MeshDisplacementCacheManager.prototype.getStartTime = function() {
        return this.start_time
    }
    ,
    MeshDisplacementCacheManager.prototype.getEndime = function() {
        return this.end_time
    }
    ,
    MeshDisplacementCacheManager.prototype.getIndexByTime = function(t) {
        var e = t - this.start_time;
        return e = Utils.clamp(e, 0, this.displacement_cache_table.length - 1)
    }
    ,
    MeshDisplacementCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
        var r = this.getIndexByTime(Math.floor(t))
          , n = this.getIndexByTime(Math.ceil(t))
          , a = t - Math.floor(t);
        if (0 != this.displacement_cache_data_ready.length && 0 != this.displacement_cache_data_ready[r] && 0 != this.displacement_cache_data_ready[n])
            for (var i = this.displacement_cache_table[r], s = this.displacement_cache_table[n], o = 0; o < i.length; o++) {
                var c = i[o]
                  , h = s[o]
                  , u = e[c.getKey()];
                if (u.getUseLocalDisplacements()) {
                    var l = u.local_displacements;
                    if (c.getLocalDisplacements().length == l.length && h.getLocalDisplacements().length == l.length)
                        for (var _ = 0; _ < l.length; _++) {
                            var p = Utils.vec2Interp(c.getLocalDisplacements()[_], h.getLocalDisplacements()[_], a);
                            l[_] = p
                        }
                    else
                        for (_ = 0; _ < l.length; _++)
                            l[_] = vec2.create()
                }
                if (u.getUsePostDisplacements()) {
                    l = u.post_displacements;
                    if (c.getPostDisplacements().length == l.length && h.getPostDisplacements().length == l.length)
                        for (_ = 0; _ < l.length; _++) {
                            p = Utils.vec2Interp(c.getPostDisplacements()[_], h.getPostDisplacements()[_], a);
                            l[_] = p
                        }
                    else
                        for (_ = 0; _ < l.length; _++)
                            l.set[_] = vec2.create()
                }
            }
    }
    ,
    MeshDisplacementCacheManager.prototype.allReady = function() {
        if (this.is_ready)
            return !0;
        for (var t = this.end_time - this.start_time + 1, e = 0, r = 0; r < this.displacement_cache_data_ready.length; r++)
            this.displacement_cache_data_ready[r] && e++;
        return e == t && (this.is_ready = !0),
        this.is_ready
    }
    ,
    MeshDisplacementCacheManager.prototype.makeAllReady = function() {
        for (var t = 0; t < this.displacement_cache_data_ready.length; t++)
            this.displacement_cache_data_ready[t] = !0
    }
    ,
    MeshUVWarpCacheManager.prototype.init = function(t, e) {
        this.start_time = t,
        this.end_time = e;
        var r = this.end_time - this.start_time + 1;
        this.uv_cache_table = [],
        this.uv_cache_data_ready = [];
        for (var n = 0; n < r; n++)
            this.uv_cache_table.push([]),
            this.uv_cache_data_ready.push(!1);
        this.is_ready = !1
    }
    ,
    MeshUVWarpCacheManager.prototype.getStartTime = function() {
        return this.start_time
    }
    ,
    MeshUVWarpCacheManager.prototype.getEndime = function() {
        return this.end_time
    }
    ,
    MeshUVWarpCacheManager.prototype.getIndexByTime = function(t) {
        var e = t - this.start_time;
        return e = Utils.clamp(e, 0, this.uv_cache_table.length - 1)
    }
    ,
    MeshUVWarpCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
        var r = this.getIndexByTime(Math.floor(t))
          , n = this.getIndexByTime(Math.ceil(t));
        Math.floor(t);
        if (0 != this.uv_cache_data_ready.length && 0 != this.uv_cache_data_ready[r] && 0 != this.uv_cache_data_ready[n])
            for (var a = this.uv_cache_table[r], i = this.uv_cache_table[n], s = 0; s < a.length; s++) {
                var o = a[s]
                  , c = (i[s],
                e[o.getKey()]);
                if (c.getUseUvWarp()) {
                    var h = o.getUvWarpLocalOffset()
                      , u = o.getUvWarpGlobalOffset()
                      , l = o.getUvWarpScale();
                    c.setUvWarpLocalOffset(h),
                    c.setUvWarpGlobalOffset(u),
                    c.setUvWarpScale(l)
                }
            }
    }
    ,
    MeshUVWarpCacheManager.prototype.allReady = function() {
        if (this.is_ready)
            return !0;
        for (var t = this.end_time - this.start_time + 1, e = 0, r = 0; r < this.uv_cache_data_ready.length; r++)
            uv_cache_data_ready[r] && e++;
        return e == t && (this.is_ready = !0),
        this.is_ready
    }
    ,
    MeshUVWarpCacheManager.prototype.makeAllReady = function() {
        for (var t = 0; t < this.uv_cache_data_ready.length; t++)
            this.uv_cache_data_ready[t] = !0
    }
    ;
    var CreatureModuleUtils = {};
    function Creature(t) {
        this.total_num_pts = 0,
        this.total_num_indices = 0,
        this.global_indices = null,
        this.global_pts = null,
        this.global_uvs = null,
        this.render_pts = null,
        this.render_colours = null,
        this.render_composition = null,
        this.boundary_indices = [],
        this.boundary_min = vec2.create(),
        this.boundary_max = vec2.create(),
        this.LoadFromData(t)
    }
    function CreatureAnimation(t, e) {
        this.name = e,
        this.bones_cache = new MeshBoneCacheManager,
        this.displacement_cache = new MeshDisplacementCacheManager,
        this.uv_warp_cache = new MeshUVWarpCacheManager,
        this.cache_pts = [],
        this.fill_cache_pts = [],
        this.LoadFromData(e, t)
    }
    function CreatureManager(t) {
        this.target_creature = t,
        this.is_playing = !1,
        this.run_time = 0,
        this.time_scale = 30,
        this.blending_factor = 0,
        this.should_loop = !0,
        this.use_custom_time_range = !1,
        this.custom_start_time = 0,
        this.custom_end_time = 0,
        this.animations = {},
        this.bones_override_callback = null,
        this.blend_render_pts = [],
        this.blend_render_pts.push([]),
        this.blend_render_pts.push([]),
        this.do_blending = !1,
        this.active_blend_animation_names = [],
        this.active_blend_animation_names.push(""),
        this.active_blend_animation_names.push("")
    }
    CreatureModuleUtils.GetAllAnimationNames = function(t) {
        var e = t.animation
          , r = [];
        for (var n in e)
            r.push(n);
        return r
    }
    ,
    CreatureModuleUtils.getFloatArray = function(t) {
        return t
    }
    ,
    CreatureModuleUtils.getIntArray = function(t) {
        return t
    }
    ,
    CreatureModuleUtils.ReadPointsArray2DJSON = function(t, e) {
        for (var r = CreatureModuleUtils.getFloatArray(t[e]), n = [], a = r.length / 2, i = 0; i < a; i++) {
            var s = 2 * i;
            n.push(vec2.fromValues(r[0 + s], r[1 + s]))
        }
        return n
    }
    ,
    CreatureModuleUtils.ReadFloatArray3DJSON = function(t, e) {
        for (var r = CreatureModuleUtils.getFloatArray(t[e]), n = [], a = r.length / 2, i = 0; i < a; i++) {
            var s = 2 * i;
            n.push(r[0 + s]),
            n.push(r[1 + s]),
            n.push(0)
        }
        return n
    }
    ,
    CreatureModuleUtils.ReadBoolJSON = function(t, e) {
        return t[e]
    }
    ,
    CreatureModuleUtils.ReadFloatArrayJSON = function(t, e) {
        return t[e]
    }
    ,
    CreatureModuleUtils.ReadIntArrayJSON = function(t, e) {
        return t[e]
    }
    ,
    CreatureModuleUtils.ReadMatrixJSON = function(t, e) {
        for (var r = CreatureModuleUtils.getFloatArray(t[e]), n = mat4.create(), a = 0; a < 16; a++)
            n[a] = r[a];
        return n
    }
    ,
    CreatureModuleUtils.ReadVector2JSON = function(t, e) {
        var r = CreatureModuleUtils.getFloatArray(t[e]);
        return vec2.fromValues(r[0], r[1])
    }
    ,
    CreatureModuleUtils.ReadVector3JSON = function(t, e) {
        var r = CreatureModuleUtils.getFloatArray(t[e]);
        return vec3.fromValues(r[0], r[1], 0)
    }
    ,
    CreatureModuleUtils.CreateBones = function(t, e) {
        var r = null
          , n = t[e]
          , a = {}
          , i = {};
        for (var s in n) {
            var o = n[s]
              , c = o.id
              , h = CreatureModuleUtils.ReadMatrixJSON(o, "restParentMat")
              , u = CreatureModuleUtils.ReadVector3JSON(o, "localRestStartPt")
              , l = CreatureModuleUtils.ReadVector3JSON(o, "localRestEndPt")
              , _ = CreatureModuleUtils.ReadIntArrayJSON(o, "children")
              , p = new MeshBone(s,vec3.create(),vec3.create(),h);
            p.local_rest_start_pt = u,
            p.local_rest_end_pt = l,
            p.calcRestData(),
            p.setTagId(c),
            a[c] = {
                first: p,
                second: _
            };
            for (var d = 0; d < _.length; d++) {
                i[g = _[d]] = g
            }
        }
        for (var c in a)
            if (c in i == 0) {
                r = (m = a[c]).first;
                break
            }
        for (var c in a) {
            var m, f = (m = a[c]).first, v = m.second;
            for (d = 0; d < v.length; d++) {
                var g, M = a[g = v[d]].first;
                f.addChild(M)
            }
        }
        return r
    }
    ,
    CreatureModuleUtils.CreateRegions = function(t, e, r, n, a) {
        var i = []
          , s = t[e];
        for (var o in s) {
            var c = s[o]
              , h = c.id
              , u = new MeshRenderRegion(r,n,a,c.start_pt_index,c.end_pt_index,c.start_index,c.end_index);
            u.setName(o),
            u.setTagId(h);
            var l = u.normal_weight_map
              , _ = c.weights;
            for (var p in _) {
                _[p];
                var d = CreatureModuleUtils.ReadFloatArrayJSON(_, p);
                l[p] = d
            }
            i.push(u)
        }
        return i
    }
    ,
    CreatureModuleUtils.GetStartEndTimes = function(t, e) {
        var r = 0
          , n = 0
          , a = !0
          , i = t[e];
        for (var s in i) {
            i[s];
            var o = parseInt(s);
            a ? (n = r = o,
            a = !1) : (n < o && (n = o),
            o < r && (r = o))
        }
        return {
            first: r,
            second: n
        }
    }
    ,
    CreatureModuleUtils.FillBoneCache = function(t, e, r, n, a) {
        var i = t[e];
        for (var s in a.init(r, n),
        i) {
            var o = i[s];
            for (var c in cache_list = [],
            o) {
                var h = o[c]
                  , u = CreatureModuleUtils.ReadVector3JSON(h, "start_pt")
                  , l = CreatureModuleUtils.ReadVector3JSON(h, "end_pt")
                  , _ = new MeshBoneCache(c);
                _.setWorldStartPt(u),
                _.setWorldEndPt(l),
                cache_list.push(_)
            }
            var p = a.getIndexByTime(s);
            a.bone_cache_table[p] = cache_list
        }
        a.makeAllReady()
    }
    ,
    CreatureModuleUtils.FillDeformationCache = function(t, e, r, n, a) {
        var i = t[e];
        for (var s in a.init(r, n),
        i) {
            var o = i[s]
              , c = [];
            for (var h in o) {
                var u = o[h]
                  , l = new MeshDisplacementCache(h)
                  , _ = CreatureModuleUtils.ReadBoolJSON(u, "use_local_displacements")
                  , p = CreatureModuleUtils.ReadBoolJSON(u, "use_post_displacements");
                if (1 == _) {
                    var d = CreatureModuleUtils.ReadPointsArray2DJSON(u, "local_displacements");
                    l.setLocalDisplacements(d)
                }
                if (1 == p) {
                    d = CreatureModuleUtils.ReadPointsArray2DJSON(u, "post_displacements");
                    l.setPostDisplacements(d)
                }
                c.push(l)
            }
            var m = a.getIndexByTime(s);
            a.displacement_cache_table[m] = c
        }
        a.makeAllReady()
    }
    ,
    CreatureModuleUtils.FillUVSwapCache = function(t, e, r, n, a) {
        var i = t[e];
        for (var s in a.init(r, n),
        i) {
            var o = i[s]
              , c = [];
            for (var h in o) {
                var u = o[h]
                  , l = new MeshUVWarpCache(h)
                  , _ = CreatureModuleUtils.ReadBoolJSON(u, "enabled");
                if (l.setEnabled(_),
                1 == _) {
                    var p = CreatureModuleUtils.ReadVector2JSON(u, "local_offset")
                      , d = CreatureModuleUtils.ReadVector2JSON(u, "global_offset")
                      , m = CreatureModuleUtils.ReadVector2JSON(u, "scale");
                    l.setUvWarpLocalOffset(p),
                    l.setUvWarpGlobalOffset(d),
                    l.setUvWarpScale(m)
                }
                c.push(l)
            }
            var f = a.getIndexByTime(s);
            a.uv_cache_table[f] = c
        }
        a.makeAllReady()
    }
    ,
    Creature.prototype.FillRenderColours = function(t, e, r, n) {
        for (var a = 0; a < this.total_num_pts; a++) {
            var i = 4 * a;
            this.render_colours[0 + i] = t,
            this.render_colours[1 + i] = e,
            this.render_colours[2 + i] = r,
            this.render_colours[3 + i] = n
        }
    }
    ,
    Creature.prototype.ComputeBoundaryIndices = function() {
        for (var t = {}, e = 0; e < this.total_num_pts; e++)
            t[e] = 0;
        var r = this.render_composition.getRegions();
        for (e = 0; e < this.global_indices.length; e++) {
            for (var n = this.global_indices[e], a = !1, i = 0; i < r.length; i++) {
                var s = r[i]
                  , o = s.getStartPtIndex()
                  , c = s.getEndPtIndex();
                if (o <= n && n <= c) {
                    a = !0;
                    break
                }
            }
            a && t[n]++
        }
        this.boundary_indices = [];
        for (e = 0; e < this.total_num_pts; e++)
            t[e] <= 5 && this.boundary_indices.push(e)
    }
    ,
    Creature.prototype.ComputeBoundaryMinMax = function() {
        this.boundary_indices.length <= 0 && this.ComputeBoundaryIndices();
        for (var t = 3 * this.boundary_indices[0], e = vec2.fromValues(this.render_pts[0 + t], this.render_pts[1 + t]), r = vec2.fromValues(e[0], e[1]), n = 0; n < this.boundary_indices.length; n++) {
            var a = 3 * this.boundary_indices[n]
              , i = this.render_pts[a]
              , s = this.render_pts[1 + a];
            e[0] > i && (e[0] = i),
            e[1] > s && (e[1] = s),
            r[0] < i && (r[0] = i),
            r[1] < s && (r[1] = s)
        }
        this.boundary_min = e,
        this.boundary_max = r
    }
    ,
    Creature.prototype.LoadFromData = function(t) {
        var e = t.mesh;
        this.global_pts = CreatureModuleUtils.ReadFloatArray3DJSON(e, "points"),
        this.total_num_pts = this.global_pts.length / 3,
        this.global_indices = CreatureModuleUtils.ReadIntArrayJSON(e, "indices"),
        this.total_num_indices = this.global_indices.length,
        this.global_uvs = CreatureModuleUtils.ReadFloatArrayJSON(e, "uvs"),
        this.render_colours = [];
        for (var r = 0; r < 4 * this.total_num_pts; r++)
            this.render_colours.push(0);
        this.FillRenderColours(1, 1, 1, 1),
        this.render_pts = [];
        var n = CreatureModuleUtils.CreateBones(t, "skeleton")
          , a = CreatureModuleUtils.CreateRegions(e, "regions", this.global_indices, this.global_pts, this.global_uvs);
        this.render_composition = new MeshRenderBoneComposition,
        this.render_composition.setRootBone(n),
        this.render_composition.getRootBone().computeRestParentTransforms();
        for (r = 0; r < a.length; r++) {
            (i = a[r]).setMainBoneKey(n.getKey()),
            i.determineMainBone(n),
            this.render_composition.addRegion(i)
        }
        this.render_composition.initBoneMap(),
        this.render_composition.initRegionsMap();
        for (r = 0; r < a.length; r++) {
            var i;
            (i = a[r]).initFastNormalWeightMap(this.render_composition.bones_map)
        }
        this.render_composition.resetToWorldRestPts()
    }
    ,
    CreatureAnimation.prototype.LoadFromData = function(t, e) {
        var r = e.animation[t]
          , n = CreatureModuleUtils.GetStartEndTimes(r, "bones");
        this.start_time = n.first,
        this.end_time = n.second,
        CreatureModuleUtils.FillBoneCache(r, "bones", this.start_time, this.end_time, this.bones_cache),
        CreatureModuleUtils.FillDeformationCache(r, "meshes", this.start_time, this.end_time, this.displacement_cache),
        CreatureModuleUtils.FillUVSwapCache(r, "uv_swaps", this.start_time, this.end_time, this.uv_warp_cache)
    }
    ,
    CreatureAnimation.prototype.getIndexByTime = function(t) {
        var e = t - this.start_time;
        return e = Utils.clamp(e, 0, this.cache_pts.length - 1)
    }
    ,
    CreatureAnimation.prototype.verifyFillCache = function() {
        this.fill_cache_pts.length == this.end_time - this.start_time + 1 && (this.cache_pts = this.fill_cache_pts)
    }
    ,
    CreatureAnimation.prototype.poseFromCachePts = function(t, e, r) {
        for (var n = this.getIndexByTime(Math.floor(t)), a = this.getIndexByTime(Math.ceil(t)), i = t - Math.floor(t), s = e, o = this.cache_pts[n], c = this.cache_pts[a], h = 0, u = 0, l = 0, _ = 0; _ < r; _++)
            s[h + 0] = (1 - i) * o[u + 0] + i * c[l + 0],
            s[h + 1] = (1 - i) * o[u + 1] + i * c[l + 1],
            s[h + 2] = (1 - i) * o[u + 2] + i * c[l + 2],
            h += 3,
            u += 3,
            l += 3
    }
    ,
    CreatureManager.prototype.CreateAnimation = function(t, e) {
        var r = new CreatureAnimation(t,e);
        this.AddAnimation(r)
    }
    ,
    CreatureManager.prototype.CreateAllAnimations = function(t) {
        for (var e = CreatureModuleUtils.GetAllAnimationNames(t), r = 0; r < e.length; r++) {
            var n = e[r];
            this.CreateAnimation(t, n)
        }
        this.SetActiveAnimationName(e.get(0))
    }
    ,
    CreatureManager.prototype.AddAnimation = function(t) {
        this.animations[t.name] = t
    }
    ,
    CreatureManager.prototype.GetAnimation = function(t) {
        return this.animations[t]
    }
    ,
    CreatureManager.prototype.GetCreature = function() {
        return this.target_creature
    }
    ,
    CreatureManager.prototype.GetAnimationNames = function() {
        var t = [];
        for (var e in animations)
            t.push(e);
        return t
    }
    ,
    CreatureManager.prototype.SetActiveAnimationName = function(t, e) {
        if (null == t || t in this.animations == 0)
            return !1;
        if (1 == e && this.active_animation_name == t)
            return !1;
        this.active_animation_name = t;
        var r = this.animations[this.active_animation_name];
        this.run_time = r.start_time;
        for (var n = r.displacement_cache.displacement_cache_table[0], a = r.uv_warp_cache.uv_cache_table[0], i = this.target_creature.render_composition.getRegions(), s = 0, o = 0; o < i.length; o++) {
            var c = i[o]
              , h = !(0 == n[s].getLocalDisplacements().length)
              , u = !(0 == n[s].getPostDisplacements().length);
            c.setUseLocalDisplacements(h),
            c.setUsePostDisplacements(u),
            c.setUseUvWarp(a[s].getEnabled()),
            s++
        }
        return !0
    }
    ,
    CreatureManager.prototype.GetActiveAnimationName = function() {
        return this.active_animation_name
    }
    ,
    CreatureManager.prototype.GetAllAnimations = function() {
        return this.animations
    }
    ,
    CreatureManager.prototype.MakePointCache = function(t) {
        var e = this.getRunTime()
          , r = this.animations[t];
        if (!(0 < r.length)) {
            for (var n = r.cache_pts, a = r.start_time; a <= r.end_time; a++) {
                this.setRunTime(a);
                for (var i = [], s = 0; s < 3 * this.target_creature.total_num_pts; s++)
                    i[s] = 0;
                this.PoseCreature(t, i),
                n.push(i)
            }
            this.setRunTime(e)
        }
    }
    ,
    CreatureManager.prototype.FillSinglePointCacheFrame = function(t, e) {
        var r = this.getRunTime()
          , n = this.animations[t];
        this.setRunTime(e);
        for (var a = [], i = 0; i < 3 * this.target_creature.total_num_pts; i++)
            a[i] = 0;
        this.PoseCreature(t, a),
        n.fill_cache_pts.push(a),
        n.verifyFillCache(),
        this.setRunTime(r)
    }
    ,
    CreatureManager.prototype.GetIsPlaying = function() {
        return this.is_playing
    }
    ,
    CreatureManager.prototype.SetShouldLoop = function(t) {
        this.should_loop = t
    }
    ,
    CreatureManager.prototype.SetUseCustomTimeRange = function(t) {
        this.use_custom_time_range = t
    }
    ,
    CreatureManager.prototype.SetCustomTimeRange = function(t, e) {
        this.custom_start_time = t,
        this.custom_end_time = e
    }
    ,
    CreatureManager.prototype.SetIsPlaying = function(t) {
        this.is_playing = t
    }
    ,
    CreatureManager.prototype.ResetToStartTimes = function() {
        var t = this.animations[active_animation_name];
        this.run_time = t.start_time
    }
    ,
    CreatureManager.prototype.setRunTime = function(t) {
        this.run_time = t,
        this.correctTime()
    }
    ,
    CreatureManager.prototype.increRunTime = function(t) {
        this.run_time += t,
        this.correctTime()
    }
    ,
    CreatureManager.prototype.correctTime = function() {
        var t = this.animations[this.active_animation_name]
          , e = t.start_time
          , r = t.end_time;
        this.use_custom_time_range && (e = this.custom_start_time,
        r = this.custom_end_time),
        this.run_time > r ? this.should_loop ? this.run_time = e : this.run_time = r : this.run_time < e && (this.should_loop ? this.run_time = r : this.run_time = e)
    }
    ,
    CreatureManager.prototype.getRunTime = function() {
        return this.run_time
    }
    ,
    CreatureManager.prototype.Update = function(t) {
        this.is_playing && (this.increRunTime(t * this.time_scale),
        this.RunCreature())
    }
    ,
    CreatureManager.prototype.RunAtTime = function(t) {
        this.is_playing && (this.setRunTime(t),
        this.RunCreature())
    }
    ,
    CreatureManager.prototype.RunCreature = function() {
        if (this.do_blending) {
            for (var t = 0; t < 2; t++) {
                0 < (i = this.animations[this.active_blend_animation_names[t]]).cache_pts.length ? i.poseFromCachePts(this.getRunTime(), this.blend_render_pts[t], this.target_creature.total_num_pts) : this.PoseCreature(this.active_blend_animation_names[t], this.blend_render_pts[t])
            }
            for (var e = 0; e < 3 * this.target_creature.total_num_pts; e++) {
                var r = e
                  , n = this.blend_render_pts[0][e]
                  , a = this.blend_render_pts[1][e];
                this.target_creature.render_pts.set(r, (1 - blending_factor) * n + blending_factor * a)
            }
        } else {
            var i;
            0 < (i = this.animations[this.active_animation_name]).cache_pts.length ? i.poseFromCachePts(this.getRunTime(), this.target_creature.render_pts, this.target_creature.total_num_pts) : this.PoseCreature(this.active_animation_name, this.target_creature.render_pts)
        }
    }
    ,
    CreatureManager.prototype.SetTimeScale = function(t) {
        this.time_scale = t
    }
    ,
    CreatureManager.prototype.SetBlending = function(t) {
        if (this.do_blending = t,
        this.do_blending) {
            if (0 == this.blend_render_pts[0].length) {
                for (var e = [], r = 0; r < 3 * target_creature.total_num_pts; r++)
                    e.push(0);
                this.blend_render_pts.set(0, e)
            }
            if (0 == this.blend_render_pts[1].length) {
                for (e = [],
                r = 0; r < 3 * this.target_creature.total_num_pts; r++)
                    e.push(0);
                this.blend_render_pts[1] = e
            }
        }
    }
    ,
    CreatureManager.prototype.SetBlendingAnimations = function(t, e) {
        this.active_blend_animation_names[0] = t,
        this.active_blend_animation_names[1] = e
    }
    ,
    CreatureManager.prototype.SetBlendingFactor = function(t) {
        this.blending_factor = t
    }
    ,
    CreatureManager.prototype.IsContactBone = function(t, e) {
        var r = this.target_creature.render_composition.getRootBone();
        return this.ProcessContactBone(t, e, r)
    }
    ,
    CreatureManager.prototype.PoseCreature = function(t, e) {
        var r = this.animations[t]
          , n = r.bones_cache
          , a = r.displacement_cache
          , i = r.uv_warp_cache
          , s = this.target_creature.render_composition
          , o = s.getBonesMap()
          , c = s.getRegionsMap();
        n.retrieveValuesAtTime(this.getRunTime(), o),
        null != this.bones_override_callback && this.bones_override_callback(o),
        a.retrieveValuesAtTime(this.getRunTime(), c),
        i.retrieveValuesAtTime(this.getRunTime(), c);
        var h = s.getRegions()
          , u = s.getBonesMap();
        s.updateAllTransforms(!1);
        for (var l = 0, _ = h.length; l < _; l++) {
            var p = h[l]
              , d = p.getStartPtIndex();
            p.poseFinalPts(e, 3 * d, u);
            for (var m = 3 * p.getStartPtIndex(), f = 3 * p.getEndPtIndex(), v = m; v <= f; v += 3)
                e[v + 2] = .001 * -l
        }
    }
    ;
    !function(e, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.dat = t() : e.dat = t()
    }(this, function() {
        return i = {},
        n.m = o = [function(e, t, n) {
            "use strict";
            var o, i = n(1), r = (o = i) && o.__esModule ? o : {
                default: o
            };
            e.exports = r.default
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = b(n(2))
              , i = b(n(6))
              , r = b(n(3))
              , a = b(n(7))
              , l = b(n(8))
              , s = b(n(10))
              , u = b(n(11))
              , d = b(n(12))
              , c = b(n(13))
              , f = b(n(14))
              , _ = b(n(15))
              , p = b(n(16))
              , h = b(n(9))
              , m = b(n(17));
            function b(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            t.default = {
                color: {
                    Color: o.default,
                    math: i.default,
                    interpret: r.default
                },
                controllers: {
                    Controller: a.default,
                    BooleanController: l.default,
                    OptionController: s.default,
                    StringController: u.default,
                    NumberController: d.default,
                    NumberControllerBox: c.default,
                    NumberControllerSlider: f.default,
                    FunctionController: _.default,
                    ColorController: p.default
                },
                dom: {
                    dom: h.default
                },
                gui: {
                    GUI: m.default
                },
                GUI: m.default
            }
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = l(n(3))
              , i = l(n(6))
              , r = l(n(4))
              , a = l(n(5));
            function l(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = (u.prototype.toString = function() {
                return (0,
                r.default)(this)
            }
            ,
            u.prototype.toHexString = function() {
                return (0,
                r.default)(this, !0)
            }
            ,
            u.prototype.toOriginal = function() {
                return this.__state.conversion.write(this)
            }
            ,
            u);
            function u() {
                if (!function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, u),
                this.__state = o.default.apply(this, arguments),
                !1 === this.__state)
                    throw new Error("Failed to interpret color arguments");
                this.__state.a = this.__state.a || 1
            }
            function d(e, t, n) {
                Object.defineProperty(e, t, {
                    get: function() {
                        return "RGB" === this.__state.space || s.recalculateRGB(this, t, n),
                        this.__state[t]
                    },
                    set: function(e) {
                        "RGB" !== this.__state.space && (s.recalculateRGB(this, t, n),
                        this.__state.space = "RGB"),
                        this.__state[t] = e
                    }
                })
            }
            function c(e, t) {
                Object.defineProperty(e, t, {
                    get: function() {
                        return "HSV" === this.__state.space || s.recalculateHSV(this),
                        this.__state[t]
                    },
                    set: function(e) {
                        "HSV" !== this.__state.space && (s.recalculateHSV(this),
                        this.__state.space = "HSV"),
                        this.__state[t] = e
                    }
                })
            }
            s.recalculateRGB = function(e, t, n) {
                if ("HEX" === e.__state.space)
                    e.__state[t] = i.default.component_from_hex(e.__state.hex, n);
                else {
                    if ("HSV" !== e.__state.space)
                        throw new Error("Corrupted color state");
                    a.default.extend(e.__state, i.default.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v))
                }
            }
            ,
            s.recalculateHSV = function(e) {
                var t = i.default.rgb_to_hsv(e.r, e.g, e.b);
                a.default.extend(e.__state, {
                    s: t.s,
                    v: t.v
                }),
                a.default.isNaN(t.h) ? a.default.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h
            }
            ,
            s.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"],
            d(s.prototype, "r", 2),
            d(s.prototype, "g", 1),
            d(s.prototype, "b", 0),
            c(s.prototype, "h"),
            c(s.prototype, "s"),
            c(s.prototype, "v"),
            Object.defineProperty(s.prototype, "a", {
                get: function() {
                    return this.__state.a
                },
                set: function(e) {
                    this.__state.a = e
                }
            }),
            Object.defineProperty(s.prototype, "hex", {
                get: function() {
                    return "HEX" !== !this.__state.space && (this.__state.hex = i.default.rgb_to_hex(this.r, this.g, this.b)),
                    this.__state.hex
                },
                set: function(e) {
                    this.__state.space = "HEX",
                    this.__state.hex = e
                }
            }),
            t.default = s
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = r(n(4))
              , i = r(n(5));
            function r(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a = [{
                litmus: i.default.isString,
                conversions: {
                    THREE_CHAR_HEX: {
                        read: function(e) {
                            var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                            return null !== t && {
                                space: "HEX",
                                hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0)
                            }
                        },
                        write: o.default
                    },
                    SIX_CHAR_HEX: {
                        read: function(e) {
                            var t = e.match(/^#([A-F0-9]{6})$/i);
                            return null !== t && {
                                space: "HEX",
                                hex: parseInt("0x" + t[1].toString(), 0)
                            }
                        },
                        write: o.default
                    },
                    CSS_RGB: {
                        read: function(e) {
                            var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                            return null !== t && {
                                space: "RGB",
                                r: parseFloat(t[1]),
                                g: parseFloat(t[2]),
                                b: parseFloat(t[3])
                            }
                        },
                        write: o.default
                    },
                    CSS_RGBA: {
                        read: function(e) {
                            var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                            return null !== t && {
                                space: "RGB",
                                r: parseFloat(t[1]),
                                g: parseFloat(t[2]),
                                b: parseFloat(t[3]),
                                a: parseFloat(t[4])
                            }
                        },
                        write: o.default
                    }
                }
            }, {
                litmus: i.default.isNumber,
                conversions: {
                    HEX: {
                        read: function(e) {
                            return {
                                space: "HEX",
                                hex: e,
                                conversionName: "HEX"
                            }
                        },
                        write: function(e) {
                            return e.hex
                        }
                    }
                }
            }, {
                litmus: i.default.isArray,
                conversions: {
                    RGB_ARRAY: {
                        read: function(e) {
                            return 3 === e.length && {
                                space: "RGB",
                                r: e[0],
                                g: e[1],
                                b: e[2]
                            }
                        },
                        write: function(e) {
                            return [e.r, e.g, e.b]
                        }
                    },
                    RGBA_ARRAY: {
                        read: function(e) {
                            return 4 === e.length && {
                                space: "RGB",
                                r: e[0],
                                g: e[1],
                                b: e[2],
                                a: e[3]
                            }
                        },
                        write: function(e) {
                            return [e.r, e.g, e.b, e.a]
                        }
                    }
                }
            }, {
                litmus: i.default.isObject,
                conversions: {
                    RGBA_OBJ: {
                        read: function(e) {
                            return !!(i.default.isNumber(e.r) && i.default.isNumber(e.g) && i.default.isNumber(e.b) && i.default.isNumber(e.a)) && {
                                space: "RGB",
                                r: e.r,
                                g: e.g,
                                b: e.b,
                                a: e.a
                            }
                        },
                        write: function(e) {
                            return {
                                r: e.r,
                                g: e.g,
                                b: e.b,
                                a: e.a
                            }
                        }
                    },
                    RGB_OBJ: {
                        read: function(e) {
                            return !!(i.default.isNumber(e.r) && i.default.isNumber(e.g) && i.default.isNumber(e.b)) && {
                                space: "RGB",
                                r: e.r,
                                g: e.g,
                                b: e.b
                            }
                        },
                        write: function(e) {
                            return {
                                r: e.r,
                                g: e.g,
                                b: e.b
                            }
                        }
                    },
                    HSVA_OBJ: {
                        read: function(e) {
                            return !!(i.default.isNumber(e.h) && i.default.isNumber(e.s) && i.default.isNumber(e.v) && i.default.isNumber(e.a)) && {
                                space: "HSV",
                                h: e.h,
                                s: e.s,
                                v: e.v,
                                a: e.a
                            }
                        },
                        write: function(e) {
                            return {
                                h: e.h,
                                s: e.s,
                                v: e.v,
                                a: e.a
                            }
                        }
                    },
                    HSV_OBJ: {
                        read: function(e) {
                            return !!(i.default.isNumber(e.h) && i.default.isNumber(e.s) && i.default.isNumber(e.v)) && {
                                space: "HSV",
                                h: e.h,
                                s: e.s,
                                v: e.v
                            }
                        },
                        write: function(e) {
                            return {
                                h: e.h,
                                s: e.s,
                                v: e.v
                            }
                        }
                    }
                }
            }]
              , l = void 0
              , s = void 0;
            t.default = function(e) {
                s = !1;
                var n = 1 < arguments.length ? i.default.toArray(arguments) : e;
                return i.default.each(a, function(e) {
                    if (e.litmus(n))
                        return i.default.each(e.conversions, function(e, t) {
                            if (l = e.read(n),
                            !1 === s && !1 !== l)
                                return (s = l).conversionName = t,
                                l.conversion = e,
                                i.default.BREAK
                        }),
                        i.default.BREAK
                }),
                s
            }
        }
        , function(e, t) {
            "use strict";
            t.__esModule = !0,
            t.default = function(e, t) {
                var n = e.__state.conversionName.toString()
                  , o = Math.round(e.r)
                  , i = Math.round(e.g)
                  , r = Math.round(e.b)
                  , a = e.a
                  , l = Math.round(e.h)
                  , s = e.s.toFixed(1)
                  , u = e.v.toFixed(1);
                if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                    for (var d = e.hex.toString(16); d.length < 6; )
                        d = "0" + d;
                    return "#" + d
                }
                return "CSS_RGB" === n ? "rgb(" + o + "," + i + "," + r + ")" : "CSS_RGBA" === n ? "rgba(" + o + "," + i + "," + r + "," + a + ")" : "HEX" === n ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === n ? "[" + o + "," + i + "," + r + "]" : "RGBA_ARRAY" === n ? "[" + o + "," + i + "," + r + "," + a + "]" : "RGB_OBJ" === n ? "{r:" + o + ",g:" + i + ",b:" + r + "}" : "RGBA_OBJ" === n ? "{r:" + o + ",g:" + i + ",b:" + r + ",a:" + a + "}" : "HSV_OBJ" === n ? "{h:" + l + ",s:" + s + ",v:" + u + "}" : "HSVA_OBJ" === n ? "{h:" + l + ",s:" + s + ",v:" + u + ",a:" + a + "}" : "unknown format"
            }
        }
        , function(e, t) {
            "use strict";
            t.__esModule = !0;
            var n, a = Array.prototype.forEach, o = Array.prototype.slice, i = {
                BREAK: {},
                extend: function(n) {
                    return this.each(o.call(arguments, 1), function(t) {
                        (this.isObject(t) ? Object.keys(t) : []).forEach(function(e) {
                            this.isUndefined(t[e]) || (n[e] = t[e])
                        }
                        .bind(this))
                    }, this),
                    n
                },
                defaults: function(n) {
                    return this.each(o.call(arguments, 1), function(t) {
                        (this.isObject(t) ? Object.keys(t) : []).forEach(function(e) {
                            this.isUndefined(n[e]) && (n[e] = t[e])
                        }
                        .bind(this))
                    }, this),
                    n
                },
                compose: function() {
                    var n = o.call(arguments);
                    return function() {
                        for (var e = o.call(arguments), t = n.length - 1; 0 <= t; t--)
                            e = [n[t].apply(this, e)];
                        return e[0]
                    }
                },
                each: function(e, t, n) {
                    if (e)
                        if (a && e.forEach && e.forEach === a)
                            e.forEach(t, n);
                        else if (e.length === e.length + 0) {
                            var o, i = void 0;
                            for (i = 0,
                            o = e.length; i < o; i++)
                                if (i in e && t.call(n, e[i], i) === this.BREAK)
                                    return
                        } else
                            for (var r in e)
                                if (t.call(n, e[r], r) === this.BREAK)
                                    return
                },
                defer: function(e) {
                    setTimeout(e, 0)
                },
                debounce: function(o, i, r) {
                    var a = void 0;
                    return function() {
                        var e = this
                          , t = arguments;
                        var n = r || !a;
                        clearTimeout(a),
                        a = setTimeout(function() {
                            a = null,
                            r || o.apply(e, t)
                        }, i),
                        n && o.apply(e, t)
                    }
                },
                toArray: function(e) {
                    return e.toArray ? e.toArray() : o.call(e)
                },
                isUndefined: function(e) {
                    return void 0 === e
                },
                isNull: function(e) {
                    return null === e
                },
                isNaN: (n = function(e) {
                    return isNaN(e)
                }
                ,
                r.toString = function() {
                    return n.toString()
                }
                ,
                r),
                isArray: Array.isArray || function(e) {
                    return e.constructor === Array
                }
                ,
                isObject: function(e) {
                    return e === Object(e)
                },
                isNumber: function(e) {
                    return e === e + 0
                },
                isString: function(e) {
                    return e === e + ""
                },
                isBoolean: function(e) {
                    return !1 === e || !0 === e
                },
                isFunction: function(e) {
                    return "[object Function]" === Object.prototype.toString.call(e)
                }
            };
            function r(e) {
                return n.apply(this, arguments)
            }
            t.default = i
        }
        , function(e, t) {
            "use strict";
            t.__esModule = !0;
            var o = void 0
              , n = {
                hsv_to_rgb: function(e, t, n) {
                    var o = Math.floor(e / 60) % 6
                      , i = e / 60 - Math.floor(e / 60)
                      , r = n * (1 - t)
                      , a = n * (1 - i * t)
                      , l = n * (1 - (1 - i) * t)
                      , s = [[n, l, r], [a, n, r], [r, n, l], [r, a, n], [l, r, n], [n, r, a]][o];
                    return {
                        r: 255 * s[0],
                        g: 255 * s[1],
                        b: 255 * s[2]
                    }
                },
                rgb_to_hsv: function(e, t, n) {
                    var o = Math.min(e, t, n)
                      , i = Math.max(e, t, n)
                      , r = i - o
                      , a = void 0;
                    return 0 === i ? {
                        h: NaN,
                        s: 0,
                        v: 0
                    } : (a = e === i ? (t - n) / r : t === i ? 2 + (n - e) / r : 4 + (e - t) / r,
                    (a /= 6) < 0 && (a += 1),
                    {
                        h: 360 * a,
                        s: r / i,
                        v: i / 255
                    })
                },
                rgb_to_hex: function(e, t, n) {
                    var o = this.hex_with_component(0, 2, e);
                    return o = this.hex_with_component(o, 1, t),
                    o = this.hex_with_component(o, 0, n)
                },
                component_from_hex: function(e, t) {
                    return e >> 8 * t & 255
                },
                hex_with_component: function(e, t, n) {
                    return n << (o = 8 * t) | e & ~(255 << o)
                }
            };
            t.default = n
        }
        , function(e, t) {
            "use strict";
            t.__esModule = !0;
            var n = (o.prototype.onChange = function(e) {
                return this.__onChange = e,
                this
            }
            ,
            o.prototype.onFinishChange = function(e) {
                return this.__onFinishChange = e,
                this
            }
            ,
            o.prototype.setValue = function(e) {
                return this.object[this.property] = e,
                this.__onChange && this.__onChange.call(this, e),
                this.updateDisplay(),
                this
            }
            ,
            o.prototype.getValue = function() {
                return this.object[this.property]
            }
            ,
            o.prototype.updateDisplay = function() {
                return this
            }
            ,
            o.prototype.isModified = function() {
                return this.initialValue !== this.getValue()
            }
            ,
            o);
            function o(e, t) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, o),
                this.initialValue = e[t],
                this.domElement = document.createElement("div"),
                this.object = e,
                this.property = t,
                this.__onChange = void 0,
                this.__onFinishChange = void 0
            }
            t.default = n
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = r(n(7))
              , i = r(n(9));
            function r(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a, l = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(s, a = o.default),
            s.prototype.setValue = function(e) {
                var t = a.prototype.setValue.call(this, e);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                this.__prev = this.getValue(),
                t
            }
            ,
            s.prototype.updateDisplay = function() {
                return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"),
                this.__checkbox.checked = !0,
                this.__prev = !0) : (this.__checkbox.checked = !1,
                this.__prev = !1),
                a.prototype.updateDisplay.call(this)
            }
            ,
            s);
            function s(e, t) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, s);
                var n = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, a.call(this, e, t))
                  , o = n;
                return n.__prev = n.getValue(),
                n.__checkbox = document.createElement("input"),
                n.__checkbox.setAttribute("type", "checkbox"),
                i.default.bind(n.__checkbox, "change", function() {
                    o.setValue(!o.__prev)
                }, !1),
                n.domElement.appendChild(n.__checkbox),
                n.updateDisplay(),
                n
            }
            t.default = l
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o, i = n(5), d = (o = i) && o.__esModule ? o : {
                default: o
            };
            var c = {};
            d.default.each({
                HTMLEvents: ["change"],
                MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
                KeyboardEvents: ["keydown"]
            }, function(e, t) {
                d.default.each(e, function(e) {
                    c[e] = t
                })
            });
            var r = /(\d+(\.\d+)?)px/;
            function a(e) {
                if ("0" === e || d.default.isUndefined(e))
                    return 0;
                var t = e.match(r);
                return d.default.isNull(t) ? 0 : parseFloat(t[1])
            }
            var l = {
                makeSelectable: function(e, t) {
                    void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function() {
                        return !1
                    }
                    : function() {}
                    ,
                    e.style.MozUserSelect = t ? "auto" : "none",
                    e.style.KhtmlUserSelect = t ? "auto" : "none",
                    e.unselectable = t ? "on" : "off")
                },
                makeFullscreen: function(e, t, n) {
                    var o = n
                      , i = t;
                    d.default.isUndefined(i) && (i = !0),
                    d.default.isUndefined(o) && (o = !0),
                    e.style.position = "absolute",
                    i && (e.style.left = 0,
                    e.style.right = 0),
                    o && (e.style.top = 0,
                    e.style.bottom = 0)
                },
                fakeEvent: function(e, t, n, o) {
                    var i = n || {}
                      , r = c[t];
                    if (!r)
                        throw new Error("Event type " + t + " not supported.");
                    var a = document.createEvent(r);
                    switch (r) {
                    case "MouseEvents":
                        var l = i.x || i.clientX || 0
                          , s = i.y || i.clientY || 0;
                        a.initMouseEvent(t, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, l, s, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        var u = a.initKeyboardEvent || a.initKeyEvent;
                        d.default.defaults(i, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }),
                        u(t, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
                        break;
                    default:
                        a.initEvent(t, i.bubbles || !1, i.cancelable || !0)
                    }
                    d.default.defaults(a, o),
                    e.dispatchEvent(a)
                },
                bind: function(e, t, n, o) {
                    var i = o || !1;
                    return e.addEventListener ? e.addEventListener(t, n, i) : e.attachEvent && e.attachEvent("on" + t, n),
                    l
                },
                unbind: function(e, t, n, o) {
                    var i = o || !1;
                    return e.removeEventListener ? e.removeEventListener(t, n, i) : e.detachEvent && e.detachEvent("on" + t, n),
                    l
                },
                addClass: function(e, t) {
                    if (void 0 === e.className)
                        e.className = t;
                    else if (e.className !== t) {
                        var n = e.className.split(/ +/);
                        -1 === n.indexOf(t) && (n.push(t),
                        e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                    }
                    return l
                },
                removeClass: function(e, t) {
                    if (t)
                        if (e.className === t)
                            e.removeAttribute("class");
                        else {
                            var n = e.className.split(/ +/)
                              , o = n.indexOf(t);
                            -1 !== o && (n.splice(o, 1),
                            e.className = n.join(" "))
                        }
                    else
                        e.className = void 0;
                    return l
                },
                hasClass: function(e, t) {
                    return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
                },
                getWidth: function(e) {
                    var t = getComputedStyle(e);
                    return a(t["border-left-width"]) + a(t["border-right-width"]) + a(t["padding-left"]) + a(t["padding-right"]) + a(t.width)
                },
                getHeight: function(e) {
                    var t = getComputedStyle(e);
                    return a(t["border-top-width"]) + a(t["border-bottom-width"]) + a(t["padding-top"]) + a(t["padding-bottom"]) + a(t.height)
                },
                getOffset: function(e) {
                    var t = e
                      , n = {
                        left: 0,
                        top: 0
                    };
                    if (t.offsetParent)
                        for (; n.left += t.offsetLeft,
                        n.top += t.offsetTop,
                        t = t.offsetParent; )
                            ;
                    return n
                },
                isActive: function(e) {
                    return e === document.activeElement && (e.type || e.href)
                }
            };
            t.default = l
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(7))
              , l = i(n(9))
              , s = i(n(5));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var u, r = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(d, u = o.default),
            d.prototype.setValue = function(e) {
                var t = u.prototype.setValue.call(this, e);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                t
            }
            ,
            d.prototype.updateDisplay = function() {
                return l.default.isActive(this.__select) ? this : (this.__select.value = this.getValue(),
                u.prototype.updateDisplay.call(this))
            }
            ,
            d);
            function d(e, t, n) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, d);
                var o, i = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, u.call(this, e, t)), r = n, a = i;
                return i.__select = document.createElement("select"),
                s.default.isArray(r) && (o = {},
                s.default.each(r, function(e) {
                    o[e] = e
                }),
                r = o),
                s.default.each(r, function(e, t) {
                    var n = document.createElement("option");
                    n.innerHTML = t,
                    n.setAttribute("value", e),
                    a.__select.appendChild(n)
                }),
                i.updateDisplay(),
                l.default.bind(i.__select, "change", function() {
                    var e = this.options[this.selectedIndex].value;
                    a.setValue(e)
                }),
                i.domElement.appendChild(i.__select),
                i
            }
            t.default = r
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(7))
              , r = i(n(9));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a, l = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(s, a = o.default),
            s.prototype.updateDisplay = function() {
                return r.default.isActive(this.__input) || (this.__input.value = this.getValue()),
                a.prototype.updateDisplay.call(this)
            }
            ,
            s);
            function s(e, t) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, s);
                var n = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, a.call(this, e, t))
                  , o = n;
                function i() {
                    o.setValue(o.__input.value)
                }
                return n.__input = document.createElement("input"),
                n.__input.setAttribute("type", "text"),
                r.default.bind(n.__input, "keyup", i),
                r.default.bind(n.__input, "change", i),
                r.default.bind(n.__input, "blur", function() {
                    o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
                }),
                r.default.bind(n.__input, "keydown", function(e) {
                    13 === e.keyCode && this.blur()
                }),
                n.updateDisplay(),
                n.domElement.appendChild(n.__input),
                n
            }
            t.default = l
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(7))
              , r = i(n(5));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function a(e) {
                var t = e.toString();
                return -1 < t.indexOf(".") ? t.length - t.indexOf(".") - 1 : 0
            }
            var l, s = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(u, l = o.default),
            u.prototype.setValue = function(e) {
                var t = e;
                return void 0 !== this.__min && t < this.__min ? t = this.__min : void 0 !== this.__max && t > this.__max && (t = this.__max),
                void 0 !== this.__step && t % this.__step != 0 && (t = Math.round(t / this.__step) * this.__step),
                l.prototype.setValue.call(this, t)
            }
            ,
            u.prototype.min = function(e) {
                return this.__min = e,
                this
            }
            ,
            u.prototype.max = function(e) {
                return this.__max = e,
                this
            }
            ,
            u.prototype.step = function(e) {
                return this.__step = e,
                this.__impliedStep = e,
                this.__precision = a(e),
                this
            }
            ,
            u);
            function u(e, t, n) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, u);
                var o = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, l.call(this, e, t))
                  , i = n || {};
                return o.__min = i.min,
                o.__max = i.max,
                o.__step = i.step,
                r.default.isUndefined(o.__step) ? 0 === o.initialValue ? o.__impliedStep = 1 : o.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(o.initialValue)) / Math.LN10)) / 10 : o.__impliedStep = o.__step,
                o.__precision = a(o.__impliedStep),
                o
            }
            t.default = s
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(12))
              , u = i(n(9))
              , d = i(n(5));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var c, r = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(f, c = o.default),
            f.prototype.updateDisplay = function() {
                return this.__input.value = this.__truncationSuspended ? this.getValue() : function(e, t) {
                    var n = Math.pow(10, t);
                    return Math.round(e * n) / n
                }(this.getValue(), this.__precision),
                c.prototype.updateDisplay.call(this)
            }
            ,
            f);
            function f(e, t, n) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, f);
                var o = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, c.call(this, e, t, n));
                o.__truncationSuspended = !1;
                var i = o
                  , r = void 0;
                function a() {
                    i.__onFinishChange && i.__onFinishChange.call(i, i.getValue())
                }
                function l(e) {
                    var t = r - e.clientY;
                    i.setValue(i.getValue() + t * i.__impliedStep),
                    r = e.clientY
                }
                function s() {
                    u.default.unbind(window, "mousemove", l),
                    u.default.unbind(window, "mouseup", s),
                    a()
                }
                return o.__input = document.createElement("input"),
                o.__input.setAttribute("type", "text"),
                u.default.bind(o.__input, "change", function() {
                    var e = parseFloat(i.__input.value);
                    d.default.isNaN(e) || i.setValue(e)
                }),
                u.default.bind(o.__input, "blur", function() {
                    a()
                }),
                u.default.bind(o.__input, "mousedown", function(e) {
                    u.default.bind(window, "mousemove", l),
                    u.default.bind(window, "mouseup", s),
                    r = e.clientY
                }),
                u.default.bind(o.__input, "keydown", function(e) {
                    13 === e.keyCode && (i.__truncationSuspended = !0,
                    this.blur(),
                    i.__truncationSuspended = !1,
                    a())
                }),
                o.updateDisplay(),
                o.domElement.appendChild(o.__input),
                o
            }
            t.default = r
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(12))
              , u = i(n(9));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var d, r = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(c, d = o.default),
            c.prototype.updateDisplay = function() {
                var e = (this.getValue() - this.__min) / (this.__max - this.__min);
                return this.__foreground.style.width = 100 * e + "%",
                d.prototype.updateDisplay.call(this)
            }
            ,
            c);
            function c(e, t, n, o, i) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, c);
                var r = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, d.call(this, e, t, {
                    min: n,
                    max: o,
                    step: i
                }))
                  , a = r;
                function l(e) {
                    e.preventDefault();
                    var t = a.__background.getBoundingClientRect();
                    return a.setValue(function(e, t, n, o, i) {
                        return o + (e - t) / (n - t) * (i - o)
                    }(e.clientX, t.left, t.right, a.__min, a.__max)),
                    !1
                }
                function s() {
                    u.default.unbind(window, "mousemove", l),
                    u.default.unbind(window, "mouseup", s),
                    a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                }
                return r.__background = document.createElement("div"),
                r.__foreground = document.createElement("div"),
                u.default.bind(r.__background, "mousedown", function(e) {
                    document.activeElement.blur(),
                    u.default.bind(window, "mousemove", l),
                    u.default.bind(window, "mouseup", s),
                    l(e)
                }),
                u.default.addClass(r.__background, "slider"),
                u.default.addClass(r.__foreground, "slider-fg"),
                r.updateDisplay(),
                r.__background.appendChild(r.__foreground),
                r.domElement.appendChild(r.__background),
                r
            }
            t.default = r
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(7))
              , r = i(n(9));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a, l = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(s, a = o.default),
            s.prototype.fire = function() {
                this.__onChange && this.__onChange.call(this),
                this.getValue().call(this.object),
                this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
            }
            ,
            s);
            function s(e, t, n) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, s);
                var o = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, a.call(this, e, t))
                  , i = o;
                return o.__button = document.createElement("div"),
                o.__button.innerHTML = void 0 === n ? "Fire" : n,
                r.default.bind(o.__button, "click", function(e) {
                    return e.preventDefault(),
                    i.fire(),
                    !1
                }),
                r.default.addClass(o.__button, "button"),
                o.domElement.appendChild(o.__button),
                o
            }
            t.default = l
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = i(n(7))
              , f = i(n(9))
              , _ = i(n(2))
              , p = i(n(3))
              , h = i(n(5));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var m, r = (function(e, t) {
                if ("function" != typeof t && null !== t)
                    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(b, m = o.default),
            b.prototype.updateDisplay = function() {
                var t = (0,
                p.default)(this.getValue());
                if (!1 !== t) {
                    var n = !1;
                    h.default.each(_.default.COMPONENTS, function(e) {
                        if (!h.default.isUndefined(t[e]) && !h.default.isUndefined(this.__color.__state[e]) && t[e] !== this.__color.__state[e])
                            return n = !0,
                            {}
                    }, this),
                    n && h.default.extend(this.__color.__state, t)
                }
                h.default.extend(this.__temp.__state, this.__color.__state),
                this.__temp.a = 1;
                var e = this.__color.v < .5 || .5 < this.__color.s ? 255 : 0
                  , o = 255 - e;
                h.default.extend(this.__field_knob.style, {
                    marginLeft: 100 * this.__color.s - 7 + "px",
                    marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                    backgroundColor: this.__temp.toHexString(),
                    border: this.__field_knob_border + "rgb(" + e + "," + e + "," + e + ")"
                }),
                this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px",
                this.__temp.s = 1,
                this.__temp.v = 1,
                g(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
                this.__input.value = this.__color.toString(),
                h.default.extend(this.__input.style, {
                    backgroundColor: this.__color.toHexString(),
                    color: "rgb(" + e + "," + e + "," + e + ")",
                    textShadow: this.__input_textShadow + "rgba(" + o + "," + o + "," + o + ",.7)"
                })
            }
            ,
            b);
            function b(e, t) {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, b);
                var n = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }(this, m.call(this, e, t));
                n.__color = new _.default(n.getValue()),
                n.__temp = new _.default(0);
                var i = n;
                n.domElement = document.createElement("div"),
                f.default.makeSelectable(n.domElement, !1),
                n.__selector = document.createElement("div"),
                n.__selector.className = "selector",
                n.__saturation_field = document.createElement("div"),
                n.__saturation_field.className = "saturation-field",
                n.__field_knob = document.createElement("div"),
                n.__field_knob.className = "field-knob",
                n.__field_knob_border = "2px solid ",
                n.__hue_knob = document.createElement("div"),
                n.__hue_knob.className = "hue-knob",
                n.__hue_field = document.createElement("div"),
                n.__hue_field.className = "hue-field",
                n.__input = document.createElement("input"),
                n.__input.type = "text",
                n.__input_textShadow = "0 1px 1px ",
                f.default.bind(n.__input, "keydown", function(e) {
                    13 === e.keyCode && l.call(this)
                }),
                f.default.bind(n.__input, "blur", l),
                f.default.bind(n.__selector, "mousedown", function() {
                    f.default.addClass(this, "drag").bind(window, "mouseup", function() {
                        f.default.removeClass(i.__selector, "drag")
                    })
                });
                var o = document.createElement("div");
                function r(e) {
                    d(e),
                    f.default.bind(window, "mousemove", d),
                    f.default.bind(window, "mouseup", a)
                }
                function a() {
                    f.default.unbind(window, "mousemove", d),
                    f.default.unbind(window, "mouseup", a),
                    u()
                }
                function l() {
                    var e = (0,
                    p.default)(this.value);
                    !1 !== e ? (i.__color.__state = e,
                    i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString()
                }
                function s() {
                    f.default.unbind(window, "mousemove", c),
                    f.default.unbind(window, "mouseup", s),
                    u()
                }
                function u() {
                    i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal())
                }
                function d(e) {
                    e.preventDefault();
                    var t = i.__saturation_field.getBoundingClientRect()
                      , n = (e.clientX - t.left) / (t.right - t.left)
                      , o = 1 - (e.clientY - t.top) / (t.bottom - t.top);
                    return 1 < o ? o = 1 : o < 0 && (o = 0),
                    1 < n ? n = 1 : n < 0 && (n = 0),
                    i.__color.v = o,
                    i.__color.s = n,
                    i.setValue(i.__color.toOriginal()),
                    !1
                }
                function c(e) {
                    e.preventDefault();
                    var t = i.__hue_field.getBoundingClientRect()
                      , n = 1 - (e.clientY - t.top) / (t.bottom - t.top);
                    return 1 < n ? n = 1 : n < 0 && (n = 0),
                    i.__color.h = 360 * n,
                    i.setValue(i.__color.toOriginal()),
                    !1
                }
                return h.default.extend(n.__selector.style, {
                    width: "122px",
                    height: "102px",
                    padding: "3px",
                    backgroundColor: "#222",
                    boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                }),
                h.default.extend(n.__field_knob.style, {
                    position: "absolute",
                    width: "12px",
                    height: "12px",
                    border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"),
                    boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                    borderRadius: "12px",
                    zIndex: 1
                }),
                h.default.extend(n.__hue_knob.style, {
                    position: "absolute",
                    width: "15px",
                    height: "2px",
                    borderRight: "4px solid #fff",
                    zIndex: 1
                }),
                h.default.extend(n.__saturation_field.style, {
                    width: "100px",
                    height: "100px",
                    border: "1px solid #555",
                    marginRight: "3px",
                    display: "inline-block",
                    cursor: "pointer"
                }),
                h.default.extend(o.style, {
                    width: "100%",
                    height: "100%",
                    background: "none"
                }),
                g(o, "top", "rgba(0,0,0,0)", "#000"),
                h.default.extend(n.__hue_field.style, {
                    width: "15px",
                    height: "100px",
                    border: "1px solid #555",
                    cursor: "ns-resize",
                    position: "absolute",
                    top: "3px",
                    right: "3px"
                }),
                function(e) {
                    e.style.background = "",
                    e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",
                    e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                    e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                    e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                    e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
                }(n.__hue_field),
                h.default.extend(n.__input.style, {
                    outline: "none",
                    textAlign: "center",
                    color: "#fff",
                    border: 0,
                    fontWeight: "bold",
                    textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)"
                }),
                f.default.bind(n.__saturation_field, "mousedown", r),
                f.default.bind(n.__field_knob, "mousedown", r),
                f.default.bind(n.__hue_field, "mousedown", function(e) {
                    c(e),
                    f.default.bind(window, "mousemove", c),
                    f.default.bind(window, "mouseup", s)
                }),
                n.__saturation_field.appendChild(o),
                n.__selector.appendChild(n.__field_knob),
                n.__selector.appendChild(n.__saturation_field),
                n.__selector.appendChild(n.__hue_field),
                n.__hue_field.appendChild(n.__hue_knob),
                n.domElement.appendChild(n.__input),
                n.domElement.appendChild(n.__selector),
                n.updateDisplay(),
                n
            }
            var a = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
            function g(t, n, o, i) {
                t.style.background = "",
                h.default.each(a, function(e) {
                    t.style.cssText += "background: " + e + "linear-gradient(" + n + ", " + o + " 0%, " + i + " 100%); "
                })
            }
            t.default = r
        }
        , function(e, t, n) {
            "use strict";
            var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            }
            : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e
            }
              , o = s(n(18))
              , i = s(n(19))
              , d = s(n(20))
              , c = s(n(7))
              , f = s(n(8))
              , _ = s(n(15))
              , p = s(n(13))
              , h = s(n(14))
              , m = s(n(16))
              , r = s(n(21))
              , a = s(n(22))
              , b = s(n(9))
              , g = s(n(5))
              , l = s(n(23));
            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            o.default.inject(l.default);
            var v = "Default"
              , y = function() {
                try {
                    return "localStorage"in window && null !== window.localStorage
                } catch (e) {
                    return !1
                }
            }()
              , w = void 0
              , x = !0
              , E = void 0
              , C = !1
              , A = []
              , S = function t(e) {
                var n = this
                  , o = e || {};
                this.domElement = document.createElement("div"),
                this.__ul = document.createElement("ul"),
                this.domElement.appendChild(this.__ul),
                b.default.addClass(this.domElement, "dg"),
                this.__folders = {},
                this.__controllers = [],
                this.__rememberedObjects = [],
                this.__rememberedObjectIndecesToControllers = [],
                this.__listening = [],
                o = g.default.defaults(o, {
                    closeOnTop: !1,
                    autoPlace: !0,
                    width: t.DEFAULT_WIDTH
                }),
                o = g.default.defaults(o, {
                    resizable: o.autoPlace,
                    hideable: o.autoPlace
                }),
                g.default.isUndefined(o.load) ? o.load = {
                    preset: v
                } : o.preset && (o.load.preset = o.preset),
                g.default.isUndefined(o.parent) && o.hideable && A.push(this),
                o.resizable = g.default.isUndefined(o.parent) && o.resizable,
                o.autoPlace && g.default.isUndefined(o.scrollable) && (o.scrollable = !0);
                var i, r = y && "true" === localStorage.getItem(L(this, "isLocal")), a = void 0;
                if (Object.defineProperties(this, {
                    parent: {
                        get: function() {
                            return o.parent
                        }
                    },
                    scrollable: {
                        get: function() {
                            return o.scrollable
                        }
                    },
                    autoPlace: {
                        get: function() {
                            return o.autoPlace
                        }
                    },
                    closeOnTop: {
                        get: function() {
                            return o.closeOnTop
                        }
                    },
                    preset: {
                        get: function() {
                            return n.parent ? n.getRoot().preset : o.load.preset
                        },
                        set: function(e) {
                            n.parent ? n.getRoot().preset = e : o.load.preset = e,
                            function(e) {
                                for (var t = 0; t < e.__preset_select.length; t++)
                                    e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t)
                            }(this),
                            n.revert()
                        }
                    },
                    width: {
                        get: function() {
                            return o.width
                        },
                        set: function(e) {
                            o.width = e,
                            M(n, e)
                        }
                    },
                    name: {
                        get: function() {
                            return o.name
                        },
                        set: function(e) {
                            o.name = e,
                            titleRowName && (titleRowName.innerHTML = o.name)
                        }
                    },
                    closed: {
                        get: function() {
                            return o.closed
                        },
                        set: function(e) {
                            o.closed = e,
                            o.closed ? b.default.addClass(n.__ul, t.CLASS_CLOSED) : b.default.removeClass(n.__ul, t.CLASS_CLOSED),
                            this.onResize(),
                            n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                        }
                    },
                    load: {
                        get: function() {
                            return o.load
                        }
                    },
                    useLocalStorage: {
                        get: function() {
                            return r
                        },
                        set: function(e) {
                            y && ((r = e) ? b.default.bind(window, "unload", a) : b.default.unbind(window, "unload", a),
                            localStorage.setItem(L(n, "isLocal"), e))
                        }
                    }
                }),
                g.default.isUndefined(o.parent)) {
                    if (o.closed = !1,
                    b.default.addClass(this.domElement, t.CLASS_MAIN),
                    b.default.makeSelectable(this.domElement, !1),
                    y && r) {
                        n.useLocalStorage = !0;
                        var l = localStorage.getItem(L(this, "gui"));
                        l && (o.load = JSON.parse(l))
                    }
                    this.__closeButton = document.createElement("div"),
                    this.__closeButton.innerHTML = t.TEXT_CLOSED,
                    b.default.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON),
                    o.closeOnTop ? (b.default.addClass(this.__closeButton, t.CLASS_CLOSE_TOP),
                    this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (b.default.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM),
                    this.domElement.appendChild(this.__closeButton)),
                    b.default.bind(this.__closeButton, "click", function() {
                        n.closed = !n.closed
                    })
                } else {
                    void 0 === o.closed && (o.closed = !0);
                    var s = document.createTextNode(o.name);
                    b.default.addClass(s, "controller-name");
                    var u = k(n, s);
                    b.default.addClass(this.__ul, t.CLASS_CLOSED),
                    b.default.addClass(u, "title"),
                    b.default.bind(u, "click", function(e) {
                        return e.preventDefault(),
                        n.closed = !n.closed,
                        !1
                    }),
                    o.closed || (this.closed = !1)
                }
                o.autoPlace && (g.default.isUndefined(o.parent) && (x && (E = document.createElement("div"),
                b.default.addClass(E, "dg"),
                b.default.addClass(E, t.CLASS_AUTO_PLACE_CONTAINER),
                document.body.appendChild(E),
                x = !1),
                E.appendChild(this.domElement),
                b.default.addClass(this.domElement, t.CLASS_AUTO_PLACE)),
                this.parent || M(n, o.width)),
                this.__resizeHandler = function() {
                    n.onResizeDebounced()
                }
                ,
                b.default.bind(window, "resize", this.__resizeHandler),
                b.default.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
                b.default.bind(this.__ul, "transitionend", this.__resizeHandler),
                b.default.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
                this.onResize(),
                o.resizable && function(t) {
                    var n = void 0;
                    function o(e) {
                        return e.preventDefault(),
                        t.width += n - e.clientX,
                        t.onResize(),
                        n = e.clientX,
                        !1
                    }
                    function i() {
                        b.default.removeClass(t.__closeButton, S.CLASS_DRAG),
                        b.default.unbind(window, "mousemove", o),
                        b.default.unbind(window, "mouseup", i)
                    }
                    function e(e) {
                        return e.preventDefault(),
                        n = e.clientX,
                        b.default.addClass(t.__closeButton, S.CLASS_DRAG),
                        b.default.bind(window, "mousemove", o),
                        b.default.bind(window, "mouseup", i),
                        !1
                    }
                    t.__resize_handle = document.createElement("div"),
                    g.default.extend(t.__resize_handle.style, {
                        width: "6px",
                        marginLeft: "-3px",
                        height: "200px",
                        cursor: "ew-resize",
                        position: "absolute"
                    }),
                    b.default.bind(t.__resize_handle, "mousedown", e),
                    b.default.bind(t.__closeButton, "mousedown", e),
                    t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
                }(this),
                a = function() {
                    y && "true" === localStorage.getItem(L(n, "isLocal")) && localStorage.setItem(L(n, "gui"), JSON.stringify(n.getSaveObject()))
                }
                ,
                this.saveToLocalStorageIfPossible = a,
                o.parent || ((i = n.getRoot()).width += 1,
                g.default.defer(function() {
                    i.width -= 1
                }))
            };
            function k(e, t, n) {
                var o = document.createElement("li");
                return t && o.appendChild(t),
                n ? e.__ul.insertBefore(o, n) : e.__ul.appendChild(o),
                e.onResize(),
                o
            }
            function O(e, t) {
                var n = e.__preset_select[e.__preset_select.selectedIndex];
                n.innerHTML = t ? n.value + "*" : n.value
            }
            function T(e, t) {
                var n = e.getRoot()
                  , o = n.__rememberedObjects.indexOf(t.object);
                if (-1 !== o) {
                    var i = n.__rememberedObjectIndecesToControllers[o];
                    if (void 0 === i && (i = {},
                    n.__rememberedObjectIndecesToControllers[o] = i),
                    i[t.property] = t,
                    n.load && n.load.remembered) {
                        var r = n.load.remembered
                          , a = void 0;
                        if (r[e.preset])
                            a = r[e.preset];
                        else {
                            if (!r[v])
                                return;
                            a = r[v]
                        }
                        if (a[o] && void 0 !== a[o][t.property]) {
                            var l = a[o][t.property];
                            t.initialValue = l,
                            t.setValue(l)
                        }
                    }
                }
            }
            function R(e, t, n, o) {
                if (void 0 === t[n])
                    throw new Error('Object "' + t + '" has no property "' + n + '"');
                var i = void 0;
                if (o.color)
                    i = new m.default(t,n);
                else {
                    var r = [t, n].concat(o.factoryArgs);
                    i = d.default.apply(e, r)
                }
                o.before instanceof c.default && (o.before = o.before.__li),
                T(e, i),
                b.default.addClass(i.domElement, "c");
                var a = document.createElement("span");
                b.default.addClass(a, "property-name"),
                a.innerHTML = i.property;
                var l = document.createElement("div");
                l.appendChild(a),
                l.appendChild(i.domElement);
                var s = k(e, l, o.before);
                return b.default.addClass(s, S.CLASS_CONTROLLER_ROW),
                i instanceof m.default ? b.default.addClass(s, "color") : b.default.addClass(s, u(i.getValue())),
                function(i, t, r) {
                    if (r.__li = t,
                    r.__gui = i,
                    g.default.extend(r, {
                        options: function(e) {
                            if (1 < arguments.length) {
                                var t = r.__li.nextElementSibling;
                                return r.remove(),
                                R(i, r.object, r.property, {
                                    before: t,
                                    factoryArgs: [g.default.toArray(arguments)]
                                })
                            }
                            if (g.default.isArray(e) || g.default.isObject(e)) {
                                var n = r.__li.nextElementSibling;
                                return r.remove(),
                                R(i, r.object, r.property, {
                                    before: n,
                                    factoryArgs: [e]
                                })
                            }
                        },
                        name: function(e) {
                            return r.__li.firstElementChild.firstElementChild.innerHTML = e,
                            r
                        },
                        listen: function() {
                            return r.__gui.listen(r),
                            r
                        },
                        remove: function() {
                            return r.__gui.remove(r),
                            r
                        }
                    }),
                    r instanceof h.default)
                        o = new p.default(r.object,r.property,{
                            min: r.__min,
                            max: r.__max,
                            step: r.__step
                        }),
                        g.default.each(["updateDisplay", "onChange", "onFinishChange", "step"], function(e) {
                            var t = r[e]
                              , n = o[e];
                            r[e] = o[e] = function() {
                                var e = Array.prototype.slice.call(arguments);
                                return n.apply(o, e),
                                t.apply(r, e)
                            }
                        }),
                        b.default.addClass(t, "has-slider"),
                        r.domElement.insertBefore(o.domElement, r.domElement.firstElementChild);
                    else if (r instanceof p.default) {
                        var e = function(e) {
                            if (g.default.isNumber(r.__min) && g.default.isNumber(r.__max)) {
                                var t = r.__li.firstElementChild.firstElementChild.innerHTML
                                  , n = -1 < r.__gui.__listening.indexOf(r);
                                r.remove();
                                var o = R(i, r.object, r.property, {
                                    before: r.__li.nextElementSibling,
                                    factoryArgs: [r.__min, r.__max, r.__step]
                                });
                                return o.name(t),
                                n && o.listen(),
                                o
                            }
                            return e
                        };
                        r.min = g.default.compose(e, r.min),
                        r.max = g.default.compose(e, r.max)
                    } else
                        r instanceof f.default ? (b.default.bind(t, "click", function() {
                            b.default.fakeEvent(r.__checkbox, "click")
                        }),
                        b.default.bind(r.__checkbox, "click", function(e) {
                            e.stopPropagation()
                        })) : r instanceof _.default ? (b.default.bind(t, "click", function() {
                            b.default.fakeEvent(r.__button, "click")
                        }),
                        b.default.bind(t, "mouseover", function() {
                            b.default.addClass(r.__button, "hover")
                        }),
                        b.default.bind(t, "mouseout", function() {
                            b.default.removeClass(r.__button, "hover")
                        })) : r instanceof m.default && (b.default.addClass(t, "color"),
                        r.updateDisplay = g.default.compose(function(e) {
                            return t.style.borderLeftColor = r.__color.toString(),
                            e
                        }, r.updateDisplay),
                        r.updateDisplay());
                    var o;
                    r.setValue = g.default.compose(function(e) {
                        return i.getRoot().__preset_select && r.isModified() && O(i.getRoot(), !0),
                        e
                    }, r.setValue)
                }(e, s, i),
                e.__controllers.push(i),
                i
            }
            function L(e, t) {
                return document.location.href + "." + t
            }
            function B(e, t, n) {
                var o = document.createElement("option");
                o.innerHTML = t,
                o.value = t,
                e.__preset_select.appendChild(o),
                n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1)
            }
            function N(e, t) {
                t.style.display = e.useLocalStorage ? "block" : "none"
            }
            function M(e, t) {
                e.domElement.style.width = t + "px",
                e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"),
                e.__closeButton && (e.__closeButton.style.width = t + "px")
            }
            function H(i, r) {
                var a = {};
                return g.default.each(i.__rememberedObjects, function(e, t) {
                    var n = {}
                      , o = i.__rememberedObjectIndecesToControllers[t];
                    g.default.each(o, function(e, t) {
                        n[t] = r ? e.initialValue : e.getValue()
                    }),
                    a[t] = n
                }),
                a
            }
            S.toggleHide = function() {
                C = !C,
                g.default.each(A, function(e) {
                    e.domElement.style.display = C ? "none" : ""
                })
            }
            ,
            S.CLASS_AUTO_PLACE = "a",
            S.CLASS_AUTO_PLACE_CONTAINER = "ac",
            S.CLASS_MAIN = "main",
            S.CLASS_CONTROLLER_ROW = "cr",
            S.CLASS_TOO_TALL = "taller-than-window",
            S.CLASS_CLOSED = "closed",
            S.CLASS_CLOSE_BUTTON = "close-button",
            S.CLASS_CLOSE_TOP = "close-top",
            S.CLASS_CLOSE_BOTTOM = "close-bottom",
            S.CLASS_DRAG = "drag",
            S.DEFAULT_WIDTH = 245,
            S.TEXT_CLOSED = "Close Controls",
            S.TEXT_OPEN = "Open Controls",
            S._keydownHandler = function(e) {
                "text" === document.activeElement.type || 72 !== e.which && 72 !== e.keyCode || S.toggleHide()
            }
            ,
            b.default.bind(window, "keydown", S._keydownHandler, !1),
            g.default.extend(S.prototype, {
                add: function(e, t) {
                    return R(this, e, t, {
                        factoryArgs: Array.prototype.slice.call(arguments, 2)
                    })
                },
                addColor: function(e, t) {
                    return R(this, e, t, {
                        color: !0
                    })
                },
                remove: function(e) {
                    this.__ul.removeChild(e.__li),
                    this.__controllers.splice(this.__controllers.indexOf(e), 1);
                    var t = this;
                    g.default.defer(function() {
                        t.onResize()
                    })
                },
                destroy: function() {
                    this.autoPlace && E.removeChild(this.domElement),
                    b.default.unbind(window, "keydown", S._keydownHandler, !1),
                    b.default.unbind(window, "resize", this.__resizeHandler),
                    this.saveToLocalStorageIfPossible && b.default.unbind(window, "unload", this.saveToLocalStorageIfPossible)
                },
                addFolder: function(e) {
                    if (void 0 !== this.__folders[e])
                        throw new Error('You already have a folder in this GUI by the name "' + e + '"');
                    var t = {
                        name: e,
                        parent: this
                    };
                    t.autoPlace = this.autoPlace,
                    this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed,
                    t.load = this.load.folders[e]);
                    var n = new S(t);
                    this.__folders[e] = n;
                    var o = k(this, n.domElement);
                    return b.default.addClass(o, "folder"),
                    n
                },
                open: function() {
                    this.closed = !1
                },
                close: function() {
                    this.closed = !0
                },
                onResize: function() {
                    var t = this.getRoot();
                    if (t.scrollable) {
                        var e = b.default.getOffset(t.__ul).top
                          , n = 0;
                        g.default.each(t.__ul.childNodes, function(e) {
                            t.autoPlace && e === t.__save_row || (n += b.default.getHeight(e))
                        }),
                        window.innerHeight - e - 20 < n ? (b.default.addClass(t.domElement, S.CLASS_TOO_TALL),
                        t.__ul.style.height = window.innerHeight - e - 20 + "px") : (b.default.removeClass(t.domElement, S.CLASS_TOO_TALL),
                        t.__ul.style.height = "auto")
                    }
                    t.__resize_handle && g.default.defer(function() {
                        t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                    }),
                    t.__closeButton && (t.__closeButton.style.width = t.width + "px")
                },
                onResizeDebounced: g.default.debounce(function() {
                    this.onResize()
                }, 50),
                remember: function() {
                    if (g.default.isUndefined(w) && ((w = new a.default).domElement.innerHTML = i.default),
                    this.parent)
                        throw new Error("You can only call remember on a top level GUI.");
                    var t = this;
                    g.default.each(Array.prototype.slice.call(arguments), function(e) {
                        0 === t.__rememberedObjects.length && function(n) {
                            var e = n.__save_row = document.createElement("li");
                            b.default.addClass(n.domElement, "has-save"),
                            n.__ul.insertBefore(e, n.__ul.firstChild),
                            b.default.addClass(e, "save-row");
                            var t = document.createElement("span");
                            t.innerHTML = "&nbsp;",
                            b.default.addClass(t, "button gears");
                            var o = document.createElement("span");
                            o.innerHTML = "Save",
                            b.default.addClass(o, "button"),
                            b.default.addClass(o, "save");
                            var i = document.createElement("span");
                            i.innerHTML = "New",
                            b.default.addClass(i, "button"),
                            b.default.addClass(i, "save-as");
                            var r = document.createElement("span");
                            r.innerHTML = "Revert",
                            b.default.addClass(r, "button"),
                            b.default.addClass(r, "revert");
                            var a = n.__preset_select = document.createElement("select");
                            n.load && n.load.remembered ? g.default.each(n.load.remembered, function(e, t) {
                                B(n, t, t === n.preset)
                            }) : B(n, v, !1);
                            b.default.bind(a, "change", function() {
                                for (var e = 0; e < n.__preset_select.length; e++)
                                    n.__preset_select[e].innerHTML = n.__preset_select[e].value;
                                n.preset = this.value
                            }),
                            e.appendChild(a),
                            e.appendChild(t),
                            e.appendChild(o),
                            e.appendChild(i),
                            e.appendChild(r),
                            y && function() {
                                var e = document.getElementById("dg-local-explain")
                                  , t = document.getElementById("dg-local-storage");
                                document.getElementById("dg-save-locally").style.display = "block",
                                "true" === localStorage.getItem(L(n, "isLocal")) && t.setAttribute("checked", "checked"),
                                N(n, e),
                                b.default.bind(t, "change", function() {
                                    n.useLocalStorage = !n.useLocalStorage,
                                    N(n, e)
                                })
                            }();
                            var l = document.getElementById("dg-new-constructor");
                            b.default.bind(l, "keydown", function(e) {
                                !e.metaKey || 67 !== e.which && 67 !== e.keyCode || w.hide()
                            }),
                            b.default.bind(t, "click", function() {
                                l.innerHTML = JSON.stringify(n.getSaveObject(), void 0, 2),
                                w.show(),
                                l.focus(),
                                l.select()
                            }),
                            b.default.bind(o, "click", function() {
                                n.save()
                            }),
                            b.default.bind(i, "click", function() {
                                var e = prompt("Enter a new preset name.");
                                e && n.saveAs(e)
                            }),
                            b.default.bind(r, "click", function() {
                                n.revert()
                            })
                        }(t),
                        -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
                    }),
                    this.autoPlace && M(this, this.width)
                },
                getRoot: function() {
                    for (var e = this; e.parent; )
                        e = e.parent;
                    return e
                },
                getSaveObject: function() {
                    var n = this.load;
                    return n.closed = this.closed,
                    0 < this.__rememberedObjects.length && (n.preset = this.preset,
                    n.remembered || (n.remembered = {}),
                    n.remembered[this.preset] = H(this)),
                    n.folders = {},
                    g.default.each(this.__folders, function(e, t) {
                        n.folders[t] = e.getSaveObject()
                    }),
                    n
                },
                save: function() {
                    this.load.remembered || (this.load.remembered = {}),
                    this.load.remembered[this.preset] = H(this),
                    O(this, !1),
                    this.saveToLocalStorageIfPossible()
                },
                saveAs: function(e) {
                    this.load.remembered || (this.load.remembered = {},
                    this.load.remembered[v] = H(this, !0)),
                    this.load.remembered[e] = H(this),
                    this.preset = e,
                    B(this, e, !0),
                    this.saveToLocalStorageIfPossible()
                },
                revert: function(t) {
                    g.default.each(this.__controllers, function(e) {
                        this.getRoot().load.remembered ? T(t || this.getRoot(), e) : e.setValue(e.initialValue),
                        e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
                    }, this),
                    g.default.each(this.__folders, function(e) {
                        e.revert(e)
                    }),
                    t || O(this.getRoot(), !1)
                },
                listen: function(e) {
                    var t = 0 === this.__listening.length;
                    this.__listening.push(e),
                    t && function e(t) {
                        0 !== t.length && r.default.call(window, function() {
                            e(t)
                        });
                        g.default.each(t, function(e) {
                            e.updateDisplay()
                        })
                    }(this.__listening)
                },
                updateDisplay: function() {
                    g.default.each(this.__controllers, function(e) {
                        e.updateDisplay()
                    }),
                    g.default.each(this.__folders, function(e) {
                        e.updateDisplay()
                    })
                }
            }),
            e.exports = S
        }
        , function(e, t) {
            "use strict";
            e.exports = {
                load: function(e, t) {
                    var n = t || document
                      , o = n.createElement("link");
                    o.type = "text/css",
                    o.rel = "stylesheet",
                    o.href = e,
                    n.getElementsByTagName("head")[0].appendChild(o)
                },
                inject: function(e, t) {
                    var n = t || document
                      , o = document.createElement("style");
                    o.type = "text/css",
                    o.innerHTML = e;
                    var i = n.getElementsByTagName("head")[0];
                    try {
                        i.appendChild(o)
                    } catch (e) {}
                }
            }
        }
        , function(e, t) {
            e.exports = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var a = o(n(10))
              , l = o(n(13))
              , s = o(n(14))
              , u = o(n(11))
              , d = o(n(15))
              , c = o(n(8))
              , f = o(n(5));
            function o(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            t.default = function(e, t, n, o, i) {
                var r = e[t];
                return f.default.isArray(n) || f.default.isObject(n) ? new a.default(e,t,n) : f.default.isNumber(r) ? f.default.isNumber(n) && f.default.isNumber(o) ? f.default.isNumber(i) ? new s.default(e,t,n,o,i) : new s.default(e,t,n,o) : f.default.isNumber(i) ? new l.default(e,t,{
                    min: n,
                    max: o,
                    step: i
                }) : new l.default(e,t,{
                    min: n,
                    max: o
                }) : f.default.isString(r) ? new u.default(e,t) : f.default.isFunction(r) ? new d.default(e,t,"") : f.default.isBoolean(r) ? new c.default(e,t) : null
            }
        }
        , function(e, t) {
            "use strict";
            t.__esModule = !0,
            t.default = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
                setTimeout(e, 1e3 / 60)
            }
        }
        , function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var o = r(n(9))
              , i = r(n(5));
            function r(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a = (l.prototype.show = function() {
                var e = this;
                this.backgroundElement.style.display = "block",
                this.domElement.style.display = "block",
                this.domElement.style.opacity = 0,
                this.domElement.style.webkitTransform = "scale(1.1)",
                this.layout(),
                i.default.defer(function() {
                    e.backgroundElement.style.opacity = 1,
                    e.domElement.style.opacity = 1,
                    e.domElement.style.webkitTransform = "scale(1)"
                })
            }
            ,
            l.prototype.hide = function() {
                function e() {
                    t.domElement.style.display = "none",
                    t.backgroundElement.style.display = "none",
                    o.default.unbind(t.domElement, "webkitTransitionEnd", e),
                    o.default.unbind(t.domElement, "transitionend", e),
                    o.default.unbind(t.domElement, "oTransitionEnd", e)
                }
                var t = this;
                o.default.bind(this.domElement, "webkitTransitionEnd", e),
                o.default.bind(this.domElement, "transitionend", e),
                o.default.bind(this.domElement, "oTransitionEnd", e),
                this.backgroundElement.style.opacity = 0,
                this.domElement.style.opacity = 0,
                this.domElement.style.webkitTransform = "scale(1.1)"
            }
            ,
            l.prototype.layout = function() {
                this.domElement.style.left = window.innerWidth / 2 - o.default.getWidth(this.domElement) / 2 + "px",
                this.domElement.style.top = window.innerHeight / 2 - o.default.getHeight(this.domElement) / 2 + "px"
            }
            ,
            l);
            function l() {
                !function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }(this, l),
                this.backgroundElement = document.createElement("div"),
                i.default.extend(this.backgroundElement.style, {
                    backgroundColor: "rgba(0,0,0,0.8)",
                    top: 0,
                    left: 0,
                    display: "none",
                    zIndex: "1000",
                    opacity: 0,
                    WebkitTransition: "opacity 0.2s linear",
                    transition: "opacity 0.2s linear"
                }),
                o.default.makeFullscreen(this.backgroundElement),
                this.backgroundElement.style.position = "fixed",
                this.domElement = document.createElement("div"),
                i.default.extend(this.domElement.style, {
                    position: "fixed",
                    display: "none",
                    zIndex: "1001",
                    opacity: 0,
                    WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                    transition: "transform 0.2s ease-out, opacity 0.2s linear"
                }),
                document.body.appendChild(this.backgroundElement),
                document.body.appendChild(this.domElement);
                var e = this;
                o.default.bind(this.backgroundElement, "click", function() {
                    e.hide()
                })
            }
            t.default = a
        }
        , function(e, t, n) {
            (e.exports = n(24)()).push([e.id, ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button.close-top {\n        position: relative; }\n      .dg.main .close-button.close-bottom {\n        position: absolute; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul.close-top {\n      margin-top: 0; }\n    .dg.a.has-save > ul.close-bottom {\n      margin-top: 27px; }\n    .dg.a.has-save > ul.closed {\n      margin-top: 0; }\n    .dg.a .save-row {\n      top: 0;\n      z-index: 1002; }\n      .dg.a .save-row.close-top {\n        position: relative; }\n      .dg.a .save-row.close-bottom {\n        position: fixed; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out;\n    -webkit-transition: overflow 0.1s linear;\n    -o-transition: overflow 0.1s linear;\n    -moz-transition: overflow 0.1s linear;\n    transition: overflow 0.1s linear; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: visible;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid transparent; }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%;\n    position: relative; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 7px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.color {\n    border-left: 3px solid; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2FA1D6; }\n    .dg .cr.number input[type=text] {\n      color: #2FA1D6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2FA1D6;\n    max-width: 100%; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", ""])
        }
        , function(e, t) {
            e.exports = function() {
                var a = [];
                return a.toString = function() {
                    for (var e = [], t = 0; t < this.length; t++) {
                        var n = this[t];
                        n[2] ? e.push("@media " + n[2] + "{" + n[1] + "}") : e.push(n[1])
                    }
                    return e.join("")
                }
                ,
                a.i = function(e, t) {
                    "string" == typeof e && (e = [[null, e, ""]]);
                    for (var n = {}, o = 0; o < this.length; o++) {
                        var i = this[o][0];
                        "number" == typeof i && (n[i] = !0)
                    }
                    for (o = 0; o < e.length; o++) {
                        var r = e[o];
                        "number" == typeof r[0] && n[r[0]] || (t && !r[2] ? r[2] = t : t && (r[2] = "(" + r[2] + ") and (" + t + ")"),
                        a.push(r))
                    }
                }
                ,
                a
            }
        }
        ],
        n.c = i,
        n.p = "",
        n(0);
        function n(e) {
            if (i[e])
                return i[e].exports;
            var t = i[e] = {
                exports: {},
                id: e,
                loaded: !1
            };
            return o[e].call(t.exports, t, t.exports, n),
            t.loaded = !0,
            t.exports
        }
        var o, i
    });
    !function(t) {
        var e;
        "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self),
        e.p2 = t())
    }(function() {
        return function n(s, a, r) {
            function c(o, t) {
                if (!a[o]) {
                    if (!s[o]) {
                        var e = "function" == typeof require && require;
                        if (!t && e)
                            return e(o, !0);
                        if (h)
                            return h(o, !0);
                        throw new Error("Cannot find module '" + o + "'")
                    }
                    var i = a[o] = {
                        exports: {}
                    };
                    s[o][0].call(i.exports, function(t) {
                        var e = s[o][1][t];
                        return c(e || t)
                    }, i, i.exports, n, s, a, r)
                }
                return a[o].exports
            }
            for (var h = "function" == typeof require && require, t = 0; t < r.length; t++)
                c(r[t]);
            return c
        }({
            1: [function(t, e, o) {
                var p = t("./Scalar");
                function i() {}
                (e.exports = i).lineInt = function(t, e, o) {
                    o = o || 0;
                    var i, n, s, a, r, c, h, l = [0, 0];
                    return i = t[1][1] - t[0][1],
                    n = t[0][0] - t[1][0],
                    s = i * t[0][0] + n * t[0][1],
                    a = e[1][1] - e[0][1],
                    r = e[0][0] - e[1][0],
                    c = a * e[0][0] + r * e[0][1],
                    h = i * r - a * n,
                    p.eq(h, 0, o) || (l[0] = (r * s - n * c) / h,
                    l[1] = (i * c - a * s) / h),
                    l
                }
                ,
                i.segmentsIntersect = function(t, e, o, i) {
                    var n = e[0] - t[0]
                      , s = e[1] - t[1]
                      , a = i[0] - o[0]
                      , r = i[1] - o[1];
                    if (a * s - r * n == 0)
                        return !1;
                    var c = (n * (o[1] - t[1]) + s * (t[0] - o[0])) / (a * s - r * n)
                      , h = (a * (t[1] - o[1]) + r * (o[0] - t[0])) / (r * n - a * s);
                    return 0 <= c && c <= 1 && 0 <= h && h <= 1
                }
            }
            , {
                "./Scalar": 4
            }],
            2: [function(t, e, o) {
                function h() {}
                (e.exports = h).area = function(t, e, o) {
                    return (e[0] - t[0]) * (o[1] - t[1]) - (o[0] - t[0]) * (e[1] - t[1])
                }
                ,
                h.left = function(t, e, o) {
                    return 0 < h.area(t, e, o)
                }
                ,
                h.leftOn = function(t, e, o) {
                    return 0 <= h.area(t, e, o)
                }
                ,
                h.right = function(t, e, o) {
                    return h.area(t, e, o) < 0
                }
                ,
                h.rightOn = function(t, e, o) {
                    return h.area(t, e, o) <= 0
                }
                ;
                var l = []
                  , p = [];
                h.collinear = function(t, e, o, i) {
                    if (i) {
                        var n = l
                          , s = p;
                        n[0] = e[0] - t[0],
                        n[1] = e[1] - t[1],
                        s[0] = o[0] - e[0],
                        s[1] = o[1] - e[1];
                        var a = n[0] * s[0] + n[1] * s[1]
                          , r = Math.sqrt(n[0] * n[0] + n[1] * n[1])
                          , c = Math.sqrt(s[0] * s[0] + s[1] * s[1]);
                        return Math.acos(a / (r * c)) < i
                    }
                    return 0 == h.area(t, e, o)
                }
                ,
                h.sqdist = function(t, e) {
                    var o = e[0] - t[0]
                      , i = e[1] - t[1];
                    return o * o + i * i
                }
            }
            , {}],
            3: [function(t, e, o) {
                var r = t("./Line")
                  , B = t("./Point")
                  , u = t("./Scalar");
                function q() {
                    this.vertices = []
                }
                (e.exports = q).prototype.at = function(t) {
                    var e = this.vertices
                      , o = e.length;
                    return e[t < 0 ? t % o + o : t % o]
                }
                ,
                q.prototype.first = function() {
                    return this.vertices[0]
                }
                ,
                q.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1]
                }
                ,
                q.prototype.clear = function() {
                    this.vertices.length = 0
                }
                ,
                q.prototype.append = function(t, e, o) {
                    if (void 0 === e)
                        throw new Error("From is not given!");
                    if (void 0 === o)
                        throw new Error("To is not given!");
                    if (o - 1 < e)
                        throw new Error("lol1");
                    if (o > t.vertices.length)
                        throw new Error("lol2");
                    if (e < 0)
                        throw new Error("lol3");
                    for (var i = e; i < o; i++)
                        this.vertices.push(t.vertices[i])
                }
                ,
                q.prototype.makeCCW = function() {
                    for (var t = 0, e = this.vertices, o = 1; o < this.vertices.length; ++o)
                        (e[o][1] < e[t][1] || e[o][1] == e[t][1] && e[o][0] > e[t][0]) && (t = o);
                    B.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
                }
                ,
                q.prototype.reverse = function() {
                    for (var t = [], e = 0, o = this.vertices.length; e !== o; e++)
                        t.push(this.vertices.pop());
                    this.vertices = t
                }
                ,
                q.prototype.isReflex = function(t) {
                    return B.right(this.at(t - 1), this.at(t), this.at(t + 1))
                }
                ;
                var c = []
                  , h = [];
                function P(t, e, o, i, n) {
                    n = n || 0;
                    var s = e[1] - t[1]
                      , a = t[0] - e[0]
                      , r = s * t[0] + a * t[1]
                      , c = i[1] - o[1]
                      , h = o[0] - i[0]
                      , l = c * o[0] + h * o[1]
                      , p = s * h - c * a;
                    return u.eq(p, 0, n) ? [0, 0] : [(h * r - a * l) / p, (s * l - c * r) / p]
                }
                q.prototype.canSee = function(t, e) {
                    var o, i, n = c, s = h;
                    if (B.leftOn(this.at(t + 1), this.at(t), this.at(e)) && B.rightOn(this.at(t - 1), this.at(t), this.at(e)))
                        return !1;
                    i = B.sqdist(this.at(t), this.at(e));
                    for (var a = 0; a !== this.vertices.length; ++a)
                        if ((a + 1) % this.vertices.length !== t && a !== t && B.leftOn(this.at(t), this.at(e), this.at(a + 1)) && B.rightOn(this.at(t), this.at(e), this.at(a)) && (n[0] = this.at(t),
                        n[1] = this.at(e),
                        s[0] = this.at(a),
                        s[1] = this.at(a + 1),
                        o = r.lineInt(n, s),
                        B.sqdist(this.at(t), o) < i))
                            return !1;
                    return !0
                }
                ,
                q.prototype.copy = function(t, e, o) {
                    var i = o || new q;
                    if (i.clear(),
                    t < e)
                        for (var n = t; n <= e; n++)
                            i.vertices.push(this.vertices[n]);
                    else {
                        for (n = 0; n <= e; n++)
                            i.vertices.push(this.vertices[n]);
                        for (n = t; n < this.vertices.length; n++)
                            i.vertices.push(this.vertices[n])
                    }
                    return i
                }
                ,
                q.prototype.getCutEdges = function() {
                    for (var t = [], e = [], o = [], i = new q, n = Number.MAX_VALUE, s = 0; s < this.vertices.length; ++s)
                        if (this.isReflex(s))
                            for (var a = 0; a < this.vertices.length; ++a)
                                if (this.canSee(s, a)) {
                                    e = this.copy(s, a, i).getCutEdges(),
                                    o = this.copy(a, s, i).getCutEdges();
                                    for (var r = 0; r < o.length; r++)
                                        e.push(o[r]);
                                    e.length < n && (n = (t = e).length,
                                    t.push([this.at(s), this.at(a)]))
                                }
                    return t
                }
                ,
                q.prototype.decomp = function() {
                    var t = this.getCutEdges();
                    return 0 < t.length ? this.slice(t) : [this]
                }
                ,
                q.prototype.slice = function(t) {
                    if (0 == t.length)
                        return [this];
                    if (t instanceof Array && t.length && t[0]instanceof Array && 2 == t[0].length && t[0][0]instanceof Array) {
                        for (var e = [this], o = 0; o < t.length; o++)
                            for (var i = t[o], n = 0; n < e.length; n++) {
                                var s = e[n].slice(i);
                                if (s) {
                                    e.splice(n, 1),
                                    e.push(s[0], s[1]);
                                    break
                                }
                            }
                        return e
                    }
                    i = t,
                    o = this.vertices.indexOf(i[0]),
                    n = this.vertices.indexOf(i[1]);
                    return -1 != o && -1 != n && [this.copy(o, n), this.copy(n, o)]
                }
                ,
                q.prototype.isSimple = function() {
                    for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                        for (var o = 0; o < e - 1; o++)
                            if (r.segmentsIntersect(t[e], t[e + 1], t[o], t[o + 1]))
                                return !1;
                    for (e = 1; e < t.length - 2; e++)
                        if (r.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1]))
                            return !1;
                    return !0
                }
                ,
                q.prototype.quickDecomp = function(t, e, o, i, n, s) {
                    n = n || 100,
                    s = s || 0,
                    i = i || 25,
                    t = void 0 !== t ? t : [],
                    e = e || [],
                    o = o || [];
                    var a = [0, 0]
                      , r = [0, 0]
                      , c = [0, 0]
                      , h = 0
                      , l = 0
                      , p = 0
                      , u = 0
                      , d = 0
                      , f = 0
                      , v = 0
                      , y = new q
                      , m = new q
                      , g = this
                      , A = this.vertices;
                    if (A.length < 3)
                        return t;
                    if (n < ++s)
                        return console.warn("quickDecomp: max level (" + n + ") reached."),
                        t;
                    for (var b = 0; b < this.vertices.length; ++b)
                        if (g.isReflex(b)) {
                            e.push(g.vertices[b]),
                            h = l = Number.MAX_VALUE;
                            for (var E = 0; E < this.vertices.length; ++E)
                                B.left(g.at(b - 1), g.at(b), g.at(E)) && B.rightOn(g.at(b - 1), g.at(b), g.at(E - 1)) && (c = P(g.at(b - 1), g.at(b), g.at(E), g.at(E - 1)),
                                B.right(g.at(b + 1), g.at(b), c) && (p = B.sqdist(g.vertices[b], c)) < l && (l = p,
                                r = c,
                                f = E)),
                                B.left(g.at(b + 1), g.at(b), g.at(E + 1)) && B.rightOn(g.at(b + 1), g.at(b), g.at(E)) && (c = P(g.at(b + 1), g.at(b), g.at(E), g.at(E + 1)),
                                B.left(g.at(b - 1), g.at(b), c) && (p = B.sqdist(g.vertices[b], c)) < h && (h = p,
                                a = c,
                                d = E));
                            if (f == (d + 1) % this.vertices.length)
                                c[0] = (r[0] + a[0]) / 2,
                                c[1] = (r[1] + a[1]) / 2,
                                o.push(c),
                                b < d ? (y.append(g, b, d + 1),
                                y.vertices.push(c),
                                m.vertices.push(c),
                                0 != f && m.append(g, f, g.vertices.length),
                                m.append(g, 0, b + 1)) : (0 != b && y.append(g, b, g.vertices.length),
                                y.append(g, 0, d + 1),
                                y.vertices.push(c),
                                m.vertices.push(c),
                                m.append(g, f, b + 1));
                            else {
                                if (d < f && (d += this.vertices.length),
                                u = Number.MAX_VALUE,
                                d < f)
                                    return t;
                                for (E = f; E <= d; ++E)
                                    B.leftOn(g.at(b - 1), g.at(b), g.at(E)) && B.rightOn(g.at(b + 1), g.at(b), g.at(E)) && (p = B.sqdist(g.at(b), g.at(E))) < u && (u = p,
                                    v = E % this.vertices.length);
                                b < v ? (y.append(g, b, v + 1),
                                0 != v && m.append(g, v, A.length),
                                m.append(g, 0, b + 1)) : (0 != b && y.append(g, b, A.length),
                                y.append(g, 0, v + 1),
                                m.append(g, v, b + 1))
                            }
                            return y.vertices.length < m.vertices.length ? (y.quickDecomp(t, e, o, i, n, s),
                            m.quickDecomp(t, e, o, i, n, s)) : (m.quickDecomp(t, e, o, i, n, s),
                            y.quickDecomp(t, e, o, i, n, s)),
                            t
                        }
                    return t.push(this),
                    t
                }
                ,
                q.prototype.removeCollinearPoints = function(t) {
                    for (var e = 0, o = this.vertices.length - 1; 3 < this.vertices.length && 0 <= o; --o)
                        B.collinear(this.at(o - 1), this.at(o), this.at(o + 1), t) && (this.vertices.splice(o % this.vertices.length, 1),
                        o--,
                        e++);
                    return e
                }
            }
            , {
                "./Line": 1,
                "./Point": 2,
                "./Scalar": 4
            }],
            4: [function(t, e, o) {
                function i() {}
                (e.exports = i).eq = function(t, e, o) {
                    return o = o || 0,
                    Math.abs(t - e) < o
                }
            }
            , {}],
            5: [function(t, e, o) {
                e.exports = {
                    Polygon: t("./Polygon"),
                    Point: t("./Point")
                }
            }
            , {
                "./Point": 2,
                "./Polygon": 3
            }],
            6: [function(t, e, o) {
                e.exports = {
                    name: "p2",
                    version: "0.7.0",
                    description: "A JavaScript 2D physics engine.",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                    main: "./src/p2.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/p2.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/p2.js/issues"
                    },
                    licenses: [{
                        type: "MIT"
                    }],
                    devDependencies: {
                        grunt: "^0.4.5",
                        "grunt-contrib-jshint": "^0.11.2",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "grunt-contrib-concat": "^0.4.0"
                    },
                    dependencies: {
                        "poly-decomp": "0.1.0"
                    }
                }
            }
            , {}],
            7: [function(t, e, o) {
                var d = t("../math/vec2");
                t("../utils/Utils");
                function i(t) {
                    this.lowerBound = d.create(),
                    t && t.lowerBound && d.copy(this.lowerBound, t.lowerBound),
                    this.upperBound = d.create(),
                    t && t.upperBound && d.copy(this.upperBound, t.upperBound)
                }
                e.exports = i;
                var f = d.create();
                i.prototype.setFromPoints = function(t, e, o, i) {
                    var n = this.lowerBound
                      , s = this.upperBound;
                    "number" != typeof o && (o = 0),
                    0 !== o ? d.rotate(n, t[0], o) : d.copy(n, t[0]),
                    d.copy(s, n);
                    for (var a = Math.cos(o), r = Math.sin(o), c = 1; c < t.length; c++) {
                        var h = t[c];
                        if (0 !== o) {
                            var l = h[0]
                              , p = h[1];
                            f[0] = a * l - r * p,
                            f[1] = r * l + a * p,
                            h = f
                        }
                        for (var u = 0; u < 2; u++)
                            h[u] > s[u] && (s[u] = h[u]),
                            h[u] < n[u] && (n[u] = h[u])
                    }
                    e && (d.add(this.lowerBound, this.lowerBound, e),
                    d.add(this.upperBound, this.upperBound, e)),
                    i && (this.lowerBound[0] -= i,
                    this.lowerBound[1] -= i,
                    this.upperBound[0] += i,
                    this.upperBound[1] += i)
                }
                ,
                i.prototype.copy = function(t) {
                    d.copy(this.lowerBound, t.lowerBound),
                    d.copy(this.upperBound, t.upperBound)
                }
                ,
                i.prototype.extend = function(t) {
                    for (var e = 2; e--; ) {
                        var o = t.lowerBound[e];
                        this.lowerBound[e] > o && (this.lowerBound[e] = o);
                        var i = t.upperBound[e];
                        this.upperBound[e] < i && (this.upperBound[e] = i)
                    }
                }
                ,
                i.prototype.overlaps = function(t) {
                    var e = this.lowerBound
                      , o = this.upperBound
                      , i = t.lowerBound
                      , n = t.upperBound;
                    return (i[0] <= o[0] && o[0] <= n[0] || e[0] <= n[0] && n[0] <= o[0]) && (i[1] <= o[1] && o[1] <= n[1] || e[1] <= n[1] && n[1] <= o[1])
                }
                ,
                i.prototype.containsPoint = function(t) {
                    var e = this.lowerBound
                      , o = this.upperBound;
                    return e[0] <= t[0] && t[0] <= o[0] && e[1] <= t[1] && t[1] <= o[1]
                }
                ,
                i.prototype.overlapsRay = function(t) {
                    var e = 1 / t.direction[0]
                      , o = 1 / t.direction[1]
                      , i = (this.lowerBound[0] - t.from[0]) * e
                      , n = (this.upperBound[0] - t.from[0]) * e
                      , s = (this.lowerBound[1] - t.from[1]) * o
                      , a = (this.upperBound[1] - t.from[1]) * o
                      , r = Math.max(Math.max(Math.min(i, n), Math.min(s, a)))
                      , c = Math.min(Math.min(Math.max(i, n), Math.max(s, a)));
                    return c < 0 ? -1 : c < r ? -1 : r
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            8: [function(t, e, o) {
                var n = t("../math/vec2")
                  , s = t("../objects/Body");
                function i(t) {
                    this.type = t,
                    this.result = [],
                    this.world = null,
                    this.boundingVolumeType = i.AABB
                }
                (e.exports = i).AABB = 1,
                i.BOUNDING_CIRCLE = 2,
                i.prototype.setWorld = function(t) {
                    this.world = t
                }
                ,
                i.prototype.getCollisionPairs = function(t) {}
                ;
                var a = n.create();
                i.boundingRadiusCheck = function(t, e) {
                    n.sub(a, t.position, e.position);
                    var o = n.squaredLength(a)
                      , i = t.boundingRadius + e.boundingRadius;
                    return o <= i * i
                }
                ,
                i.aabbCheck = function(t, e) {
                    return t.getAABB().overlaps(e.getAABB())
                }
                ,
                i.prototype.boundingVolumeCheck = function(t, e) {
                    var o;
                    switch (this.boundingVolumeType) {
                    case i.BOUNDING_CIRCLE:
                        o = i.boundingRadiusCheck(t, e);
                        break;
                    case i.AABB:
                        o = i.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                    }
                    return o
                }
                ,
                i.canCollide = function(t, e) {
                    var o = s.KINEMATIC
                      , i = s.STATIC;
                    return (t.type !== i || e.type !== i) && (!(t.type === o && e.type === i || t.type === i && e.type === o) && ((t.type !== o || e.type !== o) && ((t.sleepState !== s.SLEEPING || e.sleepState !== s.SLEEPING) && !(t.sleepState === s.SLEEPING && e.type === i || e.sleepState === s.SLEEPING && t.type === i))))
                }
                ,
                i.NAIVE = 1,
                i.SAP = 2
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31
            }],
            9: [function(t, e, o) {
                t("../shapes/Circle"),
                t("../shapes/Plane"),
                t("../shapes/Shape"),
                t("../shapes/Particle");
                var c = t("../collision/Broadphase");
                t("../math/vec2");
                function i() {
                    c.call(this, c.NAIVE)
                }
                (((e.exports = i).prototype = new c).constructor = i).prototype.getCollisionPairs = function(t) {
                    for (var e = t.bodies, o = this.result, i = o.length = 0, n = e.length; i !== n; i++)
                        for (var s = e[i], a = 0; a < i; a++) {
                            var r = e[a];
                            c.canCollide(s, r) && this.boundingVolumeCheck(s, r) && o.push(s, r)
                        }
                    return o
                }
                ,
                i.prototype.aabbQuery = function(t, e, o) {
                    o = o || [];
                    for (var i = t.bodies, n = 0; n < i.length; n++) {
                        var s = i[n];
                        s.aabbNeedsUpdate && s.updateAABB(),
                        s.aabb.overlaps(e) && o.push(s)
                    }
                    return o
                }
            }
            , {
                "../collision/Broadphase": 8,
                "../math/vec2": 30,
                "../shapes/Circle": 39,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45
            }],
            10: [function(t, e, o) {
                var _ = t("../math/vec2")
                  , D = _.sub
                  , W = _.add
                  , X = _.dot
                  , i = (t("../utils/Utils"),
                t("../utils/ContactEquationPool"))
                  , n = t("../utils/FrictionEquationPool")
                  , s = t("../utils/TupleDictionary")
                  , a = t("../equations/Equation")
                  , r = (t("../equations/ContactEquation"),
                t("../equations/FrictionEquation"),
                t("../shapes/Circle"))
                  , c = t("../shapes/Convex")
                  , h = t("../shapes/Shape")
                  , q = (t("../objects/Body"),
                t("../shapes/Box"));
                e.exports = $;
                var P = _.fromValues(0, 1)
                  , j = _.fromValues(0, 0)
                  , z = _.fromValues(0, 0)
                  , Y = _.fromValues(0, 0)
                  , K = _.fromValues(0, 0)
                  , H = _.fromValues(0, 0)
                  , V = _.fromValues(0, 0)
                  , Z = _.fromValues(0, 0)
                  , J = _.fromValues(0, 0)
                  , Q = _.fromValues(0, 0)
                  , T = _.fromValues(0, 0)
                  , N = _.fromValues(0, 0)
                  , G = _.fromValues(0, 0)
                  , O = _.fromValues(0, 0)
                  , U = _.fromValues(0, 0)
                  , F = _.fromValues(0, 0)
                  , M = _.fromValues(0, 0)
                  , L = _.fromValues(0, 0)
                  , x = _.fromValues(0, 0)
                  , k = [];
                function $() {
                    this.contactEquations = [],
                    this.frictionEquations = [],
                    this.enableFriction = !0,
                    this.enabledEquations = !0,
                    this.slipForce = 10,
                    this.frictionCoefficient = .3,
                    this.surfaceVelocity = 0,
                    this.contactEquationPool = new i({
                        size: 32
                    }),
                    this.frictionEquationPool = new n({
                        size: 64
                    }),
                    this.restitution = 0,
                    this.stiffness = a.DEFAULT_STIFFNESS,
                    this.relaxation = a.DEFAULT_RELAXATION,
                    this.frictionStiffness = a.DEFAULT_STIFFNESS,
                    this.frictionRelaxation = a.DEFAULT_RELAXATION,
                    this.enableFrictionReduction = !0,
                    this.collidingBodiesLastStep = new s,
                    this.contactSkinSize = .01
                }
                var l = _.create()
                  , p = _.create();
                function A(t, e) {
                    _.set(t.vertices[0], .5 * -e.length, -e.radius),
                    _.set(t.vertices[1], .5 * e.length, -e.radius),
                    _.set(t.vertices[2], .5 * e.length, e.radius),
                    _.set(t.vertices[3], .5 * -e.length, e.radius)
                }
                $.prototype.bodiesOverlap = function(t, e) {
                    for (var o = l, i = p, n = 0, s = t.shapes.length; n !== s; n++) {
                        var a = t.shapes[n];
                        t.toWorldFrame(o, a.position);
                        for (var r = 0, c = e.shapes.length; r !== c; r++) {
                            var h = e.shapes[r];
                            if (e.toWorldFrame(i, h.position),
                            this[a.type | h.type](t, a, o, a.angle + t.angle, e, h, i, h.angle + e.angle, !0))
                                return !0
                        }
                    }
                    return !1
                }
                ,
                $.prototype.collidedLastStep = function(t, e) {
                    var o = 0 | t.id
                      , i = 0 | e.id;
                    return !!this.collidingBodiesLastStep.get(o, i)
                }
                ,
                $.prototype.reset = function() {
                    this.collidingBodiesLastStep.reset();
                    for (var t = this.contactEquations, e = t.length; e--; ) {
                        var o = t[e]
                          , i = o.bodyA.id
                          , n = o.bodyB.id;
                        this.collidingBodiesLastStep.set(i, n, !0)
                    }
                    for (var s = this.contactEquations, a = this.frictionEquations, r = 0; r < s.length; r++)
                        this.contactEquationPool.release(s[r]);
                    for (r = 0; r < a.length; r++)
                        this.frictionEquationPool.release(a[r]);
                    this.contactEquations.length = this.frictionEquations.length = 0
                }
                ,
                $.prototype.createContactEquation = function(t, e, o, i) {
                    var n = this.contactEquationPool.get();
                    return n.bodyA = t,
                    n.bodyB = e,
                    n.shapeA = o,
                    n.shapeB = i,
                    n.restitution = this.restitution,
                    n.firstImpact = !this.collidedLastStep(t, e),
                    n.stiffness = this.stiffness,
                    n.relaxation = this.relaxation,
                    n.needsUpdate = !0,
                    n.enabled = this.enabledEquations,
                    n.offset = this.contactSkinSize,
                    n
                }
                ,
                $.prototype.createFrictionEquation = function(t, e, o, i) {
                    var n = this.frictionEquationPool.get();
                    return n.bodyA = t,
                    n.bodyB = e,
                    n.shapeA = o,
                    n.shapeB = i,
                    n.setSlipForce(this.slipForce),
                    n.frictionCoefficient = this.frictionCoefficient,
                    n.relativeVelocity = this.surfaceVelocity,
                    n.enabled = this.enabledEquations,
                    n.needsUpdate = !0,
                    n.stiffness = this.frictionStiffness,
                    n.relaxation = this.frictionRelaxation,
                    n.contactEquations.length = 0,
                    n
                }
                ,
                $.prototype.createFrictionFromContact = function(t) {
                    var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                    return _.copy(e.contactPointA, t.contactPointA),
                    _.copy(e.contactPointB, t.contactPointB),
                    _.rotate90cw(e.t, t.normalA),
                    e.contactEquations.push(t),
                    e
                }
                ,
                $.prototype.createFrictionFromAverage = function(t) {
                    var e = this.contactEquations[this.contactEquations.length - 1]
                      , o = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB)
                      , i = e.bodyA;
                    e.bodyB;
                    _.set(o.contactPointA, 0, 0),
                    _.set(o.contactPointB, 0, 0),
                    _.set(o.t, 0, 0);
                    for (var n = 0; n !== t; n++)
                        (e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === i ? (_.add(o.t, o.t, e.normalA),
                        _.add(o.contactPointA, o.contactPointA, e.contactPointA),
                        _.add(o.contactPointB, o.contactPointB, e.contactPointB)) : (_.sub(o.t, o.t, e.normalA),
                        _.add(o.contactPointA, o.contactPointA, e.contactPointB),
                        _.add(o.contactPointB, o.contactPointB, e.contactPointA)),
                        o.contactEquations.push(e);
                    var s = 1 / t;
                    return _.scale(o.contactPointA, o.contactPointA, s),
                    _.scale(o.contactPointB, o.contactPointB, s),
                    _.normalize(o.t, o.t),
                    _.rotate90cw(o.t, o.t),
                    o
                }
                ,
                $.prototype[h.LINE | h.CONVEX] = $.prototype.convexLine = function(t, e, o, i, n, s, a, r, c) {
                    return !c && 0
                }
                ,
                $.prototype[h.LINE | h.BOX] = $.prototype.lineBox = function(t, e, o, i, n, s, a, r, c) {
                    return !c && 0
                }
                ;
                var d = new q({
                    width: 1,
                    height: 1
                })
                  , f = _.create();
                $.prototype[h.CAPSULE | h.CONVEX] = $.prototype[h.CAPSULE | h.BOX] = $.prototype.convexCapsule = function(t, e, o, i, n, s, a, r, c) {
                    var h = f;
                    _.set(h, s.length / 2, 0),
                    _.rotate(h, h, r),
                    _.add(h, h, a);
                    var l = this.circleConvex(n, s, h, r, t, e, o, i, c, s.radius);
                    _.set(h, -s.length / 2, 0),
                    _.rotate(h, h, r),
                    _.add(h, h, a);
                    var p = this.circleConvex(n, s, h, r, t, e, o, i, c, s.radius);
                    if (c && (l || p))
                        return !0;
                    var u = d;
                    return A(u, s),
                    this.convexConvex(t, e, o, i, n, u, a, r, c) + l + p
                }
                ,
                $.prototype[h.CAPSULE | h.LINE] = $.prototype.lineCapsule = function(t, e, o, i, n, s, a, r, c) {
                    return !c && 0
                }
                ;
                var b = _.create()
                  , E = _.create()
                  , B = new q({
                    width: 1,
                    height: 1
                });
                $.prototype[h.CAPSULE | h.CAPSULE] = $.prototype.capsuleCapsule = function(t, e, o, i, n, s, a, r, c) {
                    for (var h = b, l = E, p = 0, u = 0; u < 2; u++) {
                        _.set(h, (0 === u ? -1 : 1) * e.length / 2, 0),
                        _.rotate(h, h, i),
                        _.add(h, h, o);
                        for (var d = 0; d < 2; d++) {
                            _.set(l, (0 === d ? -1 : 1) * s.length / 2, 0),
                            _.rotate(l, l, r),
                            _.add(l, l, a),
                            this.enableFrictionReduction && (m = this.enableFriction,
                            this.enableFriction = !1);
                            var f = this.circleCircle(t, e, h, i, n, s, l, r, c, e.radius, s.radius);
                            if (this.enableFrictionReduction && (this.enableFriction = m),
                            c && f)
                                return !0;
                            p += f
                        }
                    }
                    this.enableFrictionReduction && (m = this.enableFriction,
                    this.enableFriction = !1);
                    var v = B;
                    A(v, e);
                    var y = this.convexCapsule(t, v, o, i, n, s, a, r, c);
                    if (this.enableFrictionReduction && (this.enableFriction = m),
                    c && y)
                        return !0;
                    if (p += y,
                    this.enableFrictionReduction) {
                        var m = this.enableFriction;
                        this.enableFriction = !1
                    }
                    A(v, s);
                    var g = this.convexCapsule(n, v, a, r, t, e, o, i, c);
                    return this.enableFrictionReduction && (this.enableFriction = m),
                    !(!c || !g) || (p += g,
                    this.enableFrictionReduction && p && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(p)),
                    p)
                }
                ,
                $.prototype[h.LINE | h.LINE] = $.prototype.lineLine = function(t, e, o, i, n, s, a, r, c) {
                    return !c && 0
                }
                ,
                $.prototype[h.PLANE | h.LINE] = $.prototype.planeLine = function(t, e, o, i, n, s, a, r, c) {
                    var h = j
                      , l = z
                      , p = Y
                      , u = K
                      , d = H
                      , f = V
                      , v = Z
                      , y = J
                      , m = Q
                      , g = k
                      , A = 0;
                    _.set(h, -s.length / 2, 0),
                    _.set(l, s.length / 2, 0),
                    _.rotate(p, h, r),
                    _.rotate(u, l, r),
                    W(p, p, a),
                    W(u, u, a),
                    _.copy(h, p),
                    _.copy(l, u),
                    D(d, l, h),
                    _.normalize(f, d),
                    _.rotate90cw(m, f),
                    _.rotate(y, P, i),
                    g[0] = h,
                    g[1] = l;
                    for (var b = 0; b < g.length; b++) {
                        var E = g[b];
                        D(v, E, o);
                        var B = X(v, y);
                        if (B < 0) {
                            if (c)
                                return !0;
                            var q = this.createContactEquation(t, n, e, s);
                            A++,
                            _.copy(q.normalA, y),
                            _.normalize(q.normalA, q.normalA),
                            _.scale(v, y, B),
                            D(q.contactPointA, E, v),
                            D(q.contactPointA, q.contactPointA, t.position),
                            D(q.contactPointB, E, a),
                            W(q.contactPointB, q.contactPointB, a),
                            D(q.contactPointB, q.contactPointB, n.position),
                            this.contactEquations.push(q),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q))
                        }
                    }
                    return !c && (this.enableFrictionReduction || A && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(A)),
                    A)
                }
                ,
                $.prototype[h.PARTICLE | h.CAPSULE] = $.prototype.particleCapsule = function(t, e, o, i, n, s, a, r, c) {
                    return this.circleLine(t, e, o, i, n, s, a, r, c, s.radius, 0)
                }
                ,
                $.prototype[h.CIRCLE | h.LINE] = $.prototype.circleLine = function(t, e, o, i, n, s, a, r, c, h, l) {
                    h = h || 0,
                    l = void 0 !== l ? l : e.radius;
                    var p = j
                      , u = z
                      , d = Y
                      , f = K
                      , v = H
                      , y = V
                      , m = Z
                      , g = J
                      , A = Q
                      , b = T
                      , E = N
                      , B = G
                      , q = O
                      , P = U
                      , w = k;
                    _.set(g, -s.length / 2, 0),
                    _.set(A, s.length / 2, 0),
                    _.rotate(b, g, r),
                    _.rotate(E, A, r),
                    W(b, b, a),
                    W(E, E, a),
                    _.copy(g, b),
                    _.copy(A, E),
                    D(y, A, g),
                    _.normalize(m, y),
                    _.rotate90cw(v, m),
                    D(B, o, g);
                    var S = X(B, v);
                    D(f, g, a),
                    D(q, o, a);
                    var C = l + h;
                    if (Math.abs(S) < C) {
                        _.scale(p, v, S),
                        D(d, o, p),
                        _.scale(u, v, X(v, q)),
                        _.normalize(u, u),
                        _.scale(u, u, h),
                        W(d, d, u);
                        var L = X(m, d)
                          , x = X(m, g)
                          , F = X(m, A);
                        if (x < L && L < F) {
                            if (c)
                                return !0;
                            var M = this.createContactEquation(t, n, e, s);
                            return _.scale(M.normalA, p, -1),
                            _.normalize(M.normalA, M.normalA),
                            _.scale(M.contactPointA, M.normalA, l),
                            W(M.contactPointA, M.contactPointA, o),
                            D(M.contactPointA, M.contactPointA, t.position),
                            D(M.contactPointB, d, a),
                            W(M.contactPointB, M.contactPointB, a),
                            D(M.contactPointB, M.contactPointB, n.position),
                            this.contactEquations.push(M),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M)),
                            1
                        }
                    }
                    w[0] = g,
                    w[1] = A;
                    for (var I = 0; I < w.length; I++) {
                        var R = w[I];
                        if (D(B, R, o),
                        _.squaredLength(B) < Math.pow(C, 2)) {
                            if (c)
                                return !0;
                            M = this.createContactEquation(t, n, e, s);
                            return _.copy(M.normalA, B),
                            _.normalize(M.normalA, M.normalA),
                            _.scale(M.contactPointA, M.normalA, l),
                            W(M.contactPointA, M.contactPointA, o),
                            D(M.contactPointA, M.contactPointA, t.position),
                            D(M.contactPointB, R, a),
                            _.scale(P, M.normalA, -h),
                            W(M.contactPointB, M.contactPointB, P),
                            W(M.contactPointB, M.contactPointB, a),
                            D(M.contactPointB, M.contactPointB, n.position),
                            this.contactEquations.push(M),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M)),
                            1
                        }
                    }
                    return 0
                }
                ,
                $.prototype[h.CIRCLE | h.CAPSULE] = $.prototype.circleCapsule = function(t, e, o, i, n, s, a, r, c) {
                    return this.circleLine(t, e, o, i, n, s, a, r, c, s.radius)
                }
                ,
                $.prototype[h.CIRCLE | h.CONVEX] = $.prototype[h.CIRCLE | h.BOX] = $.prototype.circleConvex = function(t, e, o, i, n, s, a, r, c, h) {
                    h = "number" == typeof h ? h : e.radius;
                    for (var l = j, p = z, u = Y, d = K, f = H, v = T, y = N, m = O, g = U, A = F, b = M, E = !1, B = Number.MAX_VALUE, q = s.vertices, P = 0; P !== q.length + 1; P++) {
                        var w = q[P % q.length]
                          , S = q[(P + 1) % q.length];
                        if (_.rotate(l, w, r),
                        _.rotate(p, S, r),
                        W(l, l, a),
                        W(p, p, a),
                        D(u, p, l),
                        _.normalize(d, u),
                        _.rotate90cw(f, d),
                        _.scale(g, f, -e.radius),
                        W(g, g, o),
                        I(g, s, a, r)) {
                            _.sub(A, l, g);
                            var C = Math.abs(_.dot(A, f));
                            C < B && (_.copy(b, g),
                            B = C,
                            _.scale(m, f, C),
                            _.add(m, m, g),
                            E = !0)
                        }
                    }
                    if (E) {
                        if (c)
                            return !0;
                        var L = this.createContactEquation(t, n, e, s);
                        return _.sub(L.normalA, b, o),
                        _.normalize(L.normalA, L.normalA),
                        _.scale(L.contactPointA, L.normalA, h),
                        W(L.contactPointA, L.contactPointA, o),
                        D(L.contactPointA, L.contactPointA, t.position),
                        D(L.contactPointB, m, a),
                        W(L.contactPointB, L.contactPointB, a),
                        D(L.contactPointB, L.contactPointB, n.position),
                        this.contactEquations.push(L),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(L)),
                        1
                    }
                    if (0 < h)
                        for (P = 0; P < q.length; P++) {
                            var x = q[P];
                            if (_.rotate(y, x, r),
                            W(y, y, a),
                            D(v, y, o),
                            _.squaredLength(v) < Math.pow(h, 2)) {
                                if (c)
                                    return !0;
                                L = this.createContactEquation(t, n, e, s);
                                return _.copy(L.normalA, v),
                                _.normalize(L.normalA, L.normalA),
                                _.scale(L.contactPointA, L.normalA, h),
                                W(L.contactPointA, L.contactPointA, o),
                                D(L.contactPointA, L.contactPointA, t.position),
                                D(L.contactPointB, y, a),
                                W(L.contactPointB, L.contactPointB, a),
                                D(L.contactPointB, L.contactPointB, n.position),
                                this.contactEquations.push(L),
                                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(L)),
                                1
                            }
                        }
                    return 0
                }
                ;
                var v = _.create()
                  , y = _.create()
                  , m = _.create()
                  , g = _.create();
                function I(t, e, o, i) {
                    for (var n = v, s = y, a = m, r = g, c = t, h = e.vertices, l = null, p = 0; p !== h.length + 1; p++) {
                        var u = h[p % h.length]
                          , d = h[(p + 1) % h.length];
                        _.rotate(n, u, i),
                        _.rotate(s, d, i),
                        W(n, n, o),
                        W(s, s, o),
                        D(a, n, c),
                        D(r, s, c);
                        var f = _.crossLength(a, r);
                        if (null === l && (l = f),
                        f * l <= 0)
                            return !1;
                        l = f
                    }
                    return !0
                }
                $.prototype[h.PARTICLE | h.CONVEX] = $.prototype[h.PARTICLE | h.BOX] = $.prototype.particleConvex = function(t, e, o, i, n, s, a, r, c) {
                    var h = j
                      , l = z
                      , p = Y
                      , u = K
                      , d = H
                      , f = V
                      , v = Z
                      , y = T
                      , m = O
                      , g = L
                      , A = x
                      , b = Number.MAX_VALUE
                      , E = !1
                      , B = s.vertices;
                    if (!I(o, s, a, r))
                        return 0;
                    if (c)
                        return !0;
                    for (var q = 0; q !== B.length + 1; q++) {
                        var P = B[q % B.length]
                          , w = B[(q + 1) % B.length];
                        _.rotate(h, P, r),
                        _.rotate(l, w, r),
                        W(h, h, a),
                        W(l, l, a),
                        D(p, l, h),
                        _.normalize(u, p),
                        _.rotate90cw(d, u),
                        D(y, o, h);
                        X(y, d);
                        D(f, h, a),
                        D(v, o, a),
                        _.sub(g, h, o);
                        var S = Math.abs(_.dot(g, d));
                        S < b && (b = S,
                        _.scale(m, d, S),
                        _.add(m, m, o),
                        _.copy(A, d),
                        E = !0)
                    }
                    if (E) {
                        var C = this.createContactEquation(t, n, e, s);
                        return _.scale(C.normalA, A, -1),
                        _.normalize(C.normalA, C.normalA),
                        _.set(C.contactPointA, 0, 0),
                        W(C.contactPointA, C.contactPointA, o),
                        D(C.contactPointA, C.contactPointA, t.position),
                        D(C.contactPointB, m, a),
                        W(C.contactPointB, C.contactPointB, a),
                        D(C.contactPointB, C.contactPointB, n.position),
                        this.contactEquations.push(C),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C)),
                        1
                    }
                    return 0
                }
                ,
                $.prototype[h.CIRCLE] = $.prototype.circleCircle = function(t, e, o, i, n, s, a, r, c, h, l) {
                    var p = j;
                    h = h || e.radius,
                    l = l || s.radius;
                    D(p, o, a);
                    var u = h + l;
                    if (_.squaredLength(p) > Math.pow(u, 2))
                        return 0;
                    if (c)
                        return !0;
                    var d = this.createContactEquation(t, n, e, s);
                    return D(d.normalA, a, o),
                    _.normalize(d.normalA, d.normalA),
                    _.scale(d.contactPointA, d.normalA, h),
                    _.scale(d.contactPointB, d.normalA, -l),
                    W(d.contactPointA, d.contactPointA, o),
                    D(d.contactPointA, d.contactPointA, t.position),
                    W(d.contactPointB, d.contactPointB, a),
                    D(d.contactPointB, d.contactPointB, n.position),
                    this.contactEquations.push(d),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d)),
                    1
                }
                ,
                $.prototype[h.PLANE | h.CONVEX] = $.prototype[h.PLANE | h.BOX] = $.prototype.planeConvex = function(t, e, o, i, n, s, a, r, c) {
                    var h = j
                      , l = z
                      , p = Y
                      , u = 0;
                    _.rotate(l, P, i);
                    for (var d = 0; d !== s.vertices.length; d++) {
                        var f = s.vertices[d];
                        if (_.rotate(h, f, r),
                        W(h, h, a),
                        D(p, h, o),
                        X(p, l) <= 0) {
                            if (c)
                                return !0;
                            u++;
                            var v = this.createContactEquation(t, n, e, s);
                            D(p, h, o),
                            _.copy(v.normalA, l);
                            var y = X(p, v.normalA);
                            _.scale(p, v.normalA, y),
                            D(v.contactPointB, h, n.position),
                            D(v.contactPointA, h, p),
                            D(v.contactPointA, v.contactPointA, t.position),
                            this.contactEquations.push(v),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(v))
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && u && this.frictionEquations.push(this.createFrictionFromAverage(u)),
                    u
                }
                ,
                $.prototype[h.PARTICLE | h.PLANE] = $.prototype.particlePlane = function(t, e, o, i, n, s, a, r, c) {
                    var h = j
                      , l = z;
                    r = r || 0,
                    D(h, o, a),
                    _.rotate(l, P, r);
                    var p = X(h, l);
                    if (0 < p)
                        return 0;
                    if (c)
                        return !0;
                    var u = this.createContactEquation(n, t, s, e);
                    return _.copy(u.normalA, l),
                    _.scale(h, u.normalA, p),
                    D(u.contactPointA, o, h),
                    D(u.contactPointA, u.contactPointA, n.position),
                    D(u.contactPointB, o, t.position),
                    this.contactEquations.push(u),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(u)),
                    1
                }
                ,
                $.prototype[h.CIRCLE | h.PARTICLE] = $.prototype.circleParticle = function(t, e, o, i, n, s, a, r, c) {
                    var h = j;
                    if (D(h, a, o),
                    _.squaredLength(h) > Math.pow(e.radius, 2))
                        return 0;
                    if (c)
                        return !0;
                    var l = this.createContactEquation(t, n, e, s);
                    return _.copy(l.normalA, h),
                    _.normalize(l.normalA, l.normalA),
                    _.scale(l.contactPointA, l.normalA, e.radius),
                    W(l.contactPointA, l.contactPointA, o),
                    D(l.contactPointA, l.contactPointA, t.position),
                    D(l.contactPointB, a, n.position),
                    this.contactEquations.push(l),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(l)),
                    1
                }
                ;
                var w = new r({
                    radius: 1
                })
                  , S = _.create()
                  , C = _.create();
                _.create();
                $.prototype[h.PLANE | h.CAPSULE] = $.prototype.planeCapsule = function(t, e, o, i, n, s, a, r, c) {
                    var h, l = S, p = C, u = w;
                    _.set(l, -s.length / 2, 0),
                    _.rotate(l, l, r),
                    W(l, l, a),
                    _.set(p, s.length / 2, 0),
                    _.rotate(p, p, r),
                    W(p, p, a),
                    u.radius = s.radius,
                    this.enableFrictionReduction && (h = this.enableFriction,
                    this.enableFriction = !1);
                    var d = this.circlePlane(n, u, l, 0, t, e, o, i, c)
                      , f = this.circlePlane(n, u, p, 0, t, e, o, i, c);
                    if (this.enableFrictionReduction && (this.enableFriction = h),
                    c)
                        return d || f;
                    var v = d + f;
                    return this.enableFrictionReduction && v && this.frictionEquations.push(this.createFrictionFromAverage(v)),
                    v
                }
                ,
                $.prototype[h.CIRCLE | h.PLANE] = $.prototype.circlePlane = function(t, e, o, i, n, s, a, r, c) {
                    var h = t
                      , l = e
                      , p = o
                      , u = n
                      , d = a
                      , f = r;
                    f = f || 0;
                    var v = j
                      , y = z
                      , m = Y;
                    D(v, p, d),
                    _.rotate(y, P, f);
                    var g = X(y, v);
                    if (g > l.radius)
                        return 0;
                    if (c)
                        return !0;
                    var A = this.createContactEquation(u, h, s, e);
                    return _.copy(A.normalA, y),
                    _.scale(A.contactPointB, A.normalA, -l.radius),
                    W(A.contactPointB, A.contactPointB, p),
                    D(A.contactPointB, A.contactPointB, h.position),
                    _.scale(m, A.normalA, g),
                    D(A.contactPointA, v, m),
                    W(A.contactPointA, A.contactPointA, d),
                    D(A.contactPointA, A.contactPointA, u.position),
                    this.contactEquations.push(A),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)),
                    1
                }
                ,
                $.prototype[h.CONVEX] = $.prototype[h.CONVEX | h.BOX] = $.prototype[h.BOX] = $.prototype.convexConvex = function(t, e, o, i, n, s, a, r, c, h) {
                    var l = j
                      , p = z
                      , u = Y
                      , d = K
                      , f = H
                      , v = Z
                      , y = J
                      , m = Q
                      , g = 0;
                    h = "number" == typeof h ? h : 0;
                    if (!$.findSeparatingAxis(e, o, i, s, a, r, l))
                        return 0;
                    D(y, a, o),
                    0 < X(l, y) && _.scale(l, l, -1);
                    var A = $.getClosestEdge(e, i, l, !0)
                      , b = $.getClosestEdge(s, r, l);
                    if (-1 === A || -1 === b)
                        return 0;
                    for (var E = 0; E < 2; E++) {
                        var B, q = A, P = b, w = e, S = s, C = o, L = a, x = i, F = r, M = t, I = n;
                        if (0 === E)
                            B = q,
                            q = P,
                            P = B,
                            B = w,
                            w = S,
                            S = B,
                            B = C,
                            C = L,
                            L = B,
                            B = x,
                            x = F,
                            F = B,
                            B = M,
                            M = I,
                            I = B;
                        for (var R = P; R < P + 2; R++) {
                            var V = S.vertices[(R + S.vertices.length) % S.vertices.length];
                            _.rotate(p, V, F),
                            W(p, p, L);
                            for (var T = 0, N = q - 1; N < q + 2; N++) {
                                var G = w.vertices[(N + w.vertices.length) % w.vertices.length]
                                  , O = w.vertices[(N + 1 + w.vertices.length) % w.vertices.length];
                                _.rotate(u, G, x),
                                _.rotate(d, O, x),
                                W(u, u, C),
                                W(d, d, C),
                                D(f, d, u),
                                _.rotate90cw(m, f),
                                _.normalize(m, m),
                                D(y, p, u);
                                var U = X(m, y);
                                (N === q && U <= h || N !== q && U <= 0) && T++
                            }
                            if (3 <= T) {
                                if (c)
                                    return !0;
                                var k = this.createContactEquation(M, I, w, S);
                                g++;
                                G = w.vertices[q % w.vertices.length],
                                O = w.vertices[(q + 1) % w.vertices.length];
                                _.rotate(u, G, x),
                                _.rotate(d, O, x),
                                W(u, u, C),
                                W(d, d, C),
                                D(f, d, u),
                                _.rotate90cw(k.normalA, f),
                                _.normalize(k.normalA, k.normalA),
                                D(y, p, u);
                                U = X(k.normalA, y);
                                _.scale(v, k.normalA, U),
                                D(k.contactPointA, p, C),
                                D(k.contactPointA, k.contactPointA, v),
                                W(k.contactPointA, k.contactPointA, C),
                                D(k.contactPointA, k.contactPointA, M.position),
                                D(k.contactPointB, p, L),
                                W(k.contactPointB, k.contactPointB, L),
                                D(k.contactPointB, k.contactPointB, I.position),
                                this.contactEquations.push(k),
                                this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(k))
                            }
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && g && this.frictionEquations.push(this.createFrictionFromAverage(g)),
                    g
                }
                ;
                var R = _.fromValues(0, 0);
                $.projectConvexOntoAxis = function(t, e, o, i, n) {
                    var s, a, r = null, c = null, h = R;
                    _.rotate(h, i, -o);
                    for (var l = 0; l < t.vertices.length; l++)
                        s = t.vertices[l],
                        a = X(s, h),
                        (null === r || r < a) && (r = a),
                        (null === c || a < c) && (c = a);
                    if (r < c) {
                        var p = c;
                        c = r,
                        r = p
                    }
                    var u = X(e, i);
                    _.set(n, c + u, r + u)
                }
                ;
                var tt = _.fromValues(0, 0)
                  , et = _.fromValues(0, 0)
                  , ot = _.fromValues(0, 0)
                  , it = _.fromValues(0, 0)
                  , nt = _.fromValues(0, 0)
                  , st = _.fromValues(0, 0);
                $.findSeparatingAxis = function(t, e, o, i, n, s, a) {
                    var r = null
                      , c = !1
                      , h = !1
                      , l = tt
                      , p = et
                      , u = ot
                      , d = it
                      , f = nt
                      , v = st;
                    if (t instanceof q && i instanceof q)
                        for (var y = 0; 2 !== y; y++) {
                            var m = t
                              , g = o;
                            1 === y && (m = i,
                            g = s);
                            for (var A = 0; 2 !== A; A++) {
                                0 === A ? _.set(d, 0, 1) : 1 === A && _.set(d, 1, 0),
                                0 !== g && _.rotate(d, d, g),
                                $.projectConvexOntoAxis(t, e, o, d, f),
                                $.projectConvexOntoAxis(i, n, s, d, v);
                                var b = f
                                  , E = v;
                                f[0] > v[0] && (E = f,
                                b = v,
                                !0),
                                c = (B = E[0] - b[1]) <= 0,
                                (null === r || r < B) && (_.copy(a, d),
                                r = B,
                                h = c)
                            }
                        }
                    else
                        for (y = 0; 2 !== y; y++) {
                            m = t,
                            g = o;
                            1 === y && (m = i,
                            g = s);
                            for (A = 0; A !== m.vertices.length; A++) {
                                _.rotate(p, m.vertices[A], g),
                                _.rotate(u, m.vertices[(A + 1) % m.vertices.length], g),
                                D(l, u, p),
                                _.rotate90cw(d, l),
                                _.normalize(d, d),
                                $.projectConvexOntoAxis(t, e, o, d, f),
                                $.projectConvexOntoAxis(i, n, s, d, v);
                                var B;
                                b = f,
                                E = v;
                                f[0] > v[0] && (E = f,
                                b = v,
                                !0),
                                c = (B = E[0] - b[1]) <= 0,
                                (null === r || r < B) && (_.copy(a, d),
                                r = B,
                                h = c)
                            }
                        }
                    return h
                }
                ;
                var u = _.fromValues(0, 0)
                  , at = _.fromValues(0, 0)
                  , rt = _.fromValues(0, 0);
                $.getClosestEdge = function(t, e, o, i) {
                    var n = u
                      , s = at
                      , a = rt;
                    _.rotate(n, o, -e),
                    i && _.scale(n, n, -1);
                    for (var r = -1, c = t.vertices.length, h = -1, l = 0; l !== c; l++) {
                        D(s, t.vertices[(l + 1) % c], t.vertices[l % c]),
                        _.rotate90cw(a, s),
                        _.normalize(a, a);
                        var p = X(a, n);
                        (-1 === r || h < p) && (r = l % c,
                        h = p)
                    }
                    return r
                }
                ;
                var ct = _.create()
                  , ht = _.create()
                  , lt = _.create()
                  , pt = _.create()
                  , ut = _.create()
                  , dt = _.create()
                  , ft = _.create();
                $.prototype[h.CIRCLE | h.HEIGHTFIELD] = $.prototype.circleHeightfield = function(t, e, o, i, n, s, a, r, c, h) {
                    var l = s.heights
                      , p = (h = h || e.radius,
                    s.elementWidth)
                      , u = ht
                      , d = ct
                      , f = ut
                      , v = ft
                      , y = dt
                      , m = lt
                      , g = pt
                      , A = Math.floor((o[0] - h - a[0]) / p)
                      , b = Math.ceil((o[0] + h - a[0]) / p);
                    A < 0 && (A = 0),
                    b >= l.length && (b = l.length - 1);
                    for (var E = l[A], B = l[b], q = A; q < b; q++)
                        l[q] < B && (B = l[q]),
                        l[q] > E && (E = l[q]);
                    if (o[1] - h > E)
                        return !c && 0;
                    var P = !1;
                    for (q = A; q < b; q++) {
                        _.set(m, q * p, l[q]),
                        _.set(g, (q + 1) * p, l[q + 1]),
                        _.add(m, m, a),
                        _.add(g, g, a),
                        _.sub(y, g, m),
                        _.rotate(y, y, Math.PI / 2),
                        _.normalize(y, y),
                        _.scale(d, y, -h),
                        _.add(d, d, o),
                        _.sub(u, d, m);
                        var w = _.dot(u, y);
                        if (d[0] >= m[0] && d[0] < g[0] && w <= 0) {
                            if (c)
                                return !0;
                            P = !0,
                            _.scale(u, y, -w),
                            _.add(f, d, u),
                            _.copy(v, y);
                            var S = this.createContactEquation(n, t, s, e);
                            _.copy(S.normalA, v),
                            _.scale(S.contactPointB, S.normalA, -h),
                            W(S.contactPointB, S.contactPointB, o),
                            D(S.contactPointB, S.contactPointB, t.position),
                            _.copy(S.contactPointA, f),
                            _.sub(S.contactPointA, S.contactPointA, n.position),
                            this.contactEquations.push(S),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(S))
                        }
                    }
                    if (P = !1,
                    0 < h)
                        for (q = A; q <= b; q++)
                            if (_.set(m, q * p, l[q]),
                            _.add(m, m, a),
                            _.sub(u, o, m),
                            _.squaredLength(u) < Math.pow(h, 2)) {
                                if (c)
                                    return !0;
                                P = !0;
                                S = this.createContactEquation(n, t, s, e);
                                _.copy(S.normalA, u),
                                _.normalize(S.normalA, S.normalA),
                                _.scale(S.contactPointB, S.normalA, -h),
                                W(S.contactPointB, S.contactPointB, o),
                                D(S.contactPointB, S.contactPointB, t.position),
                                D(S.contactPointA, m, a),
                                W(S.contactPointA, S.contactPointA, a),
                                D(S.contactPointA, S.contactPointA, n.position),
                                this.contactEquations.push(S),
                                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(S))
                            }
                    return P ? 1 : 0
                }
                ;
                var vt = _.create()
                  , yt = _.create()
                  , mt = _.create()
                  , gt = new c({
                    vertices: [_.create(), _.create(), _.create(), _.create()]
                });
                $.prototype[h.BOX | h.HEIGHTFIELD] = $.prototype[h.CONVEX | h.HEIGHTFIELD] = $.prototype.convexHeightfield = function(t, e, o, i, n, s, a, r, c) {
                    var h = s.heights
                      , l = s.elementWidth
                      , p = vt
                      , u = yt
                      , d = mt
                      , f = gt
                      , v = Math.floor((t.aabb.lowerBound[0] - a[0]) / l)
                      , y = Math.ceil((t.aabb.upperBound[0] - a[0]) / l);
                    v < 0 && (v = 0),
                    y >= h.length && (y = h.length - 1);
                    for (var m = h[v], g = h[y], A = v; A < y; A++)
                        h[A] < g && (g = h[A]),
                        h[A] > m && (m = h[A]);
                    if (t.aabb.lowerBound[1] > m)
                        return !c && 0;
                    var b = 0;
                    for (A = v; A < y; A++) {
                        _.set(p, A * l, h[A]),
                        _.set(u, (A + 1) * l, h[A + 1]),
                        _.add(p, p, a),
                        _.add(u, u, a);
                        _.set(d, .5 * (u[0] + p[0]), .5 * (u[1] + p[1] - 100)),
                        _.sub(f.vertices[0], u, d),
                        _.sub(f.vertices[1], p, d),
                        _.copy(f.vertices[2], f.vertices[1]),
                        _.copy(f.vertices[3], f.vertices[0]),
                        f.vertices[2][1] -= 100,
                        f.vertices[3][1] -= 100,
                        b += this.convexConvex(t, e, o, i, n, f, d, 0, c)
                    }
                    return b
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Box": 37,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Shape": 45,
                "../utils/ContactEquationPool": 48,
                "../utils/FrictionEquationPool": 49,
                "../utils/TupleDictionary": 56,
                "../utils/Utils": 57
            }],
            11: [function(t, e, o) {
                e.exports = a;
                var c = t("../math/vec2");
                t("../collision/RaycastResult"),
                t("../shapes/Shape"),
                t("../collision/AABB");
                function a(t) {
                    t = t || {},
                    this.from = t.from ? c.fromValues(t.from[0], t.from[1]) : c.create(),
                    this.to = t.to ? c.fromValues(t.to[0], t.to[1]) : c.create(),
                    this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse,
                    this.skipBackfaces = !!t.skipBackfaces,
                    this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1,
                    this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1,
                    this.mode = void 0 !== t.mode ? t.mode : a.ANY,
                    this.callback = t.callback || function(t) {}
                    ,
                    this.direction = c.create(),
                    this.length = 1,
                    this.update()
                }
                (a.prototype.constructor = a).CLOSEST = 1,
                a.ANY = 2,
                a.ALL = 4,
                a.prototype.update = function() {
                    var t = this.direction;
                    c.sub(t, this.to, this.from),
                    this.length = c.length(t),
                    c.normalize(t, t)
                }
                ,
                a.prototype.intersectBodies = function(t, e) {
                    for (var o = 0, i = e.length; !t.shouldStop(this) && o < i; o++) {
                        var n = e[o]
                          , s = n.getAABB();
                        (0 <= s.overlapsRay(this) || s.containsPoint(this.from)) && this.intersectBody(t, n)
                    }
                }
                ;
                var h = c.create();
                a.prototype.intersectBody = function(t, e) {
                    var o = this.checkCollisionResponse;
                    if (!o || e.collisionResponse)
                        for (var i = h, n = 0, s = e.shapes.length; n < s; n++) {
                            var a = e.shapes[n];
                            if ((!o || a.collisionResponse) && (0 != (this.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & this.collisionMask))) {
                                c.rotate(i, a.position, e.angle),
                                c.add(i, i, e.position);
                                var r = a.angle + e.angle;
                                if (this.intersectShape(t, a, r, i, e),
                                t.shouldStop(this))
                                    break
                            }
                        }
                }
                ,
                a.prototype.intersectShape = function(t, e, o, i, n) {
                    (function(t, e, o) {
                        c.sub(s, o, t);
                        var i = c.dot(s, e);
                        return c.scale(r, e, i),
                        c.add(r, r, t),
                        c.squaredDistance(o, r)
                    }
                    )(this.from, this.direction, i) > e.boundingRadius * e.boundingRadius || (this._currentBody = n,
                    (this._currentShape = e).raycast(t, this, i, o),
                    this._currentBody = this._currentShape = null)
                }
                ,
                a.prototype.getAABB = function(t) {
                    var e = this.to
                      , o = this.from;
                    c.set(t.lowerBound, Math.min(e[0], o[0]), Math.min(e[1], o[1])),
                    c.set(t.upperBound, Math.max(e[0], o[0]), Math.max(e[1], o[1]))
                }
                ;
                c.create();
                a.prototype.reportIntersection = function(t, e, o, i) {
                    this.from,
                    this.to;
                    var n = this._currentShape
                      , s = this._currentBody;
                    if (!(this.skipBackfaces && 0 < c.dot(o, this.direction)))
                        switch (this.mode) {
                        case a.ALL:
                            t.set(o, n, s, e, i),
                            this.callback(t);
                            break;
                        case a.CLOSEST:
                            (e < t.fraction || !t.hasHit()) && t.set(o, n, s, e, i);
                            break;
                        case a.ANY:
                            t.set(o, n, s, e, i)
                        }
                }
                ;
                var s = c.create()
                  , r = c.create()
            }
            , {
                "../collision/AABB": 7,
                "../collision/RaycastResult": 12,
                "../math/vec2": 30,
                "../shapes/Shape": 45
            }],
            12: [function(t, e, o) {
                var s = t("../math/vec2")
                  , i = t("../collision/Ray");
                function n() {
                    this.normal = s.create(),
                    this.shape = null,
                    this.body = null,
                    this.faceIndex = -1,
                    this.fraction = -1,
                    this.isStopped = !1
                }
                (e.exports = n).prototype.reset = function() {
                    s.set(this.normal, 0, 0),
                    this.shape = null,
                    this.body = null,
                    this.faceIndex = -1,
                    this.fraction = -1,
                    this.isStopped = !1
                }
                ,
                n.prototype.getHitDistance = function(t) {
                    return s.distance(t.from, t.to) * this.fraction
                }
                ,
                n.prototype.hasHit = function() {
                    return -1 !== this.fraction
                }
                ,
                n.prototype.getHitPoint = function(t, e) {
                    s.lerp(t, e.from, e.to, this.fraction)
                }
                ,
                n.prototype.stop = function() {
                    this.isStopped = !0
                }
                ,
                n.prototype.shouldStop = function(t) {
                    return this.isStopped || -1 !== this.fraction && t.mode === i.ANY
                }
                ,
                n.prototype.set = function(t, e, o, i, n) {
                    s.copy(this.normal, t),
                    this.shape = e,
                    this.body = o,
                    this.fraction = i,
                    this.faceIndex = n
                }
            }
            , {
                "../collision/Ray": 11,
                "../math/vec2": 30
            }],
            13: [function(t, e, o) {
                var i = t("../utils/Utils")
                  , p = t("../collision/Broadphase");
                function n() {
                    p.call(this, p.SAP),
                    this.axisList = [],
                    this.axisIndex = 0;
                    var o = this;
                    this._addBodyHandler = function(t) {
                        o.axisList.push(t.body)
                    }
                    ,
                    this._removeBodyHandler = function(t) {
                        var e = o.axisList.indexOf(t.body);
                        -1 !== e && o.axisList.splice(e, 1)
                    }
                }
                (((e.exports = n).prototype = new p).constructor = n).prototype.setWorld = function(t) {
                    this.axisList.length = 0,
                    i.appendArray(this.axisList, t.bodies),
                    t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler),
                    t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler),
                    this.world = t
                }
                ,
                n.sortAxisList = function(t, e) {
                    e |= 0;
                    for (var o = 1, i = t.length; o < i; o++) {
                        for (var n = t[o], s = o - 1; 0 <= s && !(t[s].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); s--)
                            t[s + 1] = t[s];
                        t[s + 1] = n
                    }
                    return t
                }
                ,
                n.prototype.sortList = function() {
                    var t = this.axisList
                      , e = this.axisIndex;
                    n.sortAxisList(t, e)
                }
                ,
                n.prototype.getCollisionPairs = function(t) {
                    var e = this.axisList
                      , o = this.result
                      , i = this.axisIndex;
                    o.length = 0;
                    for (var n = e.length; n--; ) {
                        var s = e[n];
                        s.aabbNeedsUpdate && s.updateAABB()
                    }
                    this.sortList();
                    for (var a = 0, r = 0 | e.length; a !== r; a++)
                        for (var c = e[a], h = a + 1; h < r; h++) {
                            var l = e[h];
                            if (!(l.aabb.lowerBound[i] <= c.aabb.upperBound[i]))
                                break;
                            p.canCollide(c, l) && this.boundingVolumeCheck(c, l) && o.push(c, l)
                        }
                    return o
                }
                ,
                n.prototype.aabbQuery = function(t, e, o) {
                    o = o || [],
                    this.sortList();
                    var i = this.axisIndex
                      , n = "x";
                    1 === i && (n = "y"),
                    2 === i && (n = "z");
                    for (var s = this.axisList, a = (e.lowerBound[n],
                    e.upperBound[n],
                    0); a < s.length; a++) {
                        var r = s[a];
                        r.aabbNeedsUpdate && r.updateAABB(),
                        r.aabb.overlaps(e) && o.push(r)
                    }
                    return o
                }
            }
            , {
                "../collision/Broadphase": 8,
                "../utils/Utils": 57
            }],
            14: [function(t, e, o) {
                e.exports = i;
                var n = t("../utils/Utils");
                function i(t, e, o, i) {
                    this.type = o,
                    i = n.defaults(i, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }),
                    this.equations = [],
                    this.bodyA = t,
                    this.bodyB = e,
                    this.collideConnected = i.collideConnected,
                    i.wakeUpBodies && (t && t.wakeUp(),
                    e && e.wakeUp())
                }
                i.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!")
                }
                ,
                i.DISTANCE = 1,
                i.GEAR = 2,
                i.LOCK = 3,
                i.PRISMATIC = 4,
                i.REVOLUTE = 5,
                i.prototype.setStiffness = function(t) {
                    for (var e = this.equations, o = 0; o !== e.length; o++) {
                        var i = e[o];
                        i.stiffness = t,
                        i.needsUpdate = !0
                    }
                }
                ,
                i.prototype.setRelaxation = function(t) {
                    for (var e = this.equations, o = 0; o !== e.length; o++) {
                        var i = e[o];
                        i.relaxation = t,
                        i.needsUpdate = !0
                    }
                }
            }
            , {
                "../utils/Utils": 57
            }],
            15: [function(t, e, o) {
                var d = t("./Constraint")
                  , f = t("../equations/Equation")
                  , v = t("../math/vec2")
                  , y = t("../utils/Utils");
                function i(t, e, o) {
                    o = y.defaults(o, {
                        localAnchorA: [0, 0],
                        localAnchorB: [0, 0]
                    }),
                    d.call(this, t, e, d.DISTANCE, o),
                    this.localAnchorA = v.fromValues(o.localAnchorA[0], o.localAnchorA[1]),
                    this.localAnchorB = v.fromValues(o.localAnchorB[0], o.localAnchorB[1]);
                    var i, n = this.localAnchorA, s = this.localAnchorB;
                    if (this.distance = 0,
                    "number" == typeof o.distance)
                        this.distance = o.distance;
                    else {
                        var a = v.create()
                          , r = v.create()
                          , c = v.create();
                        v.rotate(a, n, t.angle),
                        v.rotate(r, s, e.angle),
                        v.add(c, e.position, r),
                        v.sub(c, c, a),
                        v.sub(c, c, t.position),
                        this.distance = v.length(c)
                    }
                    i = void 0 === o.maxForce ? Number.MAX_VALUE : o.maxForce;
                    var h = new f(t,e,-i,i);
                    this.equations = [h],
                    this.maxForce = i;
                    c = v.create();
                    var l = v.create()
                      , p = v.create()
                      , u = this;
                    h.computeGq = function() {
                        var t = this.bodyA
                          , e = this.bodyB
                          , o = t.position
                          , i = e.position;
                        return v.rotate(l, n, t.angle),
                        v.rotate(p, s, e.angle),
                        v.add(c, i, p),
                        v.sub(c, c, l),
                        v.sub(c, c, o),
                        v.length(c) - u.distance
                    }
                    ,
                    this.setMaxForce(i),
                    this.upperLimitEnabled = !1,
                    this.upperLimit = 1,
                    this.lowerLimitEnabled = !1,
                    this.lowerLimit = 0,
                    this.position = 0
                }
                ((e.exports = i).prototype = new d).constructor = i;
                var l = v.create()
                  , p = v.create()
                  , u = v.create();
                i.prototype.update = function() {
                    var t = this.equations[0]
                      , e = this.bodyA
                      , o = this.bodyB
                      , i = (this.distance,
                    e.position)
                      , n = o.position
                      , s = this.equations[0]
                      , a = t.G;
                    v.rotate(p, this.localAnchorA, e.angle),
                    v.rotate(u, this.localAnchorB, o.angle),
                    v.add(l, n, u),
                    v.sub(l, l, p),
                    v.sub(l, l, i),
                    this.position = v.length(l);
                    var r = !1;
                    if (this.upperLimitEnabled && this.position > this.upperLimit && (s.maxForce = 0,
                    s.minForce = -this.maxForce,
                    this.distance = this.upperLimit,
                    r = !0),
                    this.lowerLimitEnabled && this.position < this.lowerLimit && (s.maxForce = this.maxForce,
                    s.minForce = 0,
                    this.distance = this.lowerLimit,
                    r = !0),
                    !this.lowerLimitEnabled && !this.upperLimitEnabled || r) {
                        s.enabled = !0,
                        v.normalize(l, l);
                        var c = v.crossLength(p, l)
                          , h = v.crossLength(u, l);
                        a[0] = -l[0],
                        a[1] = -l[1],
                        a[2] = -c,
                        a[3] = l[0],
                        a[4] = l[1],
                        a[5] = h
                    } else
                        s.enabled = !1
                }
                ,
                i.prototype.setMaxForce = function(t) {
                    var e = this.equations[0];
                    e.minForce = -t,
                    e.maxForce = t
                }
                ,
                i.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                }
            }
            , {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Constraint": 14
            }],
            16: [function(t, e, o) {
                var i = t("./Constraint")
                  , n = (t("../equations/Equation"),
                t("../equations/AngleLockEquation"));
                t("../math/vec2");
                function s(t, e, o) {
                    o = o || {},
                    i.call(this, t, e, i.GEAR, o),
                    this.ratio = void 0 !== o.ratio ? o.ratio : 1,
                    this.angle = void 0 !== o.angle ? o.angle : e.angle - this.ratio * t.angle,
                    o.angle = this.angle,
                    o.ratio = this.ratio,
                    this.equations = [new n(t,e,o)],
                    void 0 !== o.maxTorque && this.setMaxTorque(o.maxTorque)
                }
                (((e.exports = s).prototype = new i).constructor = s).prototype.update = function() {
                    var t = this.equations[0];
                    t.ratio !== this.ratio && t.setRatio(this.ratio),
                    t.angle = this.angle
                }
                ,
                s.prototype.setMaxTorque = function(t) {
                    this.equations[0].setMaxTorque(t)
                }
                ,
                s.prototype.getMaxTorque = function(t) {
                    return this.equations[0].maxForce
                }
            }
            , {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            17: [function(t, e, o) {
                var u = t("./Constraint")
                  , d = t("../math/vec2")
                  , f = t("../equations/Equation");
                function i(t, e, o) {
                    o = o || {},
                    u.call(this, t, e, u.LOCK, o);
                    var i = void 0 === o.maxForce ? Number.MAX_VALUE : o.maxForce
                      , n = (o.localAngleB,
                    new f(t,e,-i,i))
                      , s = new f(t,e,-i,i)
                      , a = new f(t,e,-i,i)
                      , r = d.create()
                      , c = d.create()
                      , h = this;
                    n.computeGq = function() {
                        return d.rotate(r, h.localOffsetB, t.angle),
                        d.sub(c, e.position, t.position),
                        d.sub(c, c, r),
                        c[0]
                    }
                    ,
                    s.computeGq = function() {
                        return d.rotate(r, h.localOffsetB, t.angle),
                        d.sub(c, e.position, t.position),
                        d.sub(c, c, r),
                        c[1]
                    }
                    ;
                    var l = d.create()
                      , p = d.create();
                    a.computeGq = function() {
                        return d.rotate(l, h.localOffsetB, e.angle - h.localAngleB),
                        d.scale(l, l, -1),
                        d.sub(c, t.position, e.position),
                        d.add(c, c, l),
                        d.rotate(p, l, -Math.PI / 2),
                        d.normalize(p, p),
                        d.dot(c, p)
                    }
                    ,
                    this.localOffsetB = d.create(),
                    o.localOffsetB ? d.copy(this.localOffsetB, o.localOffsetB) : (d.sub(this.localOffsetB, e.position, t.position),
                    d.rotate(this.localOffsetB, this.localOffsetB, -t.angle)),
                    this.localAngleB = 0,
                    "number" == typeof o.localAngleB ? this.localAngleB = o.localAngleB : this.localAngleB = e.angle - t.angle,
                    this.equations.push(n, s, a),
                    this.setMaxForce(i)
                }
                (((e.exports = i).prototype = new u).constructor = i).prototype.setMaxForce = function(t) {
                    for (var e = this.equations, o = 0; o < this.equations.length; o++)
                        e[o].maxForce = t,
                        e[o].minForce = -t
                }
                ,
                i.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                }
                ;
                var s = d.create()
                  , a = d.create()
                  , r = d.create()
                  , c = d.fromValues(1, 0)
                  , h = d.fromValues(0, 1);
                i.prototype.update = function() {
                    var t = this.equations[0]
                      , e = this.equations[1]
                      , o = this.equations[2]
                      , i = this.bodyA
                      , n = this.bodyB;
                    d.rotate(s, this.localOffsetB, i.angle),
                    d.rotate(a, this.localOffsetB, n.angle - this.localAngleB),
                    d.scale(a, a, -1),
                    d.rotate(r, a, Math.PI / 2),
                    d.normalize(r, r),
                    t.G[0] = -1,
                    t.G[1] = 0,
                    t.G[2] = -d.crossLength(s, c),
                    t.G[3] = 1,
                    e.G[0] = 0,
                    e.G[1] = -1,
                    e.G[2] = -d.crossLength(s, h),
                    e.G[4] = 1,
                    o.G[0] = -r[0],
                    o.G[1] = -r[1],
                    o.G[3] = r[0],
                    o.G[4] = r[1],
                    o.G[5] = d.crossLength(a, r)
                }
            }
            , {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            18: [function(t, e, o) {
                var v = t("./Constraint")
                  , y = t("../equations/ContactEquation")
                  , m = t("../equations/Equation")
                  , g = t("../math/vec2")
                  , A = t("../equations/RotationalLockEquation");
                function i(i, n, t) {
                    t = t || {},
                    v.call(this, i, n, v.PRISMATIC, t);
                    var s = g.fromValues(0, 0)
                      , a = g.fromValues(1, 0)
                      , r = g.fromValues(0, 0);
                    t.localAnchorA && g.copy(s, t.localAnchorA),
                    t.localAxisA && g.copy(a, t.localAxisA),
                    t.localAnchorB && g.copy(r, t.localAnchorB),
                    this.localAnchorA = s,
                    this.localAnchorB = r,
                    this.localAxisA = a;
                    var e = this.maxForce = void 0 !== t.maxForce ? t.maxForce : Number.MAX_VALUE
                      , o = new m(i,n,-e,e)
                      , c = new g.create
                      , h = new g.create
                      , l = new g.create
                      , p = new g.create;
                    if (o.computeGq = function() {
                        return g.dot(l, p)
                    }
                    ,
                    o.updateJacobian = function() {
                        var t = this.G
                          , e = i.position
                          , o = n.position;
                        g.rotate(c, s, i.angle),
                        g.rotate(h, r, n.angle),
                        g.add(l, o, h),
                        g.sub(l, l, e),
                        g.sub(l, l, c),
                        g.rotate(p, a, i.angle + Math.PI / 2),
                        t[0] = -p[0],
                        t[1] = -p[1],
                        t[2] = -g.crossLength(c, p) + g.crossLength(p, l),
                        t[3] = p[0],
                        t[4] = p[1],
                        t[5] = g.crossLength(h, p)
                    }
                    ,
                    this.equations.push(o),
                    !t.disableRotationalLock) {
                        var u = new A(i,n,-e,e);
                        this.equations.push(u)
                    }
                    this.position = 0,
                    this.velocity = 0,
                    this.lowerLimitEnabled = void 0 !== t.lowerLimit,
                    this.upperLimitEnabled = void 0 !== t.upperLimit,
                    this.lowerLimit = void 0 !== t.lowerLimit ? t.lowerLimit : 0,
                    this.upperLimit = void 0 !== t.upperLimit ? t.upperLimit : 1,
                    this.upperLimitEquation = new y(i,n),
                    this.lowerLimitEquation = new y(i,n),
                    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0,
                    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = e,
                    this.motorEquation = new m(i,n),
                    this.motorEnabled = !1,
                    this.motorSpeed = 0;
                    var d = this
                      , f = this.motorEquation;
                    f.computeGW;
                    f.computeGq = function() {
                        return 0
                    }
                    ,
                    f.computeGW = function() {
                        var t = this.G
                          , e = this.bodyA
                          , o = this.bodyB
                          , i = e.velocity
                          , n = o.velocity
                          , s = e.angularVelocity
                          , a = o.angularVelocity;
                        return this.gmult(t, i, s, n, a) + d.motorSpeed
                    }
                }
                ((e.exports = i).prototype = new v).constructor = i;
                var f = g.create()
                  , b = g.create()
                  , E = g.create()
                  , B = g.create()
                  , q = g.create()
                  , P = g.create();
                i.prototype.update = function() {
                    var t = this.equations
                      , e = t[0]
                      , o = this.upperLimit
                      , i = this.lowerLimit
                      , n = this.upperLimitEquation
                      , s = this.lowerLimitEquation
                      , a = this.bodyA
                      , r = this.bodyB
                      , c = this.localAxisA
                      , h = this.localAnchorA
                      , l = this.localAnchorB;
                    e.updateJacobian(),
                    g.rotate(f, c, a.angle),
                    g.rotate(B, h, a.angle),
                    g.add(b, B, a.position),
                    g.rotate(q, l, r.angle),
                    g.add(E, q, r.position);
                    var p, u = this.position = g.dot(E, f) - g.dot(b, f);
                    if (this.motorEnabled) {
                        var d = this.motorEquation.G;
                        d[0] = f[0],
                        d[1] = f[1],
                        d[2] = g.crossLength(f, q),
                        d[3] = -f[0],
                        d[4] = -f[1],
                        d[5] = -g.crossLength(f, B)
                    }
                    this.upperLimitEnabled && o < u ? (g.scale(n.normalA, f, -1),
                    g.sub(n.contactPointA, b, a.position),
                    g.sub(n.contactPointB, E, r.position),
                    g.scale(P, f, o),
                    g.add(n.contactPointA, n.contactPointA, P),
                    -1 === t.indexOf(n) && t.push(n)) : -1 !== (p = t.indexOf(n)) && t.splice(p, 1);
                    this.lowerLimitEnabled && u < i ? (g.scale(s.normalA, f, 1),
                    g.sub(s.contactPointA, b, a.position),
                    g.sub(s.contactPointB, E, r.position),
                    g.scale(P, f, i),
                    g.sub(s.contactPointB, s.contactPointB, P),
                    -1 === t.indexOf(s) && t.push(s)) : -1 !== (p = t.indexOf(s)) && t.splice(p, 1)
                }
                ,
                i.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation),
                    this.motorEnabled = !0)
                }
                ,
                i.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1),
                        this.motorEnabled = !1
                    }
                }
                ,
                i.prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t,
                    this.lowerLimitEnabled = !0) : (this.lowerLimit = t,
                    this.lowerLimitEnabled = !1),
                    "number" == typeof e ? (this.upperLimit = e,
                    this.upperLimitEnabled = !0) : (this.upperLimit = e,
                    this.upperLimitEnabled = !1)
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            19: [function(t, e, o) {
                var c = t("./Constraint")
                  , h = t("../equations/Equation")
                  , l = t("../equations/RotationalVelocityEquation")
                  , p = t("../equations/RotationalLockEquation")
                  , d = t("../math/vec2");
                e.exports = i;
                var f = d.create()
                  , v = d.create()
                  , y = d.fromValues(1, 0)
                  , m = d.fromValues(0, 1)
                  , u = d.create();
                function i(t, e, o) {
                    o = o || {},
                    c.call(this, t, e, c.REVOLUTE, o);
                    var i = this.maxForce = void 0 !== o.maxForce ? o.maxForce : Number.MAX_VALUE;
                    this.pivotA = d.create(),
                    this.pivotB = d.create(),
                    o.worldPivot ? (d.sub(this.pivotA, o.worldPivot, t.position),
                    d.sub(this.pivotB, o.worldPivot, e.position),
                    d.rotate(this.pivotA, this.pivotA, -t.angle),
                    d.rotate(this.pivotB, this.pivotB, -e.angle)) : (d.copy(this.pivotA, o.localPivotA),
                    d.copy(this.pivotB, o.localPivotB));
                    var n = this.equations = [new h(t,e,-i,i), new h(t,e,-i,i)]
                      , s = n[0]
                      , a = n[1]
                      , r = this;
                    s.computeGq = function() {
                        return d.rotate(f, r.pivotA, t.angle),
                        d.rotate(v, r.pivotB, e.angle),
                        d.add(u, e.position, v),
                        d.sub(u, u, t.position),
                        d.sub(u, u, f),
                        d.dot(u, y)
                    }
                    ,
                    a.computeGq = function() {
                        return d.rotate(f, r.pivotA, t.angle),
                        d.rotate(v, r.pivotB, e.angle),
                        d.add(u, e.position, v),
                        d.sub(u, u, t.position),
                        d.sub(u, u, f),
                        d.dot(u, m)
                    }
                    ,
                    a.minForce = s.minForce = -i,
                    a.maxForce = s.maxForce = i,
                    this.motorEquation = new l(t,e),
                    this.motorEnabled = !1,
                    this.angle = 0,
                    this.lowerLimitEnabled = !1,
                    this.upperLimitEnabled = !1,
                    this.lowerLimit = 0,
                    this.upperLimit = 0,
                    this.upperLimitEquation = new p(t,e),
                    this.lowerLimitEquation = new p(t,e),
                    this.upperLimitEquation.minForce = 0,
                    this.lowerLimitEquation.maxForce = 0
                }
                ((i.prototype = new c).constructor = i).prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t,
                    this.lowerLimitEnabled = !0) : (this.lowerLimit = t,
                    this.lowerLimitEnabled = !1),
                    "number" == typeof e ? (this.upperLimit = e,
                    this.upperLimitEnabled = !0) : (this.upperLimit = e,
                    this.upperLimitEnabled = !1)
                }
                ,
                i.prototype.update = function() {
                    var t, e = this.bodyA, o = this.bodyB, i = this.pivotA, n = this.pivotB, s = this.equations, a = (s[0],
                    s[1],
                    s[0]), r = s[1], c = this.upperLimit, h = this.lowerLimit, l = this.upperLimitEquation, p = this.lowerLimitEquation, u = this.angle = o.angle - e.angle;
                    this.upperLimitEnabled && c < u ? (l.angle = c,
                    -1 === s.indexOf(l) && s.push(l)) : -1 !== (t = s.indexOf(l)) && s.splice(t, 1);
                    this.lowerLimitEnabled && u < h ? (p.angle = h,
                    -1 === s.indexOf(p) && s.push(p)) : -1 !== (t = s.indexOf(p)) && s.splice(t, 1);
                    d.rotate(f, i, e.angle),
                    d.rotate(v, n, o.angle),
                    a.G[0] = -1,
                    a.G[1] = 0,
                    a.G[2] = -d.crossLength(f, y),
                    a.G[3] = 1,
                    a.G[4] = 0,
                    a.G[5] = d.crossLength(v, y),
                    r.G[0] = 0,
                    r.G[1] = -1,
                    r.G[2] = -d.crossLength(f, m),
                    r.G[3] = 0,
                    r.G[4] = 1,
                    r.G[5] = d.crossLength(v, m)
                }
                ,
                i.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation),
                    this.motorEnabled = !0)
                }
                ,
                i.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1),
                        this.motorEnabled = !1
                    }
                }
                ,
                i.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled
                }
                ,
                i.prototype.setMotorSpeed = function(t) {
                    if (this.motorEnabled) {
                        var e = this.equations.indexOf(this.motorEquation);
                        this.equations[e].relativeVelocity = t
                    }
                }
                ,
                i.prototype.getMotorSpeed = function() {
                    return !!this.motorEnabled && this.motorEquation.relativeVelocity
                }
            }
            , {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            20: [function(t, e, o) {
                var i = t("./Equation");
                t("../math/vec2");
                function n(t, e, o) {
                    o = o || {},
                    i.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.angle = o.angle || 0,
                    this.ratio = "number" == typeof o.ratio ? o.ratio : 1,
                    this.setRatio(this.ratio)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                }
                ,
                n.prototype.setRatio = function(t) {
                    var e = this.G;
                    e[2] = t,
                    e[5] = -1,
                    this.ratio = t
                }
                ,
                n.prototype.setMaxTorque = function(t) {
                    this.maxForce = t,
                    this.minForce = -t
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            21: [function(t, e, o) {
                var i = t("./Equation")
                  , y = t("../math/vec2");
                function n(t, e) {
                    i.call(this, t, e, 0, Number.MAX_VALUE),
                    this.contactPointA = y.create(),
                    this.penetrationVec = y.create(),
                    this.contactPointB = y.create(),
                    this.normalA = y.create(),
                    this.restitution = 0,
                    this.firstImpact = !1,
                    this.shapeA = null,
                    this.shapeB = null
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeB = function(t, e, o) {
                    var i, n, s = this.bodyA, a = this.bodyB, r = this.contactPointA, c = this.contactPointB, h = s.position, l = a.position, p = this.penetrationVec, u = this.normalA, d = this.G, f = y.crossLength(r, u), v = y.crossLength(c, u);
                    return d[0] = -u[0],
                    d[1] = -u[1],
                    d[2] = -f,
                    d[3] = u[0],
                    d[4] = u[1],
                    d[5] = v,
                    y.add(p, l, c),
                    y.sub(p, p, h),
                    y.sub(p, p, r),
                    i = this.firstImpact && 0 !== this.restitution ? (n = 0,
                    1 / e * (1 + this.restitution) * this.computeGW()) : (n = y.dot(u, p) + this.offset,
                    this.computeGW()),
                    -n * t - i * e - o * this.computeGiMf()
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            22: [function(t, e, o) {
                e.exports = a;
                var p = t("../math/vec2")
                  , s = t("../utils/Utils");
                t("../objects/Body");
                function a(t, e, o, i) {
                    this.minForce = void 0 === o ? -Number.MAX_VALUE : o,
                    this.maxForce = void 0 === i ? Number.MAX_VALUE : i,
                    this.bodyA = t,
                    this.bodyB = e,
                    this.stiffness = a.DEFAULT_STIFFNESS,
                    this.relaxation = a.DEFAULT_RELAXATION,
                    this.G = new s.ARRAY_TYPE(6);
                    for (var n = 0; n < 6; n++)
                        this.G[n] = 0;
                    this.offset = 0,
                    this.a = 0,
                    this.b = 0,
                    this.epsilon = 0,
                    this.timeStep = 1 / 60,
                    this.needsUpdate = !0,
                    this.multiplier = 0,
                    this.relativeVelocity = 0,
                    this.enabled = !0
                }
                (a.prototype.constructor = a).DEFAULT_STIFFNESS = 1e6,
                a.DEFAULT_RELAXATION = 4,
                a.prototype.update = function() {
                    var t = this.stiffness
                      , e = this.relaxation
                      , o = this.timeStep;
                    this.a = 4 / (o * (1 + 4 * e)),
                    this.b = 4 * e / (1 + 4 * e),
                    this.epsilon = 4 / (o * o * t * (1 + 4 * e)),
                    this.needsUpdate = !1
                }
                ,
                a.prototype.gmult = function(t, e, o, i, n) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * o + t[3] * i[0] + t[4] * i[1] + t[5] * n
                }
                ,
                a.prototype.computeB = function(t, e, o) {
                    var i = this.computeGW();
                    return -this.computeGq() * t - i * e - this.computeGiMf() * o
                }
                ;
                var r = p.create()
                  , c = p.create();
                a.prototype.computeGq = function() {
                    var t = this.G
                      , e = this.bodyA
                      , o = this.bodyB
                      , i = (e.position,
                    o.position,
                    e.angle)
                      , n = o.angle;
                    return this.gmult(t, r, i, c, n) + this.offset
                }
                ,
                a.prototype.computeGW = function() {
                    var t = this.G
                      , e = this.bodyA
                      , o = this.bodyB
                      , i = e.velocity
                      , n = o.velocity
                      , s = e.angularVelocity
                      , a = o.angularVelocity;
                    return this.gmult(t, i, s, n, a) + this.relativeVelocity
                }
                ,
                a.prototype.computeGWlambda = function() {
                    var t = this.G
                      , e = this.bodyA
                      , o = this.bodyB
                      , i = e.vlambda
                      , n = o.vlambda
                      , s = e.wlambda
                      , a = o.wlambda;
                    return this.gmult(t, i, s, n, a)
                }
                ;
                var u = p.create()
                  , d = p.create();
                a.prototype.computeGiMf = function() {
                    var t = this.bodyA
                      , e = this.bodyB
                      , o = t.force
                      , i = t.angularForce
                      , n = e.force
                      , s = e.angularForce
                      , a = t.invMassSolve
                      , r = e.invMassSolve
                      , c = t.invInertiaSolve
                      , h = e.invInertiaSolve
                      , l = this.G;
                    return p.scale(u, o, a),
                    p.multiply(u, t.massMultiplier, u),
                    p.scale(d, n, r),
                    p.multiply(d, e.massMultiplier, d),
                    this.gmult(l, u, i * c, d, s * h)
                }
                ,
                a.prototype.computeGiMGt = function() {
                    var t = this.bodyA
                      , e = this.bodyB
                      , o = t.invMassSolve
                      , i = e.invMassSolve
                      , n = t.invInertiaSolve
                      , s = e.invInertiaSolve
                      , a = this.G;
                    return a[0] * a[0] * o * t.massMultiplier[0] + a[1] * a[1] * o * t.massMultiplier[1] + a[2] * a[2] * n + a[3] * a[3] * i * e.massMultiplier[0] + a[4] * a[4] * i * e.massMultiplier[1] + a[5] * a[5] * s
                }
                ;
                var f = p.create()
                  , v = p.create()
                  , y = p.create();
                p.create(),
                p.create(),
                p.create();
                a.prototype.addToWlambda = function(t) {
                    var e = this.bodyA
                      , o = this.bodyB
                      , i = f
                      , n = v
                      , s = y
                      , a = e.invMassSolve
                      , r = o.invMassSolve
                      , c = e.invInertiaSolve
                      , h = o.invInertiaSolve
                      , l = this.G;
                    n[0] = l[0],
                    n[1] = l[1],
                    s[0] = l[3],
                    s[1] = l[4],
                    p.scale(i, n, a * t),
                    p.multiply(i, i, e.massMultiplier),
                    p.add(e.vlambda, e.vlambda, i),
                    e.wlambda += c * l[2] * t,
                    p.scale(i, s, r * t),
                    p.multiply(i, i, o.massMultiplier),
                    p.add(o.vlambda, o.vlambda, i),
                    o.wlambda += h * l[5] * t
                }
                ,
                a.prototype.computeInvC = function(t) {
                    return 1 / (this.computeGiMGt() + t)
                }
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            23: [function(t, e, o) {
                var r = t("../math/vec2")
                  , i = t("./Equation");
                t("../utils/Utils");
                function n(t, e, o) {
                    i.call(this, t, e, -o, o),
                    this.contactPointA = r.create(),
                    this.contactPointB = r.create(),
                    this.t = r.create(),
                    this.contactEquations = [],
                    this.shapeA = null,
                    this.shapeB = null,
                    this.frictionCoefficient = .3
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.setSlipForce = function(t) {
                    this.maxForce = t,
                    this.minForce = -t
                }
                ,
                n.prototype.getSlipForce = function() {
                    return this.maxForce
                }
                ,
                n.prototype.computeB = function(t, e, o) {
                    this.bodyA,
                    this.bodyB;
                    var i = this.contactPointA
                      , n = this.contactPointB
                      , s = this.t
                      , a = this.G;
                    return a[0] = -s[0],
                    a[1] = -s[1],
                    a[2] = -r.crossLength(i, s),
                    a[3] = s[0],
                    a[4] = s[1],
                    a[5] = r.crossLength(n, s),
                    -this.computeGW() * e - o * this.computeGiMf()
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Equation": 22
            }],
            24: [function(t, e, o) {
                var n = t("./Equation")
                  , i = t("../math/vec2");
                function s(t, e, o) {
                    o = o || {},
                    n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.angle = o.angle || 0;
                    var i = this.G;
                    i[2] = 1,
                    i[5] = -1
                }
                ((e.exports = s).prototype = new n).constructor = s;
                var a = i.create()
                  , r = i.create()
                  , c = i.fromValues(1, 0)
                  , h = i.fromValues(0, 1);
                s.prototype.computeGq = function() {
                    return i.rotate(a, c, this.bodyA.angle + this.angle),
                    i.rotate(r, h, this.bodyB.angle),
                    i.dot(a, r)
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            25: [function(t, e, o) {
                var i = t("./Equation");
                t("../math/vec2");
                function n(t, e) {
                    i.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                    this.relativeVelocity = 1,
                    this.ratio = 1
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeB = function(t, e, o) {
                    var i = this.G;
                    i[2] = -1,
                    i[5] = this.ratio;
                    var n = this.computeGiMf();
                    return -this.computeGW() * e - o * n
                }
            }
            , {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            26: [function(t, e, o) {
                function i() {}
                (e.exports = i).prototype = {
                    constructor: i,
                    on: function(t, e, o) {
                        e.context = o || this,
                        void 0 === this._listeners && (this._listeners = {});
                        var i = this._listeners;
                        return void 0 === i[t] && (i[t] = []),
                        -1 === i[t].indexOf(e) && i[t].push(e),
                        this
                    },
                    has: function(t, e) {
                        if (void 0 === this._listeners)
                            return !1;
                        var o = this._listeners;
                        if (e) {
                            if (void 0 !== o[t] && -1 !== o[t].indexOf(e))
                                return !0
                        } else if (void 0 !== o[t])
                            return !0;
                        return !1
                    },
                    off: function(t, e) {
                        if (void 0 === this._listeners)
                            return this;
                        var o = this._listeners
                          , i = o[t].indexOf(e);
                        return -1 !== i && o[t].splice(i, 1),
                        this
                    },
                    emit: function(t) {
                        if (void 0 === this._listeners)
                            return this;
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var o = 0, i = e.length; o < i; o++) {
                                var n = e[o];
                                n.call(n.context, t)
                            }
                        }
                        return this
                    }
                }
            }
            , {}],
            27: [function(t, e, o) {
                var i = t("./Material")
                  , n = t("../equations/Equation");
                function s(t, e, o) {
                    if (o = o || {},
                    !(t instanceof i && e instanceof i))
                        throw new Error("First two arguments must be Material instances.");
                    this.id = s.idCounter++,
                    this.materialA = t,
                    this.materialB = e,
                    this.friction = void 0 !== o.friction ? Number(o.friction) : .3,
                    this.restitution = void 0 !== o.restitution ? Number(o.restitution) : 0,
                    this.stiffness = void 0 !== o.stiffness ? Number(o.stiffness) : n.DEFAULT_STIFFNESS,
                    this.relaxation = void 0 !== o.relaxation ? Number(o.relaxation) : n.DEFAULT_RELAXATION,
                    this.frictionStiffness = void 0 !== o.frictionStiffness ? Number(o.frictionStiffness) : n.DEFAULT_STIFFNESS,
                    this.frictionRelaxation = void 0 !== o.frictionRelaxation ? Number(o.frictionRelaxation) : n.DEFAULT_RELAXATION,
                    this.surfaceVelocity = void 0 !== o.surfaceVelocity ? Number(o.surfaceVelocity) : 0,
                    this.contactSkinSize = .005
                }
                (e.exports = s).idCounter = 0
            }
            , {
                "../equations/Equation": 22,
                "./Material": 28
            }],
            28: [function(t, e, o) {
                function i(t) {
                    this.id = t || i.idCounter++
                }
                (e.exports = i).idCounter = 0
            }
            , {}],
            29: [function(t, e, o) {
                var g = {
                    GetArea: function(t) {
                        if (t.length < 6)
                            return 0;
                        for (var e = t.length - 2, o = 0, i = 0; i < e; i += 2)
                            o += (t[i + 2] - t[i]) * (t[i + 1] + t[i + 3]);
                        return .5 * -(o += (t[0] - t[e]) * (t[1 + e] + t[1]))
                    },
                    Triangulate: function(t) {
                        var e = t.length >> 1;
                        if (e < 3)
                            return [];
                        for (var o = [], i = [], n = 0; n < e; n++)
                            i.push(n);
                        n = 0;
                        for (var s = e; 3 < s; ) {
                            var a = i[(n + 0) % s]
                              , r = i[(n + 1) % s]
                              , c = i[(n + 2) % s]
                              , h = t[2 * a]
                              , l = t[2 * a + 1]
                              , p = t[2 * r]
                              , u = t[2 * r + 1]
                              , d = t[2 * c]
                              , f = t[2 * c + 1]
                              , v = !1;
                            if (g._convex(h, l, p, u, d, f)) {
                                v = !0;
                                for (var y = 0; y < s; y++) {
                                    var m = i[y];
                                    if (m != a && m != r && m != c && g._PointInTriangle(t[2 * m], t[2 * m + 1], h, l, p, u, d, f)) {
                                        v = !1;
                                        break
                                    }
                                }
                            }
                            if (v)
                                o.push(a, r, c),
                                i.splice((n + 1) % s, 1),
                                s--,
                                n = 0;
                            else if (n++ > 3 * s)
                                break
                        }
                        return o.push(i[0], i[1], i[2]),
                        o
                    },
                    _PointInTriangle: function(t, e, o, i, n, s, a, r) {
                        var c = a - o
                          , h = r - i
                          , l = n - o
                          , p = s - i
                          , u = t - o
                          , d = e - i
                          , f = c * c + h * h
                          , v = c * l + h * p
                          , y = c * u + h * d
                          , m = l * l + p * p
                          , g = l * u + p * d
                          , A = 1 / (f * m - v * v)
                          , b = (m * y - v * g) * A
                          , E = (f * g - v * y) * A;
                        return 0 <= b && 0 <= E && b + E < 1
                    },
                    _convex: function(t, e, o, i, n, s) {
                        return 0 <= (e - i) * (n - o) + (o - t) * (s - i)
                    }
                };
                e.exports = g
            }
            , {}],
            30: [function(t, e, o) {
                var a = e.exports = {}
                  , i = t("../utils/Utils");
                a.crossLength = function(t, e) {
                    return t[0] * e[1] - t[1] * e[0]
                }
                ,
                a.crossVZ = function(t, e, o) {
                    return a.rotate(t, e, -Math.PI / 2),
                    a.scale(t, t, o),
                    t
                }
                ,
                a.crossZV = function(t, e, o) {
                    return a.rotate(t, o, Math.PI / 2),
                    a.scale(t, t, e),
                    t
                }
                ,
                a.rotate = function(t, e, o) {
                    if (0 !== o) {
                        var i = Math.cos(o)
                          , n = Math.sin(o)
                          , s = e[0]
                          , a = e[1];
                        t[0] = i * s - n * a,
                        t[1] = n * s + i * a
                    } else
                        t[0] = e[0],
                        t[1] = e[1]
                }
                ,
                a.rotate90cw = function(t, e) {
                    var o = e[0]
                      , i = e[1];
                    t[0] = i,
                    t[1] = -o
                }
                ,
                a.toLocalFrame = function(t, e, o, i) {
                    a.copy(t, e),
                    a.sub(t, t, o),
                    a.rotate(t, t, -i)
                }
                ,
                a.toGlobalFrame = function(t, e, o, i) {
                    a.copy(t, e),
                    a.rotate(t, t, i),
                    a.add(t, t, o)
                }
                ,
                a.vectorToLocalFrame = function(t, e, o) {
                    a.rotate(t, e, -o)
                }
                ,
                a.vectorToGlobalFrame = function(t, e, o) {
                    a.rotate(t, e, o)
                }
                ,
                a.centroid = function(t, e, o, i) {
                    return a.add(t, e, o),
                    a.add(t, t, i),
                    a.scale(t, t, 1 / 3),
                    t
                }
                ,
                a.create = function() {
                    var t = new i.ARRAY_TYPE(2);
                    return t[0] = 0,
                    t[1] = 0,
                    t
                }
                ,
                a.clone = function(t) {
                    var e = new i.ARRAY_TYPE(2);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e
                }
                ,
                a.fromValues = function(t, e) {
                    var o = new i.ARRAY_TYPE(2);
                    return o[0] = t,
                    o[1] = e,
                    o
                }
                ,
                a.copy = function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t
                }
                ,
                a.set = function(t, e, o) {
                    return t[0] = e,
                    t[1] = o,
                    t
                }
                ,
                a.add = function(t, e, o) {
                    return t[0] = e[0] + o[0],
                    t[1] = e[1] + o[1],
                    t
                }
                ,
                a.subtract = function(t, e, o) {
                    return t[0] = e[0] - o[0],
                    t[1] = e[1] - o[1],
                    t
                }
                ,
                a.sub = a.subtract,
                a.multiply = function(t, e, o) {
                    return t[0] = e[0] * o[0],
                    t[1] = e[1] * o[1],
                    t
                }
                ,
                a.mul = a.multiply,
                a.divide = function(t, e, o) {
                    return t[0] = e[0] / o[0],
                    t[1] = e[1] / o[1],
                    t
                }
                ,
                a.div = a.divide,
                a.scale = function(t, e, o) {
                    return t[0] = e[0] * o,
                    t[1] = e[1] * o,
                    t
                }
                ,
                a.distance = function(t, e) {
                    var o = e[0] - t[0]
                      , i = e[1] - t[1];
                    return Math.sqrt(o * o + i * i)
                }
                ,
                a.dist = a.distance,
                a.squaredDistance = function(t, e) {
                    var o = e[0] - t[0]
                      , i = e[1] - t[1];
                    return o * o + i * i
                }
                ,
                a.sqrDist = a.squaredDistance,
                a.length = function(t) {
                    var e = t[0]
                      , o = t[1];
                    return Math.sqrt(e * e + o * o)
                }
                ,
                a.len = a.length,
                a.squaredLength = function(t) {
                    var e = t[0]
                      , o = t[1];
                    return e * e + o * o
                }
                ,
                a.sqrLen = a.squaredLength,
                a.negate = function(t, e) {
                    return t[0] = -e[0],
                    t[1] = -e[1],
                    t
                }
                ,
                a.normalize = function(t, e) {
                    var o = e[0]
                      , i = e[1]
                      , n = o * o + i * i;
                    return 0 < n && (n = 1 / Math.sqrt(n),
                    t[0] = e[0] * n,
                    t[1] = e[1] * n),
                    t
                }
                ,
                a.dot = function(t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                }
                ,
                a.str = function(t) {
                    return "vec2(" + t[0] + ", " + t[1] + ")"
                }
                ,
                a.lerp = function(t, e, o, i) {
                    var n = e[0]
                      , s = e[1];
                    return t[0] = n + i * (o[0] - n),
                    t[1] = s + i * (o[1] - s),
                    t
                }
                ,
                a.reflect = function(t, e, o) {
                    var i = e[0] * o[0] + e[1] * o[1];
                    t[0] = e[0] - 2 * o[0] * i,
                    t[1] = e[1] - 2 * o[1] * i
                }
                ,
                a.getLineSegmentsIntersection = function(t, e, o, i, n) {
                    var s = a.getLineSegmentsIntersectionFraction(e, o, i, n);
                    return !(s < 0) && (t[0] = e[0] + s * (o[0] - e[0]),
                    t[1] = e[1] + s * (o[1] - e[1]),
                    !0)
                }
                ,
                a.getLineSegmentsIntersectionFraction = function(t, e, o, i) {
                    var n, s, a = e[0] - t[0], r = e[1] - t[1], c = i[0] - o[0], h = i[1] - o[1];
                    return n = (-r * (t[0] - o[0]) + a * (t[1] - o[1])) / (-c * r + a * h),
                    s = (c * (t[1] - o[1]) - h * (t[0] - o[0])) / (-c * r + a * h),
                    0 <= n && n <= 1 && 0 <= s && s <= 1 ? s : -1
                }
            }
            , {
                "../utils/Utils": 57
            }],
            31: [function(t, e, o) {
                var p = t("../math/vec2")
                  , h = t("poly-decomp")
                  , l = t("../shapes/Convex")
                  , i = t("../collision/RaycastResult")
                  , n = t("../collision/Ray")
                  , s = t("../collision/AABB")
                  , a = t("../events/EventEmitter");
                function r(t) {
                    t = t || {},
                    a.call(this),
                    this.id = t.id || ++r._idCounter,
                    this.world = null,
                    this.shapes = [],
                    this.mass = t.mass || 0,
                    this.invMass = 0,
                    this.inertia = 0,
                    this.invInertia = 0,
                    this.invMassSolve = 0,
                    this.invInertiaSolve = 0,
                    this.fixedRotation = !!t.fixedRotation,
                    this.fixedX = !!t.fixedX,
                    this.fixedY = !!t.fixedY,
                    this.massMultiplier = p.create(),
                    this.position = p.fromValues(0, 0),
                    t.position && p.copy(this.position, t.position),
                    this.interpolatedPosition = p.fromValues(0, 0),
                    this.interpolatedAngle = 0,
                    this.previousPosition = p.fromValues(0, 0),
                    this.previousAngle = 0,
                    this.velocity = p.fromValues(0, 0),
                    t.velocity && p.copy(this.velocity, t.velocity),
                    this.vlambda = p.fromValues(0, 0),
                    this.wlambda = 0,
                    this.angle = t.angle || 0,
                    this.angularVelocity = t.angularVelocity || 0,
                    this.force = p.create(),
                    t.force && p.copy(this.force, t.force),
                    this.angularForce = t.angularForce || 0,
                    this.damping = "number" == typeof t.damping ? t.damping : .1,
                    this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1,
                    this.type = r.STATIC,
                    void 0 !== t.type ? this.type = t.type : t.mass ? this.type = r.DYNAMIC : this.type = r.STATIC,
                    this.boundingRadius = 0,
                    this.aabb = new s,
                    this.aabbNeedsUpdate = !0,
                    this.allowSleep = void 0 === t.allowSleep || t.allowSleep,
                    this.wantsToSleep = !1,
                    this.sleepState = r.AWAKE,
                    this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2,
                    this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1,
                    this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1,
                    this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                    this.idleTime = 0,
                    this.timeLastSleepy = 0,
                    this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1,
                    this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10,
                    this.concavePath = null,
                    this._wakeUpAfterNarrowphase = !1,
                    this.updateMassProperties()
                }
                (((e.exports = r).prototype = new a).constructor = r)._idCounter = 0,
                r.prototype.updateSolveMassProperties = function() {
                    this.sleepState === r.SLEEPING || this.type === r.KINEMATIC ? (this.invMassSolve = 0,
                    this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass,
                    this.invInertiaSolve = this.invInertia)
                }
                ,
                r.prototype.setDensity = function(t) {
                    var e = this.getArea();
                    this.mass = e * t,
                    this.updateMassProperties()
                }
                ,
                r.prototype.getArea = function() {
                    for (var t = 0, e = 0; e < this.shapes.length; e++)
                        t += this.shapes[e].area;
                    return t
                }
                ,
                r.prototype.getAABB = function() {
                    return this.aabbNeedsUpdate && this.updateAABB(),
                    this.aabb
                }
                ;
                var c = new s
                  , u = p.create();
                r.prototype.updateAABB = function() {
                    for (var t = this.shapes, e = t.length, o = u, i = this.angle, n = 0; n !== e; n++) {
                        var s = t[n]
                          , a = s.angle + i;
                        p.rotate(o, s.position, i),
                        p.add(o, o, this.position),
                        s.computeAABB(c, o, a),
                        0 === n ? this.aabb.copy(c) : this.aabb.extend(c)
                    }
                    this.aabbNeedsUpdate = !1
                }
                ,
                r.prototype.updateBoundingRadius = function() {
                    for (var t = this.shapes, e = t.length, o = 0, i = 0; i !== e; i++) {
                        var n = t[i]
                          , s = p.length(n.position)
                          , a = n.boundingRadius;
                        o < s + a && (o = s + a)
                    }
                    this.boundingRadius = o
                }
                ,
                r.prototype.addShape = function(t, e, o) {
                    if (t.body)
                        throw new Error("A shape can only be added to one body.");
                    t.body = this,
                    e ? p.copy(t.position, e) : p.set(t.position, 0, 0),
                    t.angle = o || 0,
                    this.shapes.push(t),
                    this.updateMassProperties(),
                    this.updateBoundingRadius(),
                    this.aabbNeedsUpdate = !0
                }
                ,
                r.prototype.removeShape = function(t) {
                    var e = this.shapes.indexOf(t);
                    return -1 !== e && (this.shapes.splice(e, 1),
                    this.aabbNeedsUpdate = !0,
                    !(t.body = null))
                }
                ,
                r.prototype.updateMassProperties = function() {
                    if (this.type === r.STATIC || this.type === r.KINEMATIC)
                        this.mass = Number.MAX_VALUE,
                        this.invMass = 0,
                        this.inertia = Number.MAX_VALUE,
                        this.invInertia = 0;
                    else {
                        var t = this.shapes
                          , e = t.length
                          , o = this.mass / e
                          , i = 0;
                        if (this.fixedRotation)
                            this.inertia = Number.MAX_VALUE,
                            this.invInertia = 0;
                        else {
                            for (var n = 0; n < e; n++) {
                                var s = t[n]
                                  , a = p.squaredLength(s.position);
                                i += s.computeMomentOfInertia(o) + o * a
                            }
                            this.inertia = i,
                            this.invInertia = 0 < i ? 1 / i : 0
                        }
                        this.invMass = 1 / this.mass,
                        p.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                    }
                }
                ;
                p.create();
                r.prototype.applyForce = function(t, e) {
                    if (p.add(this.force, this.force, t),
                    e) {
                        var o = p.crossLength(e, t);
                        this.angularForce += o
                    }
                }
                ;
                var d = p.create()
                  , f = p.create()
                  , v = p.create();
                r.prototype.applyForceLocal = function(t, e) {
                    e = e || v;
                    var o = d
                      , i = f;
                    this.vectorToWorldFrame(o, t),
                    this.vectorToWorldFrame(i, e),
                    this.applyForce(o, i)
                }
                ;
                var y = p.create();
                r.prototype.applyImpulse = function(t, e) {
                    if (this.type === r.DYNAMIC) {
                        var o = y;
                        if (p.scale(o, t, this.invMass),
                        p.multiply(o, this.massMultiplier, o),
                        p.add(this.velocity, o, this.velocity),
                        e) {
                            var i = p.crossLength(e, t);
                            i *= this.invInertia,
                            this.angularVelocity += i
                        }
                    }
                }
                ;
                var m = p.create()
                  , g = p.create()
                  , A = p.create();
                r.prototype.applyImpulseLocal = function(t, e) {
                    e = e || A;
                    var o = m
                      , i = g;
                    this.vectorToWorldFrame(o, t),
                    this.vectorToWorldFrame(i, e),
                    this.applyImpulse(o, i)
                }
                ,
                r.prototype.toLocalFrame = function(t, e) {
                    p.toLocalFrame(t, e, this.position, this.angle)
                }
                ,
                r.prototype.toWorldFrame = function(t, e) {
                    p.toGlobalFrame(t, e, this.position, this.angle)
                }
                ,
                r.prototype.vectorToLocalFrame = function(t, e) {
                    p.vectorToLocalFrame(t, e, this.angle)
                }
                ,
                r.prototype.vectorToWorldFrame = function(t, e) {
                    p.vectorToGlobalFrame(t, e, this.angle)
                }
                ,
                r.prototype.fromPolygon = function(t, e) {
                    e = e || {};
                    for (var o = this.shapes.length; 0 <= o; --o)
                        this.removeShape(this.shapes[o]);
                    var i, n = new h.Polygon;
                    if (n.vertices = t,
                    n.makeCCW(),
                    "number" == typeof e.removeCollinearPoints && n.removeCollinearPoints(e.removeCollinearPoints),
                    void 0 === e.skipSimpleCheck && !n.isSimple())
                        return !1;
                    this.concavePath = n.vertices.slice(0);
                    for (o = 0; o < this.concavePath.length; o++) {
                        var s = [0, 0];
                        p.copy(s, this.concavePath[o]),
                        this.concavePath[o] = s
                    }
                    i = e.optimalDecomp ? n.decomp() : n.quickDecomp();
                    var a = p.create();
                    for (o = 0; o !== i.length; o++) {
                        for (var r = new l({
                            vertices: i[o].vertices
                        }), c = 0; c !== r.vertices.length; c++) {
                            s = r.vertices[c];
                            p.sub(s, s, r.centerOfMass)
                        }
                        p.scale(a, r.centerOfMass, 1),
                        r.updateTriangles(),
                        r.updateCenterOfMass(),
                        r.updateBoundingRadius(),
                        this.addShape(r, a)
                    }
                    return this.adjustCenterOfMass(),
                    this.aabbNeedsUpdate = !0
                }
                ;
                p.fromValues(0, 0);
                var b = p.fromValues(0, 0)
                  , E = p.fromValues(0, 0)
                  , B = p.fromValues(0, 0);
                r.prototype.adjustCenterOfMass = function() {
                    var t = b
                      , e = E
                      , o = B
                      , i = 0;
                    p.set(e, 0, 0);
                    for (var n = 0; n !== this.shapes.length; n++) {
                        var s = this.shapes[n];
                        p.scale(t, s.position, s.area),
                        p.add(e, e, t),
                        i += s.area
                    }
                    p.scale(o, e, 1 / i);
                    for (n = 0; n !== this.shapes.length; n++) {
                        s = this.shapes[n];
                        p.sub(s.position, s.position, o)
                    }
                    p.add(this.position, this.position, o);
                    for (n = 0; this.concavePath && n < this.concavePath.length; n++)
                        p.sub(this.concavePath[n], this.concavePath[n], o);
                    this.updateMassProperties(),
                    this.updateBoundingRadius()
                }
                ,
                r.prototype.setZeroForce = function() {
                    p.set(this.force, 0, 0),
                    this.angularForce = 0
                }
                ,
                r.prototype.resetConstraintVelocity = function() {
                    var t = this.vlambda;
                    p.set(t, 0, 0),
                    this.wlambda = 0
                }
                ,
                r.prototype.addConstraintVelocity = function() {
                    var t = this.velocity;
                    p.add(t, t, this.vlambda),
                    this.angularVelocity += this.wlambda
                }
                ,
                r.prototype.applyDamping = function(t) {
                    if (this.type === r.DYNAMIC) {
                        var e = this.velocity;
                        p.scale(e, e, Math.pow(1 - this.damping, t)),
                        this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                    }
                }
                ,
                r.prototype.wakeUp = function() {
                    var t = this.sleepState;
                    this.sleepState = r.AWAKE,
                    this.idleTime = 0,
                    t !== r.AWAKE && this.emit(r.wakeUpEvent)
                }
                ,
                r.prototype.sleep = function() {
                    this.sleepState = r.SLEEPING,
                    this.angularVelocity = 0,
                    this.angularForce = 0,
                    p.set(this.velocity, 0, 0),
                    p.set(this.force, 0, 0),
                    this.emit(r.sleepEvent)
                }
                ,
                r.prototype.sleepTick = function(t, e, o) {
                    if (this.allowSleep && this.type !== r.SLEEPING) {
                        this.wantsToSleep = !1;
                        this.sleepState;
                        var i = p.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2);
                        Math.pow(this.sleepSpeedLimit, 2) <= i ? (this.idleTime = 0,
                        this.sleepState = r.AWAKE) : (this.idleTime += o,
                        this.sleepState = r.SLEEPY),
                        this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                    }
                }
                ,
                r.prototype.overlaps = function(t) {
                    return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
                }
                ;
                var q = p.create()
                  , P = p.create();
                r.prototype.integrate = function(t) {
                    var e = this.invMass
                      , o = this.force
                      , i = this.position
                      , n = this.velocity;
                    p.copy(this.previousPosition, this.position),
                    this.previousAngle = this.angle,
                    this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t),
                    p.scale(q, o, t * e),
                    p.multiply(q, this.massMultiplier, q),
                    p.add(n, q, n),
                    this.integrateToTimeOfImpact(t) || (p.scale(P, n, t),
                    p.add(i, i, P),
                    this.fixedRotation || (this.angle += this.angularVelocity * t)),
                    this.aabbNeedsUpdate = !0
                }
                ;
                var w = new i
                  , S = new n({
                    mode: n.ALL
                })
                  , C = p.create()
                  , L = p.create()
                  , x = p.create()
                  , F = p.create();
                r.prototype.integrateToTimeOfImpact = function(t) {
                    if (this.ccdSpeedThreshold < 0 || p.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2))
                        return !1;
                    p.normalize(C, this.velocity),
                    p.scale(L, this.velocity, t),
                    p.add(L, L, this.position),
                    p.sub(x, L, this.position);
                    var e, o = this.angularVelocity * t, i = p.length(x), n = 1, s = this;
                    if (w.reset(),
                    S.callback = function(t) {
                        t.body !== s && (e = t.body,
                        t.getHitPoint(L, S),
                        p.sub(x, L, s.position),
                        n = p.length(x) / i,
                        t.stop())
                    }
                    ,
                    p.copy(S.from, this.position),
                    p.copy(S.to, L),
                    S.update(),
                    this.world.raycast(w, S),
                    !e)
                        return !1;
                    var a = this.angle;
                    p.copy(F, this.position);
                    for (var r = 0, c = 0, h = 0, l = n; c <= l && r < this.ccdIterations; ) {
                        r++,
                        h = (l - c) / 2,
                        p.scale(P, x, n),
                        p.add(this.position, F, P),
                        this.angle = a + o * n,
                        this.updateAABB(),
                        this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? c = h : l = h
                    }
                    return n = h,
                    p.copy(this.position, F),
                    this.angle = a,
                    p.scale(P, x, n),
                    p.add(this.position, this.position, P),
                    this.fixedRotation || (this.angle += o * n),
                    !0
                }
                ,
                r.prototype.getVelocityAtPoint = function(t, e) {
                    return p.crossVZ(t, e, this.angularVelocity),
                    p.subtract(t, this.velocity, t),
                    t
                }
                ,
                r.sleepyEvent = {
                    type: "sleepy"
                },
                r.sleepEvent = {
                    type: "sleep"
                },
                r.wakeUpEvent = {
                    type: "wakeup"
                },
                r.DYNAMIC = 1,
                r.STATIC = 2,
                r.KINEMATIC = 4,
                r.AWAKE = 0,
                r.SLEEPY = 1,
                r.SLEEPING = 2
            }
            , {
                "../collision/AABB": 7,
                "../collision/Ray": 11,
                "../collision/RaycastResult": 12,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 40,
                "poly-decomp": 5
            }],
            32: [function(t, e, o) {
                var m = t("../math/vec2")
                  , a = t("./Spring");
                t("../utils/Utils");
                function i(t, e, o) {
                    o = o || {},
                    a.call(this, t, e, o),
                    this.localAnchorA = m.fromValues(0, 0),
                    this.localAnchorB = m.fromValues(0, 0),
                    o.localAnchorA && m.copy(this.localAnchorA, o.localAnchorA),
                    o.localAnchorB && m.copy(this.localAnchorB, o.localAnchorB),
                    o.worldAnchorA && this.setWorldAnchorA(o.worldAnchorA),
                    o.worldAnchorB && this.setWorldAnchorB(o.worldAnchorB);
                    var i = m.create()
                      , n = m.create();
                    this.getWorldAnchorA(i),
                    this.getWorldAnchorB(n);
                    var s = m.distance(i, n);
                    this.restLength = "number" == typeof o.restLength ? o.restLength : s
                }
                (((e.exports = i).prototype = new a).constructor = i).prototype.setWorldAnchorA = function(t) {
                    this.bodyA.toLocalFrame(this.localAnchorA, t)
                }
                ,
                i.prototype.setWorldAnchorB = function(t) {
                    this.bodyB.toLocalFrame(this.localAnchorB, t)
                }
                ,
                i.prototype.getWorldAnchorA = function(t) {
                    this.bodyA.toWorldFrame(t, this.localAnchorA)
                }
                ,
                i.prototype.getWorldAnchorB = function(t) {
                    this.bodyB.toWorldFrame(t, this.localAnchorB)
                }
                ;
                var g = m.create()
                  , A = m.create()
                  , b = m.create()
                  , E = m.create()
                  , B = m.create()
                  , q = m.create()
                  , P = m.create()
                  , w = m.create()
                  , S = m.create();
                i.prototype.applyForce = function() {
                    var t = this.stiffness
                      , e = this.damping
                      , o = this.restLength
                      , i = this.bodyA
                      , n = this.bodyB
                      , s = g
                      , a = A
                      , r = b
                      , c = E
                      , h = S
                      , l = B
                      , p = q
                      , u = P
                      , d = w;
                    this.getWorldAnchorA(l),
                    this.getWorldAnchorB(p),
                    m.sub(u, l, i.position),
                    m.sub(d, p, n.position),
                    m.sub(s, p, l);
                    var f = m.len(s);
                    m.normalize(a, s),
                    m.sub(r, n.velocity, i.velocity),
                    m.crossZV(h, n.angularVelocity, d),
                    m.add(r, r, h),
                    m.crossZV(h, i.angularVelocity, u),
                    m.sub(r, r, h),
                    m.scale(c, a, -t * (f - o) - e * m.dot(r, a)),
                    m.sub(i.force, i.force, c),
                    m.add(n.force, n.force, c);
                    var v = m.crossLength(u, c)
                      , y = m.crossLength(d, c);
                    i.angularForce -= v,
                    n.angularForce += y
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Spring": 34
            }],
            33: [function(t, e, o) {
                t("../math/vec2");
                var i = t("./Spring");
                function n(t, e, o) {
                    o = o || {},
                    i.call(this, t, e, o),
                    this.restAngle = "number" == typeof o.restAngle ? o.restAngle : e.angle - t.angle
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.applyForce = function() {
                    var t = this.stiffness
                      , e = this.damping
                      , o = this.restAngle
                      , i = this.bodyA
                      , n = this.bodyB
                      , s = -t * (n.angle - i.angle - o) - e * (n.angularVelocity - i.angularVelocity) * 0;
                    i.angularForce -= s,
                    n.angularForce += s
                }
            }
            , {
                "../math/vec2": 30,
                "./Spring": 34
            }],
            34: [function(t, e, o) {
                t("../math/vec2");
                var i = t("../utils/Utils");
                function n(t, e, o) {
                    o = i.defaults(o, {
                        stiffness: 100,
                        damping: 1
                    }),
                    this.stiffness = o.stiffness,
                    this.damping = o.damping,
                    this.bodyA = t,
                    this.bodyB = e
                }
                (e.exports = n).prototype.applyForce = function() {}
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            35: [function(t, e, o) {
                var i = t("../math/vec2")
                  , n = (t("../utils/Utils"),
                t("../constraints/Constraint"))
                  , s = t("../equations/FrictionEquation")
                  , a = t("../objects/Body");
                function r(t, e) {
                    this.chassisBody = t,
                    this.wheels = [],
                    this.groundBody = new a({
                        mass: 0
                    }),
                    this.world = null;
                    var o = this;
                    this.preStepCallback = function() {
                        o.update()
                    }
                }
                function c(t, e) {
                    e = e || {},
                    this.vehicle = t,
                    this.forwardEquation = new s(t.chassisBody,t.groundBody),
                    this.sideEquation = new s(t.chassisBody,t.groundBody),
                    this.steerValue = 0,
                    this.engineForce = 0,
                    this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5),
                    this.localForwardVector = i.fromValues(0, 1),
                    e.localForwardVector && i.copy(this.localForwardVector, e.localForwardVector),
                    this.localPosition = i.fromValues(0, 0),
                    e.localPosition && i.copy(this.localPosition, e.localPosition),
                    n.apply(this, t.chassisBody, t.groundBody),
                    this.equations.push(this.forwardEquation, this.sideEquation),
                    this.setBrakeForce(0)
                }
                (e.exports = r).prototype.addToWorld = function(t) {
                    (this.world = t).addBody(this.groundBody),
                    t.on("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var o = this.wheels[e];
                        t.addConstraint(o)
                    }
                }
                ,
                r.prototype.removeFromWorld = function() {
                    var t = this.world;
                    t.removeBody(this.groundBody),
                    t.off("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var o = this.wheels[e];
                        t.removeConstraint(o)
                    }
                    this.world = null
                }
                ,
                r.prototype.addWheel = function(t) {
                    var e = new c(this,t);
                    return this.wheels.push(e),
                    e
                }
                ,
                r.prototype.update = function() {
                    for (var t = 0; t < this.wheels.length; t++)
                        this.wheels[t].update()
                }
                ,
                (c.prototype = new n).setBrakeForce = function(t) {
                    this.forwardEquation.setSlipForce(t)
                }
                ,
                c.prototype.setSideFriction = function(t) {
                    this.sideEquation.setSlipForce(t)
                }
                ;
                var h = i.create()
                  , l = i.create();
                c.prototype.getSpeed = function() {
                    return this.vehicle.chassisBody.vectorToWorldFrame(l, this.localForwardVector),
                    this.vehicle.chassisBody.getVelocityAtPoint(h, l),
                    i.dot(h, l)
                }
                ;
                var p = i.create();
                c.prototype.update = function() {
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector),
                    i.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2),
                    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t),
                    i.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue),
                    i.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue),
                    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition),
                    i.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB),
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition),
                    i.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA),
                    i.normalize(p, this.forwardEquation.t),
                    i.scale(p, p, this.engineForce),
                    this.vehicle.chassisBody.applyForce(p, this.forwardEquation.contactPointA)
                }
            }
            , {
                "../constraints/Constraint": 14,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            36: [function(t, e, o) {
                var i = e.exports = {
                    AABB: t("./collision/AABB"),
                    AngleLockEquation: t("./equations/AngleLockEquation"),
                    Body: t("./objects/Body"),
                    Broadphase: t("./collision/Broadphase"),
                    Capsule: t("./shapes/Capsule"),
                    Circle: t("./shapes/Circle"),
                    Constraint: t("./constraints/Constraint"),
                    ContactEquation: t("./equations/ContactEquation"),
                    ContactEquationPool: t("./utils/ContactEquationPool"),
                    ContactMaterial: t("./material/ContactMaterial"),
                    Convex: t("./shapes/Convex"),
                    DistanceConstraint: t("./constraints/DistanceConstraint"),
                    Equation: t("./equations/Equation"),
                    EventEmitter: t("./events/EventEmitter"),
                    FrictionEquation: t("./equations/FrictionEquation"),
                    FrictionEquationPool: t("./utils/FrictionEquationPool"),
                    GearConstraint: t("./constraints/GearConstraint"),
                    GSSolver: t("./solver/GSSolver"),
                    Heightfield: t("./shapes/Heightfield"),
                    Line: t("./shapes/Line"),
                    LockConstraint: t("./constraints/LockConstraint"),
                    Material: t("./material/Material"),
                    Narrowphase: t("./collision/Narrowphase"),
                    NaiveBroadphase: t("./collision/NaiveBroadphase"),
                    Particle: t("./shapes/Particle"),
                    Plane: t("./shapes/Plane"),
                    Pool: t("./utils/Pool"),
                    RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                    PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                    Ray: t("./collision/Ray"),
                    RaycastResult: t("./collision/RaycastResult"),
                    Box: t("./shapes/Box"),
                    RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                    SAPBroadphase: t("./collision/SAPBroadphase"),
                    Shape: t("./shapes/Shape"),
                    Solver: t("./solver/Solver"),
                    Spring: t("./objects/Spring"),
                    TopDownVehicle: t("./objects/TopDownVehicle"),
                    LinearSpring: t("./objects/LinearSpring"),
                    RotationalSpring: t("./objects/RotationalSpring"),
                    Utils: t("./utils/Utils"),
                    World: t("./world/World"),
                    vec2: t("./math/vec2"),
                    version: t("../package.json").version
                };
                Object.defineProperty(i, "Rectangle", {
                    get: function() {
                        return console.warn("The Rectangle class has been renamed to Box."),
                        this.Box
                    }
                })
            }
            , {
                "../package.json": 6,
                "./collision/AABB": 7,
                "./collision/Broadphase": 8,
                "./collision/NaiveBroadphase": 9,
                "./collision/Narrowphase": 10,
                "./collision/Ray": 11,
                "./collision/RaycastResult": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/LinearSpring": 32,
                "./objects/RotationalSpring": 33,
                "./objects/Spring": 34,
                "./objects/TopDownVehicle": 35,
                "./shapes/Box": 37,
                "./shapes/Capsule": 38,
                "./shapes/Circle": 39,
                "./shapes/Convex": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Line": 42,
                "./shapes/Particle": 43,
                "./shapes/Plane": 44,
                "./shapes/Shape": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./utils/ContactEquationPool": 48,
                "./utils/FrictionEquationPool": 49,
                "./utils/Pool": 55,
                "./utils/Utils": 57,
                "./world/World": 61
            }],
            37: [function(t, e, o) {
                var s = t("../math/vec2")
                  , a = t("./Shape")
                  , r = t("./Convex");
                function i(t) {
                    "number" == typeof t && "number" == typeof arguments[1] && (t = {
                        width: t,
                        height: arguments[1]
                    },
                    console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")),
                    t = t || {};
                    var e = this.width = t.width || 1
                      , o = this.height = t.height || 1
                      , i = [s.fromValues(-e / 2, -o / 2), s.fromValues(e / 2, -o / 2), s.fromValues(e / 2, o / 2), s.fromValues(-e / 2, o / 2)]
                      , n = [s.fromValues(1, 0), s.fromValues(0, 1)];
                    t.vertices = i,
                    t.axes = n,
                    t.type = a.BOX,
                    r.call(this, t)
                }
                (((e.exports = i).prototype = new r).constructor = i).prototype.computeMomentOfInertia = function(t) {
                    var e = this.width
                      , o = this.height;
                    return t * (o * o + e * e) / 12
                }
                ,
                i.prototype.updateBoundingRadius = function() {
                    var t = this.width
                      , e = this.height;
                    this.boundingRadius = Math.sqrt(t * t + e * e) / 2
                }
                ;
                s.create(),
                s.create(),
                s.create(),
                s.create();
                i.prototype.computeAABB = function(t, e, o) {
                    t.setFromPoints(this.vertices, e, o, 0)
                }
                ,
                i.prototype.updateArea = function() {
                    this.area = this.width * this.height
                }
            }
            , {
                "../math/vec2": 30,
                "./Convex": 40,
                "./Shape": 45
            }],
            38: [function(t, e, o) {
                var i = t("./Shape")
                  , B = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && "number" == typeof arguments[1] && (t = {
                        length: t,
                        radius: arguments[1]
                    },
                    console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")),
                    t = t || {},
                    this.length = t.length || 1,
                    this.radius = t.radius || 1,
                    t.type = i.CAPSULE,
                    i.call(this, t)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius
                      , o = this.length + e
                      , i = 2 * e;
                    return t * (i * i + o * o) / 12
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
                }
                ;
                var s = B.create();
                n.prototype.computeAABB = function(t, e, o) {
                    var i = this.radius;
                    B.set(s, this.length / 2, 0),
                    0 !== o && B.rotate(s, s, o),
                    B.set(t.upperBound, Math.max(s[0] + i, -s[0] + i), Math.max(s[1] + i, -s[1] + i)),
                    B.set(t.lowerBound, Math.min(s[0] - i, -s[0] - i), Math.min(s[1] - i, -s[1] - i)),
                    B.add(t.lowerBound, t.lowerBound, e),
                    B.add(t.upperBound, t.upperBound, e)
                }
                ;
                var q = B.create()
                  , P = B.create()
                  , w = B.create()
                  , S = B.create()
                  , C = B.fromValues(0, 1);
                n.prototype.raycast = function(t, e, o, i) {
                    for (var n = e.from, s = e.to, a = (e.direction,
                    q), r = P, c = w, h = S, l = this.length / 2, p = 0; p < 2; p++) {
                        var u = this.radius * (2 * p - 1);
                        if (B.set(c, -l, u),
                        B.set(h, l, u),
                        B.toGlobalFrame(c, c, o, i),
                        B.toGlobalFrame(h, h, o, i),
                        0 <= (f = B.getLineSegmentsIntersectionFraction(n, s, c, h)) && (B.rotate(r, C, i),
                        B.scale(r, r, 2 * p - 1),
                        e.reportIntersection(t, f, r, -1),
                        t.shouldStop(e)))
                            return
                    }
                    var d = Math.pow(this.radius, 2) + Math.pow(l, 2);
                    for (p = 0; p < 2; p++) {
                        B.set(c, l * (2 * p - 1), 0),
                        B.toGlobalFrame(c, c, o, i);
                        var f, v = Math.pow(s[0] - n[0], 2) + Math.pow(s[1] - n[1], 2), y = 2 * ((s[0] - n[0]) * (n[0] - c[0]) + (s[1] - n[1]) * (n[1] - c[1])), m = Math.pow(n[0] - c[0], 2) + Math.pow(n[1] - c[1], 2) - Math.pow(this.radius, 2);
                        if (!((f = Math.pow(y, 2) - 4 * v * m) < 0))
                            if (0 === f) {
                                if (B.lerp(a, n, s, f),
                                B.squaredDistance(a, o) > d && (B.sub(r, a, c),
                                B.normalize(r, r),
                                e.reportIntersection(t, f, r, -1),
                                t.shouldStop(e)))
                                    return
                            } else {
                                var g = Math.sqrt(f)
                                  , A = 1 / (2 * v)
                                  , b = (-y - g) * A
                                  , E = (-y + g) * A;
                                if (0 <= b && b <= 1 && (B.lerp(a, n, s, b),
                                B.squaredDistance(a, o) > d && (B.sub(r, a, c),
                                B.normalize(r, r),
                                e.reportIntersection(t, b, r, -1),
                                t.shouldStop(e))))
                                    return;
                                if (0 <= E && E <= 1 && (B.lerp(a, n, s, E),
                                B.squaredDistance(a, o) > d && (B.sub(r, a, c),
                                B.normalize(r, r),
                                e.reportIntersection(t, E, r, -1),
                                t.shouldStop(e))))
                                    return
                            }
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            39: [function(t, e, o) {
                var i = t("./Shape")
                  , m = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && (t = {
                        radius: t
                    },
                    console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")),
                    t = t || {},
                    this.radius = t.radius || 1,
                    t.type = i.CIRCLE,
                    i.call(this, t)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius;
                    return t * e * e / 2
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius
                }
                ,
                n.prototype.computeAABB = function(t, e, o) {
                    var i = this.radius;
                    m.set(t.upperBound, i, i),
                    m.set(t.lowerBound, -i, -i),
                    e && (m.add(t.lowerBound, t.lowerBound, e),
                    m.add(t.upperBound, t.upperBound, e))
                }
                ;
                var g = m.create()
                  , A = m.create();
                n.prototype.raycast = function(t, e, o, i) {
                    var n = e.from
                      , s = e.to
                      , a = this.radius
                      , r = Math.pow(s[0] - n[0], 2) + Math.pow(s[1] - n[1], 2)
                      , c = 2 * ((s[0] - n[0]) * (n[0] - o[0]) + (s[1] - n[1]) * (n[1] - o[1]))
                      , h = Math.pow(n[0] - o[0], 2) + Math.pow(n[1] - o[1], 2) - Math.pow(a, 2)
                      , l = Math.pow(c, 2) - 4 * r * h
                      , p = g
                      , u = A;
                    if (!(l < 0))
                        if (0 == l)
                            m.lerp(p, n, s, l),
                            m.sub(u, p, o),
                            m.normalize(u, u),
                            e.reportIntersection(t, l, u, -1);
                        else {
                            var d = Math.sqrt(l)
                              , f = 1 / (2 * r)
                              , v = (-c - d) * f
                              , y = (-c + d) * f;
                            if (0 <= v && v <= 1 && (m.lerp(p, n, s, v),
                            m.sub(u, p, o),
                            m.normalize(u, u),
                            e.reportIntersection(t, v, u, -1),
                            t.shouldStop(e)))
                                return;
                            0 <= y && y <= 1 && (m.lerp(p, n, s, y),
                            m.sub(u, p, o),
                            m.normalize(u, u),
                            e.reportIntersection(t, y, u, -1))
                        }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            40: [function(t, e, o) {
                var c = t("./Shape")
                  , d = t("../math/vec2")
                  , r = t("../math/polyk");
                t("poly-decomp");
                function u(t) {
                    Array.isArray(t) && (t = {
                        vertices: t,
                        axes: arguments[1]
                    },
                    console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")),
                    t = t || {},
                    this.vertices = [];
                    for (var e = void 0 !== t.vertices ? t.vertices : [], o = 0; o < e.length; o++) {
                        var i = d.create();
                        d.copy(i, e[o]),
                        this.vertices.push(i)
                    }
                    if (this.axes = [],
                    t.axes)
                        for (o = 0; o < t.axes.length; o++) {
                            var n = d.create();
                            d.copy(n, t.axes[o]),
                            this.axes.push(n)
                        }
                    else
                        for (o = 0; o < this.vertices.length; o++) {
                            var s = this.vertices[o]
                              , a = this.vertices[(o + 1) % this.vertices.length]
                              , r = d.create();
                            d.sub(r, a, s),
                            d.rotate90cw(r, r),
                            d.normalize(r, r),
                            this.axes.push(r)
                        }
                    if (this.centerOfMass = d.fromValues(0, 0),
                    this.triangles = [],
                    this.vertices.length && (this.updateTriangles(),
                    this.updateCenterOfMass()),
                    this.boundingRadius = 0,
                    t.type = c.CONVEX,
                    c.call(this, t),
                    this.updateBoundingRadius(),
                    this.updateArea(),
                    this.area < 0)
                        throw new Error("Convex vertices must be given in conter-clockwise winding.")
                }
                ((e.exports = u).prototype = new c).constructor = u;
                var h = d.create()
                  , a = d.create();
                u.prototype.projectOntoLocalAxis = function(t, e) {
                    for (var o, i, n = null, s = null, a = (t = h,
                    0); a < this.vertices.length; a++)
                        o = this.vertices[a],
                        i = d.dot(o, t),
                        (null === n || n < i) && (n = i),
                        (null === s || i < s) && (s = i);
                    if (n < s) {
                        var r = s;
                        s = n,
                        n = r
                    }
                    d.set(e, s, n)
                }
                ,
                u.prototype.projectOntoWorldAxis = function(t, e, o, i) {
                    var n = a;
                    this.projectOntoLocalAxis(t, i),
                    0 !== o ? d.rotate(n, t, o) : n = t;
                    var s = d.dot(e, n);
                    d.set(i, i[0] + s, i[1] + s)
                }
                ,
                u.prototype.updateTriangles = function() {
                    for (var t = [], e = this.triangles.length = 0; e < this.vertices.length; e++) {
                        var o = this.vertices[e];
                        t.push(o[0], o[1])
                    }
                    var i = r.Triangulate(t);
                    for (e = 0; e < i.length; e += 3) {
                        var n = i[e]
                          , s = i[e + 1]
                          , a = i[e + 2];
                        this.triangles.push([n, s, a])
                    }
                }
                ;
                var f = d.create()
                  , v = d.create()
                  , y = d.create()
                  , m = d.create()
                  , g = d.create();
                d.create(),
                d.create(),
                d.create(),
                d.create();
                u.prototype.updateCenterOfMass = function() {
                    var t = this.triangles
                      , e = this.vertices
                      , o = this.centerOfMass
                      , i = f
                      , n = y
                      , s = m
                      , a = g
                      , r = v;
                    d.set(o, 0, 0);
                    for (var c = 0, h = 0; h !== t.length; h++) {
                        var l = t[h];
                        n = e[l[0]],
                        s = e[l[1]],
                        a = e[l[2]];
                        d.centroid(i, n, s, a);
                        var p = u.triangleArea(n, s, a);
                        c += p,
                        d.scale(r, i, p),
                        d.add(o, o, r)
                    }
                    d.scale(o, o, 1 / c)
                }
                ,
                u.prototype.computeMomentOfInertia = function(t) {
                    for (var e = 0, o = 0, i = this.vertices.length, n = i - 1, s = 0; s < i; n = s,
                    s++) {
                        var a = this.vertices[n]
                          , r = this.vertices[s]
                          , c = Math.abs(d.crossLength(a, r));
                        e += c * (d.dot(r, r) + d.dot(r, a) + d.dot(a, a)),
                        o += c
                    }
                    return t / 6 * (e / o)
                }
                ,
                u.prototype.updateBoundingRadius = function() {
                    for (var t = this.vertices, e = 0, o = 0; o !== t.length; o++) {
                        var i = d.squaredLength(t[o]);
                        e < i && (e = i)
                    }
                    this.boundingRadius = Math.sqrt(e)
                }
                ,
                u.triangleArea = function(t, e, o) {
                    return .5 * ((e[0] - t[0]) * (o[1] - t[1]) - (o[0] - t[0]) * (e[1] - t[1]))
                }
                ,
                u.prototype.updateArea = function() {
                    this.updateTriangles(),
                    this.area = 0;
                    for (var t = this.triangles, e = this.vertices, o = 0; o !== t.length; o++) {
                        var i = t[o]
                          , n = e[i[0]]
                          , s = e[i[1]]
                          , a = e[i[2]]
                          , r = u.triangleArea(n, s, a);
                        this.area += r
                    }
                }
                ,
                u.prototype.computeAABB = function(t, e, o) {
                    t.setFromPoints(this.vertices, e, o, 0)
                }
                ;
                var A = d.create()
                  , b = d.create()
                  , E = d.create();
                u.prototype.raycast = function(t, e, o, i) {
                    var n = A
                      , s = b
                      , a = E
                      , r = this.vertices;
                    d.toLocalFrame(n, e.from, o, i),
                    d.toLocalFrame(s, e.to, o, i);
                    for (var c = r.length, h = 0; h < c && !t.shouldStop(e); h++) {
                        var l = r[h]
                          , p = r[(h + 1) % c]
                          , u = d.getLineSegmentsIntersectionFraction(n, s, l, p);
                        0 <= u && (d.sub(a, p, l),
                        d.rotate(a, a, -Math.PI / 2 + i),
                        d.normalize(a, a),
                        e.reportIntersection(t, u, a, h))
                    }
                }
            }
            , {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 45,
                "poly-decomp": 5
            }],
            41: [function(t, e, o) {
                var i = t("./Shape")
                  , y = t("../math/vec2");
                t("../utils/Utils");
                function n(t) {
                    if (Array.isArray(t)) {
                        if (t = {
                            heights: t
                        },
                        "object" == typeof arguments[1])
                            for (var e in arguments[1])
                                t[e] = arguments[1][e];
                        console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                    }
                    t = t || {},
                    this.heights = t.heights ? t.heights.slice(0) : [],
                    this.maxValue = t.maxValue || null,
                    this.minValue = t.minValue || null,
                    this.elementWidth = t.elementWidth || .1,
                    void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(),
                    t.type = i.HEIGHTFIELD,
                    i.call(this, t)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.updateMaxMinValues = function() {
                    for (var t = this.heights, e = t[0], o = t[0], i = 0; i !== t.length; i++) {
                        var n = t[i];
                        e < n && (e = n),
                        n < o && (o = n)
                    }
                    this.maxValue = e,
                    this.minValue = o
                }
                ,
                n.prototype.computeMomentOfInertia = function(t) {
                    return Number.MAX_VALUE
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }
                ,
                n.prototype.updateArea = function() {
                    for (var t = this.heights, e = 0, o = 0; o < t.length - 1; o++)
                        e += (t[o] + t[o + 1]) / 2 * this.elementWidth;
                    this.area = e
                }
                ;
                var s = [y.create(), y.create(), y.create(), y.create()];
                n.prototype.computeAABB = function(t, e, o) {
                    y.set(s[0], 0, this.maxValue),
                    y.set(s[1], this.elementWidth * this.heights.length, this.maxValue),
                    y.set(s[2], this.elementWidth * this.heights.length, this.minValue),
                    y.set(s[3], 0, this.minValue),
                    t.setFromPoints(s, e, o)
                }
                ,
                n.prototype.getLineSegment = function(t, e, o) {
                    var i = this.heights
                      , n = this.elementWidth;
                    y.set(t, o * n, i[o]),
                    y.set(e, (o + 1) * n, i[o + 1])
                }
                ,
                n.prototype.getSegmentIndex = function(t) {
                    return Math.floor(t[0] / this.elementWidth)
                }
                ,
                n.prototype.getClampedSegmentIndex = function(t) {
                    var e = this.getSegmentIndex(t);
                    return e = Math.min(this.heights.length, Math.max(e, 0))
                }
                ;
                y.create();
                var m = y.create()
                  , g = y.create()
                  , A = y.create()
                  , b = y.create()
                  , E = y.create();
                y.fromValues(0, 1);
                n.prototype.raycast = function(t, e, o, i) {
                    var n = e.from
                      , s = e.to
                      , a = (e.direction,
                    m)
                      , r = g
                      , c = A
                      , h = b
                      , l = E;
                    y.toLocalFrame(h, n, o, i),
                    y.toLocalFrame(l, s, o, i);
                    var p = this.getClampedSegmentIndex(h)
                      , u = this.getClampedSegmentIndex(l);
                    if (u < p) {
                        var d = p;
                        p = u,
                        u = d
                    }
                    for (var f = 0; f < this.heights.length - 1; f++) {
                        this.getLineSegment(r, c, f);
                        var v = y.getLineSegmentsIntersectionFraction(h, l, r, c);
                        if (0 <= v && (y.sub(a, c, r),
                        y.rotate(a, a, i + Math.PI / 2),
                        y.normalize(a, a),
                        e.reportIntersection(t, v, a, -1),
                        t.shouldStop(e)))
                            return
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            42: [function(t, e, o) {
                var i = t("./Shape")
                  , p = t("../math/vec2");
                function n(t) {
                    "number" == typeof t && (t = {
                        length: t
                    },
                    console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")),
                    t = t || {},
                    this.length = t.length || 1,
                    t.type = i.LINE,
                    i.call(this, t)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    return t * Math.pow(this.length, 2) / 12
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2
                }
                ;
                var s = [p.create(), p.create()];
                n.prototype.computeAABB = function(t, e, o) {
                    var i = this.length / 2;
                    p.set(s[0], -i, 0),
                    p.set(s[1], i, 0),
                    t.setFromPoints(s, e, o, 0)
                }
                ;
                p.create();
                var u = p.create()
                  , d = p.create()
                  , f = p.create()
                  , v = p.fromValues(0, 1);
                n.prototype.raycast = function(t, e, o, i) {
                    var n = e.from
                      , s = e.to
                      , a = d
                      , r = f
                      , c = this.length / 2;
                    p.set(a, -c, 0),
                    p.set(r, c, 0),
                    p.toGlobalFrame(a, a, o, i),
                    p.toGlobalFrame(r, r, o, i);
                    var h = p.getLineSegmentsIntersectionFraction(a, r, n, s);
                    if (0 <= h) {
                        var l = u;
                        p.rotate(l, v, i),
                        e.reportIntersection(t, h, l, -1)
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            43: [function(t, e, o) {
                var i = t("./Shape")
                  , n = t("../math/vec2");
                function s(t) {
                    (t = t || {}).type = i.PARTICLE,
                    i.call(this, t)
                }
                (((e.exports = s).prototype = new i).constructor = s).prototype.computeMomentOfInertia = function(t) {
                    return 0
                }
                ,
                s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0
                }
                ,
                s.prototype.computeAABB = function(t, e, o) {
                    n.copy(t.lowerBound, e),
                    n.copy(t.upperBound, e)
                }
            }
            , {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            44: [function(t, e, o) {
                var i = t("./Shape")
                  , d = t("../math/vec2");
                t("../utils/Utils");
                function n(t) {
                    (t = t || {}).type = i.PLANE,
                    i.call(this, t)
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.computeMomentOfInertia = function(t) {
                    return 0
                }
                ,
                n.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }
                ,
                n.prototype.computeAABB = function(t, e, o) {
                    var i = o % (2 * Math.PI)
                      , n = d.set
                      , s = Number.MAX_VALUE
                      , a = t.lowerBound
                      , r = t.upperBound;
                    0 == i ? (n(a, -s, -s),
                    n(r, s, 0)) : i == Math.PI / 2 ? (n(a, 0, -s),
                    n(r, s, s)) : i === Math.PI ? (n(a, -s, 0),
                    n(r, s, s)) : i == 3 * Math.PI / 2 ? (n(a, -s, -s),
                    n(r, 0, s)) : (n(a, -s, -s),
                    n(r, s, s)),
                    d.add(a, a, e),
                    d.add(r, r, e)
                }
                ,
                n.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE
                }
                ;
                var f = d.create()
                  , v = (d.create(),
                d.create(),
                d.create())
                  , y = d.create();
                n.prototype.raycast = function(t, e, o, i) {
                    var n = e.from
                      , s = e.to
                      , a = e.direction
                      , r = f
                      , c = v
                      , h = y;
                    d.set(c, 0, 1),
                    d.rotate(c, c, i),
                    d.sub(h, n, o);
                    var l = d.dot(h, c);
                    if (d.sub(h, s, o),
                    !(0 < l * d.dot(h, c) || d.squaredDistance(n, s) < l * l)) {
                        var p = d.dot(c, a);
                        d.sub(r, n, o);
                        var u = -d.dot(c, r) / p / e.length;
                        e.reportIntersection(t, u, c, -1)
                    }
                }
            }
            , {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            45: [function(t, e, o) {
                e.exports = n;
                var i = t("../math/vec2");
                function n(t) {
                    t = t || {},
                    this.body = null,
                    this.position = i.fromValues(0, 0),
                    t.position && i.copy(this.position, t.position),
                    this.angle = t.angle || 0,
                    this.type = t.type || 0,
                    this.id = n.idCounter++,
                    this.boundingRadius = 0,
                    this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1,
                    this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                    this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1,
                    this.material = t.material || null,
                    this.area = 0,
                    this.sensor = void 0 !== t.sensor && t.sensor,
                    this.type && this.updateBoundingRadius(),
                    this.updateArea()
                }
                n.idCounter = 0,
                n.CIRCLE = 1,
                n.PARTICLE = 2,
                n.PLANE = 4,
                n.CONVEX = 8,
                n.LINE = 16,
                n.BOX = 32,
                Object.defineProperty(n, "RECTANGLE", {
                    get: function() {
                        return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."),
                        n.BOX
                    }
                }),
                n.CAPSULE = 64,
                n.HEIGHTFIELD = 128,
                n.prototype.computeMomentOfInertia = function(t) {}
                ,
                n.prototype.updateBoundingRadius = function() {}
                ,
                n.prototype.updateArea = function() {}
                ,
                n.prototype.computeAABB = function(t, e, o) {}
                ,
                n.prototype.raycast = function(t, e, o, i) {}
            }
            , {
                "../math/vec2": 30
            }],
            46: [function(t, e, o) {
                var B = t("../math/vec2")
                  , i = t("./Solver")
                  , q = t("../utils/Utils")
                  , P = t("../equations/FrictionEquation");
                function w(t) {
                    i.call(this, t, i.GS),
                    t = t || {},
                    this.iterations = t.iterations || 10,
                    this.tolerance = t.tolerance || 1e-7,
                    this.arrayStep = 30,
                    this.lambda = new q.ARRAY_TYPE(this.arrayStep),
                    this.Bs = new q.ARRAY_TYPE(this.arrayStep),
                    this.invCs = new q.ARRAY_TYPE(this.arrayStep),
                    this.useZeroRHS = !1,
                    this.frictionIterations = 0,
                    this.usedIterations = 0
                }
                (((e.exports = w).prototype = new i).constructor = w).prototype.solve = function(t, e) {
                    this.sortEquations();
                    var o = 0
                      , i = this.iterations
                      , n = this.frictionIterations
                      , s = this.equations
                      , a = s.length
                      , r = Math.pow(this.tolerance * a, 2)
                      , c = e.bodies
                      , h = e.bodies.length
                      , l = (B.add,
                    B.set,
                    this.useZeroRHS)
                      , p = this.lambda;
                    if (this.usedIterations = 0,
                    a)
                        for (var u = 0; u !== h; u++) {
                            c[u].updateSolveMassProperties()
                        }
                    p.length < a && (p = this.lambda = new q.ARRAY_TYPE(a + this.arrayStep),
                    this.Bs = new q.ARRAY_TYPE(a + this.arrayStep),
                    this.invCs = new q.ARRAY_TYPE(a + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--; )
                            t[e] = 0
                    }(p);
                    var d, f, v = this.invCs, y = this.Bs;
                    for (p = this.lambda,
                    u = 0; u !== s.length; u++) {
                        var m;
                        (m = s[u]).timeStep === t && !m.needsUpdate || (m.timeStep = t,
                        m.update()),
                        y[u] = m.computeB(m.a, m.b, t),
                        v[u] = m.computeInvC(m.epsilon)
                    }
                    if (0 !== a) {
                        for (u = 0; u !== h; u++) {
                            c[u].resetConstraintVelocity()
                        }
                        if (n) {
                            for (o = 0; o !== n; o++) {
                                for (f = d = 0; f !== a; f++) {
                                    m = s[f];
                                    var g = w.iterateEquation(f, m, m.epsilon, y, v, p, l, t, o);
                                    d += Math.abs(g)
                                }
                                if (this.usedIterations++,
                                d * d <= r)
                                    break
                            }
                            for (w.updateMultipliers(s, p, 1 / t),
                            f = 0; f !== a; f++) {
                                var A = s[f];
                                if (A instanceof P) {
                                    for (var b = 0, E = 0; E !== A.contactEquations.length; E++)
                                        b += A.contactEquations[E].multiplier;
                                    b *= A.frictionCoefficient / A.contactEquations.length,
                                    A.maxForce = b,
                                    A.minForce = -b
                                }
                            }
                        }
                        for (o = 0; o !== i; o++) {
                            for (f = d = 0; f !== a; f++) {
                                m = s[f];
                                g = w.iterateEquation(f, m, m.epsilon, y, v, p, l, t, o);
                                d += Math.abs(g)
                            }
                            if (this.usedIterations++,
                            d * d <= r)
                                break
                        }
                        for (u = 0; u !== h; u++)
                            c[u].addConstraintVelocity();
                        w.updateMultipliers(s, p, 1 / t)
                    }
                }
                ,
                w.updateMultipliers = function(t, e, o) {
                    for (var i = t.length; i--; )
                        t[i].multiplier = e[i] * o
                }
                ,
                w.iterateEquation = function(t, e, o, i, n, s, a, r, c) {
                    var h = i[t]
                      , l = n[t]
                      , p = s[t]
                      , u = e.computeGWlambda()
                      , d = e.maxForce
                      , f = e.minForce;
                    a && (h = 0);
                    var v = l * (h - u - o * p)
                      , y = p + v;
                    return y < f * r ? v = f * r - p : d * r < y && (v = d * r - p),
                    s[t] += v,
                    e.addToWlambda(v),
                    v
                }
            }
            , {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Solver": 47
            }],
            47: [function(t, e, o) {
                t("../utils/Utils");
                var i = t("../events/EventEmitter");
                function n(t, e) {
                    t = t || {},
                    i.call(this),
                    this.type = e,
                    this.equations = [],
                    this.equationSortFunction = t.equationSortFunction || !1
                }
                (((e.exports = n).prototype = new i).constructor = n).prototype.solve = function(t, e) {
                    throw new Error("Solver.solve should be implemented by subclasses!")
                }
                ;
                var s = {
                    bodies: []
                };
                n.prototype.solveIsland = function(t, e) {
                    this.removeAllEquations(),
                    e.equations.length && (this.addEquations(e.equations),
                    s.bodies.length = 0,
                    e.getBodies(s.bodies),
                    s.bodies.length && this.solve(t, s))
                }
                ,
                n.prototype.sortEquations = function() {
                    this.equationSortFunction && this.equations.sort(this.equationSortFunction)
                }
                ,
                n.prototype.addEquation = function(t) {
                    t.enabled && this.equations.push(t)
                }
                ,
                n.prototype.addEquations = function(t) {
                    for (var e = 0, o = t.length; e !== o; e++) {
                        var i = t[e];
                        i.enabled && this.equations.push(i)
                    }
                }
                ,
                n.prototype.removeEquation = function(t) {
                    var e = this.equations.indexOf(t);
                    -1 !== e && this.equations.splice(e, 1)
                }
                ,
                n.prototype.removeAllEquations = function() {
                    this.equations.length = 0
                }
                ,
                n.GS = 1,
                n.ISLAND = 2
            }
            , {
                "../events/EventEmitter": 26,
                "../utils/Utils": 57
            }],
            48: [function(t, e, o) {
                var i = t("../equations/ContactEquation")
                  , n = t("./Pool");
                function s() {
                    n.apply(this, arguments)
                }
                (((e.exports = s).prototype = new n).constructor = s).prototype.create = function() {
                    return new i
                }
                ,
                s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null,
                    this
                }
            }
            , {
                "../equations/ContactEquation": 21,
                "./Pool": 55
            }],
            49: [function(t, e, o) {
                var i = t("../equations/FrictionEquation")
                  , n = t("./Pool");
                function s() {
                    n.apply(this, arguments)
                }
                (((e.exports = s).prototype = new n).constructor = s).prototype.create = function() {
                    return new i
                }
                ,
                s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null,
                    this
                }
            }
            , {
                "../equations/FrictionEquation": 23,
                "./Pool": 55
            }],
            50: [function(t, e, o) {
                var i = t("../world/IslandNode")
                  , n = t("./Pool");
                function s() {
                    n.apply(this, arguments)
                }
                (((e.exports = s).prototype = new n).constructor = s).prototype.create = function() {
                    return new i
                }
                ,
                s.prototype.destroy = function(t) {
                    return t.reset(),
                    this
                }
            }
            , {
                "../world/IslandNode": 60,
                "./Pool": 55
            }],
            51: [function(t, e, o) {
                var i = t("../world/Island")
                  , n = t("./Pool");
                function s() {
                    n.apply(this, arguments)
                }
                (((e.exports = s).prototype = new n).constructor = s).prototype.create = function() {
                    return new i
                }
                ,
                s.prototype.destroy = function(t) {
                    return t.reset(),
                    this
                }
            }
            , {
                "../world/Island": 58,
                "./Pool": 55
            }],
            52: [function(t, e, o) {
                var i = t("./TupleDictionary")
                  , n = (t("./OverlapKeeperRecord"),
                t("./OverlapKeeperRecordPool"));
                t("./Utils");
                function s() {
                    this.overlappingShapesLastState = new i,
                    this.overlappingShapesCurrentState = new i,
                    this.recordPool = new n({
                        size: 16
                    }),
                    this.tmpDict = new i,
                    this.tmpArray1 = []
                }
                (e.exports = s).prototype.tick = function() {
                    for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, o = t.keys.length; o--; ) {
                        var i = t.keys[o]
                          , n = t.getByKey(i);
                        e.getByKey(i);
                        n && this.recordPool.release(n)
                    }
                    t.reset(),
                    t.copy(e),
                    e.reset()
                }
                ,
                s.prototype.setOverlapping = function(t, e, o, i) {
                    this.overlappingShapesLastState;
                    var n = this.overlappingShapesCurrentState;
                    if (!n.get(e.id, i.id)) {
                        var s = this.recordPool.get();
                        s.set(t, e, o, i),
                        n.set(e.id, i.id, s)
                    }
                }
                ,
                s.prototype.getNewOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
                }
                ,
                s.prototype.getEndOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
                }
                ,
                s.prototype.bodiesAreOverlapping = function(t, e) {
                    for (var o = this.overlappingShapesCurrentState, i = o.keys.length; i--; ) {
                        var n = o.keys[i]
                          , s = o.data[n];
                        if (s.bodyA === t && s.bodyB === e || s.bodyA === e && s.bodyB === t)
                            return !0
                    }
                    return !1
                }
                ,
                s.prototype.getDiff = function(t, e, o) {
                    var i = t
                      , n = e;
                    (o = o || []).length = 0;
                    for (var s = n.keys.length; s--; ) {
                        var a = n.keys[s]
                          , r = n.data[a];
                        if (!r)
                            throw new Error("Key " + a + " had no data!");
                        i.data[a] || o.push(r)
                    }
                    return o
                }
                ,
                s.prototype.isNewOverlap = function(t, e) {
                    var o = 0 | t.id
                      , i = 0 | e.id
                      , n = this.overlappingShapesLastState
                      , s = this.overlappingShapesCurrentState;
                    return !n.get(o, i) && !!s.get(o, i)
                }
                ,
                s.prototype.getNewBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }
                ,
                s.prototype.getEndBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }
                ,
                s.prototype.getBodyDiff = function(t, e) {
                    e = e || [];
                    for (var o = this.tmpDict, i = t.length; i--; ) {
                        var n = t[i];
                        o.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                    }
                    for (i = o.keys.length; i--; ) {
                        (n = o.getByKey(o.keys[i])) && e.push(n.bodyA, n.bodyB)
                    }
                    return o.reset(),
                    e
                }
            }
            , {
                "./OverlapKeeperRecord": 53,
                "./OverlapKeeperRecordPool": 54,
                "./TupleDictionary": 56,
                "./Utils": 57
            }],
            53: [function(t, e, o) {
                function n(t, e, o, i) {
                    this.shapeA = e,
                    this.shapeB = i,
                    this.bodyA = t,
                    this.bodyB = o
                }
                (e.exports = n).prototype.set = function(t, e, o, i) {
                    n.call(this, t, e, o, i)
                }
            }
            , {}],
            54: [function(t, e, o) {
                var i = t("./OverlapKeeperRecord")
                  , n = t("./Pool");
                function s() {
                    n.apply(this, arguments)
                }
                (((e.exports = s).prototype = new n).constructor = s).prototype.create = function() {
                    return new i
                }
                ,
                s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null,
                    this
                }
            }
            , {
                "./OverlapKeeperRecord": 53,
                "./Pool": 55
            }],
            55: [function(t, e, o) {
                function i(t) {
                    t = t || {},
                    this.objects = [],
                    void 0 !== t.size && this.resize(t.size)
                }
                (e.exports = i).prototype.resize = function(t) {
                    for (var e = this.objects; e.length > t; )
                        e.pop();
                    for (; e.length < t; )
                        e.push(this.create());
                    return this
                }
                ,
                i.prototype.get = function() {
                    var t = this.objects;
                    return t.length ? t.pop() : this.create()
                }
                ,
                i.prototype.release = function(t) {
                    return this.destroy(t),
                    this.objects.push(t),
                    this
                }
            }
            , {}],
            56: [function(t, e, o) {
                var i = t("./Utils");
                function n() {
                    this.data = {},
                    this.keys = []
                }
                (e.exports = n).prototype.getKey = function(t, e) {
                    return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | e) < (0 | t) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
                }
                ,
                n.prototype.getByKey = function(t) {
                    return t |= 0,
                    this.data[t]
                }
                ,
                n.prototype.get = function(t, e) {
                    return this.data[this.getKey(t, e)]
                }
                ,
                n.prototype.set = function(t, e, o) {
                    if (!o)
                        throw new Error("No data!");
                    var i = this.getKey(t, e);
                    return this.data[i] || this.keys.push(i),
                    this.data[i] = o,
                    i
                }
                ,
                n.prototype.reset = function() {
                    for (var t = this.data, e = this.keys, o = e.length; o--; )
                        delete t[e[o]];
                    e.length = 0
                }
                ,
                n.prototype.copy = function(t) {
                    this.reset(),
                    i.appendArray(this.keys, t.keys);
                    for (var e = t.keys.length; e--; ) {
                        var o = t.keys[e];
                        this.data[o] = t.data[o]
                    }
                }
            }
            , {
                "./Utils": 57
            }],
            57: [function(t, e, o) {
                function i() {}
                (e.exports = i).appendArray = function(t, e) {
                    if (e.length < 15e4)
                        t.push.apply(t, e);
                    else
                        for (var o = 0, i = e.length; o !== i; ++o)
                            t.push(e[o])
                }
                ,
                i.splice = function(t, e, o) {
                    o = o || 1;
                    for (var i = e, n = t.length - o; i < n; i++)
                        t[i] = t[i + o];
                    t.length = n
                }
                ,
                i.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array,
                i.extend = function(t, e) {
                    for (var o in e)
                        t[o] = e[o]
                }
                ,
                i.defaults = function(t, e) {
                    for (var o in t = t || {},
                    e)
                        o in t || (t[o] = e[o]);
                    return t
                }
            }
            , {}],
            58: [function(t, e, o) {
                var i = t("../objects/Body");
                function n() {
                    this.equations = [],
                    this.bodies = []
                }
                (e.exports = n).prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0
                }
                ;
                var s = [];
                n.prototype.getBodies = function(t) {
                    for (var e = t || [], o = this.equations, i = s.length = 0; i !== o.length; i++) {
                        var n = o[i];
                        -1 === s.indexOf(n.bodyA.id) && (e.push(n.bodyA),
                        s.push(n.bodyA.id)),
                        -1 === s.indexOf(n.bodyB.id) && (e.push(n.bodyB),
                        s.push(n.bodyB.id))
                    }
                    return e
                }
                ,
                n.prototype.wantsToSleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        var e = this.bodies[t];
                        if (e.type === i.DYNAMIC && !e.wantsToSleep)
                            return !1
                    }
                    return !0
                }
                ,
                n.prototype.sleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        this.bodies[t].sleep()
                    }
                    return !0
                }
            }
            , {
                "../objects/Body": 31
            }],
            59: [function(t, e, o) {
                t("../math/vec2"),
                t("./Island"),
                t("./IslandNode");
                var i = t("./../utils/IslandNodePool")
                  , n = t("./../utils/IslandPool")
                  , a = t("../objects/Body");
                function f(t) {
                    this.nodePool = new i({
                        size: 16
                    }),
                    this.islandPool = new n({
                        size: 8
                    }),
                    this.equations = [],
                    this.islands = [],
                    this.nodes = [],
                    this.queue = []
                }
                (e.exports = f).getUnvisitedNode = function(t) {
                    for (var e = t.length, o = 0; o !== e; o++) {
                        var i = t[o];
                        if (!i.visited && i.body.type === a.DYNAMIC)
                            return i
                    }
                    return !1
                }
                ,
                f.prototype.visit = function(t, e, o) {
                    e.push(t.body);
                    for (var i = t.equations.length, n = 0; n !== i; n++) {
                        var s = t.equations[n];
                        -1 === o.indexOf(s) && o.push(s)
                    }
                }
                ,
                f.prototype.bfs = function(t, e, o) {
                    var i = this.queue;
                    for (i.length = 0,
                    i.push(t),
                    t.visited = !0,
                    this.visit(t, e, o); i.length; )
                        for (var n, s = i.pop(); n = f.getUnvisitedNode(s.neighbors); )
                            n.visited = !0,
                            this.visit(n, e, o),
                            n.body.type === a.DYNAMIC && i.push(n)
                }
                ,
                f.prototype.split = function(t) {
                    for (var e = t.bodies, o = this.nodes, i = this.equations; o.length; )
                        this.nodePool.release(o.pop());
                    for (var n = 0; n !== e.length; n++) {
                        var s = this.nodePool.get();
                        s.body = e[n],
                        o.push(s)
                    }
                    for (var a = 0; a !== i.length; a++) {
                        var r = i[a]
                          , c = (n = e.indexOf(r.bodyA),
                        e.indexOf(r.bodyB))
                          , h = o[n]
                          , l = o[c];
                        h.neighbors.push(l),
                        l.neighbors.push(h),
                        h.equations.push(r),
                        l.equations.push(r)
                    }
                    var p, u = this.islands;
                    for (n = 0; n < u.length; n++)
                        this.islandPool.release(u[n]);
                    for (u.length = 0; p = f.getUnvisitedNode(o); ) {
                        var d = this.islandPool.get();
                        this.bfs(p, d.bodies, d.equations),
                        u.push(d)
                    }
                    return u
                }
            }
            , {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./../utils/IslandNodePool": 50,
                "./../utils/IslandPool": 51,
                "./Island": 58,
                "./IslandNode": 60
            }],
            60: [function(t, e, o) {
                function i(t) {
                    this.body = t,
                    this.neighbors = [],
                    this.equations = [],
                    this.visited = !1
                }
                (e.exports = i).prototype.reset = function() {
                    this.equations.length = 0,
                    this.neighbors.length = 0,
                    this.visited = !1,
                    this.body = null
                }
            }
            , {}],
            61: [function(t, e, o) {
                var i = t("../solver/GSSolver")
                  , j = (t("../solver/Solver"),
                t("../collision/Ray"),
                t("../math/vec2"))
                  , m = t("../shapes/Circle")
                  , g = t("../shapes/Convex")
                  , A = (t("../shapes/Line"),
                t("../shapes/Plane"))
                  , b = t("../shapes/Capsule")
                  , E = t("../shapes/Particle")
                  , n = t("../events/EventEmitter")
                  , z = t("../objects/Body")
                  , s = (t("../shapes/Shape"),
                t("../objects/LinearSpring"),
                t("../material/Material"))
                  , a = t("../material/ContactMaterial")
                  , r = (t("../constraints/DistanceConstraint"),
                t("../constraints/Constraint"),
                t("../constraints/LockConstraint"),
                t("../constraints/RevoluteConstraint"),
                t("../constraints/PrismaticConstraint"),
                t("../constraints/GearConstraint"),
                t("../../package.json"),
                t("../collision/Broadphase"),
                t("../collision/AABB"))
                  , c = t("../collision/SAPBroadphase")
                  , h = t("../collision/Narrowphase")
                  , Y = t("../utils/Utils")
                  , l = t("../utils/OverlapKeeper")
                  , p = t("./IslandManager");
                t("../objects/RotationalSpring");
                function K(t) {
                    n.apply(this),
                    t = t || {},
                    this.springs = [],
                    this.bodies = [],
                    this.disabledBodyCollisionPairs = [],
                    this.solver = t.solver || new i,
                    this.narrowphase = new h(this),
                    this.islandManager = new p,
                    this.gravity = j.fromValues(0, -9.78),
                    t.gravity && j.copy(this.gravity, t.gravity),
                    this.frictionGravity = j.length(this.gravity) || 10,
                    this.useWorldGravityAsFrictionGravity = !0,
                    this.useFrictionGravityOnZeroGravity = !0,
                    this.broadphase = t.broadphase || new c,
                    this.broadphase.setWorld(this),
                    this.constraints = [],
                    this.defaultMaterial = new s,
                    this.defaultContactMaterial = new a(this.defaultMaterial,this.defaultMaterial),
                    this.lastTimeStep = 1 / 60,
                    this.applySpringForces = !0,
                    this.applyDamping = !0,
                    this.applyGravity = !0,
                    this.solveConstraints = !0,
                    this.contactMaterials = [],
                    this.time = 0,
                    this.accumulator = 0,
                    this.stepping = !1,
                    this.bodiesToBeRemoved = [],
                    this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit,
                    this.emitImpactEvent = !0,
                    this._constraintIdCounter = 0,
                    this._bodyIdCounter = 0,
                    this.postStepEvent = {
                        type: "postStep"
                    },
                    this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    },
                    this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    },
                    this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    },
                    this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    },
                    this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    },
                    this.sleepMode = K.NO_SLEEPING,
                    this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    },
                    this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    },
                    this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    },
                    this.overlappingShapesLastState = {
                        keys: []
                    },
                    this.overlappingShapesCurrentState = {
                        keys: []
                    },
                    this.overlapKeeper = new l
                }
                (((e.exports = K).prototype = new Object(n.prototype)).constructor = K).NO_SLEEPING = 1,
                K.BODY_SLEEPING = 2,
                K.ISLAND_SLEEPING = 4,
                K.prototype.addConstraint = function(t) {
                    this.constraints.push(t)
                }
                ,
                K.prototype.addContactMaterial = function(t) {
                    this.contactMaterials.push(t)
                }
                ,
                K.prototype.removeContactMaterial = function(t) {
                    var e = this.contactMaterials.indexOf(t);
                    -1 !== e && Y.splice(this.contactMaterials, e, 1)
                }
                ,
                K.prototype.getContactMaterial = function(t, e) {
                    for (var o = this.contactMaterials, i = 0, n = o.length; i !== n; i++) {
                        var s = o[i];
                        if (s.materialA.id === t.id && s.materialB.id === e.id || s.materialA.id === e.id && s.materialB.id === t.id)
                            return s
                    }
                    return !1
                }
                ,
                K.prototype.removeConstraint = function(t) {
                    var e = this.constraints.indexOf(t);
                    -1 !== e && Y.splice(this.constraints, e, 1)
                }
                ;
                j.create(),
                j.create(),
                j.create(),
                j.create(),
                j.create(),
                j.create();
                var H = j.create()
                  , P = j.fromValues(0, 0)
                  , w = j.fromValues(0, 0);
                j.fromValues(0, 0),
                j.fromValues(0, 0);
                K.prototype.step = function(t, e, o) {
                    if (o = o || 10,
                    0 === (e = e || 0))
                        this.internalStep(t),
                        this.time += t;
                    else {
                        this.accumulator += e;
                        for (var i = 0; this.accumulator >= t && i < o; )
                            this.internalStep(t),
                            this.time += t,
                            this.accumulator -= t,
                            i++;
                        for (var n = this.accumulator % t / t, s = 0; s !== this.bodies.length; s++) {
                            var a = this.bodies[s];
                            j.lerp(a.interpolatedPosition, a.previousPosition, a.position, n),
                            a.interpolatedAngle = a.previousAngle + n * (a.angle - a.previousAngle)
                        }
                    }
                }
                ;
                var Z = [];
                K.prototype.internalStep = function(t) {
                    this.stepping = !0;
                    var e = this.springs.length
                      , o = this.springs
                      , i = this.bodies
                      , n = this.gravity
                      , s = this.solver
                      , a = this.bodies.length
                      , r = this.broadphase
                      , c = this.narrowphase
                      , h = this.constraints
                      , l = H
                      , p = (j.scale,
                    j.add)
                      , u = (j.rotate,
                    this.islandManager);
                    if (this.overlapKeeper.tick(),
                    this.lastTimeStep = t,
                    this.useWorldGravityAsFrictionGravity) {
                        var d = j.length(this.gravity);
                        0 === d && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = d)
                    }
                    if (this.applyGravity)
                        for (var f = 0; f !== a; f++) {
                            var v = (y = i[f]).force;
                            y.type === z.DYNAMIC && y.sleepState !== z.SLEEPING && (j.scale(l, n, y.mass * y.gravityScale),
                            p(v, v, l))
                        }
                    if (this.applySpringForces)
                        for (f = 0; f !== e; f++) {
                            o[f].applyForce()
                        }
                    if (this.applyDamping)
                        for (f = 0; f !== a; f++) {
                            var y;
                            (y = i[f]).type === z.DYNAMIC && y.applyDamping(t)
                        }
                    var m = r.getCollisionPairs(this)
                      , g = this.disabledBodyCollisionPairs;
                    for (f = g.length - 2; 0 <= f; f -= 2)
                        for (var A = m.length - 2; 0 <= A; A -= 2)
                            (g[f] === m[A] && g[f + 1] === m[A + 1] || g[f + 1] === m[A] && g[f] === m[A + 1]) && m.splice(A, 2);
                    var b = h.length;
                    for (f = 0; f !== b; f++) {
                        var E = h[f];
                        if (!E.collideConnected)
                            for (A = m.length - 2; 0 <= A; A -= 2)
                                (E.bodyA === m[A] && E.bodyB === m[A + 1] || E.bodyB === m[A] && E.bodyA === m[A + 1]) && m.splice(A, 2)
                    }
                    this.postBroadphaseEvent.pairs = m,
                    this.emit(this.postBroadphaseEvent),
                    this.postBroadphaseEvent.pairs = null,
                    c.reset(this);
                    f = 0;
                    for (var B = m.length; f !== B; f += 2)
                        for (var q = m[f], P = m[f + 1], w = 0, S = q.shapes.length; w !== S; w++)
                            for (var C = q.shapes[w], L = C.position, x = C.angle, F = 0, M = P.shapes.length; F !== M; F++) {
                                var I = P.shapes[F]
                                  , R = I.position
                                  , V = I.angle
                                  , T = this.defaultContactMaterial;
                                if (C.material && I.material) {
                                    var N = this.getContactMaterial(C.material, I.material);
                                    N && (T = N)
                                }
                                this.runNarrowphase(c, q, C, L, x, P, I, R, V, T, this.frictionGravity)
                            }
                    for (f = 0; f !== a; f++) {
                        (k = i[f])._wakeUpAfterNarrowphase && (k.wakeUp(),
                        k._wakeUpAfterNarrowphase = !1)
                    }
                    if (this.has("endContact")) {
                        this.overlapKeeper.getEndOverlaps(Z);
                        var G = this.endContactEvent;
                        for (F = Z.length; F--; ) {
                            var O = Z[F];
                            G.shapeA = O.shapeA,
                            G.shapeB = O.shapeB,
                            G.bodyA = O.bodyA,
                            G.bodyB = O.bodyB,
                            this.emit(G)
                        }
                        Z.length = 0
                    }
                    var U = this.preSolveEvent;
                    U.contactEquations = c.contactEquations,
                    U.frictionEquations = c.frictionEquations,
                    this.emit(U),
                    U.contactEquations = U.frictionEquations = null;
                    b = h.length;
                    for (f = 0; f !== b; f++)
                        h[f].update();
                    if (c.contactEquations.length || c.frictionEquations.length || b)
                        if (this.islandSplit) {
                            for (u.equations.length = 0,
                            Y.appendArray(u.equations, c.contactEquations),
                            Y.appendArray(u.equations, c.frictionEquations),
                            f = 0; f !== b; f++)
                                Y.appendArray(u.equations, h[f].equations);
                            u.split(this);
                            for (f = 0; f !== u.islands.length; f++) {
                                (W = u.islands[f]).equations.length && s.solveIsland(t, W)
                            }
                        } else {
                            for (s.addEquations(c.contactEquations),
                            s.addEquations(c.frictionEquations),
                            f = 0; f !== b; f++)
                                s.addEquations(h[f].equations);
                            this.solveConstraints && s.solve(t, this),
                            s.removeAllEquations()
                        }
                    for (f = 0; f !== a; f++) {
                        var k;
                        (k = i[f]).integrate(t)
                    }
                    for (f = 0; f !== a; f++)
                        i[f].setZeroForce();
                    if (this.emitImpactEvent && this.has("impact")) {
                        var _ = this.impactEvent;
                        for (f = 0; f !== c.contactEquations.length; f++) {
                            var D = c.contactEquations[f];
                            D.firstImpact && (_.bodyA = D.bodyA,
                            _.bodyB = D.bodyB,
                            _.shapeA = D.shapeA,
                            _.shapeB = D.shapeB,
                            _.contactEquation = D,
                            this.emit(_))
                        }
                    }
                    if (this.sleepMode === K.BODY_SLEEPING)
                        for (f = 0; f !== a; f++)
                            i[f].sleepTick(this.time, !1, t);
                    else if (this.sleepMode === K.ISLAND_SLEEPING && this.islandSplit) {
                        for (f = 0; f !== a; f++)
                            i[f].sleepTick(this.time, !0, t);
                        for (f = 0; f < this.islandManager.islands.length; f++) {
                            var W;
                            (W = this.islandManager.islands[f]).wantsToSleep() && W.sleep()
                        }
                    }
                    this.stepping = !1;
                    var X = this.bodiesToBeRemoved;
                    for (f = 0; f !== X.length; f++)
                        this.removeBody(X[f]);
                    X.length = 0,
                    this.emit(this.postStepEvent)
                }
                ,
                K.prototype.runNarrowphase = function(t, e, o, i, n, s, a, r, c, h, l) {
                    if (0 != (o.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & o.collisionMask)) {
                        j.rotate(P, i, e.angle),
                        j.rotate(w, r, s.angle),
                        j.add(P, P, e.position),
                        j.add(w, w, s.position);
                        var p, u = n + e.angle, d = c + s.angle;
                        t.enableFriction = 0 < h.friction,
                        t.frictionCoefficient = h.friction,
                        p = e.type === z.STATIC || e.type === z.KINEMATIC ? s.mass : s.type === z.STATIC || s.type === z.KINEMATIC ? e.mass : e.mass * s.mass / (e.mass + s.mass),
                        t.slipForce = h.friction * l * p,
                        t.restitution = h.restitution,
                        t.surfaceVelocity = h.surfaceVelocity,
                        t.frictionStiffness = h.frictionStiffness,
                        t.frictionRelaxation = h.frictionRelaxation,
                        t.stiffness = h.stiffness,
                        t.relaxation = h.relaxation,
                        t.contactSkinSize = h.contactSkinSize,
                        t.enabledEquations = e.collisionResponse && s.collisionResponse && o.collisionResponse && a.collisionResponse;
                        var f = t[o.type | a.type]
                          , v = 0;
                        if (f) {
                            var y = o.sensor || a.sensor
                              , m = t.frictionEquations.length;
                            v = o.type < a.type ? f.call(t, e, o, P, u, s, a, w, d, y) : f.call(t, s, a, w, d, e, o, P, u, y);
                            var g = t.frictionEquations.length - m;
                            if (v) {
                                if (e.allowSleep && e.type === z.DYNAMIC && e.sleepState === z.SLEEPING && s.sleepState === z.AWAKE && s.type !== z.STATIC) {
                                    var A = j.squaredLength(s.velocity) + Math.pow(s.angularVelocity, 2);
                                    2 * Math.pow(s.sleepSpeedLimit, 2) <= A && (e._wakeUpAfterNarrowphase = !0)
                                }
                                if (s.allowSleep && s.type === z.DYNAMIC && s.sleepState === z.SLEEPING && e.sleepState === z.AWAKE && e.type !== z.STATIC) {
                                    var b = j.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2);
                                    2 * Math.pow(e.sleepSpeedLimit, 2) <= b && (s._wakeUpAfterNarrowphase = !0)
                                }
                                if (this.overlapKeeper.setOverlapping(e, o, s, a),
                                this.has("beginContact") && this.overlapKeeper.isNewOverlap(o, a)) {
                                    var E = this.beginContactEvent;
                                    if (E.shapeA = o,
                                    E.shapeB = a,
                                    E.bodyA = e,
                                    E.bodyB = s,
                                    E.contactEquations.length = 0,
                                    "number" == typeof v)
                                        for (var B = t.contactEquations.length - v; B < t.contactEquations.length; B++)
                                            E.contactEquations.push(t.contactEquations[B]);
                                    this.emit(E)
                                }
                                if ("number" == typeof v && 1 < g)
                                    for (B = t.frictionEquations.length - g; B < t.frictionEquations.length; B++) {
                                        var q = t.frictionEquations[B];
                                        q.setSlipForce(q.getSlipForce() / g)
                                    }
                            }
                        }
                    }
                }
                ,
                K.prototype.addSpring = function(t) {
                    this.springs.push(t);
                    var e = this.addSpringEvent;
                    e.spring = t,
                    this.emit(e),
                    e.spring = null
                }
                ,
                K.prototype.removeSpring = function(t) {
                    var e = this.springs.indexOf(t);
                    -1 !== e && Y.splice(this.springs, e, 1)
                }
                ,
                K.prototype.addBody = function(t) {
                    if (-1 === this.bodies.indexOf(t)) {
                        this.bodies.push(t);
                        var e = (t.world = this).addBodyEvent;
                        e.body = t,
                        this.emit(e),
                        e.body = null
                    }
                }
                ,
                K.prototype.removeBody = function(t) {
                    if (this.stepping)
                        this.bodiesToBeRemoved.push(t);
                    else {
                        t.world = null;
                        var e = this.bodies.indexOf(t);
                        -1 !== e && (Y.splice(this.bodies, e, 1),
                        (this.removeBodyEvent.body = t).resetConstraintVelocity(),
                        this.emit(this.removeBodyEvent),
                        this.removeBodyEvent.body = null)
                    }
                }
                ,
                K.prototype.getBodyById = function(t) {
                    for (var e = this.bodies, o = 0; o < e.length; o++) {
                        var i = e[o];
                        if (i.id === t)
                            return i
                    }
                    return !1
                }
                ,
                K.prototype.disableBodyCollision = function(t, e) {
                    this.disabledBodyCollisionPairs.push(t, e)
                }
                ,
                K.prototype.enableBodyCollision = function(t, e) {
                    for (var o = this.disabledBodyCollisionPairs, i = 0; i < o.length; i += 2)
                        if (o[i] === t && o[i + 1] === e || o[i + 1] === t && o[i] === e)
                            return void o.splice(i, 2)
                }
                ,
                K.prototype.clear = function() {
                    this.time = 0,
                    this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                    for (var t = this.constraints, e = t.length - 1; 0 <= e; e--)
                        this.removeConstraint(t[e]);
                    var o = this.bodies;
                    for (e = o.length - 1; 0 <= e; e--)
                        this.removeBody(o[e]);
                    var i = this.springs;
                    for (e = i.length - 1; 0 <= e; e--)
                        this.removeSpring(i[e]);
                    var n = this.contactMaterials;
                    for (e = n.length - 1; 0 <= e; e--)
                        this.removeContactMaterial(n[e]);
                    K.apply(this)
                }
                ;
                var B = j.create()
                  , q = (j.fromValues(0, 0),
                j.fromValues(0, 0));
                K.prototype.hitTest = function(t, e, o) {
                    o = o || 0;
                    var i = new z({
                        position: t
                    })
                      , n = new E
                      , s = t
                      , a = B
                      , r = q;
                    i.addShape(n);
                    for (var c = this.narrowphase, h = [], l = 0, p = e.length; l !== p; l++)
                        for (var u = e[l], d = 0, f = u.shapes.length; d !== f; d++) {
                            var v = u.shapes[d];
                            j.rotate(a, v.position, u.angle),
                            j.add(a, a, u.position);
                            var y = v.angle + u.angle;
                            (v instanceof m && c.circleParticle(u, v, a, y, i, n, s, 0, !0) || v instanceof g && c.particleConvex(i, n, s, 0, u, v, a, y, !0) || v instanceof A && c.particlePlane(i, n, s, 0, u, v, a, y, !0) || v instanceof b && c.particleCapsule(i, n, s, 0, u, v, a, y, !0) || v instanceof E && j.squaredLength(j.sub(r, a, t)) < o * o) && h.push(u)
                        }
                    return h
                }
                ,
                K.prototype.setGlobalStiffness = function(t) {
                    for (var e = this.constraints, o = 0; o !== e.length; o++)
                        for (var i = e[o], n = 0; n !== i.equations.length; n++) {
                            var s = i.equations[n];
                            s.stiffness = t,
                            s.needsUpdate = !0
                        }
                    var a = this.contactMaterials;
                    for (o = 0; o !== a.length; o++) {
                        (i = a[o]).stiffness = i.frictionStiffness = t
                    }
                    (i = this.defaultContactMaterial).stiffness = i.frictionStiffness = t
                }
                ,
                K.prototype.setGlobalRelaxation = function(t) {
                    for (var e = 0; e !== this.constraints.length; e++)
                        for (var o = this.constraints[e], i = 0; i !== o.equations.length; i++) {
                            var n = o.equations[i];
                            n.relaxation = t,
                            n.needsUpdate = !0
                        }
                    for (e = 0; e !== this.contactMaterials.length; e++) {
                        (o = this.contactMaterials[e]).relaxation = o.frictionRelaxation = t
                    }
                    (o = this.defaultContactMaterial).relaxation = o.frictionRelaxation = t
                }
                ;
                var u = new r
                  , d = [];
                K.prototype.raycast = function(t, e) {
                    return e.getAABB(u),
                    this.broadphase.aabbQuery(this, u, d),
                    e.intersectBodies(t, d),
                    d.length = 0,
                    t.hasHit()
                }
            }
            , {
                "../../package.json": 6,
                "../collision/AABB": 7,
                "../collision/Broadphase": 8,
                "../collision/Narrowphase": 10,
                "../collision/Ray": 11,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/LinearSpring": 32,
                "../objects/RotationalSpring": 33,
                "../shapes/Capsule": 38,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Line": 42,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45,
                "../solver/GSSolver": 46,
                "../solver/Solver": 47,
                "../utils/OverlapKeeper": 52,
                "../utils/Utils": 57,
                "./IslandManager": 59
            }]
        }, {}, [36])(36)
    });
    (function() {
        var t, i, r, e;
        t = this.Phaser,
        i = t.Camera.prototype.boot,
        r = t.Camera.prototype.follow,
        e = t.Camera.prototype.unfollow,
        t.Camera.prototype.boot = function() {
            return i.apply(this, arguments),
            this.targetOffset = new t.Point,
            this
        }
        ,
        t.Camera.prototype.follow = function(t, i, e, s, h, o) {
            var a;
            return a = r.call(this, t, i, e, s),
            null != h && null != o && this.targetOffset.set(h, o),
            this.lockX && (this.x = this.lockX),
            a
        }
        ,
        t.Camera.prototype.unfollow = function() {
            var t;
            return t = e.call(this, arguments),
            this.targetOffset.set(0),
            t
        }
        ,
        t.Camera.prototype.updateTarget = function() {
            this._targetPosition.x = this.view.x + this.target.worldPosition.x,
            this._targetPosition.y = this.view.y + this.target.worldPosition.y,
            this._targetPosition.x += this.targetOffset.x,
            this._targetPosition.y += this.targetOffset.y,
            this.deadzone ? (this._edge = this._targetPosition.x - this.view.x,
            this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)),
            this._edge = this._targetPosition.y - this.view.y,
            this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x),
            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)),
            this.bounds && this.checkBounds(),
            this.roundPx && this.view.floor(),
            this.displayObject.position.x = -this.view.x,
            this.displayObject.position.y = -this.view.y
        }
    }
    ).call(this);
    var Checkbox = function(e) {
        var a = this
          , i = e || {};
        a.children = [],
        a.asterisks = i.asterisks,
        a.yTop = i.yTop || 0,
        a.playhead = 0,
        a.fallTime = i.fallTime || 5e3,
        a.active = !1,
        a.isComplete = !1,
        a.scrollSpeed = i.scrollSpeed || .6,
        a.textScrollSpeed = i.textScrollSpeed || .6,
        a.mask = i.mask || game.add.graphics(100, 1760),
        a.text = i.text || game.add.image(100, 1760, "terms"),
        a.text.visible = !1,
        a.mask.drawRect(0, 0, a.mask.y - 40, 940),
        a.check = i.check || game.add.image(762, a.yTop + 1034, "spritesheet", "background/check.png"),
        a.show = function() {
            a.asterisks.mask = a.mask,
            a.text.mask = a.mask,
            a.text.visible = !0,
            a.asterisks.visible = !0;
            for (var e = 0; e < a.asterisks.children.length; e++)
                a.asterisks.children[e].visible = !0
        }
        ,
        a.hide = function() {
            a.text.visible = !1,
            a.asterisks.visible = !1;
            for (var e = 0; e < a.asterisks.children.length; e++)
                a.asterisks.children[e].visible = !1
        }
        ,
        a.start = function() {
            a.isComplete || (a.active = !0,
            player.lastYVel = player.body.velocity.y,
            player.body.velocity.y = 0,
            player.fallLock = !0,
            player.body.allowGravity = !1,
            a.check.visible = !1)
        }
        ,
        a.updateScroll = function() {
            a.playhead += game.time.elapsed,
            a.asterisks.y -= a.scrollSpeed * game.time.elapsed,
            a.text.y -= a.scrollSpeed * a.textScrollSpeed * game.time.elapsed,
            a.playhead >= a.fallTime && a.complete()
        }
        ,
        a.update = function() {
            !a.alive && a.yTop >= game.camera.view.top && a.yTop <= game.camera.view.bottom ? (a.visible = !0,
            a.alive = !0,
            a.show()) : (a.alive && a.yTop < game.camera.view.top || a.alive && a.yTop > game.camera.view.bottom) && (a.visible = !1,
            a.alive = !1,
            a.hide(),
            a.reset())
        }
        ,
        a.reset = function() {
            a.playhead = 0,
            a.isComplete = !1,
            a.active = !1,
            a.asterisks.y = 0,
            a.text.y = a.yTop,
            player.body.allowGravity = !0,
            player.fallLock = !1,
            a.asterisks.forEach(function(e) {
                e.x = e.originalPosition.x,
                e.y = e.originalPosition.y
            })
        }
        ,
        a.complete = function() {
            a.active = !1,
            a.isComplete = !0,
            player.body.allowGravity = !0,
            player.body.velocity.y = player.lastYVel,
            player.fallLock = !1,
            a.check.visible = !0
        }
    };
    var Dropdown = function(e) {
        var o = this
          , i = e || {};
        if (o.children = [],
        o.isComplete = !1,
        o.active = !1,
        o.field = i.field || console.warn('this dropdown requires an attribute "field"'),
        o.image = i.image || console.warn('this dropdown requires an attribute "image"'),
        o.toHide = i.toHide,
        o.origin = i.origin,
        o.backgrounds = [],
        o.image.length)
            for (var a = 0; a < o.image.length; a++)
                o.image[a].originalY = o.image[a].position.y;
        else
            o.image.originalY = o.image.position.y;
        o.placeholder = game.add.image(o.origin.x + 25, o.origin.y + 40, "spritesheet", i.placeholder),
        o.placeholder.alpha = .1,
        o.backgrounds.push(o.placeholder),
        o.arrow = game.add.image(o.origin.x + 700, o.origin.y + 45, "spritesheet", i.arrow),
        o.backgrounds.push(o.arrow),
        o.options = [];
        for (a = 0; a < i.options.length; a++) {
            var n = game.add.image(o.origin.x + 25, o.origin.y + 160 * a + 40, "spritesheet", i.options[a]);
            n.alpha = .1,
            o.options.push(n)
        }
        o.showBackgrounds = function() {
            o.backgrounds.forEach(function(e) {
                e.visible = !0
            })
        }
        ,
        o.hideBackgrounds = function() {
            o.backgrounds.forEach(function(e) {
                e.visible = !1
            })
        }
        ,
        o.hide = function() {
            o.children.forEach(function(e) {
                e.visible = !1
            }),
            o.options.forEach(function(e) {
                e.visible = !1
            });
            for (var e = 0; e < groups.dropdowns.length; e++)
                groups.dropdowns[e].isComplete || groups.dropdowns[e].showBackgrounds()
        }
        ,
        o.show = function() {
            o.children.forEach(function(e) {
                e.visible = !0
            }),
            o.options.forEach(function(e) {
                e.visible = !0
            });
            for (var e = 0; e < groups.dropdowns.length; e++)
                groups.dropdowns[e].hideBackgrounds()
        }
        ,
        o.enter = function() {
            if (!o.isComplete && !o.active && !restarting && player.currentLocation == o.field) {
                collisions = o.field,
                o.active = !0;
                var e = 1200;
                if (o.image.length)
                    for (var i = 0; i < o.image.length; i++)
                        o.image[i].tween = game.add.tween(o.image[i].position),
                        o.image[i].tween.to({
                            y: o.image[i].position.y + 1400
                        }, e, Phaser.Easing.Quintic.InOut, !0);
                else
                    o.image.tween = game.add.tween(o.image.position),
                    o.image.tween.to({
                        y: o.image.position.y + 1400
                    }, e, Phaser.Easing.Quintic.InOut, !0);
                superHideInteractives(),
                superHideEnemies(),
                setTimeout(function() {
                    if (!player.dead && !restarting && player.currentLocation == o.field) {
                        zoomTo(2.2, 1500),
                        game.camera.lockX = 87,
                        groups.checkboxes.hide(),
                        labels.hide(),
                        heckles.hide(),
                        shadows.hide(),
                        o.show(),
                        menuBtn.visible = !1;
                        for (var e = 0; e < player.tallies.length; e++)
                            player.tallies[e].visible = !1
                    }
                }, 600),
                foreground.visible = !1,
                warpDowns.visible = !1,
                warpUps.visible = !1,
                vacuums.visible = !1
            }
        }
        ,
        o.reset = function() {
            if (o.hide(),
            o.image.length)
                for (var e = 0; e < o.image.length; e++)
                    o.image[e].tween && o.image[e].tween.pause(),
                    o.image[e].position.y = o.image[e].originalY;
            else
                o.image.tween && o.image.tween.pause(),
                o.image.position.y = o.image.originalY;
            o.isComplete = !1,
            o.active = !1
        }
        ,
        o.complete = function() {
            var e = 1200;
            if (zoomTo(1, e),
            o.options.forEach(function(e) {
                e.visible = !1
            }),
            o.image.length)
                for (var i = 0; i < o.image.length; i++)
                    o.image[i].tween = game.add.tween(o.image[i].position),
                    o.image[i].tween.to({
                        y: o.image[i].originalY
                    }, e, Phaser.Easing.Linear.InOut, !0);
            else
                o.image.tween = game.add.tween(o.image.position),
                o.image.tween.to({
                    y: o.image.originalY
                }, e, Phaser.Easing.Linear.InOut, !0);
            player.dropdownTween = game.add.tween(player.position),
            o.isComplete = !0,
            player.dropdownTween.to({
                y: player.y - 1160
            }, e, Phaser.Easing.Linear.None, !0),
            player.dropdownTween.onComplete.add(function() {
                o.exit()
            })
        }
        ,
        o.exit = function() {
            collisions = "default",
            o.active = !1,
            foreground.visible = !0,
            labels.show(),
            shadows.show(),
            warpDowns.visible = !0,
            warpUps.visible = !0,
            vacuums.visible = !0,
            game.camera.lockX = null,
            enemiesRenderable(!0),
            interactivesRenderable(!0),
            o.hide(),
            menuBtn.visible = !0;
            for (var e = 0; e < player.tallies.length; e++)
                player.tallies[e].visible = !0
        }
    };
    var initEnemy = function(n) {
        game.physics.enable(n, Phaser.Physics.ARCADE),
        n.group && groups[n.group].children.push(n),
        n.name && areas[n.name].enemies.push(n),
        n.body.allowGravity = !1,
        n.body.immovable = !0,
        n.position.x += 10,
        n.position.y += 10,
        n.originalPosition = {
            x: n.position.x,
            y: n.position.y
        },
        n.anchor.set(.5),
        n.body.setCircle(6),
        n.tweens = {},
        n.update = function() {
            n.noCull || (n.renderable && !n.dead && !n.alive && n.position.y >= game.camera.view.top && n.position.y <= game.camera.view.bottom ? n.revive() : (n.alive && n.position.y < game.camera.view.top || n.alive && n.position.y > game.camera.view.bottom) && n.kill()),
            n.fresh && n.reset()
        }
        ,
        n.die = function() {
            n.body.allowGravity = !0,
            n.body.immovable = !1,
            n.dead = !0;
            for (var e = game.rnd.integerInRange(200, 600), i = 0; !i; )
                i = game.rnd.integerInRange(-250, 250);
            for (var o = 0; !o; )
                o = game.rnd.integerInRange(-180, 180);
            for (var a in n.body.velocity.y = e,
            n.body.velocity.x = i,
            n.body.angularAcceleration = o,
            n.tweens)
                n.tweens[a].pause()
        }
        ,
        n.reset = function() {
            if (n.dead && (n.dead = !1),
            n.revive(),
            n.fresh = !0,
            n.tweens)
                for (var e in n.tweens)
                    n.tweens[e].resume(),
                    n.tweens[e].timeline[0].dt = 0;
            n.body.allowGravity = !1,
            n.body.immovable = !0,
            n.body.velocity.y = 0,
            n.body.velocity.x = 0,
            n.body.angularAcceleration = 0,
            n.body.angularVelocity = 0,
            n.scale.x = 1,
            n.scale.y = 1,
            n.position.set(n.originalPosition.x, n.originalPosition.y),
            n.angle = 0
        }
    };
    var areas = {};
    var jumpSound, deathSound, explosionSound, ding, returnCarriage, suckDown, suckUp, yesMusic, music = {}, typeSounds = {}, coinToneVolume = .1, coinTypeVolume = .25, initAudio = function() {
        (music = game.add.audio("maxo")).volume = .5,
        music.play(),
        music.loopFull(),
        (yesMusic = game.add.audio("ohya")).volume = .8,
        yesMusic.loopFull(),
        yesMusic.pause(),
        (jumpSound = game.add.audio("jump")).volume = .5,
        (deathSound = game.add.audio("death")).volume = .75,
        (explosionSound = game.add.audio("explosion")).volume = .5,
        (ding = game.add.sound("ding")).volume = .3,
        (returnCarriage = game.add.sound("return")).volume = .4,
        (suckDown = game.add.sound("suck-down")).volume = .6,
        (suckUp = game.add.sound("suck-up")).volume = .6;
        for (var o = 1; o <= 20; o++) {
            typeSounds[u = "type" + o] = game.add.audio(u),
            typeSounds[u].volume = coinTypeVolume
        }
        for (o = 1; o <= 4; o++) {
            var u;
            typeSounds[u = "tone" + o] = game.add.audio(u),
            typeSounds[u].volume = coinToneVolume
        }
    };
    var nameLabel, streetNameLabel, cityLabel, zipCodeLabel, countryLabel, emailLabel, verifyEmailLabel, homeNumberLabel, mobileNumberLabel, usernameLabel, passwordLabel, passwordConfirmLabel, paymentLabel, accountLabel, bankCodeLabel, accountNameLabel, streetNameBillingLabel, cityBillingLabel, zipCodeBillingLabel, countryBillingLabel, idTypeLabel, birthDateLabel, idNumberLabel, issueDateLabel, expirationDateLabel, issueStateLabel, taxIdLabel, termsAndConditionsLabel, privacyPolicyLabel, approveCreditLabel, nameShadowB, addressShadowT, addressShadowB, cityShadowT, cityShadowB, zipCodeShadowT, zipCodeShadowB, countryShadowT, countryShadowB, emailShadowT, emailShadowB, verifyEmailShadowT, verifyEmailShadowB, homeNumberShadowT, homeNumberShadowB, mobileNumberShadowT, mobileNumberShadowB, usernameShadowT, usernameShadowB, passwordShadowT, passwordShadowB, passwordConfirmShadowT, passwordConfirmShadowB, paymentShadowT, paymentShadowB, accountShadowT, accountShadowB, bankCodeShadowT, bankCodeShadowB, accountNameShadowT, accountNameShadowB, streetNameShadowT, streetNameShadowB, cityBillingShadowT, cityBillingShadowB, zipCodeBillingShadowT, zipCodeBillingShadowB, countryBillingShadowT, countryBillingShadowB, idTypeShadowT, idTypeShadowB, birthDateShadow1T, birthDateShadow1B, birthDateShadow2T, birthDateShadow2B, birthDateShadow3T, birthDateShadow3B, idNumberShadowT, idNumberShadowB, issueDateShadow1T, issueDateShadow1B, issueDateShadow2T, issueDateShadow2B, issueDateShadow3T, issueDateShadow3B, expirationDateShadow1T, expirationDateShadow1B, expirationDateShadow2T, expirationDateShadow2B, expirationDateShadow3T, expirationDateShadow3B, issueStateShadowT, issueStateShadowB, taxIdShadowT, taxIdShadowB, termsShadowT, termsShadowB, privacyShadowT, privacyShadowB, creditShadowT, creditShadowB, yesButtonBg, yesButton, dropdownHighlightGreen, dropdownHighlightBlue, pressEnter, fieldImages, labels = {
        children: []
    }, heckles = {
        children: []
    }, shadows = {
        children: []
    }, skippingGame = !1;
    labels.hide = function() {
        for (var e = 0; e < labels.children.length; e++)
            labels.children[e].visible = !1
    }
    ,
    labels.show = function() {
        for (var e = 0; e < labels.children.length; e++)
            labels.children[e].visible = !0
    }
    ,
    shadows.hide = function() {
        for (var e = 0; e < shadows.children.length; e++)
            shadows.children[e].visible = !1
    }
    ,
    shadows.show = function() {
        for (var e = 0; e < shadows.children.length; e++)
            shadows.children[e].visible = !0
    }
    ,
    heckles.hide = function() {
        for (var e = 0; e < heckles.children.length; e++)
            heckles.children[e].visible = !1
    }
    ,
    heckles.show = function() {
        for (var e = 0; e < heckles.children.length; e++)
            heckles.children[e].visible = !0
    }
    ;
    var initBackground = function() {
        (pressEnter = game.add.image(game.world.centerX, game.height - 120, "spritesheet", "background/enter-to-restart.png")).anchor.set(.5),
        pressEnter.cacheAsBitmap = !0,
        pressEnter.visible = !1,
        pressEnter.fixedToCamera = !0,
        (dropdownHighlightBlue = game.add.group()).visible = !1;
        var e = game.add.image(1, 2, "spritesheet", "fields/dropdown-blue-top.png");
        dropdownHighlightBlue.add(e);
        var i = game.add.image(-1, 1275, "spritesheet", "fields/dropdown-blue-bottom.png");
        dropdownHighlightBlue.add(i);
        var l = game.add.image(-1, 29, "spritesheet", "fields/dropdown-blue-left.png");
        dropdownHighlightBlue.add(l);
        var a = game.add.image(806, 29, "spritesheet", "fields/dropdown-blue-right.png");
        dropdownHighlightBlue.add(a),
        (dropdownHighlightGreen = game.add.group()).visible = !1;
        var t = game.add.image(1, 2, "spritesheet", "fields/dropdown-green-top.png");
        dropdownHighlightGreen.add(t);
        var s = game.add.image(-1, 1275, "spritesheet", "fields/dropdown-green-bottom.png");
        dropdownHighlightGreen.add(s);
        var n = game.add.image(-1, 29, "spritesheet", "fields/dropdown-green-left.png");
        dropdownHighlightGreen.add(n);
        var d = game.add.image(806, 29, "spritesheet", "fields/dropdown-green-right.png");
        dropdownHighlightGreen.add(d),
        dropdownHighlightRed = game.add.group(),
        dropdownHighlightRed.visible = !1;
        var g = game.add.image(1, 2, "spritesheet", "fields/dropdown-red-top.png");
        dropdownHighlightRed.add(g);
        var o = game.add.image(-1, 1275, "spritesheet", "fields/dropdown-red-bottom.png");
        dropdownHighlightRed.add(o);
        var p = game.add.image(-1, 29, "spritesheet", "fields/dropdown-red-left.png");
        dropdownHighlightRed.add(p);
        var h = game.add.image(806, 29, "spritesheet", "fields/dropdown-red-right.png");
        dropdownHighlightRed.add(h),
        giantHighlightBlue = game.add.group(),
        giantHighlightBlue.visible = !1;
        e = game.add.image(0, 0, "spritesheet", "fields/big-field-blue-top.png");
        giantHighlightBlue.add(e);
        i = game.add.image(0, 1e3, "spritesheet", "fields/big-field-blue-bottom.png");
        giantHighlightBlue.add(i);
        l = game.add.image(0, 26, "spritesheet", "fields/big-field-blue-left.png");
        giantHighlightBlue.add(l);
        a = game.add.image(1686, 26, "spritesheet", "fields/big-field-blue-right.png");
        giantHighlightBlue.add(a),
        giantHighlightGreen = game.add.group(),
        giantHighlightGreen.visible = !1;
        t = game.add.image(0, 0, "spritesheet", "fields/big-field-green-top.png");
        giantHighlightGreen.add(t);
        s = game.add.image(0, 1e3, "spritesheet", "fields/big-field-green-bottom.png");
        giantHighlightGreen.add(s);
        n = game.add.image(0, 26, "spritesheet", "fields/big-field-green-left.png");
        giantHighlightGreen.add(n);
        d = game.add.image(1686, 26, "spritesheet", "fields/big-field-green-right.png");
        giantHighlightGreen.add(d),
        giantHighlightRed = game.add.group(),
        giantHighlightRed.visible = !1;
        g = game.add.image(0, 0, "spritesheet", "fields/big-field-red-top.png");
        giantHighlightRed.add(g);
        o = game.add.image(0, 1e3, "spritesheet", "fields/big-field-red-bottom.png");
        giantHighlightRed.add(o);
        p = game.add.image(0, 26, "spritesheet", "fields/big-field-red-left.png");
        giantHighlightRed.add(p);
        h = game.add.image(1686, 26, "spritesheet", "fields/big-field-red-right.png");
        giantHighlightRed.add(h),
        fieldImages = {
            name: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 400
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 400
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 323
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 323
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 323
                    }
                }
            },
            streetName: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 680
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 680
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 603
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 603
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 603
                    }
                }
            },
            city: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 960
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 960
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 883
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 883
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 883
                    }
                }
            },
            zipCode: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 960
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 960
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 1014,
                        y: 883
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 1014,
                        y: 883
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 1014,
                        y: 883
                    }
                }
            },
            country: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 1240
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 1240
                    }
                },
                greenOutline: {
                    image: dropdownHighlightGreen,
                    position: {
                        x: 110,
                        y: 1147
                    }
                },
                redOutline: {
                    image: dropdownHighlightRed,
                    position: {
                        x: 110,
                        y: 1147
                    }
                },
                blueOutline: {
                    image: dropdownHighlightBlue,
                    position: {
                        x: 110,
                        y: 1147
                    }
                }
            },
            email: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 1520
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 1520
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 1443
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 1443
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 1443
                    }
                }
            },
            verifyEmail: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 1800
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 1800
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 1723
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 1723
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 1723
                    }
                }
            },
            homeNumber: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 2080
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 2080
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 2003
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 2003
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 2003
                    }
                }
            },
            mobileNumber: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 2080
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 2080
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 1014,
                        y: 2003
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 1014,
                        y: 2003
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 1014,
                        y: 2003
                    }
                }
            },
            username: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 2360
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 2360
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 2283
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 2283
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 2283
                    }
                }
            },
            password: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 2640
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 2640
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 2563
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 2563
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 2563
                    }
                }
            },
            passwordConfirm: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 2640
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 2640
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 1014,
                        y: 2563
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 1014,
                        y: 2563
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 1014,
                        y: 2563
                    }
                }
            },
            payment: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 2920
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 2920
                    }
                },
                greenOutline: {
                    image: dropdownHighlightGreen,
                    position: {
                        x: 112,
                        y: 2829
                    }
                },
                redOutline: {
                    image: dropdownHighlightRed,
                    position: {
                        x: 112,
                        y: 2829
                    }
                },
                blueOutline: {
                    image: dropdownHighlightBlue,
                    position: {
                        x: 112,
                        y: 2829
                    }
                }
            },
            account: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 3200
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 3200
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 3123
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 3123
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 3123
                    }
                }
            },
            bankCode: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 3480
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 3480
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 3403
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 3403
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 3403
                    }
                }
            },
            accountName: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 3760
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 3760
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 3683
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 3683
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 3683
                    }
                }
            },
            streetNameBilling: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 4040
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 4040
                    }
                },
                greenOutline: {
                    image: "fields/full-field-green.png",
                    position: {
                        x: 133,
                        y: 3963
                    }
                },
                redOutline: {
                    image: "fields/full-field-red.png",
                    position: {
                        x: 133,
                        y: 3963
                    }
                },
                blueOutline: {
                    image: "fields/full-field-blue.png",
                    position: {
                        x: 133,
                        y: 3963
                    }
                }
            },
            cityBilling: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 4320
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 4320
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 4243
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 4243
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 4243
                    }
                }
            },
            zipCodeBilling: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 4320
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 4320
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 1014,
                        y: 4243
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 1014,
                        y: 4243
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 1014,
                        y: 4243
                    }
                }
            },
            countryBilling: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 4600
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 4600
                    }
                },
                greenOutline: {
                    image: dropdownHighlightGreen,
                    position: {
                        x: 112,
                        y: 4509
                    }
                },
                redOutline: {
                    image: dropdownHighlightRed,
                    position: {
                        x: 112,
                        y: 4509
                    }
                },
                blueOutline: {
                    image: dropdownHighlightBlue,
                    position: {
                        x: 112,
                        y: 4509
                    }
                }
            },
            idType: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 4880
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 4880
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 4803
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 4803
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 4803
                    }
                }
            },
            birthDate: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 5160
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 5160
                    }
                },
                greenOutline: {
                    image: "fields/date-field-green.png",
                    position: {
                        x: 135,
                        y: 5084
                    }
                },
                redOutline: {
                    image: "fields/date-field-red.png",
                    position: {
                        x: 135,
                        y: 5084
                    }
                },
                blueOutline: {
                    image: "fields/date-field-blue.png",
                    position: {
                        x: 135,
                        y: 5084
                    }
                }
            },
            idNumber: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 5160
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 5160
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 1014,
                        y: 5083
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 1014,
                        y: 5083
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 1014,
                        y: 5083
                    }
                }
            },
            issueDate: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 5440
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 5440
                    }
                },
                greenOutline: {
                    image: "fields/date-field-green.png",
                    position: {
                        x: 135,
                        y: 5364
                    }
                },
                redOutline: {
                    image: "fields/date-field-red.png",
                    position: {
                        x: 135,
                        y: 5364
                    }
                },
                blueOutline: {
                    image: "fields/date-field-blue.png",
                    position: {
                        x: 135,
                        y: 5364
                    }
                }
            },
            expirationDate: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 5440
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 5440
                    }
                },
                greenOutline: {
                    image: "fields/date-field-green.png",
                    position: {
                        x: 1015,
                        y: 5364
                    }
                },
                redOutline: {
                    image: "fields/date-field-red.png",
                    position: {
                        x: 1015,
                        y: 5364
                    }
                },
                blueOutline: {
                    image: "fields/date-field-blue.png",
                    position: {
                        x: 1015,
                        y: 5364
                    }
                }
            },
            issueState: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 5720
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 5720
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 5643
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 5643
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 5643
                    }
                }
            },
            taxId: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 850,
                        y: 6e3
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 850,
                        y: 6e3
                    }
                },
                greenOutline: {
                    image: "fields/half-field-green.png",
                    position: {
                        x: 134,
                        y: 5923
                    }
                },
                redOutline: {
                    image: "fields/half-field-red.png",
                    position: {
                        x: 134,
                        y: 5923
                    }
                },
                blueOutline: {
                    image: "fields/half-field-blue.png",
                    position: {
                        x: 134,
                        y: 5923
                    }
                }
            },
            terms: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 7100
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 7100
                    }
                },
                greenOutline: {
                    image: giantHighlightGreen,
                    position: {
                        x: 106,
                        y: 6186
                    }
                },
                redOutline: {
                    image: giantHighlightRed,
                    position: {
                        x: 106,
                        y: 6186
                    }
                },
                blueOutline: {
                    image: giantHighlightBlue,
                    position: {
                        x: 106,
                        y: 6186
                    }
                }
            },
            privacy: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 8300
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 8300
                    }
                },
                greenOutline: {
                    image: giantHighlightGreen,
                    position: {
                        x: 106,
                        y: 7386
                    }
                },
                redOutline: {
                    image: giantHighlightRed,
                    position: {
                        x: 106,
                        y: 7386
                    }
                },
                blueOutline: {
                    image: giantHighlightBlue,
                    position: {
                        x: 106,
                        y: 7386
                    }
                }
            },
            credit: {
                stamp: {
                    image: "tiles/stamp.png",
                    position: {
                        x: 1730,
                        y: 9500
                    }
                },
                strike: {
                    image: "tiles/strike.png",
                    position: {
                        x: 1730,
                        y: 9500
                    }
                },
                greenOutline: {
                    image: giantHighlightGreen,
                    position: {
                        x: 106,
                        y: 8586
                    }
                },
                redOutline: {
                    image: giantHighlightRed,
                    position: {
                        x: 106,
                        y: 8586
                    }
                },
                blueOutline: {
                    image: giantHighlightBlue,
                    position: {
                        x: 106,
                        y: 8586
                    }
                }
            }
        },
        (yesButton = game.add.sprite(1500, 55, "spritesheet", "yes-button/yes-button-00.png")).inputEnabled = !0,
        yesButton.scale.set(1),
        yesButton.animations.add("not-pressed", ["yes-button/yes-button-00.png", "yes-button/yes-button-01.png", "yes-button/yes-button-02.png", "yes-button/yes-button-03.png", "yes-button/yes-button-04.png", "yes-button/yes-button-05.png", "yes-button/yes-button-06.png", "yes-button/yes-button-00.png"], 5, !1),
        yesButton.play("not-pressed"),
        yesButton.animations.add("press-down", ["yes-button/yes-button-00.png", "yes-button/yes-button-01.png", "yes-button/yes-button-02.png", "yes-button/yes-button-03.png", "yes-button/yes-button-04.png", "yes-button/yes-button-05.png", "yes-button/yes-button-06.png", "yes-button/yes-button-00.png"], 5, !1),
        yesButton.events.onInputDown.add(function() {
            skippingGame || (skippingGame = !0,
            yesButton.play("press-down"),
            music.pause(),
            yesMusic.restart(),
            yesMusic.loopFull(),
            yesMusic.volume = .7,
            setTimeout(function() {
                skipGame()
            }, 400))
        }),
        yesButtonBg = game.add.image(1020, 80, "spritesheet", "yes-button/yes-button-bg.png"),
        thankYouButton = game.add.image(1230, 9820, "spritesheet", "background/finish-active.png"),
        thankYouButton.alpha = .33,
        (nameLabel = game.add.image(130, 266, "spritesheet", "labels/label01.png")).cacheAsBitmap = !0,
        nameLabel.autoCull = !0,
        labels.children.push(nameLabel),
        (streetNameLabel = game.add.image(130, 546, "spritesheet", "labels/label02.png")).cacheAsBitmap = !0,
        streetNameLabel.autoCull = !0,
        labels.children.push(streetNameLabel),
        (cityLabel = game.add.image(130, 826, "spritesheet", "labels/label03.png")).cacheAsBitmap = !0,
        cityLabel.autoCull = !0,
        labels.children.push(cityLabel),
        (zipCodeLabel = game.add.image(1012, 826, "spritesheet", "labels/label04.png")).cacheAsBitmap = !0,
        zipCodeLabel.autoCull = !0,
        labels.children.push(zipCodeLabel),
        (countryLabel = game.add.image(130, 1106, "spritesheet", "labels/label05.png")).cacheAsBitmap = !0,
        countryLabel.autoCull = !0,
        labels.children.push(countryLabel),
        (emailLabel = game.add.image(130, 1386, "spritesheet", "labels/label06.png")).cacheAsBitmap = !0,
        emailLabel.autoCull = !0,
        labels.children.push(emailLabel),
        (verifyEmailLabel = game.add.image(130, 1666, "spritesheet", "labels/label07.png")).cacheAsBitmap = !0,
        verifyEmailLabel.autoCull = !0,
        labels.children.push(verifyEmailLabel),
        (homeNumberLabel = game.add.image(130, 1946, "spritesheet", "labels/label08.png")).cacheAsBitmap = !0,
        homeNumberLabel.autoCull = !0,
        labels.children.push(homeNumberLabel),
        (mobileNumberLabel = game.add.image(1012, 1946, "spritesheet", "labels/label09.png")).cacheAsBitmap = !0,
        mobileNumberLabel.autoCull = !0,
        labels.children.push(mobileNumberLabel),
        (usernameLabel = game.add.image(130, 2226, "spritesheet", "labels/label10.png")).cacheAsBitmap = !0,
        usernameLabel.autoCull = !0,
        labels.children.push(usernameLabel),
        (passwordLabel = game.add.image(130, 2506, "spritesheet", "labels/label11.png")).cacheAsBitmap = !0,
        passwordLabel.autoCull = !0,
        labels.children.push(passwordLabel),
        (passwordConfirmLabel = game.add.image(1012, 2506, "spritesheet", "labels/label12.png")).cacheAsBitmap = !0,
        passwordConfirmLabel.autoCull = !0,
        labels.children.push(passwordConfirmLabel),
        (paymentLabel = game.add.image(130, 2786, "spritesheet", "labels/label13.png")).cacheAsBitmap = !0,
        paymentLabel.autoCull = !0,
        labels.children.push(paymentLabel),
        (accountLabel = game.add.image(130, 3066, "spritesheet", "labels/label14.png")).cacheAsBitmap = !0,
        accountLabel.autoCull = !0,
        labels.children.push(accountLabel),
        (bankCodeLabel = game.add.image(130, 3346, "spritesheet", "labels/label15.png")).cacheAsBitmap = !0,
        bankCodeLabel.autoCull = !0,
        labels.children.push(bankCodeLabel),
        (accountNameLabel = game.add.image(130, 3626, "spritesheet", "labels/label16.png")).cacheAsBitmap = !0,
        accountNameLabel.autoCull = !0,
        labels.children.push(accountNameLabel),
        (streetNameBillingLabel = game.add.image(130, 3906, "spritesheet", "labels/label17.png")).cacheAsBitmap = !0,
        streetNameBillingLabel.autoCull = !0,
        labels.children.push(streetNameBillingLabel),
        (cityBillingLabel = game.add.image(130, 4186, "spritesheet", "labels/label18.png")).cacheAsBitmap = !0,
        cityBillingLabel.autoCull = !0,
        labels.children.push(cityBillingLabel),
        (zipCodeBillingLabel = game.add.image(1012, 4186, "spritesheet", "labels/label19.png")).cacheAsBitmap = !0,
        zipCodeBillingLabel.autoCull = !0,
        labels.children.push(zipCodeBillingLabel),
        (countryBillingLabel = game.add.image(130, 4466, "spritesheet", "labels/label20.png")).cacheAsBitmap = !0,
        countryBillingLabel.autoCull = !0,
        labels.children.push(countryBillingLabel),
        (idTypeLabel = game.add.image(130, 4746, "spritesheet", "labels/label21.png")).cacheAsBitmap = !0,
        idTypeLabel.autoCull = !0,
        labels.children.push(idTypeLabel),
        (birthDateLabel = game.add.image(130, 5026, "spritesheet", "labels/label22.png")).cacheAsBitmap = !0,
        birthDateLabel.autoCull = !0,
        labels.children.push(birthDateLabel),
        (idNumberLabel = game.add.image(1012, 5026, "spritesheet", "labels/label23.png")).cacheAsBitmap = !0,
        idNumberLabel.autoCull = !0,
        labels.children.push(idNumberLabel),
        (issueDateLabel = game.add.image(130, 5306, "spritesheet", "labels/label24.png")).cacheAsBitmap = !0,
        issueDateLabel.autoCull = !0,
        labels.children.push(issueDateLabel),
        (expirationDateLabel = game.add.image(1012, 5306, "spritesheet", "labels/label25.png")).cacheAsBitmap = !0,
        expirationDateLabel.autoCull = !0,
        labels.children.push(expirationDateLabel),
        (issueStateLabel = game.add.image(130, 5586, "spritesheet", "labels/label26.png")).cacheAsBitmap = !0,
        issueStateLabel.autoCull = !0,
        labels.children.push(issueStateLabel),
        (taxIdLabel = game.add.image(130, 5866, "spritesheet", "labels/label27.png")).cacheAsBitmap = !0,
        taxIdLabel.autoCull = !0,
        labels.children.push(taxIdLabel),
        (termsAndConditionsLabel = game.add.image(130, 6146, "spritesheet", "labels/label28.png")).cacheAsBitmap = !0,
        termsAndConditionsLabel.autoCull = !0,
        labels.children.push(termsAndConditionsLabel),
        (privacyPolicyLabel = game.add.image(130, 7346, "spritesheet", "labels/label29.png")).cacheAsBitmap = !0,
        privacyPolicyLabel.autoCull = !0,
        labels.children.push(privacyPolicyLabel),
        (approveCreditLabel = game.add.image(130, 8546, "spritesheet", "labels/label30.png")).cacheAsBitmap = !0,
        approveCreditLabel.autoCull = !0,
        labels.children.push(approveCreditLabel),
        nameHeckle = game.add.image(130, 490, "spritesheet", "heckling/heckling01.png"),
        nameHeckle.cacheAsBitmap = !0,
        nameHeckle.autoCull = !0,
        fieldImages.name.heckle = nameHeckle,
        nameHeckle.visible = !1,
        heckles.children.push(nameHeckle),
        streetNameHeckle = game.add.image(130, 770, "spritesheet", "heckling/heckling02.png"),
        streetNameHeckle.cacheAsBitmap = !0,
        streetNameHeckle.autoCull = !0,
        fieldImages.streetName.heckle = streetNameHeckle,
        streetNameHeckle.visible = !1,
        heckles.children.push(streetNameHeckle),
        cityHeckle = game.add.image(130, 1050, "spritesheet", "heckling/heckling03.png"),
        cityHeckle.cacheAsBitmap = !0,
        cityHeckle.autoCull = !0,
        fieldImages.city.heckle = cityHeckle,
        cityHeckle.visible = !1,
        heckles.children.push(cityHeckle),
        zipCodeHeckle = game.add.image(1012, 1050, "spritesheet", "heckling/heckling04.png"),
        zipCodeHeckle.cacheAsBitmap = !0,
        zipCodeHeckle.autoCull = !0,
        fieldImages.zipCode.heckle = zipCodeHeckle,
        zipCodeHeckle.visible = !1,
        heckles.children.push(zipCodeHeckle),
        emailHeckle = game.add.image(130, 1610, "spritesheet", "heckling/heckling06.png"),
        emailHeckle.cacheAsBitmap = !0,
        emailHeckle.autoCull = !0,
        fieldImages.email.heckle = emailHeckle,
        emailHeckle.visible = !1,
        heckles.children.push(emailHeckle),
        verifyEmailHeckle = game.add.image(130, 1890, "spritesheet", "heckling/heckling07.png"),
        verifyEmailHeckle.cacheAsBitmap = !0,
        verifyEmailHeckle.autoCull = !0,
        fieldImages.verifyEmail.heckle = verifyEmailHeckle,
        verifyEmailHeckle.visible = !1,
        heckles.children.push(verifyEmailHeckle),
        homeNumberHeckle = game.add.image(130, 2170, "spritesheet", "heckling/heckling08.png"),
        homeNumberHeckle.cacheAsBitmap = !0,
        homeNumberHeckle.autoCull = !0,
        fieldImages.homeNumber.heckle = homeNumberHeckle,
        homeNumberHeckle.visible = !1,
        heckles.children.push(homeNumberHeckle),
        mobileNumberHeckle = game.add.image(1012, 2170, "spritesheet", "heckling/heckling09.png"),
        mobileNumberHeckle.cacheAsBitmap = !0,
        mobileNumberHeckle.autoCull = !0,
        fieldImages.mobileNumber.heckle = mobileNumberHeckle,
        mobileNumberHeckle.visible = !1,
        heckles.children.push(mobileNumberHeckle),
        usernameHeckle = game.add.image(130, 2450, "spritesheet", "heckling/heckling10.png"),
        usernameHeckle.cacheAsBitmap = !0,
        usernameHeckle.autoCull = !0,
        fieldImages.username.heckle = usernameHeckle,
        usernameHeckle.visible = !1,
        heckles.children.push(usernameHeckle),
        passwordHeckle = game.add.image(130, 2730, "spritesheet", "heckling/heckling11.png"),
        passwordHeckle.cacheAsBitmap = !0,
        passwordHeckle.autoCull = !0,
        fieldImages.password.heckle = passwordHeckle,
        passwordHeckle.visible = !1,
        heckles.children.push(passwordHeckle),
        passwordConfirmHeckle = game.add.image(1012, 2730, "spritesheet", "heckling/heckling12.png"),
        passwordConfirmHeckle.cacheAsBitmap = !0,
        passwordConfirmHeckle.autoCull = !0,
        fieldImages.passwordConfirm.heckle = passwordConfirmHeckle,
        passwordConfirmHeckle.visible = !1,
        heckles.children.push(passwordConfirmHeckle),
        accountHeckle = game.add.image(130, 3290, "spritesheet", "heckling/heckling14.png"),
        accountHeckle.cacheAsBitmap = !0,
        accountHeckle.autoCull = !0,
        fieldImages.account.heckle = accountHeckle,
        accountHeckle.visible = !1,
        heckles.children.push(accountHeckle),
        bankCodeHeckle = game.add.image(130, 3570, "spritesheet", "heckling/heckling15.png"),
        bankCodeHeckle.cacheAsBitmap = !0,
        bankCodeHeckle.autoCull = !0,
        fieldImages.bankCode.heckle = bankCodeHeckle,
        bankCodeHeckle.visible = !1,
        heckles.children.push(bankCodeHeckle),
        accountNameHeckle = game.add.image(130, 3850, "spritesheet", "heckling/heckling16.png"),
        accountNameHeckle.cacheAsBitmap = !0,
        accountNameHeckle.autoCull = !0,
        fieldImages.accountName.heckle = accountNameHeckle,
        accountNameHeckle.visible = !1,
        heckles.children.push(accountNameHeckle),
        streetNameBillingHeckle = game.add.image(130, 4130, "spritesheet", "heckling/heckling17.png"),
        streetNameBillingHeckle.cacheAsBitmap = !0,
        streetNameBillingHeckle.autoCull = !0,
        fieldImages.streetNameBilling.heckle = streetNameBillingHeckle,
        streetNameBillingHeckle.visible = !1,
        heckles.children.push(streetNameBillingHeckle),
        cityBillingHeckle = game.add.image(130, 4410, "spritesheet", "heckling/heckling18.png"),
        cityBillingHeckle.cacheAsBitmap = !0,
        cityBillingHeckle.autoCull = !0,
        fieldImages.cityBilling.heckle = cityBillingHeckle,
        cityBillingHeckle.visible = !1,
        heckles.children.push(cityBillingHeckle),
        zipCodeBillingHeckle = game.add.image(1012, 4410, "spritesheet", "heckling/heckling19.png"),
        zipCodeBillingHeckle.cacheAsBitmap = !0,
        zipCodeBillingHeckle.autoCull = !0,
        fieldImages.zipCodeBilling.heckle = zipCodeBillingHeckle,
        zipCodeBillingHeckle.visible = !1,
        heckles.children.push(zipCodeBillingHeckle),
        idTypeHeckle = game.add.image(130, 4970, "spritesheet", "heckling/heckling21.png"),
        idTypeHeckle.cacheAsBitmap = !0,
        idTypeHeckle.autoCull = !0,
        fieldImages.idType.heckle = idTypeHeckle,
        idTypeHeckle.visible = !1,
        heckles.children.push(idTypeHeckle),
        birthDateHeckle = game.add.image(130, 5250, "spritesheet", "heckling/heckling22.png"),
        birthDateHeckle.cacheAsBitmap = !0,
        birthDateHeckle.autoCull = !0,
        fieldImages.birthDate.heckle = birthDateHeckle,
        birthDateHeckle.visible = !1,
        heckles.children.push(birthDateHeckle),
        idNumberHeckle = game.add.image(1012, 5250, "spritesheet", "heckling/heckling23.png"),
        idNumberHeckle.cacheAsBitmap = !0,
        idNumberHeckle.autoCull = !0,
        fieldImages.idNumber.heckle = idNumberHeckle,
        idNumberHeckle.visible = !1,
        heckles.children.push(idNumberHeckle),
        issueDateHeckle = game.add.image(130, 5530, "spritesheet", "heckling/heckling24.png"),
        issueDateHeckle.cacheAsBitmap = !0,
        issueDateHeckle.autoCull = !0,
        fieldImages.issueDate.heckle = issueDateHeckle,
        issueDateHeckle.visible = !1,
        heckles.children.push(issueDateHeckle),
        expirationDateHeckle = game.add.image(1012, 5530, "spritesheet", "heckling/heckling25.png"),
        expirationDateHeckle.cacheAsBitmap = !0,
        expirationDateHeckle.autoCull = !0,
        fieldImages.expirationDate.heckle = expirationDateHeckle,
        expirationDateHeckle.visible = !1,
        heckles.children.push(expirationDateHeckle),
        issueStateHeckle = game.add.image(130, 5810, "spritesheet", "heckling/heckling26.png"),
        issueStateHeckle.cacheAsBitmap = !0,
        issueStateHeckle.autoCull = !0,
        fieldImages.issueState.heckle = issueStateHeckle,
        issueStateHeckle.visible = !1,
        heckles.children.push(issueStateHeckle),
        taxIdHeckle = game.add.image(130, 6090, "spritesheet", "heckling/heckling27.png"),
        taxIdHeckle.cacheAsBitmap = !0,
        taxIdHeckle.autoCull = !0,
        fieldImages.taxId.heckle = taxIdHeckle,
        taxIdHeckle.visible = !1,
        heckles.children.push(taxIdHeckle);
        function r(e, i, l) {
            var a = game.add.image(e, i, "spritesheet", "background/shadow.png");
            return bgElements.add(a),
            a.cacheAsBitmap = !0,
            a.autoCull = !0,
            a.scale.y = l ? -1 : 1,
            a.y = l ? a.y + 15 : a.y - 15,
            a.alpha = 1,
            shadows.children.push(a),
            a
        }
        nameShadowB = r(1640, 480, !0),
        addressShadowT = r(1640, 600),
        addressShadowB = r(160, 760, !0),
        cityShadowT = r(160, 880),
        cityShadowB = r(760, 1040, !0),
        zipCodeShadowT = r(1040, 880),
        zipCodeShadowB = r(1640, 1040, !0),
        countryShadowT = r(160, 1160),
        countryShadowB = r(760, 1320, !0),
        emailShadowT = r(160, 1440),
        emailShadowB = r(1640, 1600, !0),
        verifyEmailShadowT = r(1640, 1720),
        verifyEmailShadowB = r(160, 1880, !0),
        homeNumberShadowT = r(160, 2e3),
        homeNumberShadowB = r(760, 2160, !0),
        mobileNumberShadowT = r(1040, 2e3),
        mobileNumberShadowB = r(1640, 2160, !0),
        usernameShadowT = r(160, 2280),
        usernameShadowB = r(1640, 2440, !0),
        passwordShadowT = r(160, 2560),
        passwordShadowB = r(760, 2720, !0),
        passwordConfirmShadowT = r(1040, 2560),
        passwordConfirmShadowB = r(1640, 2720, !0),
        paymentShadowT = r(160, 2840),
        paymentShadowB = r(760, 3e3, !0),
        paymentShadowT = r(160, 2840),
        paymentShadowB = r(760, 3e3, !0),
        accountShadowT = r(160, 3120),
        accountShadowB = r(1640, 3280, !0),
        bankCodeShadowT = r(1640, 3400),
        bankCodeShadowB = r(160, 3560, !0),
        accountNameShadowT = r(160, 3680),
        accountNameShadowB = r(1640, 3840, !0),
        streetNameShadowT = r(1640, 3960),
        streetNameShadowB = r(160, 4120, !0),
        cityBillingShadowT = r(160, 4240),
        cityBillingShadowB = r(760, 4400, !0),
        zipCodeBillingShadowT = r(1040, 4240),
        zipCodeBillingShadowB = r(1640, 4400, !0),
        countryBillingShadowT = r(160, 4520),
        countryBillingShadowB = r(760, 4680, !0),
        idTypeShadowT = r(160, 4800),
        idTypeShadowB = r(760, 4960, !0),
        birthDateShadow1T = r(160, 5080),
        birthDateShadow1B = r(160, 5240, !0),
        birthDateShadow2T = r(400, 5080),
        birthDateShadow2B = r(400, 5240, !0),
        birthDateShadow3T = r(640, 5080),
        birthDateShadow3B = r(760, 5240, !0),
        idNumberShadowT = r(1040, 5080),
        idNumberShadowB = r(1640, 5240, !0),
        issueDateShadow1T = r(160, 5360),
        issueDateShadow1B = r(160, 5520, !0),
        issueDateShadow2T = r(400, 5360),
        issueDateShadow2B = r(400, 5520, !0),
        issueDateShadow3T = r(640, 5360),
        issueDateShadow3B = r(760, 5520, !0),
        expirationDateShadow1T = r(1040, 5360),
        expirationDateShadow1B = r(1040, 5520, !0),
        expirationDateShadow2T = r(1280, 5360),
        expirationDateShadow2B = r(1280, 5520, !0),
        expirationDateShadow3T = r(1520, 5360),
        expirationDateShadow3B = r(1640, 5520, !0),
        issueStateShadowT = r(160, 5640),
        issueStateShadowB = r(760, 5800, !0),
        taxIdShadowT = r(760, 5920),
        taxIdShadowB = r(160, 6080, !0),
        termsShadowT = r(160, 6200),
        termsShadowB = r(640, 7200, !0),
        privacyShadowT = r(160, 7400),
        privacyShadowB = r(640, 8400, !0),
        creditShadowT = r(160, 8600),
        creditShadowB = r(640, 9600, !0)
    };
    var cursors, jumpButton, restartBtn, menuBtn, touchControlPadding = touchControlPaddingInit = 180, restarting = !1, fastFallSpeed = 50, initControls = function() {
        console.log("init controls"),
        !0 === game.device.desktop ? (cursors = game.input.keyboard.createCursorKeys(),
        jumpButton = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR),
        restartBtn = game.input.keyboard.addKey(Phaser.Keyboard.ENTER),
        game.input.keyboard.onDownCallback = function() {
            player.justRestarted && (areas[player.currentLocation].onActive(),
            player.justRestarted = !1,
            game.physics.arcade.isPaused = !1)
        }
        ) : (cursors = {
            layout: {
                current: "right",
                rightHanded: {
                    left: {
                        x: 170,
                        y: game.height - 275
                    },
                    right: {
                        x: 450,
                        y: game.height - 275
                    },
                    down: {
                        x: 1700,
                        y: game.height - 150
                    },
                    jump: {
                        x: 1700,
                        y: game.height - 425
                    }
                },
                leftHanded: {
                    left: {
                        x: 1420,
                        y: game.height - 275
                    },
                    right: {
                        x: 1700,
                        y: game.height - 275
                    },
                    down: {
                        x: 170,
                        y: game.height - 150
                    },
                    jump: {
                        x: 170,
                        y: game.height - 425
                    }
                }
            },
            up: {}
        },
        jumpButton = game.add.image(cursors.layout.rightHanded.jump.x, cursors.layout.rightHanded.jump.y, "spritesheet", "controls/control-up.png"),
        cursors.down = game.add.image(cursors.layout.rightHanded.down.x, cursors.layout.rightHanded.down.y, "spritesheet", "controls/control-down.png"),
        cursors.left = game.add.image(cursors.layout.rightHanded.left.x, cursors.layout.rightHanded.left.y, "spritesheet", "controls/control-left.png"),
        cursors.right = game.add.image(cursors.layout.rightHanded.right.x, cursors.layout.rightHanded.right.y, "spritesheet", "controls/control-right.png"),
        restartBtn = game.add.image(915, game.height - 120, "spritesheet", "controls/restart.png"),
        cursors.down.anchor.set(.5),
        cursors.left.anchor.set(.5),
        cursors.right.anchor.set(.5),
        jumpButton.anchor.set(.5),
        cursors.down.fixedToCamera = !0,
        cursors.left.fixedToCamera = !0,
        cursors.right.fixedToCamera = !0,
        jumpButton.fixedToCamera = !0,
        restartBtn.fixedToCamera = !0,
        cursors.down.init = {
            x: cursors.down.x,
            y: cursors.down.y
        },
        cursors.left.init = {
            x: cursors.left.x,
            y: cursors.left.y
        },
        cursors.right.init = {
            x: cursors.right.x,
            y: cursors.right.y
        },
        jumpButton.init = {
            x: jumpButton.x,
            y: jumpButton.y
        },
        restartBtn.init = {
            x: restartBtn.x,
            y: restartBtn.y
        },
        cursors.down.alpha = 1,
        cursors.left.alpha = 1,
        cursors.right.alpha = 1,
        jumpButton.alpha = 1,
        restartBtn.alpha = 1),
        (menuBtn = game.add.image(40, 78, "spritesheet", "controls/settings.png")).inputEnabled = !0,
        menuBtn.fixedToCamera = !0,
        menuBtn.init = {
            x: menuBtn.x,
            y: menuBtn.y
        },
        menuBtn.hitArea = new Phaser.Rectangle(-20,-20,60,60),
        menuBtn.events.onInputUp.add(function() {
            menuScreen ? hideMenu() : showMenu()
        })
    }, updateControlPositions = function() {
        jumpButton.fixedToCamera = !1,
        cursors.down.fixedToCamera = !1,
        cursors.left.fixedToCamera = !1,
        cursors.right.fixedToCamera = !1,
        restartBtn.fixedToCamera = !1,
        jumpButton.y = jumpButton.init.y = (game.height - 425) / zoom.y,
        cursors.down.y = cursors.down.init.y = (game.height - 150) / zoom.y,
        cursors.left.y = cursors.left.init.y = (game.height - 275) / zoom.y,
        cursors.right.y = cursors.right.init.y = (game.height - 275) / zoom.y,
        restartBtn.y = restartBtn.init.y = (game.height - 120) / zoom.y,
        jumpButton.fixedToCamera = !0,
        cursors.down.fixedToCamera = !0,
        cursors.left.fixedToCamera = !0,
        cursors.right.fixedToCamera = !0,
        restartBtn.fixedToCamera = !0
    }, updateControls = function() {
        if (1 != game.device.desktop) {
            cursors.down.isDown = !1,
            cursors.left.isDown = !1,
            cursors.right.isDown = !1,
            jumpButton.isDown = !1,
            restartBtn.isDown = !1;
            for (var r = 0; r < game.input.pointers.length; r++) {
                player.justRestarted && (player.justRestarted = !1,
                game.physics.arcade.isPaused = !1,
                areas[player.currentLocation].onActive());
                var o = game.input.pointers[r];
                o.active && game.physics.arcade.distanceToXY(cursors.down.cameraOffset, o.x, o.y) < touchControlPadding || cursors.down.isDown ? (cursors.down.isDown = !0,
                cursors.down.wasPressed = !0,
                cursors.down.loadTexture("spritesheet", "controls/control-down-pressed.png")) : cursors.down.wasPressed && (cursors.down.loadTexture("spritesheet", "controls/control-down.png"),
                cursors.down.wasPressed = !1),
                o.active && game.physics.arcade.distanceToXY(cursors.right.cameraOffset, o.x, o.y) < touchControlPadding || cursors.right.isDown ? (cursors.right.isDown = !0,
                cursors.right.wasPressed = !0,
                cursors.right.loadTexture("spritesheet", "controls/control-right-pressed.png")) : cursors.right.wasPressed && (cursors.right.loadTexture("spritesheet", "controls/control-right.png"),
                cursors.right.wasPressed = !1),
                o.active && game.physics.arcade.distanceToXY(cursors.left.cameraOffset, o.x, o.y) < touchControlPadding || cursors.left.isDown ? (cursors.left.isDown = !0,
                cursors.left.wasPressed = !0,
                cursors.left.loadTexture("spritesheet", "controls/control-left-pressed.png")) : cursors.left.wasPressed && (cursors.left.loadTexture("spritesheet", "controls/control-left.png"),
                cursors.left.wasPressed = !1),
                o.active && game.physics.arcade.distanceToXY(jumpButton.cameraOffset, o.x, o.y) < touchControlPadding || jumpButton.isDown ? (jumpButton.isDown = !0,
                jumpButton.wasPressed = !0,
                jumpButton.loadTexture("spritesheet", "controls/control-up-pressed.png")) : jumpButton.wasPressed && (jumpButton.loadTexture("spritesheet", "controls/control-up.png"),
                jumpButton.wasPressed = !1),
                (o.active && game.physics.arcade.distanceToXY(restartBtn.cameraOffset, o.x, o.y) < touchControlPadding || restartBtn.isDown) && (restartBtn.isDown = !0)
            }
        }
        player.isDead || controlOverride || stopTime || (controlPageGroup && (controlPageGroup.visible && cursors.left.isDown || cursors.right.isDown || cursors.down.isDown || jumpButton.isDown) && (controlPageGroup.visible = !1),
        player.body.onFloor() || "jumping" == player.body.state || player.justRestarted || (cursors.left.isDown ? player.animations.play("jump-left") : player.animations.play("jump-right"),
        player.body.setJumping(),
        facing = "jump"),
        player.body.onFloor() && "jumping" == player.body.state && "ducking" != player.body.state && player.body.setStanding(),
        cursors.left.isDown ? (player.body.acceleration.x = -accel,
        "left" != facing && player.body.onFloor() && (player.animations.play("left"),
        10 == player.frame && player.animations.currentAnim.setFrame(10, !0),
        facing = "left")) : cursors.right.isDown ? (player.body.acceleration.x = accel,
        "right" != facing && player.body.onFloor() && (player.animations.play("right"),
        10 == player.frame && player.animations.currentAnim.setFrame(10, !0),
        facing = "right")) : "idle" != facing && player.body.onFloor() && !cursors.down.isDown && (player.animations.play("idle"),
        10 == player.frame && player.animations.currentAnim.setFrame(10, !0),
        facing = "idle"),
        cursors.down.isDown ? "down" != facing && player.body.onFloor() ? ("left" == facing ? player.animations.play("down-left") : player.animations.play("down-right"),
        facing = "down",
        "ducking" != player.body.state && player.body.setDucking()) : player.body.onFloor() || lock.down || player.fallLock || (player.body.velocity.y += 50) : "standing" != player.body.state && player.body.onFloor() && player.body.setStanding(),
        (jumpButton.isDown && player.body.onFloor() && !lock.jump && !lock.up || cursors.up.isDown && player.body.onFloor() && !lock.jump && !lock.up) && (jumpSound.play(),
        cursors.down.isDown ? (player.body.velocity.y = 1.2 * -jumpHeight,
        player.body.velocity.x *= 2.5,
        lock.down = !0) : player.body.velocity.y = -jumpHeight,
        lock.jump = !0,
        cursors.left.isDown ? player.animations.play("jump-left") : player.animations.play("jump-right"),
        player.body.setJumping(),
        facing = "jump")),
        restartBtn.isDown && restart()
    }, handleKeyLocks = function() {
        cursors.down.isDown || (lock.down = !1),
        cursors.left.isDown || (lock.left = !1),
        cursors.up.isDown || (lock.up = !1),
        cursors.right.isDown || (lock.right = !1),
        jumpButton.isDown || (lock.jump = !1)
    }, pointerOnSprite = function(r) {
        game.physics.arcade.distanceToPointer(r)
    };
    var updateDebug = function() {
        game.debug.text(game.time.fps, 1, 25, "white", "36 Arial"),
        window.debugMessage && game.debug.text(window.debugMessage, 1, 100, "white", "36 Arial")
    };
    Phaser.Easing.Elastobounce = {
        In: function(n) {
            var t, r = .1;
            return 0 === n ? 0 : 1 === n ? 1 : (t = !r || r < 1 ? (r = 1,
            .1) : .4 * Math.asin(1 / r) / (2 * Math.PI),
            -r * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / .4))
        },
        Out: function(n) {
            return 0 === n ? 0 : 1 === n ? 1 : .8 * Math.pow(2, -10 * n) * Math.sin((n - .2) * (2 * Math.PI) / .2) + 1
        },
        InOut: function(n) {
            var t, r = .1;
            return 0 === n ? 0 : 1 === n ? 1 : (t = !r || r < 1 ? (r = 1,
            .1) : .4 * Math.asin(1 / r) / (2 * Math.PI),
            (n *= 2) < 1 ? r * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / .4) * -.5 : r * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / .4) * .5 + 1)
        }
    },
    Phaser.Easing.Superback = {
        In: function(n) {
            var t = 13.61264;
            return n * n * ((1 + t) * n - t)
        },
        Out: function(n) {
            var t = 13.61264;
            return --n * n * ((1 + t) * n + t) + 1
        },
        InOut: function(n) {
            var t = 20.759276;
            return (n *= 2) < 1 ? n * n * ((1 + t) * n - t) * .5 : .5 * ((n -= 2) * n * ((1 + t) * n + t) + 2)
        }
    },
    Phaser.Easing.TwoStep = {
        In: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        },
        Out: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        },
        InOut: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        }
    },
    Phaser.Easing.OneStep = {
        In: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        },
        Out: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        },
        InOut: function(n) {
            var t = 0;
            return .5 < n && (t = 1),
            t
        }
    },
    Phaser.Easing.TwoStep = {
        In: function(n) {
            var t = 0;
            return .5 < n && (t = .5),
            1 === n && (t = 1),
            t
        },
        Out: function(n) {
            var t = 0;
            return .5 < n && (t = .5),
            1 === n && (t = 1),
            t
        },
        InOut: function(n) {
            var t = 0;
            return .5 < n && (t = .5),
            1 === n && (t = 1),
            t
        }
    },
    Phaser.Easing.ThreeStep = {
        In: function(n) {
            var t = 0;
            return .25 < n && (t = .33),
            .5 < n && (t = .66),
            .75 < n && (t = 1),
            t
        },
        Out: function(n) {
            var t = 0;
            return .25 < n && (t = .33),
            .5 < n && (t = .66),
            .75 < n && (t = 1),
            t
        },
        InOut: function(n) {
            var t = 0;
            return .25 < n && (t = .33),
            .5 < n && (t = .66),
            .75 < n && (t = 1),
            t
        }
    },
    Phaser.Easing.FourStep = {
        In: function(n) {
            var t = 0;
            return .2 < n && (t = .25),
            .4 < n && (t = .5),
            .6 < n && (t = .75),
            .8 < n && (t = 1),
            t
        },
        Out: function(n) {
            var t = 0;
            return .2 < n && (t = .25),
            .4 < n && (t = .5),
            .6 < n && (t = .75),
            .8 < n && (t = 1),
            t
        },
        InOut: function(n) {
            var t = 0;
            return .2 < n && (t = .25),
            .4 < n && (t = .5),
            .6 < n && (t = .75),
            .8 < n && (t = 1),
            t
        }
    },
    Phaser.Easing.FourStepBack = {
        Out: function(n) {
            var t = 0;
            return .25 < n && (t = .5),
            .5 < n && (t = 1),
            .75 < n && (t = 1.5),
            1 == n && (t = 1),
            t
        }
    },
    Phaser.Easing.FourStepBackSuper = {
        Out: function(n) {
            var t = 0;
            return .25 < n && (t = .5),
            .5 < n && (t = 1),
            .75 < n && (t = 2.5),
            1 == n && (t = 1),
            t
        }
    };
    var initEffects = function() {
        buildText(),
        buildAreas()
    }
      , resetEffects = function() {
        for (var e in resetText(),
        areas) {
            areas[e].reset()
        }
    }
      , buildAreas = function() {
        function e(i) {
            return function() {
                var t = areas[i];
                "country" === i && groups.country.complete(),
                "countryBilling" === i && groups.countryBilling.complete(),
                "payment" === i && groups.payment.complete();
                for (var e = 0; e < t.enemies.length; e++) {
                    t.enemies[e].die()
                }
                t.images.blueOutline.sprite && ("string" == typeof t.images.blueOutline.image ? t.images.blueOutline.sprite.destroy() : t.images.blueOutline.sprite.visible = !1),
                t.images.redOutline.sprite && ("string" == typeof t.images.redOutline.image ? t.images.redOutline.sprite.destroy() : t.images.redOutline.sprite.visible = !1),
                t.images.stamp.sprite && t.images.stamp.sprite.destroy(),
                t.images.strike.sprite && t.images.strike.sprite.destroy(),
                t.images.heckle && (t.images.heckle.visible = !1),
                t.images.stamp.sprite = game.add.image(t.images.stamp.position.x, t.images.stamp.position.y, "spritesheet", t.images.stamp.image),
                t.images.stamp.sprite.anchor.set(.5),
                "string" == typeof t.images.greenOutline.image ? t.images.greenOutline.sprite = game.add.image(t.images.greenOutline.position.x - 24, t.images.greenOutline.position.y - 12, "spritesheet", t.images.greenOutline.image) : (t.images.greenOutline.sprite = t.images.greenOutline.image,
                t.images.greenOutline.sprite.x = t.images.greenOutline.position.x,
                t.images.greenOutline.sprite.y = t.images.greenOutline.position.y,
                t.images.greenOutline.sprite.visible = !0,
                t.images.greenOutline.sprite.alpha = 1),
                bgElements.add(t.images.stamp.sprite),
                fgElements.add(t.images.greenOutline.sprite),
                t.images.stamp.tween = game.add.tween(t.images.stamp.sprite.scale),
                t.images.stamp.tween.from({
                    x: .1,
                    y: .1
                }, 333, Phaser.Easing.FourStepBack.Out, !0),
                t.images.stamp.tween.onComplete.add(function() {
                    var e = {
                        x: t.images.stamp.sprite.x,
                        y: t.images.stamp.sprite.y,
                        tint: 239185,
                        count: 10,
                        popDistance: 8,
                        popOffset: 50,
                        lifespan: 200,
                        scale: {
                            x: .4,
                            y: 1
                        },
                        popRotation: QPI
                    };
                    spritePop(e)
                }),
                t.images.greenOutline.tween = game.add.tween(t.images.greenOutline.sprite),
                t.images.greenOutline.tween.to({
                    alpha: 0
                }, 600, Phaser.Easing.ThreeStep.Out, !0),
                t.images.greenOutline.tween.onComplete.add(function() {
                    "string" == typeof t.images.greenOutline.image ? t.images.greenOutline.sprite.destroy() : t.images.greenOutline.sprite.visible = !1
                }),
                ding.play(),
                returnCarriage.play()
            }
        }
        function t(t) {
            return function() {
                var e = areas[t];
                areas[player.currentLocation].images.blueOutline.sprite && ("string" == typeof areas[player.currentLocation].images.blueOutline.image ? areas[player.currentLocation].images.blueOutline.sprite.destroy() : areas[player.currentLocation].images.blueOutline.sprite.visible = !1),
                areas[player.currentLocation].images.redOutline.sprite && ("string" == typeof areas[player.currentLocation].images.redOutline.image ? areas[player.currentLocation].images.redOutline.sprite.destroy() : areas[player.currentLocation].images.redOutline.sprite.visible = !1),
                "string" == typeof e.images.blueOutline.image ? e.images.blueOutline.sprite = game.add.image(e.images.blueOutline.position.x - 24, e.images.blueOutline.position.y - 12, "spritesheet", e.images.blueOutline.image) : (e.images.blueOutline.sprite = e.images.blueOutline.image,
                e.images.blueOutline.sprite.x = e.images.blueOutline.position.x,
                e.images.blueOutline.sprite.y = e.images.blueOutline.position.y,
                e.images.blueOutline.sprite.visible = !0,
                e.images.blueOutline.sprite.alpha = 1),
                fgElements.add(e.images.blueOutline.sprite)
            }
        }
        function i(e) {
            return function() {
                var t = areas[e];
                t.images.blueOutline.sprite && ("string" == typeof t.images.blueOutline.image ? t.images.blueOutline.sprite.destroy() : t.images.blueOutline.sprite.visible = !1),
                t.images.strike.sprite && t.images.strike.sprite.destroy(),
                t.images.strike.sprite = game.add.image(t.images.strike.position.x, t.images.strike.position.y, "spritesheet", t.images.strike.image),
                t.images.heckle && (t.images.heckle.visible = !0),
                t.images.strike.sprite.anchor.set(.5),
                "string" == typeof t.images.redOutline.image ? t.images.redOutline.sprite = game.add.image(t.images.redOutline.position.x - 24, t.images.redOutline.position.y - 12, "spritesheet", t.images.redOutline.image) : (t.images.redOutline.sprite = t.images.redOutline.image,
                t.images.redOutline.sprite.x = t.images.redOutline.position.x,
                t.images.redOutline.sprite.y = t.images.redOutline.position.y,
                t.images.redOutline.sprite.visible = !0,
                t.images.redOutline.sprite.alpha = 1),
                bgElements.add(t.images.strike.sprite),
                fgElements.add(t.images.redOutline.sprite),
                t.images.strike.tween = game.add.tween(t.images.strike.sprite.scale),
                t.images.strike.tween.from({
                    x: .1,
                    y: .1
                }, 333, Phaser.Easing.FourStepBack.Out, !0),
                t.images.strike.tween.onComplete.add(function() {
                    var e = {
                        x: t.images.strike.sprite.x,
                        y: t.images.strike.sprite.y,
                        tint: 16711680,
                        count: 10,
                        popDistance: 8,
                        popOffset: 50,
                        lifespan: 200,
                        scale: {
                            x: .4,
                            y: 1
                        },
                        popRotation: QPI
                    };
                    spritePop(e)
                })
            }
        }
        function a(i) {
            return function() {
                var e = areas[i];
                for (var t in e.isComplete = !1,
                e.images)
                    e.images[t].tween && e.images[t].tween.stop(),
                    e.images[t].sprite && ("string" == typeof e.images[t] ? e.images[t].sprite.destroy() : e.images[t].sprite.visible = !1)
            }
        }
        for (var s = 0; s < fields.length; s++) {
            var n = fields[s];
            areas[n] = {},
            areas[n].enemies = [],
            areas[n].text = fieldText[n],
            areas[n].images = fieldImages[n],
            areas[n].onComplete = e(n),
            areas[n].onActive = t(n),
            areas[n].onIncomplete = i(n),
            areas[n].reset = a(n)
        }
    }
      , buildText = function() {
        function e(t) {
            return function() {
                text[t].renderString = "";
                for (var e = 0; e < text[t].grabbed.length; e++) {
                    text[t].grabbed[e] ? (text[t].renderString += text[t].string[e],
                    " " == text[t].string[e] && (text[t].grabbed[e + 1] = 1)) : text[t].renderString += ""
                }
                text[t].renderString.length == text[t].string.length && (text[t].isComplete = !0)
            }
        }
        function t(e) {
            return function() {
                text[e].isComplete ? (text[e].inGame && text[e].inGame.destroy(),
                text[e].inGame = game.add.bitmapText(text[e].position.x, text[e].position.y, "graphik", text[e].renderString, "80"),
                bgElements.add(text[e].inGame)) : text[e].inGame ? text[e].inGame.setText(text[e].renderString) : (text[e].inGame = game.add.bitmapText(text[e].position.x, text[e].position.y, "graphik-gray", text[e].renderString, "80"),
                bgElements.add(text[e].inGame))
            }
        }
        for (var i in fieldText) {
            text[i] = {},
            text[i].string = fieldText[i].text,
            text[i].renderString = "",
            text[i].position = fieldText[i].position,
            text[i].grabbed = [];
            for (var a = 0; a < text[i].string.length; a++)
                text[i].grabbed.push(0);
            text[i].update = e(i),
            text[i].render = t(i)
        }
    }
      , resetText = function() {
        for (var e in fieldText) {
            text[e].renderString = "",
            text[e].isComplete = !1,
            text[e].inGame && (text[e].inGame.destroy(),
            text[e].inGame = game.add.bitmapText(text[e].position.x, text[e].position.y, "graphik-gray", text[e].renderString, "80"),
            bgElements.add(text[e].inGame));
            for (var t = 0; t < text[e].grabbed.length; t++)
                text[e].grabbed[t] = 0
        }
    }
      , spritePop = function(e) {
        for (var t = e || {}, i = t.x || console.warn('sprite pop requires an option "x"'), a = t.y || console.warn('sprite pop requires an option "y"'), s = t.count || 4, n = t.popDistance || 50, r = t.popOffset || 0, g = t.lifespan || 500, m = t.tint || 0, o = t.scale || {
            x: 1,
            y: 1
        }, p = t.easing || Phaser.Easing.TwoStep.Out, l = t.popRotation || Math.random(), u = 0; u < s; u++) {
            var d = Math.sin(l + PI2 * (u / s))
              , x = Math.cos(l + PI2 * (u / s))
              , c = {
                x: i + r * d + n * d,
                y: a + r * x + n * x
            }
              , O = game.add.image(i + r * d, a + r * x, "spritesheet", "tiles/white-piece.png");
            O.anchor.set(.5),
            O.scale.x = o.x,
            O.scale.y = o.y,
            O.tint = m,
            O.fly = game.add.tween(O.position),
            (O.position.parent = O).rotation = Math.atan(-(c.x - i) / (c.y - a)),
            O.fly.to({
                x: c.x,
                y: c.y
            }, g, p, !0),
            O.fly.onComplete.add(function(e) {
                e.parent.destroy()
            })
        }
    }
      , skipGame = function() {
        cameraOverride = !0,
        game.camera.unfollow(),
        game.panDown = game.add.tween(game.camera),
        game.panDown.to({
            y: 10080 - game.height / 2
        }, 5e3, Phaser.Easing.Linear.None, !0),
        game.panDown.onComplete.add(function() {
            showFinalPage(),
            skippingGame = !1
        })
    };
    var asterisks, termsAsterisks, privacyAsterisks, creditAsterisks, bangs, rollers, asteriskTweenData, enemies = [], initEnemies = function() {
        bakeTweens(),
        asterisks = game.add.group(),
        map.createFromObjects("Asterisks", 6, "spritesheet", "enemies/asterisk.png", !0, !1, asterisks),
        asterisks.forEach(function(e) {
            initAsterisk(e)
        }, this),
        enemies.push(asterisks),
        termsAsterisks = game.add.group(),
        map.createFromObjects("Terms Asterisks", 6, "spritesheet", "enemies/asterisk.png", !0, !1, termsAsterisks),
        termsAsterisks.forEach(function(e) {
            e.noCull = !0,
            initAsterisk(e)
        }, this),
        enemies.push(termsAsterisks),
        privacyAsterisks = game.add.group(),
        map.createFromObjects("Privacy Asterisks", 6, "spritesheet", "enemies/asterisk.png", !0, !1, privacyAsterisks),
        privacyAsterisks.forEach(function(e) {
            e.noCull = !0,
            initAsterisk(e)
        }, this),
        enemies.push(privacyAsterisks),
        creditAsterisks = game.add.group(),
        map.createFromObjects("Credit Asterisks", 6, "spritesheet", "enemies/asterisk.png", !0, !1, creditAsterisks),
        creditAsterisks.forEach(function(e) {
            e.noCull = !0,
            initAsterisk(e)
        }, this),
        enemies.push(creditAsterisks),
        bangs = game.add.group(),
        map.createFromObjects("Bangs", 7, "spritesheet", "enemies/bang.png", !0, !1, bangs),
        bangs.forEach(function(e) {
            initBang(e)
        }, this),
        enemies.push(bangs),
        rollers = game.add.group(),
        map.createFromObjects("Rollers", 2, "spritesheet", "enemies/roller.png", !0, !1, rollers),
        rollers.forEach(function(e) {
            initRoller(e)
        }, this),
        enemies.push(rollers)
    }, bakeTweens = function() {
        var e = game.add.tween({
            x: 1,
            y: 1
        });
        e.to({
            x: 1.4,
            y: 1.4
        }, 250, Phaser.Easing.TwoStep.Out, !0),
        e.yoyo(!0, 250),
        e.repeat(-1, 2e3),
        asteriskTweenData = e.generateData(60)
    }, initAsterisk = function(e) {
        initEnemy(e)
    }, initBang = function(e) {
        initEnemy(e);
        var s = parseInt(e.delay) || game.rnd.integerInRange(0, 1e3);
        e.body.offset.x += 10,
        e.body.offset.y += 10,
        e.slideX && (e.tweens.slideX = game.add.tween(e.position),
        e.tweens.slideX.to({
            x: e.slideX
        }, 500, Phaser.Easing.Quintic.Out, !0, s),
        e.tweens.slideX.yoyo(!0, 250),
        e.tweens.slideX.repeat(-1, 2e3)),
        e.slideY && (e.tweens.slideY = game.add.tween(e.position),
        e.tweens.slideY.to({
            y: e.slideY
        }, 500, Phaser.Easing.Quintic.Out, !0, s),
        e.tweens.slideY.yoyo(!0, 250),
        e.tweens.slideY.repeat(-1, 2e3))
    }, initRoller = function(e) {
        if (initEnemy(e),
        e.rollX) {
            e.tweens.rollX = game.add.tween(e.position),
            e.tweens.rollX.to({
                x: e.rollX
            }, 5e3, Phaser.Easing.Linear.None, !0),
            e.tweens.rollX.yoyo(!0),
            e.tweens.rollX.repeat(-1);
            var s = e.spinFlip || 1;
            e.tweens.spin = game.add.tween(e),
            e.tweens.spin.to({
                angle: .85 * e.rollX * s
            }, 5e3, Phaser.Easing.Linear.None, !0),
            e.tweens.spin.yoyo(!0),
            e.tweens.spin.repeat(-1)
        }
    }, resetEnemies = function() {
        termsAsterisks.y = 0,
        asterisks.y = 0,
        asterisks.forEach(function(e) {
            e.reset()
        }),
        termsAsterisks.forEach(function(e) {
            e.reset()
        }),
        privacyAsterisks.forEach(function(e) {
            e.reset()
        }),
        creditAsterisks.forEach(function(e) {
            e.reset()
        }),
        bangs.forEach(function(e) {
            e.reset()
        }),
        rollers.forEach(function(e) {
            e.reset()
        })
    }, hideEnemies = function() {
        for (var e = 0; e < enemies.length; e++) {
            enemies[e].forEach(function(e) {
                e.group == player.currentLocation ? e.visible = !0 : e.visible = !1
            })
        }
    }, superHideEnemies = function() {
        for (var e = 0; e < enemies.length; e++) {
            enemies[e].forEach(function(e) {
                e.group == player.currentLocation ? e.renderable = !0 : (e.visible = !1,
                e.renderable = !1)
            })
        }
    }, showEnemies = function() {
        for (var e = 0; e < enemies.length; e++) {
            enemies[e].forEach(function(e) {
                e.group && e.group != player.currentLocation ? e.visible = !1 : e.visible = !0
            })
        }
    }, enemiesRenderable = function(s) {
        for (var e = 0; e < enemies.length; e++) {
            enemies[e].forEach(function(e) {
                s && !e.startsHidden ? e.renderable = !0 : e.renderable = !1
            })
        }
    }, updateEnemies = function() {};
    var text = {
        style: {
            complete: {
                font: "80pt Graphik",
                fill: "#000000",
                align: "left"
            },
            clock: {
                font: "32px Arial",
                fill: "#000000",
                align: "center"
            },
            retina: {
                font: "66px Retina",
                fill: "#000000",
                align: "center"
            },
            pixel: {
                font: "110px Pixel",
                fill: "#000000",
                align: "left"
            },
            progress: {
                font: "80pt Graphik",
                fill: "rgba( 64, 64, 64, .1 )",
                align: "left"
            }
        }
    }
      , fields = ["name", "streetName", "city", "zipCode", "country", "email", "verifyEmail", "homeNumber", "mobileNumber", "username", "password", "passwordConfirm", "payment", "account", "bankCode", "accountName", "streetNameBilling", "cityBilling", "zipCodeBilling", "countryBilling", "idType", "birthDate", "idNumber", "issueDate", "expirationDate", "issueState", "taxId", "terms", "privacy", "credit"]
      , fieldText = {
        name: {
            text: "Niklas von Cursor",
            position: {
                x: 145,
                y: 365
            }
        },
        streetName: {
            text: "Strobelallee 50 Apt 3L",
            position: {
                x: 145,
                y: 645
            }
        },
        city: {
            text: "Frankfurt",
            position: {
                x: 145,
                y: 925
            }
        },
        zipCode: {
            text: "60437",
            position: {
                x: 1025,
                y: 925
            }
        },
        country: {
            text: ".",
            position: {
                x: 145,
                y: 1205
            }
        },
        email: {
            text: "niklas@voncursor.co",
            position: {
                x: 145,
                y: 1485
            }
        },
        verifyEmail: {
            text: "niklas@voncursor.co",
            position: {
                x: 145,
                y: 1765
            }
        },
        homeNumber: {
            text: "49 89 23531 7150",
            position: {
                x: 145,
                y: 2045
            }
        },
        mobileNumber: {
            text: "49 151 6295331",
            position: {
                x: 1025,
                y: 2045
            }
        },
        username: {
            text: "niklascursor1987",
            position: {
                x: 145,
                y: 2325
            }
        },
        password: {
            text: "1987voncursor!",
            position: {
                x: 145,
                y: 2605
            }
        },
        passwordConfirm: {
            text: "1987voncursor!",
            position: {
                x: 1025,
                y: 2605
            }
        },
        payment: {
            text: ".",
            position: {
                x: 145,
                y: 2885
            }
        },
        account: {
            text: "DE84 5201 1517 7407 3449 91",
            position: {
                x: 145,
                y: 3165
            }
        },
        bankCode: {
            text: "BANKDEFF300",
            position: {
                x: 145,
                y: 3445
            }
        },
        accountName: {
            text: "Niklas von Cursor",
            position: {
                x: 145,
                y: 3725
            }
        },
        streetNameBilling: {
            text: "Strobelallee 50 Apt 3L",
            position: {
                x: 145,
                y: 4005
            }
        },
        cityBilling: {
            text: "Frankfurt",
            position: {
                x: 145,
                y: 4285
            }
        },
        zipCodeBilling: {
            text: "60437",
            position: {
                x: 1025,
                y: 4285
            }
        },
        countryBilling: {
            text: ".",
            position: {
                x: 145,
                y: 4565
            }
        },
        idType: {
            text: "Fuhrerschein",
            position: {
                x: 145,
                y: 4845
            }
        },
        birthDate: {
            text: " 15        11       1987",
            position: {
                x: 145,
                y: 5125
            }
        },
        idNumber: {
            text: "B072RRE2I52",
            position: {
                x: 1025,
                y: 5125
            }
        },
        issueDate: {
            text: " 25       01       2014",
            position: {
                x: 145,
                y: 5405
            }
        },
        expirationDate: {
            text: " 26       01       2019",
            position: {
                x: 1025,
                y: 5405
            }
        },
        issueState: {
            text: "Frankfurt",
            position: {
                x: 145,
                y: 5685
            }
        },
        taxId: {
            text: "01020304955",
            position: {
                x: 145,
                y: 5965
            }
        },
        terms: {
            text: ".",
            position: {
                x: -99999,
                y: -99976
            }
        },
        privacy: {
            text: ".",
            position: {
                x: -99999,
                y: -99976
            }
        },
        credit: {
            text: ".",
            position: {
                x: -99999,
                y: -99976
            }
        }
    };
    var dropDownGroup, bgElements, fgElements, groups = {
        enemies: {},
        coins: {},
        dropdowns: [],
        checkboxes: {
            children: []
        }
    }, initGroups = function() {
        groups.checkboxes.hide = function() {
            groups.checkboxes.children.forEach(function(o) {
                o.hide()
            })
        }
        ,
        groups.checkboxes.show = function() {
            groups.checkboxes.children.forEach(function(o) {
                o.show()
            })
        }
        ,
        groups.checkboxes.reset = function() {
            groups.checkboxes.children.forEach(function(o) {
                o.reset()
            })
        }
        ,
        bgElements = game.add.group(),
        groups.country = new Dropdown({
            field: "country",
            origin: {
                x: 120,
                y: 1160
            },
            arrow: "background/dropdown-arrow.png",
            options: ["options/Country.png", "options/Argentina.png", "options/Belgium.png", "options/Brazil.png", "options/Chile.png", "options/China.png", "options/Denmark.png", "options/Germany.png"],
            placeholder: "options/Country.png",
            image: paymentDropdownLevelImage
        }),
        groups.country.hide(),
        groups.dropdowns.push(groups.country),
        groups.countryBilling = new Dropdown({
            field: "countryBilling",
            origin: {
                x: 120,
                y: 4520
            },
            arrow: "background/dropdown-arrow.png",
            options: ["options/Country.png", "options/Argentina.png", "options/Belgium.png", "options/Brazil.png", "options/Chile.png", "options/China.png", "options/Denmark.png", "options/Germany.png"],
            placeholder: "options/Country.png",
            image: idTypeDropdownLevelImage
        }),
        groups.countryBilling.hide(),
        groups.dropdowns.push(groups.countryBilling),
        groups.payment = new Dropdown({
            field: "payment",
            origin: {
                x: 120,
                y: 2840
            },
            arrow: "background/dropdown-arrow.png",
            options: ["options/advance-payment.png", "options/app-payment.png", "options/credit-card.png", "options/cryptocurrency.png", "options/direct-debit.png", "options/gift-card.png", "options/pay-on-account.png", "options/bank-transfer.png"],
            placeholder: "options/choose-payment.png",
            image: countryBillingDropdownLevelImage
        }),
        groups.payment.hide(),
        groups.dropdowns.push(groups.payment)
    }, initCheckboxes = function() {
        var o, e, n;
        groups.terms = new Checkbox({
            asterisks: termsAsterisks,
            check: game.add.image(772, 7234, "spritesheet", "background/check.png"),
            yTop: 6200,
            text: (o = game.add.image(160, 6210, "terms"),
            o.scale.set(2),
            o),
            mask: game.add.graphics(120, 6200),
            textScrollSpeed: .4
        }),
        groups.checkboxes.children.push(groups.terms),
        groups.privacy = new Checkbox({
            asterisks: privacyAsterisks,
            check: game.add.image(645, 8448, "spritesheet", "background/check.png"),
            yTop: 7400,
            text: (e = game.add.image(160, 7410, "privacy"),
            e.scale.set(2),
            e),
            mask: game.add.graphics(120, 7400),
            textScrollSpeed: .4
        }),
        groups.checkboxes.children.push(groups.privacy),
        groups.credit = new Checkbox({
            asterisks: creditAsterisks,
            check: game.add.image(618, 9660, "spritesheet", "background/check.png"),
            yTop: 8600,
            text: (n = game.add.image(160, 8610, "credit"),
            n.scale.set(2),
            n),
            mask: game.add.graphics(120, 8600),
            textScrollSpeed: .4
        }),
        groups.checkboxes.children.push(groups.credit)
    }, updateGroups = function() {
        groups.terms.active && groups.terms.updateScroll(),
        groups.privacy.active && groups.privacy.updateScroll(),
        groups.credit.active && groups.credit.updateScroll(),
        groups.terms.update(),
        groups.privacy.update(),
        groups.credit.update()
    };
    var coins, asterisks, vacuums, warpUps, warpDowns, triggers, interactives = [], grabbedCoins = 0, initInteractiveElements = function() {
        foreground = game.add.group(),
        map.createFromObjects("Foreground Tiles", 12, "spritesheet", "tiles/bg-e6.png", !0, !1, foreground),
        foreground.forEach(function(e) {
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.body.setCircle(19.5),
            e.renderable = !1,
            e.hidden = !0,
            e.update = updateInteractiveGenerator(e)
        }, this),
        interactives.push(foreground),
        triggers = game.add.group(),
        map.createFromObjects("Triggers", 9, "spritesheet", "tiles/bg-e6.png", !0, !1, triggers),
        triggers.forEach(function(e) {
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.body.setCircle(19.5),
            e.hidden = !0,
            e.cacheAsBitmap = !0,
            e.update = updateInteractiveGenerator(e)
        }, this),
        interactives.push(triggers),
        vacuums = game.add.group(),
        map.createFromObjects("Vacuums", 12, "spritesheet", "tiles/bg-e6.png", !0, !1, vacuums),
        vacuums.forEach(function(e) {
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.body.setCircle(19.5),
            e.renderable = !1,
            e.hidden = !0,
            e.cacheAsBitmap = !0,
            e.update = updateInteractiveGenerator(e)
        }, this),
        interactives.push(vacuums),
        warpUps = game.add.group(),
        map.createFromObjects("Warp Up", 12, "spritesheet", "tiles/bg-e6.png", !0, !1, warpUps),
        warpUps.forEach(function(e) {
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.body.setCircle(19.5),
            e.renderable = !1,
            e.hidden = !0,
            e.cacheAsBitmap = !0,
            e.update = updateInteractiveGenerator(e)
        }, this),
        interactives.push(warpUps),
        warpDowns = game.add.group(),
        map.createFromObjects("Warp Down", 12, "spritesheet", "tiles/bg-e6.png", !0, !1, warpDowns),
        warpDowns.forEach(function(e) {
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.body.setCircle(19.5),
            e.renderable = !1,
            e.hidden = !0,
            e.cacheAsBitmap = !0,
            e.update = updateInteractiveGenerator(e)
        }, this),
        interactives.push(warpDowns),
        coins = game.add.group(),
        map.createFromObjects("Coins", 1, "spritesheet", "tiles/coin.png", !0, !1, coins),
        coins.forEach(function(e) {
            e.group && groups[e.group].children.push(e),
            e.cacheAsBitmap = !0,
            game.physics.enable(e, Phaser.Physics.ARCADE),
            e.body.allowGravity = !1,
            e.body.immovable = !0,
            e.anchor.set(.5),
            e.body.setCircle(16),
            e.position.x += 10,
            e.position.y += 10,
            e.update = updateInteractiveGenerator(e),
            e.oPosition = {
                x: e.position.x,
                y: e.position.y
            },
            e.grabbed = !1,
            e.tweens = {}
        }, this),
        interactives.push(coins)
    }, getCoin = function(e, t) {
        if (!t.grabbed && t.visible) {
            if (playCoinSound(),
            t.alpha = 0,
            t.grabbed = !0,
            t.name) {
                var a = text[t.name];
                for (var n in a.grabbed)
                    if (0 == a.grabbed[n]) {
                        a.grabbed[n] = 1;
                        break
                    }
                a.update();
                var r = a.renderString[a.renderString.length - 1]
                  , i = game.add.bitmapText(t.x, t.y, "vcr", r.toUpperCase(), "72");
                i.anchor.set(.5),
                i.scale.set(.28, .28),
                i.x += .5 * i.width;
                var o = 250
                  , s = {
                    x: 0,
                    y: 0,
                    tint: 0,
                    count: 6,
                    popDistance: 1,
                    popOffset: 40,
                    lifespan: 125,
                    scale: {
                        x: .2,
                        y: 1
                    },
                    popRotation: QPI
                };
                setTimeout(a.render, 150),
                i.tweens = {},
                i.tweens.floatUp = game.add.tween(i.position).to({
                    y: i.position.y - 40
                }, o, Phaser.Easing.TwoStep.Out, !0),
                i.tweens.floatUp.onComplete.add(function(e) {
                    s.x = e.x,
                    s.y = e.y,
                    spritePop(s)
                }),
                i.tweens.scaleUp = game.add.tween(i.scale).to({
                    y: 1.6 * i.scale.y,
                    x: 1.6 * i.scale.x
                }, o, Phaser.Easing.FourStepBackSuper.Out, !0),
                i.tweens.alphaOut = game.add.tween(i).to({
                    alpha: 0
                }, o, Phaser.Easing.TwoStep.Out, !0, 375),
                i.tweens.alphaOut.onComplete.add(function(e) {
                    e.destroy()
                }, this),
                a.isComplete && ("country" === t.name && (text.country.renderString = "Deutschland"),
                "payment" === t.name && (text.payment.renderString = "Bank Transfer"),
                "idType" === t.name && (text.idType.renderString = "Personalausweis"),
                "countryBilling" === t.name && (text.countryBilling.renderString = "Deutschland"),
                areas[t.name].isComplete = a.isComplete,
                areas[t.name].onComplete())
            }
            ++grabbedCoins == coins.children.length && gameComplete()
        }
    }, coinSoundCount = 1, playCoinSound = function() {
        typeSounds["tone" + coinSoundCount].play(),
        typeSounds["type" + game.rnd.integerInRange(1, 20)].play(),
        4 < coinSoundCount + 1 ? coinSoundCount = 1 : coinSoundCount++
    }, handleVacuum = function(e, t) {
        !e.vacuumed && e.body.velocity.y < 0 && (e.body.velocity.y -= vacuumSpeed,
        e.vacuumed = !0,
        game.time.events.add(250, function() {
            e.vacuumed = !1
        }, this))
    }, handleDownWarps = function(e, t) {
        !e.warped && 0 <= e.body.velocity.y && (e.x += parseInt(t.warpX),
        e.y += parseInt(t.warpY),
        e.warped = !0,
        game.time.events.add(250, function() {
            e.warped = !1
        }, this))
    }, handleUpWarps = function(e, t) {
        !e.warped && e.body.velocity.y < 0 && (e.x += parseInt(t.warpX),
        e.y += parseInt(t.warpY),
        e.warped = !0,
        game.time.events.add(250, function() {
            e.warped = !1
        }, this))
    }, handleLocation = function(e, t) {
        if (t.up && t.down) {
            var a = e.currentFg;
            0 < e.body.velocity.y ? e.currentFg = t.down : e.currentFg = t.up,
            a !== e.currentFg && (0 < e.body.velocity.y ? suckDown.play() : suckUp.play())
        }
    }, resetCoins = function() {
        grabbedCoins = 0,
        gotAllCoins = !1,
        coins.forEach(function(e) {
            for (var t in e.tweens)
                e.tweens[t].tween && e.tweens[t].tween.stop();
            e.grabbed = !1,
            e.scale.x = 1,
            e.scale.y = 1,
            e.position.set(e.oPosition.x, e.oPosition.y),
            e.loadTexture("spritesheet", "tiles/coin.png"),
            e.alpha = 1
        })
    }, handleTriggers = function(e, t) {
        if ("terms" !== t.field || groups.terms.active || groups.terms.start(),
        "privacy" !== t.field || groups.privacy.active || groups.privacy.start(),
        "credit" !== t.field || groups.credit.active || groups.credit.start(),
        t.name !== e.currentLocation) {
            var a = e.currentLocation;
            "finish" != t.name && (e.currentLocation = t.name),
            "country" === t.field && groups.country.enter(),
            "payment" === t.field && groups.payment.enter(),
            "countryBilling" === t.field && groups.countryBilling.enter(),
            "finish" === t.field && endGame(),
            a !== e.currentLocation && (areas[a].isComplete || areas[a].onIncomplete(),
            areas[e.currentLocation].isComplete || areas[e.currentLocation].onActive())
        }
    }, hideInteractives = function() {
        for (var e = 0; e < interactives.length; e++) {
            interactives[e].forEach(function(e) {
                e.group == player.currentLocation ? e.visible = !0 : e.visible = !1
            })
        }
    }, superHideInteractives = function() {
        for (var e = 0; e < interactives.length; e++) {
            interactives[e].forEach(function(e) {
                e.group == player.currentLocation ? e.renderable = !0 : (e.visible = !1,
                e.renderable = !1)
            })
        }
    }, showInteractives = function() {
        for (var e = 0; e < interactives.length; e++) {
            interactives[e].forEach(function(e) {
                e.group && e.group != player.currentLocation ? e.visible = !1 : e.hidden || (e.visible = !0)
            })
        }
    }, killInteractives = function() {
        for (var e = 0; e < interactives.length; e++) {
            interactives[e].forEach(function(e) {
                e.kill()
            })
        }
    }, interactivesRenderable = function(t) {
        for (var e = 0; e < interactives.length; e++) {
            interactives[e].forEach(function(e) {
                e.renderable = !!t
            })
        }
    }, updateInteractiveGenerator = function(e) {
        return function() {
            e.renderable && !e.alive && e.position.y >= game.camera.view.top && e.position.y <= game.camera.view.bottom ? (e.revive(),
            e.hidden && (e.renderable = !1)) : (e.alive && e.position.y < game.camera.view.top || e.alive && e.position.y > game.camera.view.bottom) && e.kill()
        }
    };
    var settingsGroup, settingsGfx, settingsHeading, settingsBody, backBtn, settingsLabel, controlsBtn, controlsBtnBg, controlsIcon, controlsIconOff, soundBtn, soundBtnBg, soundIcon, soundIconOff, musicBtn, musicBtnBg, musicIcon, musicIconOff, settingsRestartBtn, settingsRestartBtnBg, outLinkBtn, outLinkBtnBg, finalGroup, finalGfx, finalPlayButton, finalYesButton, finalYesMessage1, finalShareMessage, finalFacebookButton, finalTwitterButton, finalEmailButton, finalBarLogo, scoreGroup, scoreGfx, scoreLabel, congratulations, fastestBtnBg, fastestLabel, totalBtnBg, totalLabe, totalTime, fastestTime, controlPageGroup, controlPageImg, initScoreScreen = function() {
        (scoreGroup = game.add.group()).init = {
            x: 0,
            y: 0
        },
        (scoreGfx = game.add.graphics(0, 0)).beginFill(parseInt("0x" + BG_COLOR.slice(1, 7))),
        scoreGfx.drawRect(0, 0, 1920, 200),
        scoreGfx.endFill(),
        scoreGfx.beginFill(15132390),
        scoreGfx.drawRect(0, 200, 1920, 10080),
        scoreGfx.endFill(),
        scoreGroup.add(scoreGfx),
        scoreGroup.fixedToCamera = !0,
        scoreGroup.visible = !1,
        (scoreLabel = game.add.image(960, 95, "spritesheet", "score-page/score-title.png")).anchor.set(.5),
        scoreGroup.add(scoreLabel),
        (congratulations = game.add.image(960, 0, "spritesheet", "score-page/congratulations.png")).anchor.set(.5),
        congratulations.centerOffsetY = -175,
        congratulations.y = game.halfHeight + congratulations.offsetY,
        scoreGroup.add(congratulations),
        failed = game.add.image(960, 0, "spritesheet", "score-page/failed.png"),
        failed.anchor.set(.5),
        failed.centerOffsetY = -175,
        failed.y = game.halfHeight + failed.centerOffsetY,
        scoreGroup.add(failed),
        failed.renderable = !1,
        (fastestBtnBg = game.add.image(613, 0, "spritesheet", "settings/field.png")).centerOffsetY = 10,
        fastestBtnBg.y = game.halfHeight + fastestBtnBg.centerOffsetY,
        scoreGroup.add(fastestBtnBg),
        (fastestLabel = game.add.image(615, 0, "spritesheet", "score-page/fastest-time.png")).centerOffsetY = -39,
        fastestLabel.y = game.halfHeight + fastestLabel.centerOffsetY,
        scoreGroup.add(fastestLabel),
        (totalBtnBg = game.add.image(613, 0, "spritesheet", "settings/field.png")).centerOffsetY = 232,
        totalBtnBg.y = game.halfHeight + totalBtnBg.centerOffsetY,
        scoreGroup.add(totalBtnBg),
        totalLabel = game.add.image(615, 0, "spritesheet", "score-page/total-time.png"),
        totalLabel.centerOffsetY = 184,
        totalLabel.y = game.halfHeight + totalLabel.centerOffsetY,
        scoreGroup.add(totalLabel)
    }, resizeScreens = function() {
        resizeScoreScreen(),
        resizeSettingsScreen(),
        resizeFinalScreen()
    }, resizeScoreScreen = function() {
        for (var t = 2; t < scoreGroup.children.length; t++) {
            var e = scoreGroup.children[t];
            e.y = game.halfHeight + e.centerOffsetY
        }
    }, resizeSettingsScreen = function() {
        for (var t = 3; t < settingsGroup.children.length; t++) {
            var e = settingsGroup.children[t];
            e.y = game.halfHeight + e.centerOffsetY
        }
    }, resizeFinalScreen = function() {
        for (var t = 3; t < finalGroup.children.length; t++) {
            var e = finalGroup.children[t];
            e.y = game.halfHeight + e.centerOffsetY
        }
    }, initFinalScreen = function() {
        (finalGroup = game.add.group()).init = {
            x: 0,
            y: 0
        },
        (finalGfx = game.add.graphics(0, 0)).beginFill(parseInt("0x" + BG_COLOR.slice(1, 7))),
        finalGfx.drawRect(0, 0, 1920, game.height),
        finalGfx.endFill(),
        finalGroup.add(finalGfx),
        finalGroup.visible = !1,
        THE_LOGO,
        (finalPlayButton = game.add.image(1540, 70, "spritesheet", "final/play-button.png")).inputEnabled = !0,
        finalPlayButton.events.onInputUp.add(function() {
            hideFinalPage(),
            restart()
        }),
        finalGroup.add(finalPlayButton);
        finalShareMessage = game.add.image(800, 0, "spritesheet", "final/share-score.png"),
        finalGroup.add(finalShareMessage),
        finalShareMessage.centerOffsetY = -64,
        finalShareMessage.y = game.halfHeight + finalShareMessage.centerOffsetY,
        (finalFacebookButton = game.add.image(800, 0, "spritesheet", "final/facebook.png")).inputEnabled = !0,
        finalFacebookButton.centerOffsetY = 0,
        finalFacebookButton.y = game.halfHeight + finalFacebookButton.centerOffsetY,
        finalFacebookButton.events.onInputUp.add(function() {
            window.open("http://www.facebook.com/share.php?u=" + shareUrl + "&title=" + shareTitle)
        }),
        finalGroup.add(finalFacebookButton),
        (finalTwitterButton = game.add.image(920, 0, "spritesheet", "final/twitter.png")).inputEnabled = !0,
        finalTwitterButton.centerOffsetY = 0,
        finalTwitterButton.y = game.halfHeight + finalTwitterButton.centerOffsetY,
        finalTwitterButton.events.onInputUp.add(function() {
            window.open("http://twitter.com/home?status=" + shareTitle + "+" + shareUrl)
        }),
        finalGroup.add(finalTwitterButton),
        (finalEmailButton = game.add.image(1040, 0, "spritesheet", "final/email.png")).inputEnabled = !0,
        finalEmailButton.centerOffsetY = 0,
        finalEmailButton.y = game.halfHeight + finalEmailButton.centerOffsetY,
        finalEmailButton.events.onInputUp.add(function() {
            window.open("mailto:?subject=" + shareTitle + "&body=" + shareUrl)
        }),
        finalGroup.add(finalEmailButton)
    }, initControlScreen = function() {
        (controlPageGroup = game.add.group()).init = {
            x: 0,
            y: 0
        },
        controlPageGfx = game.add.graphics(0, 0),
        controlPageGfx.beginFill(0),
        controlPageGfx.drawRect(0, 0, 1920, game.height),
        controlPageGfx.endFill(),
        controlPageGfx.inputEnabled = !0,
        controlPageGroup.add(controlPageGfx),
        (controlPageImg = game.add.image(383, game.halfHeight, "control-image")).y -= controlPageImg.height / 2,
        controlPageGroup.add(controlPageImg),
        controlPageGroup.alpha = .66
    }, initMenu = function() {
        (settingsGroup = game.add.group()).init = {
            x: 0,
            y: 0
        },
        (settingsGfx = game.add.graphics(0, 0)).beginFill(parseInt("0x" + BG_COLOR.slice(1, 7))),
        settingsGfx.drawRect(0, 0, 1920, 200),
        settingsGfx.endFill(),
        settingsGfx.beginFill(15132390),
        settingsGfx.drawRect(0, 200, 1920, 10080),
        settingsGfx.endFill(),
        settingsGroup.add(settingsGfx),
        (backBtn = game.add.image(40, 40, "spritesheet", "settings/back.png")).inputEnabled = !0,
        backBtn.fixedToCamera = !0,
        backBtn.init = {
            x: backBtn.x,
            y: backBtn.y
        },
        backBtn.events.onInputUp.add(function() {
            hideMenu()
        }),
        settingsGroup.add(backBtn),
        (settingsLabel = game.add.image(960, 95, "spritesheet", "settings/settings.png")).anchor.set(.5),
        settingsGroup.add(settingsLabel),
        !0 !== game.device.desktop && ((controlsBtnBg = game.add.image(960, 0, "spritesheet", "settings/field.png")).anchor.set(.5),
        controlsBtnBg.scale.x = .8625,
        controlsBtnBg.centerOffsetY = 389,
        controlsBtnBg.y = game.halfHeight + controlsBtnBg.centerOffsetY,
        controlsBtnBg.inputEnabled = !0,
        controlsBtnBg.events.onInputUp.add(function() {
            toggleControls()
        }),
        settingsGroup.add(controlsBtnBg),
        (controlsBtn = game.add.image(698, 0, "spritesheet", "settings/swap-controls.png")).centerOffsetY = 367,
        controlsBtn.y = game.halfHeight + controlsBtn.centerOffsetY,
        controlsBtn.inputEnabled = !0,
        controlsBtn.events.onInputUp.add(function() {
            toggleControls()
        }),
        settingsGroup.add(controlsBtn),
        (controlsIcon = game.add.image(1108, 0, "spritesheet", "settings/controlR.png")).centerOffsetY = 359,
        controlsIcon.y = game.halfHeight + controlsIcon.centerOffsetY,
        controlsIcon.inputEnabled = !0,
        controlsIcon.events.onInputUp.add(function() {
            toggleControls()
        }),
        settingsGroup.add(controlsIcon),
        (controlsIconOff = game.add.image(1108, 0, "spritesheet", "settings/controlL.png")).centerOffsetY = 359,
        controlsIconOff.y = game.halfHeight + controlsIconOff.centerOffsetY,
        controlsIconOff.inputEnabled = !0,
        controlsIconOff.events.onInputUp.add(function() {
            toggleControls()
        }),
        controlsIconOff.visible = !1,
        settingsGroup.add(controlsIconOff)),
        (soundBtnBg = game.add.image(960, 0, "spritesheet", "settings/field.png")).anchor.set(.5),
        soundBtnBg.scale.x = .8625,
        soundBtnBg.centerOffsetY = -61,
        soundBtnBg.y = game.halfHeight + soundBtnBg.centerOffsetY,
        soundBtnBg.inputEnabled = !0,
        soundBtnBg.events.onInputUp.add(function() {
            toggleSound()
        }),
        settingsGroup.add(soundBtnBg),
        (soundBtn = game.add.image(698, 0, "spritesheet", "settings/sound.png")).centerOffsetY = -79,
        soundBtn.y = game.halfHeight + soundBtn.centerOffsetY,
        soundBtn.inputEnabled = !0,
        soundBtn.events.onInputUp.add(function() {
            toggleSound()
        }),
        settingsGroup.add(soundBtn),
        (soundIcon = game.add.image(1144, 0, "spritesheet", "settings/speaker.png")).centerOffsetY = -82,
        soundIcon.y = game.halfHeight + soundIcon.centerOffsetY,
        soundIcon.inputEnabled = !0,
        soundIcon.events.onInputUp.add(function() {
            toggleSound()
        }),
        settingsGroup.add(soundIcon),
        (soundIconOff = game.add.image(1137, 0, "spritesheet", "settings/soundoff.png")).centerOffsetY = -90,
        soundIconOff.y = game.halfHeight + soundIconOff.centerOffsetY,
        soundIconOff.inputEnabled = !0,
        soundIconOff.visible = !1,
        soundIconOff.events.onInputUp.add(function() {
            toggleSound()
        }),
        settingsGroup.add(soundIconOff),
        (musicBtnBg = game.add.image(960, 0, "spritesheet", "settings/field.png")).anchor.set(.5),
        musicBtnBg.scale.x = .8625,
        musicBtnBg.centerOffsetY = 89,
        musicBtnBg.y = game.halfHeight + musicBtnBg.centerOffsetY,
        musicBtnBg.inputEnabled = !0,
        musicBtnBg.events.onInputUp.add(function() {
            toggleMusic()
        }),
        settingsGroup.add(musicBtnBg),
        (musicBtn = game.add.image(698, 0, "spritesheet", "settings/music.png")).centerOffsetY = 71,
        musicBtn.y = game.halfHeight + musicBtn.centerOffsetY,
        musicBtn.inputEnabled = !0,
        musicBtn.events.onInputUp.add(function() {
            toggleMusic()
        }),
        settingsGroup.add(musicBtn),
        (musicIcon = game.add.image(1150, 0, "spritesheet", "settings/music-icon.png")).centerOffsetY = 63,
        musicIcon.y = game.halfHeight + musicIcon.centerOffsetY,
        musicIcon.inputEnabled = !0,
        musicIcon.events.onInputUp.add(function() {
            toggleMusic()
        }),
        settingsGroup.add(musicIcon),
        (musicIconOff = game.add.image(1143, 0, "spritesheet", "settings/musicoff.png")).centerOffsetY = 63,
        musicIconOff.y = game.halfHeight + musicIconOff.centerOffsetY,
        musicIconOff.inputEnabled = !0,
        musicIconOff.events.onInputUp.add(function() {
            toggleMusic()
        }),
        musicIconOff.visible = !1,
        settingsGroup.add(musicIconOff),
        settingRestartBtnBg = game.add.image(960, 0, "spritesheet", "settings/field.png"),
        settingRestartBtnBg.anchor.set(.5),
        settingRestartBtnBg.scale.x = .8625,
        settingRestartBtnBg.centerOffsetY = 239,
        settingRestartBtnBg.y = game.halfHeight + settingRestartBtnBg.centerOffsetY,
        settingRestartBtnBg.inputEnabled = !0,
        settingRestartBtnBg.events.onInputUp.add(function() {
            restart(),
            hideMenu()
        }),
        settingsGroup.add(settingRestartBtnBg),
        (settingsRestartBtn = game.add.image(698, 0, "spritesheet", "settings/restart.png")).centerOffsetY = 220,
        settingsRestartBtn.y = game.halfHeight + settingsRestartBtn.centerOffsetY,
        settingsRestartBtn.inputEnabled = !0,
        settingsRestartBtn.events.onInputUp.add(function() {
            restart(),
            hideMenu()
        }),
        settingsGroup.add(settingsRestartBtn),
        (outLinkBtnBg = game.add.image(960, 0, "spritesheet", "settings/field.png")).anchor.set(.5),
        outLinkBtnBg.scale.x = .8625,
        outLinkBtnBg.centerOffsetY = -211,
        outLinkBtnBg.y = game.halfHeight + outLinkBtnBg.centerOffsetY,
        outLinkBtnBg.inputEnabled = !0,
        outLinkBtnBg.events.onInputUp.add(function() {
            window.open(OUT_LINK)
        }),
        settingsGroup.add(outLinkBtnBg),
        (outLinkBtn = game.add.image(698, 0, "spritesheet", "settings/yes-website.png")).centerOffsetY = -229,
        outLinkBtn.y = game.halfHeight + outLinkBtn.centerOffsetY,
        outLinkBtn.inputEnabled = !0,
        outLinkBtn.events.onInputUp.add(function() {
            window.open(OUT_LINK)
        }),
        settingsGroup.add(outLinkBtn),
        settingsGroup.fixedToCamera = !0,
        settingsGroup.visible = !1
    }, showMenu = function() {
        settingsGroup.visible = !0,
        stopTime = !0,
        controlOverride = !0,
        menuScreen = !0
    }, hideMenu = function() {
        settingsGroup.visible = !1,
        stopTime = !1,
        controlOverride = !1,
        menuScreen = !1
    }, toggleControls = function() {
        "right" == cursors.layout.current ? (cursors.down.fixedToCamera = !1,
        cursors.left.fixedToCamera = !1,
        cursors.right.fixedToCamera = !1,
        jumpButton.fixedToCamera = !1,
        restartBtn.fixedToCamera = !1,
        cursors.layout.current = "left",
        jumpButton.position.set(cursors.layout.leftHanded.jump.x, cursors.layout.leftHanded.jump.y),
        cursors.down.position.set(cursors.layout.leftHanded.down.x, cursors.layout.leftHanded.down.y),
        cursors.left.position.set(cursors.layout.leftHanded.left.x, cursors.layout.leftHanded.left.y),
        cursors.right.position.set(cursors.layout.leftHanded.right.x, cursors.layout.leftHanded.right.y),
        cursors.down.init = {
            x: cursors.down.x,
            y: cursors.down.y
        },
        cursors.left.init = {
            x: cursors.left.x,
            y: cursors.left.y
        },
        cursors.right.init = {
            x: cursors.right.x,
            y: cursors.right.y
        },
        jumpButton.init = {
            x: jumpButton.x,
            y: jumpButton.y
        },
        controlsIcon.visible = !1,
        controlsIconOff.visible = !0) : (cursors.down.fixedToCamera = !1,
        cursors.left.fixedToCamera = !1,
        cursors.right.fixedToCamera = !1,
        jumpButton.fixedToCamera = !1,
        restartBtn.fixedToCamera = !1,
        cursors.layout.current = "right",
        jumpButton.position.set(cursors.layout.rightHanded.jump.x, cursors.layout.rightHanded.jump.y),
        cursors.down.position.set(cursors.layout.rightHanded.down.x, cursors.layout.rightHanded.down.y),
        cursors.left.position.set(cursors.layout.rightHanded.left.x, cursors.layout.rightHanded.left.y),
        cursors.right.position.set(cursors.layout.rightHanded.right.x, cursors.layout.rightHanded.right.y),
        cursors.down.init = {
            x: cursors.down.x,
            y: cursors.down.y
        },
        cursors.left.init = {
            x: cursors.left.x,
            y: cursors.left.y
        },
        cursors.right.init = {
            x: cursors.right.x,
            y: cursors.right.y
        },
        jumpButton.init = {
            x: jumpButton.x,
            y: jumpButton.y
        },
        controlsIcon.visible = !0,
        controlsIconOff.visible = !1),
        cursors.down.fixedToCamera = !0,
        cursors.left.fixedToCamera = !0,
        cursors.right.fixedToCamera = !0,
        jumpButton.fixedToCamera = !0,
        restartBtn.fixedToCamera = !0
    }, toggleSound = function() {
        game.sound.mute ? (game.sound.mute = !1,
        soundIcon.visible = !0,
        soundIconOff.visible = !1) : (game.sound.mute = !0,
        soundIcon.visible = !1,
        soundIconOff.visible = !0)
    }, toggleMusic = function() {
        music.mute ? (music.mute = !1,
        musicIcon.visible = !0,
        musicIconOff.visible = !1) : (music.mute = !0,
        musicIcon.visible = !1,
        musicIconOff.visible = !0)
    }, showFinalPage = function() {
        zoomTo(1, 25),
        finalGroup.y = 10080 + game.height,
        finalGroup.slideUp = game.add.tween(finalGroup.position),
        finalGroup.slideUp.to({
            y: 10080 - game.height
        }, 800, Phaser.Easing.Quintic.Out, !0),
        finalGroup.visible = !0
    }, hideFinalPage = function() {
        finalGroup.visible = !1,
        game.paused = !1
    }, showScorePage = function() {
        zoomTo(1, 25),
        fastestTime && fastestTime.destroy(),
        game.completed ? ((fastestTime = game.add.bitmapText(960, game.halfHeight, "retina", msToTime(timer.current), "66")).centerOffsetY = 40,
        fastestTime.y += fastestTime.centerOffsetY,
        fastestTime.x -= fastestTime.width / 2,
        congratulations.renderable = !0,
        failed.renderable = !1) : ((fastestTime = game.add.image(735, game.halfHeight, "spritesheet", "score-page/incomplete.png")).centerOffsetY = 40,
        fastestTime.y += fastestTime.centerOffsetY,
        congratulations.renderable = !1,
        failed.renderable = !0),
        scoreGroup.add(fastestTime),
        totalTime && totalTime.destroy(),
        (totalTime = game.add.bitmapText(960, game.halfHeight, "retina", msToTime(Date.now() - timer.firstStart), "66")).centerOffsetY = 265,
        totalTime.y += totalTime.centerOffsetY,
        totalTime.x -= totalTime.width / 2,
        scoreGroup.add(totalTime),
        scoreGroup.visible = !0,
        stopTime = !0
    }, hideScorePage = function() {
        scoreGroup.visible = !1,
        fastestTime && fastestTime.destroy(),
        totalTime && totalTime.destroy()
    };
    var updatePhysics = function() {
        player.isDead || player.justRestarted || ("country" === collisions || "payment" === collisions || "countryBilling" === collisions ? (game.physics.arcade.collide(player, dropdownCollisionLayer),
        game.physics.arcade.collide(player, dropdownInteriorCollisionLayer)) : game.physics.arcade.collide(player, collisionLayer),
        "default" == collisions && (game.physics.arcade.overlap(player, vacuums, handleVacuum, null, this),
        game.physics.arcade.overlap(player, warpUps, handleUpWarps, null, this),
        game.physics.arcade.overlap(player, warpDowns, handleDownWarps, null, this),
        game.physics.arcade.overlap(player, foreground, handleLocation, null, this),
        game.physics.arcade.overlap(player, triggers, handleTriggers, null, this)),
        game.physics.arcade.overlap(player, coins, getCoin, null, this),
        "terms" == player.currentLocation || "privacy" == player.currentLocation || "credit" == player.currentLocation ? (groups.terms.active && game.physics.arcade.overlap(player, termsAsterisks, playerDie, null, this),
        groups.privacy.active && game.physics.arcade.overlap(player, privacyAsterisks, playerDie, null, this),
        groups.credit.active && game.physics.arcade.overlap(player, creditAsterisks, playerDie, null, this)) : (game.physics.arcade.overlap(player, asterisks, playerDie, null, this),
        game.physics.arcade.overlap(player, bangs, playerDie, null, this),
        game.physics.arcade.overlap(player, rollers, playerDie, null, this)),
        player.body.acceleration.x = 0,
        player.body.velocity.x *= .94,
        player.body.velocity.y > maxFallSpeed && (player.body.velocity.y = maxFallSpeed))
    };
    var playerExplosion, initPlayer = function() {
        player = game.add.sprite(levelStart.x, levelStart.y, "dude"),
        game.physics.enable(player, Phaser.Physics.ARCADE),
        player.body.bounce.y = 0,
        player.body.collideWorldBounds = !0,
        player.anchor.set(.5, .5),
        player.currentLocation = "name",
        player.currentFg = "name",
        player.tweens = {},
        player.body.setStanding = function() {
            player.body.position.y -= 8 * player.scale.y,
            player.body.setSize(8, 84, 12, -1),
            player.body.state = "standing"
        }
        ,
        player.body.setJumping = function() {
            player.body.setSize(28, 54, 1, 14),
            player.body.state = "jumping"
        }
        ,
        player.body.setDucking = function() {
            player.body.position.y += 15 * player.scale.y,
            player.body.setSize(23, 50, 4, 17),
            player.body.state = "ducking"
        }
        ,
        player.justRestarted = !0,
        game.physics.arcade.isPaused = !0,
        player.body.setStanding(),
        player.animations.add("idle", [0, 5], 3, !0),
        player.animations.add("left", [0], 3, !0),
        player.animations.add("down-right", [4], 3, !0),
        player.animations.add("down-left", [1], 3, !0),
        player.animations.add("right", [0], 3, !0),
        player.animations.add("jump-right", [3], 3, !0),
        player.animations.add("jump-left", [2], 3, !0),
        player.isDead = !1,
        player.vacuumed = !1,
        player.warped = !1,
        player.deaths = 0,
        player.tallies = [],
        player.originalScale = {
            x: 1,
            y: 1.25
        },
        player.scale.y = player.originalScale.y,
        (playerExplosion = game.add.emitter(0, 0, 100)).makeParticles("spritesheet", "tiles/player-piece.png"),
        playerExplosion.enableBody = !0
    }, resetPlayer = function() {
        player.position.set(levelStart.x, levelStart.y),
        pressEnter.visible = !1,
        player.tweens.blowUp && player.tweens.blowUp.stop(),
        player.currentLocation = "name",
        player.alpha = 1,
        player.scale.set(player.originalScale.x, player.originalScale.y),
        player.body.velocity.y = 0,
        player.body.velocity.x = 0,
        player.body.angularAcceleration = 0,
        player.body.angularVelocity = 0,
        player.rotation = 0,
        player.isDead = !1,
        player.body.setStanding(),
        player.animations.play("left"),
        player.justRestarted = !0,
        game.physics.arcade.isPaused = !0
    }, playerDie = function(e, a) {
        if (!a.dead && a.visible) {
            e.isDead = !0,
            game.device.desktop && (pressEnter.visible = !0),
            deathSound.play(),
            jumpButton.isDown = cursors.left.isDown = cursors.right.isDown = cursors.down.isDown = !1,
            e.body.acceleration.x = 0,
            e.body.velocity.y = game.rnd.integerInRange(400, 600),
            e.body.velocity.x = game.rnd.integerInRange(-180, 180);
            for (var l = 0; Math.abs(l) < 25; )
                l = 200 * game.rnd.integerInRange(-8, 8);
            e.body.angularAcceleration = l,
            tallyDeath(),
            e.tweens.blowUp = game.add.tween(e.scale),
            setTimeout(function() {
                e.isDead && (e.tweens.blowUp.to({
                    y: .25
                }, 250, Phaser.Easing.Superback.Out, !0),
                e.tweens.blowUp.onComplete.add(function() {
                    e.isDead && (explosionSound.play(),
                    game.camera.shake(.01, 400),
                    game.camera.flash(16748688, 600),
                    e.alpha = 0,
                    playerExplosion.x = e.x,
                    playerExplosion.y = e.y,
                    playerExplosion.gravity.x = 2 * e.body.velocity.x,
                    playerExplosion.gravity.y = 2 * e.body.velocity.y,
                    playerExplosion.explode(2e3, 6))
                }))
            }, 1e3),
            game.camera.shake(.01, 400),
            game.time.events.add(100, function() {
                game.camera.flash(16748688, 600)
            }, this),
            setTimeout(function() {
                e.isDead && restart()
            }, 2500)
        }
    }, tallyDeath = function() {
        player.deaths++;
        for (var e = Math.floor(player.deaths / 5), a = 0; a < player.tallies.length; a++)
            player.tallies[a].destroy();
        player.tallies = [];
        for (a = 0; a < e; a++) {
            var l;
            (l = game.add.image(300 + 80 * a, 78, "spritesheet", "tallies/tally5.png")).fixedToCamera = !0,
            bgElements.add(l),
            player.tallies.push(l)
        }
        player.deaths % 5 && ((l = game.add.image(300 + 80 * e, 78, "spritesheet", "tallies/tally" + player.deaths % 5 + ".png")).fixedToCamera = !0,
        bgElements.add(l),
        player.tallies.push(l))
    };
    var game = new Phaser.Game(1920 * window.devicePixelRatio,window.devicePixelRatio * (1920 * window.innerHeight) / window.innerWidth,Phaser.CANVAS,"main",{
        preload: preload,
        create: create,
        update: update,
        render: render
    })
      , loaderLooped = !1
      , loadState = !1
      , loadingTimer = setTimeout(function() {
        loaderLooped = !0,
        loadState && (window.onresize(),
        restart(),
        loading.style.display = "none")
    }, 4250);
    function preload() {
        game.load.image("tiles-40-40", "assets/imgs/tiles-40-40.png", 40, 40),
        game.load.bitmapFont("graphik", "assets/fonts/graphik.png", "assets/fonts/graphik.xml"),
        game.load.bitmapFont("retina", "assets/fonts/retina.png", "assets/fonts/retina.xml"),
        game.load.bitmapFont("vcr", "assets/fonts/vcr.png", "assets/fonts/vcr.xml"),
        game.load.bitmapFont("vcr-white", "assets/fonts/vcr-white.png", "assets/fonts/vcr-white.xml"),
        game.load.bitmapFont("graphik-gray", "assets/fonts/graphik-gray.png", "assets/fonts/graphik-gray.xml"),
        game.load.tilemap("full-game", "assets/imgs/tilemap.json", null, Phaser.Tilemap.TILED_JSON),
        game.load.spritesheet("dude", "assets/imgs/cursor/cursor-sprites.png", 32, 80),
        game.load.pack("sprites", "assets/pack.json", null, this),
        THE_LOGO && game.load.image("logo", THE_LOGO),
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL,
        game.device.desktop || game.canvas.classList.add("mobile")
    }
    var player, bg, map, levelImage, countryDropdownLevelImage, paymentDropdownLevelImage, idTypeDropdownLevelImage, countryBillingDropdownLevelImage, collisionLayer, countryCollisionLayer, countryInteriorCollisionLayer, paymentCollisionLayer, paymentInteriorCollisionLayer, countryBillingCollisionLayer, countryBillingInteriorCollisionLayer, idTypeCollisionLayer, idTypeInteriorCollisionLayer, background, dropDownBackground, foreground, music, zoom, gameSize, newSize, updateDimensions, zoomTo, BG_COLOR = BACKGROUND_COLOR || "#fffa99", THE_LOGO = LOGO_URL || !1, OUT_LINK = LINK_OUT || "https://yes.com", shareUrl = SHARE_URL || "https://yes.com", shareTitle = SHARE_TITLE || "Play the yes game.", DEBUG = !1, startButton = document.getElementById("start-game"), rotateScreen = document.getElementById("portrait"), levelStart = {
        x: 140,
        y: 400
    }, facing = "left", timer = {}, scores = {}, collisions = "default", cameraOffset = {
        y: 0,
        tweens: {}
    }, cameraOverride = !1, resolutionOffset = 0, stopTime = !1, menuScreen = !1, accel = 1650, jumpHeight = 400, vacuumSpeed = 300, maxFallSpeed = 600, controlOverride = !1, camZoomTween = {
        isRunning: !1
    }, controlsNeedUpdate = !1, lock = {
        down: !1,
        up: !1,
        left: !1,
        right: !1,
        jump: !1
    }, gotAllCoins = !1, currentHeight = 0, lastGameHeight = 0, DPR = 1;
    function create() {
        game.debug.font = "36px courier",
        game.halfHeight = .5 * game.height,
        game.device.desktop && (DPR = 1),
        game.scale.setGameSize(1920 * DPR, DPR * (1920 * window.innerHeight) / window.innerWidth),
        window.onresize = function() {
            game.scale.setGameSize(1920 * DPR, DPR * (1920 * window.innerHeight) / window.innerWidth),
            gameSize = Object.freeze(new Phaser.Point(game.width,game.height)),
            newSize = gameSize.clone(),
            zoom.setTo(zoom.x, zoom.y),
            game.halfHeight = .5 * game.height,
            resizeScreens(),
            updateDimensions()
        }
        ,
        zoom = new Phaser.Point(1,1),
        gameSize = Object.freeze(new Phaser.Point(game.width,game.height)),
        newSize = gameSize.clone(),
        updateDimensions = function() {
            Phaser.Point.divide(gameSize, zoom, newSize),
            newSize.floor(),
            game.scale.updateDimensions(newSize.x, newSize.y, !0),
            dontScaleSprite(timer.onScreen),
            dontScaleSprite(timer.background),
            dontScaleSprite(menuBtn),
            dontScaleSprite(settingsGroup),
            game.device.desktop || (dontScaleSprite(cursors.down),
            dontScaleSprite(cursors.left),
            dontScaleSprite(cursors.right),
            dontScaleSprite(jumpButton),
            dontScaleSprite(restartBtn)),
            1 != zoom.x && game.input.scale.set(1 / zoom.x, 1 / zoom.y),
            touchControlPadding = touchControlPaddingInit / zoom.x,
            game.scale.refresh()
        }
        ,
        dontScaleSprite = function(e) {
            e.scale.set(1 / zoom.x, 1 / zoom.y),
            e.fixedToCamera = !1,
            e.x = e.init.x / zoom.x,
            e.y = e.init.y / zoom.y,
            e.fixedToCamera = !0
        }
        ,
        zoomTo = function(e, a) {
            var o = {
                x: zoom.x,
                y: zoom.y
            };
            (camZoomTween = game.add.tween(o)).onUpdateCallback(function() {
                zoom.setTo(o.x, o.x),
                updateDimensions()
            }),
            camZoomTween.onComplete.add(function() {
                zoom.setTo(o.x, o.x),
                updateDimensions()
            }),
            camZoomTween.onStart.add(function() {
                zoom.setTo(o.x, o.x),
                updateDimensions()
            }),
            camZoomTween.to({
                x: e
            }, a, Phaser.Easing.Quintic.InOut, !0)
        }
        ,
        game.device.desktop && initAudio(),
        game.physics.startSystem(Phaser.Physics.ARCADE),
        game.physics.arcade.TILE_BIAS = 21,
        game.physics.arcade.gravity.y = 500,
        game.time.desiredFps = 60,
        game.stage.backgroundColor = BG_COLOR,
        (countryDropdownLevelImage = game.add.image(0, 200, "country-dropdown-level-image")).scale.set(2),
        countryDropdownLevelImage.cacheAsBitmap = !0,
        (paymentDropdownLevelImage = game.add.image(0, 1280, "payment-dropdown-level-image")).scale.set(2),
        paymentDropdownLevelImage.cacheAsBitmap = !0,
        (countryBillingDropdownLevelImage = game.add.image(0, 2960, "country-billing-dropdown-level-image")).scale.set(2),
        countryBillingDropdownLevelImage.cacheAsBitmap = !0,
        (idTypeDropdownLevelImage = game.add.image(0, 4640, "id-type-dropdown-level-image")).scale.set(2),
        idTypeDropdownLevelImage.cacheAsBitmap = !0,
        (map = game.add.tilemap("full-game")).addTilesetImage("tiles-40-40"),
        (collisionLayer = map.createLayer("Collision Layer")).resizeWorld(),
        collisionLayer.visible = !1,
        collisionLayer.renderSettings.enableScrollDelta = !1,
        map.setCollisionByExclusion([], !0, "Collision Layer"),
        dropdownCollisionLayer = map.createLayer("Dropdown CL"),
        dropdownCollisionLayer.resizeWorld(),
        dropdownCollisionLayer.visible = !1,
        dropdownCollisionLayer.renderSettings.enableScrollDelta = !1,
        map.setCollisionByExclusion([], !0, "Dropdown CL"),
        dropdownInteriorCollisionLayer = map.createLayer("Dropdown CLI"),
        dropdownInteriorCollisionLayer.resizeWorld(),
        dropdownInteriorCollisionLayer.visible = !1,
        dropdownInteriorCollisionLayer.renderSettings.enableScrollDelta = !1,
        map.setCollisionByExclusion([], !0, "Dropdown CLI");
        for (var e = 0; e < dropdownInteriorCollisionLayer.layer.data.length; e++)
            for (var a = dropdownInteriorCollisionLayer.layer.data[e], o = 0; o < a.length; o++) {
                a[o].height = 1
            }
        game.camera.bounds = game.world.bounds,
        initGroups(),
        fgElements = game.add.group(),
        initPlayer(),
        initInteractiveElements(),
        hideInteractives(),
        initBackground(),
        initEffects(),
        initEnemies(),
        showEnemies(),
        initCheckboxes(),
        initControls(),
        timer.start = timer.firstStart = Date.now(),
        timer.current = timer.now - timer.start,
        timer.background = game.add.graphics(),
        //timer.background.beginFill(16777215, 0),
        timer.background.drawRect(125, 73, 160, 50),
        timer.background.init = {
            x: timer.background.x,
            y: timer.background.y
        },
        timer.background.fixedToCamera = !0,
        timer.onScreen = game.add.bitmapText(137, 82, "vcr", msToTime(timer.now)),
        timer.onScreen.init = {
            x: timer.onScreen.x,
            y: timer.onScreen.y
        },
        timer.onScreen.fixedToCamera = !0,
        timer.render = function() {
            game.paused && stopTime || (timer.current = Date.now() - timer.start,
            timer.onScreen.text = msToTime(timer.current))
        }
        ,
        game.device.desktop || (game.canvas.classList.add("hide"),
        startButton.classList.add("ready"),
        rotateScreen.classList.add("ready"),
        startButton.onclick = startButton.ontouchstart = function(e) {
            e.preventDefault(),
            initAudio(),
            game.canvas.classList.remove("hide"),
            game.canvas.classList.add("ready"),
            startButton.style.display = "none",
            updateControlPositions(),
            restart()
        }
        ),
        initMenu(),
        initFinalScreen(),
        initScoreScreen(),
        window.onresize(),
        game.device.desktop && initControlScreen(),
        game.cache.removeTilemap("full-game"),
        map.destroy(),
        loadState = !0,
        loaderLooped && (window.onresize(),
        restart(),
        loading.style.display = "none")
    }
    function update() {
        if (!game.paused || !stopTime) {
            if (game.device.desktop || (currentHeight !== window.innerHeight && setTimeout(function() {
                game.scale.refresh(),
                currentHeight = window.innerHeight,
                controlsNeedUpdate && (updateControlPositions(),
                controlsNeedUpdate = !1),
                window.onresize()
            }, 200),
            lastGameHeight === game.height || controlsNeedUpdate || (controlsNeedUpdate = !0,
            setTimeout(function() {
                camZoomTween.isRunning || (window.onresize(),
                controlsNeedUpdate && (updateControlPositions(),
                controlsNeedUpdate = !1)),
                lastGameHeight = game.height
            }, 200)),
            player.y < 520 ? cameraOffset.y = 0 : 0 == cameraOffset.y && (cameraOffset.tweens.toOffset = game.add.tween(cameraOffset),
            cameraOffset.tweens.toOffset.to({
                y: 190
            }, 400, Phaser.Easing.Linear.None, !0))),
            cameraOverride || game.camera.follow(player, Phaser.Camera.FOLLOW_PLATFORMER, 1, 1, 0, cameraOffset.y + resolutionOffset),
            game.camera.lockX) {
                game.camera.unfollow();
                var e = player.y - game.camera.y;
                if (e < .4 * game.camera.height) {
                    var a = .4 * game.camera.height - e;
                    game.camera.x = game.camera.lockX,
                    game.camera.y -= a
                } else if (e > .6 * game.camera.height) {
                    a = .6 * game.camera.height - e;
                    game.camera.x = game.camera.lockX,
                    game.camera.y -= a
                } else
                    game.camera.x = game.camera.lockX
            }
            updatePhysics(),
            handleKeyLocks(),
            updateControls(),
            updateGroups()
        }
    }
    function render() {
        timer.render()
    }
    var restart = function() {
        restarting || (window.onresize(),
        restarting = !0,
        thankYouButton.alpha = .33,
        game.completed = !1,
        controlOverride = stopTime = !1,
        camZoomTween.isRunning && camZoomTween.stop(),
        zoomTo(1, 50),
        resetEnemies(),
        setTimeout(function() {
            cameraOverride = !1,
            game.camera.y = 0,
            yesMusic && yesMusic.isPlaying && (music.restart(),
            yesMusic.pause(),
            music.volume = .5,
            music.loopFull()),
            collisions = "default",
            heckles.hide(),
            labels.show(),
            shadows.show(),
            groups.country.reset(),
            groups.country.exit(),
            groups.payment.reset(),
            groups.payment.exit(),
            groups.countryBilling.reset(),
            groups.countryBilling.exit(),
            groups.terms.reset(),
            groups.privacy.reset(),
            groups.credit.reset(),
            timer.start = Date.now(),
            resetPlayer(),
            areas[player.currentLocation].onActive(),
            resetCoins(),
            resetEffects(),
            interactivesRenderable(!0),
            killInteractives(),
            groups.checkboxes.hide(),
            resetEnemies(),
            game.input.enabled = !0,
            restarting = !1
        }, 150))
    }
      , gameComplete = function() {
        game.completed = !0,
        gotAllCoins = !0,
        thankYouButton.alpha = 1
    }
      , endGame = function() {
        controlOverride = !0,
        finalAnimation()
    }
      , finalAnimation = function() {
        player.animations.play("right"),
        setTimeout(function() {
            var e = game.add.tween(player.position);
            e.to({
                x: 1250
            }, 1250, Phaser.Easing.Linear.None, !0),
            e.onComplete.add(function() {
                thankYouButton.loadTexture("spritesheet", "background/finish-thankyou.png"),
                setTimeout(function() {
                    showScorePage(),
                    setTimeout(function() {
                        showFinalPage(),
                        setTimeout(function() {
                            hideScorePage()
                        }, 5e3)
                    }, 5e3)
                }, 800)
            })
        }, 1e3)
    };
    var PI2 = 2 * Math.PI
      , QPI = .25 * Math.PI
      , msToTime = function(e) {
        var r = parseInt(e % 1e3 / 100)
          , n = parseInt(e / 1e3 % 60)
          , t = parseInt(e / 6e4 % 60);
        return (t = t < 10 ? "0" + t : t) + ":" + (n = n < 10 ? "0" + n : n) + "." + r
    };
    function compareNumbers(e, r) {
        return e - r
    }
    //# sourceMappingURL=maps/main.js.map

}
)();
